"use strict";
var Harbour = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod6) => function __require() {
    return mod6 || (0, cb[__getOwnPropNames(cb)[0]])((mod6 = { exports: {} }).exports, mod6), mod6.exports;
  };
  var __export = (target, all3) => {
    for (var name19 in all3)
      __defProp(target, name19, { get: all3[name19], enumerable: true });
  };
  var __copyProps = (to, from39, except, desc) => {
    if (from39 && typeof from39 === "object" || typeof from39 === "function") {
      for (let key of __getOwnPropNames(from39))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from39[key], enumerable: !(desc = __getOwnPropDesc(from39, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod6, isNodeMode, target) => (target = mod6 != null ? __create(__getProtoOf(mod6)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod6 || !mod6.__esModule ? __defProp(target, "default", { value: mod6, enumerable: true }) : target,
    mod6
  ));
  var __toCommonJS = (mod6) => __copyProps(__defProp({}, "__esModule", { value: true }), mod6);

  // ../node_modules/ms/index.js
  var require_ms = __commonJS({
    "../node_modules/ms/index.js"(exports2, module2) {
      var s2 = 1e3;
      var m2 = s2 * 60;
      var h2 = m2 * 60;
      var d2 = h2 * 24;
      var w2 = d2 * 7;
      var y2 = d2 * 365.25;
      module2.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse2(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong2(val) : fmtShort2(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse2(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y2;
          case "weeks":
          case "week":
          case "w":
            return n * w2;
          case "days":
          case "day":
          case "d":
            return n * d2;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h2;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m2;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s2;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort2(ms2) {
        var msAbs = Math.abs(ms2);
        if (msAbs >= d2) {
          return Math.round(ms2 / d2) + "d";
        }
        if (msAbs >= h2) {
          return Math.round(ms2 / h2) + "h";
        }
        if (msAbs >= m2) {
          return Math.round(ms2 / m2) + "m";
        }
        if (msAbs >= s2) {
          return Math.round(ms2 / s2) + "s";
        }
        return ms2 + "ms";
      }
      function fmtLong2(ms2) {
        var msAbs = Math.abs(ms2);
        if (msAbs >= d2) {
          return plural2(ms2, msAbs, d2, "day");
        }
        if (msAbs >= h2) {
          return plural2(ms2, msAbs, h2, "hour");
        }
        if (msAbs >= m2) {
          return plural2(ms2, msAbs, m2, "minute");
        }
        if (msAbs >= s2) {
          return plural2(ms2, msAbs, s2, "second");
        }
        return ms2 + " ms";
      }
      function plural2(ms2, msAbs, n, name19) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms2 / n) + " " + name19 + (isPlural ? "s" : "");
      }
    }
  });

  // ../node_modules/debug/src/common.js
  var require_common = __commonJS({
    "../node_modules/debug/src/common.js"(exports2, module2) {
      function setup3(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce22;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash2 = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
            hash2 |= 0;
          }
          return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug2(...args) {
            if (!debug2.enabled) {
              return;
            }
            const self2 = debug2;
            const curr = Number(/* @__PURE__ */ new Date());
            const ms2 = curr - (prevTime || curr);
            self2.diff = ms2;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format19) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format19];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug2.namespace = namespace;
          debug2.useColors = createDebug.useColors();
          debug2.color = createDebug.selectColor(namespace);
          debug2.extend = extend;
          debug2.destroy = createDebug.destroy;
          Object.defineProperty(debug2, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug2);
          }
          return debug2;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          const split4 = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
          for (const ns of split4) {
            if (ns[0] === "-") {
              createDebug.skips.push(ns.slice(1));
            } else {
              createDebug.names.push(ns);
            }
          }
        }
        function matchesTemplate(search, template) {
          let searchIndex = 0;
          let templateIndex = 0;
          let starIndex = -1;
          let matchIndex = 0;
          while (searchIndex < search.length) {
            if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
              if (template[templateIndex] === "*") {
                starIndex = templateIndex;
                matchIndex = searchIndex;
                templateIndex++;
              } else {
                searchIndex++;
                templateIndex++;
              }
            } else if (starIndex !== -1) {
              templateIndex = starIndex + 1;
              matchIndex++;
              searchIndex = matchIndex;
            } else {
              return false;
            }
          }
          while (templateIndex < template.length && template[templateIndex] === "*") {
            templateIndex++;
          }
          return templateIndex === template.length;
        }
        function disable() {
          const namespaces = [
            ...createDebug.names,
            ...createDebug.skips.map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name19) {
          for (const skip of createDebug.skips) {
            if (matchesTemplate(name19, skip)) {
              return false;
            }
          }
          for (const ns of createDebug.names) {
            if (matchesTemplate(name19, ns)) {
              return true;
            }
          }
          return false;
        }
        function coerce22(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module2.exports = setup3;
    }
  });

  // ../node_modules/debug/src/browser.js
  var require_browser = __commonJS({
    "../node_modules/debug/src/browser.js"(exports2, module2) {
      exports2.formatArgs = formatArgs2;
      exports2.save = save2;
      exports2.load = load2;
      exports2.useColors = useColors2;
      exports2.storage = localstorage2();
      exports2.destroy = /* @__PURE__ */ (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports2.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors2() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        let m2;
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs2(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports2.log = console.debug || console.log || (() => {
      });
      function save2(namespaces) {
        try {
          if (namespaces) {
            exports2.storage.setItem("debug", namespaces);
          } else {
            exports2.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load2() {
        let r;
        try {
          r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
        } catch (error) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage2() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module2.exports = require_common()(exports2);
      var { formatters } = module2.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // ../node_modules/netmask/lib/netmask.js
  var require_netmask = __commonJS({
    "../node_modules/netmask/lib/netmask.js"(exports2) {
      (function() {
        var Netmask2, atob, chr, chr0, chrA, chra, ip2long, long2ip;
        long2ip = function(long) {
          var a, b, c, d2;
          a = (long & 255 << 24) >>> 24;
          b = (long & 255 << 16) >>> 16;
          c = (long & 255 << 8) >>> 8;
          d2 = long & 255;
          return [a, b, c, d2].join(".");
        };
        ip2long = function(ip) {
          var b, c, i, j, n, ref;
          b = [];
          for (i = j = 0; j <= 3; i = ++j) {
            if (ip.length === 0) {
              break;
            }
            if (i > 0) {
              if (ip[0] !== ".") {
                throw new Error("Invalid IP");
              }
              ip = ip.substring(1);
            }
            ref = atob(ip), n = ref[0], c = ref[1];
            ip = ip.substring(c);
            b.push(n);
          }
          if (ip.length !== 0) {
            throw new Error("Invalid IP");
          }
          switch (b.length) {
            case 1:
              if (b[0] > 4294967295) {
                throw new Error("Invalid IP");
              }
              return b[0] >>> 0;
            case 2:
              if (b[0] > 255 || b[1] > 16777215) {
                throw new Error("Invalid IP");
              }
              return (b[0] << 24 | b[1]) >>> 0;
            case 3:
              if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
                throw new Error("Invalid IP");
              }
              return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
            case 4:
              if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
                throw new Error("Invalid IP");
              }
              return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
            default:
              throw new Error("Invalid IP");
          }
        };
        chr = function(b) {
          return b.charCodeAt(0);
        };
        chr0 = chr("0");
        chra = chr("a");
        chrA = chr("A");
        atob = function(s2) {
          var base37, dmax, i, n, start2;
          n = 0;
          base37 = 10;
          dmax = "9";
          i = 0;
          if (s2.length > 1 && s2[i] === "0") {
            if (s2[i + 1] === "x" || s2[i + 1] === "X") {
              i += 2;
              base37 = 16;
            } else if ("0" <= s2[i + 1] && s2[i + 1] <= "9") {
              i++;
              base37 = 8;
              dmax = "7";
            }
          }
          start2 = i;
          while (i < s2.length) {
            if ("0" <= s2[i] && s2[i] <= dmax) {
              n = n * base37 + (chr(s2[i]) - chr0) >>> 0;
            } else if (base37 === 16) {
              if ("a" <= s2[i] && s2[i] <= "f") {
                n = n * base37 + (10 + chr(s2[i]) - chra) >>> 0;
              } else if ("A" <= s2[i] && s2[i] <= "F") {
                n = n * base37 + (10 + chr(s2[i]) - chrA) >>> 0;
              } else {
                break;
              }
            } else {
              break;
            }
            if (n > 4294967295) {
              throw new Error("too large");
            }
            i++;
          }
          if (i === start2) {
            throw new Error("empty octet");
          }
          return [n, i];
        };
        Netmask2 = (function() {
          function Netmask3(net, mask) {
            var error, i, j, ref;
            if (typeof net !== "string") {
              throw new Error("Missing `net' parameter");
            }
            if (!mask) {
              ref = net.split("/", 2), net = ref[0], mask = ref[1];
            }
            if (!mask) {
              mask = 32;
            }
            if (typeof mask === "string" && mask.indexOf(".") > -1) {
              try {
                this.maskLong = ip2long(mask);
              } catch (error1) {
                error = error1;
                throw new Error("Invalid mask: " + mask);
              }
              for (i = j = 32; j >= 0; i = --j) {
                if (this.maskLong === 4294967295 << 32 - i >>> 0) {
                  this.bitmask = i;
                  break;
                }
              }
            } else if (mask || mask === 0) {
              this.bitmask = parseInt(mask, 10);
              this.maskLong = 0;
              if (this.bitmask > 0) {
                this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
              }
            } else {
              throw new Error("Invalid mask: empty");
            }
            try {
              this.netLong = (ip2long(net) & this.maskLong) >>> 0;
            } catch (error1) {
              error = error1;
              throw new Error("Invalid net address: " + net);
            }
            if (!(this.bitmask <= 32)) {
              throw new Error("Invalid mask for ip4: " + mask);
            }
            this.size = Math.pow(2, 32 - this.bitmask);
            this.base = long2ip(this.netLong);
            this.mask = long2ip(this.maskLong);
            this.hostmask = long2ip(~this.maskLong);
            this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
            this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
            this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
          }
          Netmask3.prototype.contains = function(ip) {
            if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
              ip = new Netmask3(ip);
            }
            if (ip instanceof Netmask3) {
              return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
            } else {
              return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
            }
          };
          Netmask3.prototype.next = function(count) {
            if (count == null) {
              count = 1;
            }
            return new Netmask3(long2ip(this.netLong + this.size * count), this.mask);
          };
          Netmask3.prototype.forEach = function(fn) {
            var index, lastLong, long;
            long = ip2long(this.first);
            lastLong = ip2long(this.last);
            index = 0;
            while (long <= lastLong) {
              fn(long2ip(long), long, index);
              index++;
              long++;
            }
          };
          Netmask3.prototype.toString = function() {
            return this.base + "/" + this.bitmask;
          };
          return Netmask3;
        })();
        exports2.ip2long = ip2long;
        exports2.long2ip = long2ip;
        exports2.Netmask = Netmask2;
      }).call(exports2);
    }
  });

  // ../node_modules/event-iterator/lib/event-iterator.js
  var require_event_iterator = __commonJS({
    "../node_modules/event-iterator/lib/event-iterator.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var EventQueue = class {
        constructor() {
          this.pullQueue = [];
          this.pushQueue = [];
          this.eventHandlers = {};
          this.isPaused = false;
          this.isStopped = false;
        }
        push(value) {
          if (this.isStopped)
            return;
          const resolution = { value, done: false };
          if (this.pullQueue.length) {
            const placeholder = this.pullQueue.shift();
            if (placeholder)
              placeholder.resolve(resolution);
          } else {
            this.pushQueue.push(Promise.resolve(resolution));
            if (this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {
              this.isPaused = true;
              if (this.eventHandlers.highWater) {
                this.eventHandlers.highWater();
              } else if (console) {
                console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
              }
            }
          }
        }
        stop() {
          if (this.isStopped)
            return;
          this.isStopped = true;
          this.remove();
          for (const placeholder of this.pullQueue) {
            placeholder.resolve({ value: void 0, done: true });
          }
          this.pullQueue.length = 0;
        }
        fail(error) {
          if (this.isStopped)
            return;
          this.isStopped = true;
          this.remove();
          if (this.pullQueue.length) {
            for (const placeholder of this.pullQueue) {
              placeholder.reject(error);
            }
            this.pullQueue.length = 0;
          } else {
            const rejection = Promise.reject(error);
            rejection.catch(() => {
            });
            this.pushQueue.push(rejection);
          }
        }
        remove() {
          Promise.resolve().then(() => {
            if (this.removeCallback)
              this.removeCallback();
          });
        }
        [Symbol.asyncIterator]() {
          return {
            next: (value) => {
              const result = this.pushQueue.shift();
              if (result) {
                if (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {
                  this.isPaused = false;
                  if (this.eventHandlers.lowWater) {
                    this.eventHandlers.lowWater();
                  }
                }
                return result;
              } else if (this.isStopped) {
                return Promise.resolve({ value: void 0, done: true });
              } else {
                return new Promise((resolve, reject) => {
                  this.pullQueue.push({ resolve, reject });
                });
              }
            },
            return: () => {
              this.isStopped = true;
              this.pushQueue.length = 0;
              this.remove();
              return Promise.resolve({ value: void 0, done: true });
            }
          };
        }
      };
      var EventIterator2 = class {
        constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
          const queue = new EventQueue();
          queue.highWaterMark = highWaterMark;
          queue.lowWaterMark = lowWaterMark;
          queue.removeCallback = listen({
            push: (value) => queue.push(value),
            stop: () => queue.stop(),
            fail: (error) => queue.fail(error),
            on: (event, fn) => {
              queue.eventHandlers[event] = fn;
            }
          }) || (() => {
          });
          this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
          Object.freeze(this);
        }
      };
      exports2.EventIterator = EventIterator2;
      exports2.default = EventIterator2;
    }
  });

  // ../node_modules/event-iterator/lib/dom.js
  var require_dom = __commonJS({
    "../node_modules/event-iterator/lib/dom.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var event_iterator_1 = require_event_iterator();
      exports2.EventIterator = event_iterator_1.EventIterator;
      function subscribe(event, options, evOptions) {
        return new event_iterator_1.EventIterator(({ push }) => {
          this.addEventListener(event, push, options);
          return () => this.removeEventListener(event, push, options);
        }, evOptions);
      }
      exports2.subscribe = subscribe;
      exports2.default = event_iterator_1.EventIterator;
    }
  });

  // ../node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "../node_modules/eventemitter3/index.js"(exports2, module2) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__) prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener2(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names2 = [], events, name19;
        if (this._eventsCount === 0) return names2;
        for (name19 in events = this._events) {
          if (has.call(events, name19)) names2.push(prefix ? name19.slice(1) : name19);
        }
        if (Object.getOwnPropertySymbols) {
          return names2.concat(Object.getOwnPropertySymbols(events));
        }
        return names2;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length21 = listeners.length, j;
          for (i = 0; i < length21; i++) {
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context) {
        return addListener2(this, event, fn, context, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context) {
        return addListener2(this, event, fn, context, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener2(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length21 = listeners.length; i < length21; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          }
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module2) {
        module2.exports = EventEmitter2;
      }
    }
  });

  // ../node_modules/hashlru/index.js
  var require_hashlru = __commonJS({
    "../node_modules/hashlru/index.js"(exports2, module2) {
      module2.exports = function(max) {
        if (!max) throw Error("hashlru must have a max value, of type number, greater than 0");
        var size = 0, cache20 = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
        function update(key, value) {
          cache20[key] = value;
          size++;
          if (size >= max) {
            size = 0;
            _cache = cache20;
            cache20 = /* @__PURE__ */ Object.create(null);
          }
        }
        return {
          has: function(key) {
            return cache20[key] !== void 0 || _cache[key] !== void 0;
          },
          remove: function(key) {
            if (cache20[key] !== void 0)
              cache20[key] = void 0;
            if (_cache[key] !== void 0)
              _cache[key] = void 0;
          },
          get: function(key) {
            var v = cache20[key];
            if (v !== void 0) return v;
            if ((v = _cache[key]) !== void 0) {
              update(key, v);
              return v;
            }
          },
          set: function(key, value) {
            if (cache20[key] !== void 0) cache20[key] = value;
            else update(key, value);
          },
          clear: function() {
            cache20 = /* @__PURE__ */ Object.create(null);
            _cache = /* @__PURE__ */ Object.create(null);
          }
        };
      };
    }
  });

  // ../node_modules/retry/lib/retry_operation.js
  var require_retry_operation = __commonJS({
    "../node_modules/retry/lib/retry_operation.js"(exports2, module2) {
      function RetryOperation(timeouts, options) {
        if (typeof options === "boolean") {
          options = { forever: options };
        }
        this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
        this._timeouts = timeouts;
        this._options = options || {};
        this._maxRetryTime = options && options.maxRetryTime || Infinity;
        this._fn = null;
        this._errors = [];
        this._attempts = 1;
        this._operationTimeout = null;
        this._operationTimeoutCb = null;
        this._timeout = null;
        this._operationStart = null;
        this._timer = null;
        if (this._options.forever) {
          this._cachedTimeouts = this._timeouts.slice(0);
        }
      }
      module2.exports = RetryOperation;
      RetryOperation.prototype.reset = function() {
        this._attempts = 1;
        this._timeouts = this._originalTimeouts.slice(0);
      };
      RetryOperation.prototype.stop = function() {
        if (this._timeout) {
          clearTimeout(this._timeout);
        }
        if (this._timer) {
          clearTimeout(this._timer);
        }
        this._timeouts = [];
        this._cachedTimeouts = null;
      };
      RetryOperation.prototype.retry = function(err) {
        if (this._timeout) {
          clearTimeout(this._timeout);
        }
        if (!err) {
          return false;
        }
        var currentTime = (/* @__PURE__ */ new Date()).getTime();
        if (err && currentTime - this._operationStart >= this._maxRetryTime) {
          this._errors.push(err);
          this._errors.unshift(new Error("RetryOperation timeout occurred"));
          return false;
        }
        this._errors.push(err);
        var timeout2 = this._timeouts.shift();
        if (timeout2 === void 0) {
          if (this._cachedTimeouts) {
            this._errors.splice(0, this._errors.length - 1);
            timeout2 = this._cachedTimeouts.slice(-1);
          } else {
            return false;
          }
        }
        var self2 = this;
        this._timer = setTimeout(function() {
          self2._attempts++;
          if (self2._operationTimeoutCb) {
            self2._timeout = setTimeout(function() {
              self2._operationTimeoutCb(self2._attempts);
            }, self2._operationTimeout);
            if (self2._options.unref) {
              self2._timeout.unref();
            }
          }
          self2._fn(self2._attempts);
        }, timeout2);
        if (this._options.unref) {
          this._timer.unref();
        }
        return true;
      };
      RetryOperation.prototype.attempt = function(fn, timeoutOps) {
        this._fn = fn;
        if (timeoutOps) {
          if (timeoutOps.timeout) {
            this._operationTimeout = timeoutOps.timeout;
          }
          if (timeoutOps.cb) {
            this._operationTimeoutCb = timeoutOps.cb;
          }
        }
        var self2 = this;
        if (this._operationTimeoutCb) {
          this._timeout = setTimeout(function() {
            self2._operationTimeoutCb();
          }, self2._operationTimeout);
        }
        this._operationStart = (/* @__PURE__ */ new Date()).getTime();
        this._fn(this._attempts);
      };
      RetryOperation.prototype.try = function(fn) {
        console.log("Using RetryOperation.try() is deprecated");
        this.attempt(fn);
      };
      RetryOperation.prototype.start = function(fn) {
        console.log("Using RetryOperation.start() is deprecated");
        this.attempt(fn);
      };
      RetryOperation.prototype.start = RetryOperation.prototype.try;
      RetryOperation.prototype.errors = function() {
        return this._errors;
      };
      RetryOperation.prototype.attempts = function() {
        return this._attempts;
      };
      RetryOperation.prototype.mainError = function() {
        if (this._errors.length === 0) {
          return null;
        }
        var counts = {};
        var mainError = null;
        var mainErrorCount = 0;
        for (var i = 0; i < this._errors.length; i++) {
          var error = this._errors[i];
          var message2 = error.message;
          var count = (counts[message2] || 0) + 1;
          counts[message2] = count;
          if (count >= mainErrorCount) {
            mainError = error;
            mainErrorCount = count;
          }
        }
        return mainError;
      };
    }
  });

  // ../node_modules/retry/lib/retry.js
  var require_retry = __commonJS({
    "../node_modules/retry/lib/retry.js"(exports2) {
      var RetryOperation = require_retry_operation();
      exports2.operation = function(options) {
        var timeouts = exports2.timeouts(options);
        return new RetryOperation(timeouts, {
          forever: options && (options.forever || options.retries === Infinity),
          unref: options && options.unref,
          maxRetryTime: options && options.maxRetryTime
        });
      };
      exports2.timeouts = function(options) {
        if (options instanceof Array) {
          return [].concat(options);
        }
        var opts = {
          retries: 10,
          factor: 2,
          minTimeout: 1 * 1e3,
          maxTimeout: Infinity,
          randomize: false
        };
        for (var key in options) {
          opts[key] = options[key];
        }
        if (opts.minTimeout > opts.maxTimeout) {
          throw new Error("minTimeout is greater than maxTimeout");
        }
        var timeouts = [];
        for (var i = 0; i < opts.retries; i++) {
          timeouts.push(this.createTimeout(i, opts));
        }
        if (options && options.forever && !timeouts.length) {
          timeouts.push(this.createTimeout(i, opts));
        }
        timeouts.sort(function(a, b) {
          return a - b;
        });
        return timeouts;
      };
      exports2.createTimeout = function(attempt, opts) {
        var random = opts.randomize ? Math.random() + 1 : 1;
        var timeout2 = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
        timeout2 = Math.min(timeout2, opts.maxTimeout);
        return timeout2;
      };
      exports2.wrap = function(obj, options, methods) {
        if (options instanceof Array) {
          methods = options;
          options = null;
        }
        if (!methods) {
          methods = [];
          for (var key in obj) {
            if (typeof obj[key] === "function") {
              methods.push(key);
            }
          }
        }
        for (var i = 0; i < methods.length; i++) {
          var method = methods[i];
          var original = obj[method];
          obj[method] = function retryWrapper(original2) {
            var op = exports2.operation(options);
            var args = Array.prototype.slice.call(arguments, 1);
            var callback = args.pop();
            args.push(function(err) {
              if (op.retry(err)) {
                return;
              }
              if (err) {
                arguments[0] = op.mainError();
              }
              callback.apply(this, arguments);
            });
            op.attempt(function() {
              original2.apply(obj, args);
            });
          }.bind(obj, original);
          obj[method].options = options;
        }
      };
    }
  });

  // ../node_modules/retry/index.js
  var require_retry2 = __commonJS({
    "../node_modules/retry/index.js"(exports2, module2) {
      module2.exports = require_retry();
    }
  });

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // ../node_modules/@waku/enr/node_modules/js-sha3/src/sha3.js
  var require_sha3 = __commonJS({
    "../node_modules/@waku/enr/node_modules/js-sha3/src/sha3.js"(exports2, module2) {
      (function() {
        "use strict";
        var INPUT_ERROR = "input is invalid type";
        var FINALIZE_ERROR = "finalize already called";
        var WINDOW = typeof window === "object";
        var root = WINDOW ? window : {};
        if (root.JS_SHA3_NO_WINDOW) {
          WINDOW = false;
        }
        var WEB_WORKER = !WINDOW && typeof self === "object";
        var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = global;
        } else if (WEB_WORKER) {
          root = self;
        }
        var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
        var AMD = typeof define === "function" && define.amd;
        var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS = "0123456789abcdef".split("");
        var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
        var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
        var KECCAK_PADDING = [1, 256, 65536, 16777216];
        var PADDING = [6, 1536, 393216, 100663296];
        var SHIFT = [0, 8, 16, 24];
        var RC = [
          1,
          0,
          32898,
          0,
          32906,
          2147483648,
          2147516416,
          2147483648,
          32907,
          0,
          2147483649,
          0,
          2147516545,
          2147483648,
          32777,
          2147483648,
          138,
          0,
          136,
          0,
          2147516425,
          0,
          2147483658,
          0,
          2147516555,
          0,
          139,
          2147483648,
          32905,
          2147483648,
          32771,
          2147483648,
          32770,
          2147483648,
          128,
          2147483648,
          32778,
          0,
          2147483658,
          2147483648,
          2147516545,
          2147483648,
          32896,
          2147483648,
          2147483649,
          0,
          2147516424,
          2147483648
        ];
        var BITS = [224, 256, 384, 512];
        var SHAKE_BITS = [128, 256];
        var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
        var CSHAKE_BYTEPAD = {
          "128": 168,
          "256": 136
        };
        var isArray = root.JS_SHA3_NO_NODE_JS || !Array.isArray ? function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        } : Array.isArray;
        var isView = ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) ? function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        } : ArrayBuffer.isView;
        var formatMessage = function(message2) {
          var type = typeof message2;
          if (type === "string") {
            return [message2, true];
          }
          if (type !== "object" || message2 === null) {
            throw new Error(INPUT_ERROR);
          }
          if (ARRAY_BUFFER && message2.constructor === ArrayBuffer) {
            return [new Uint8Array(message2), false];
          }
          if (!isArray(message2) && !isView(message2)) {
            throw new Error(INPUT_ERROR);
          }
          return [message2, false];
        };
        var empty22 = function(message2) {
          return formatMessage(message2)[0].length === 0;
        };
        var cloneArray2 = function(array) {
          var newArray = [];
          for (var i2 = 0; i2 < array.length; ++i2) {
            newArray[i2] = array[i2];
          }
          return newArray;
        };
        var createOutputMethod = function(bits2, padding, outputType) {
          return function(message2) {
            return new Keccak(bits2, padding, bits2).update(message2)[outputType]();
          };
        };
        var createShakeOutputMethod = function(bits2, padding, outputType) {
          return function(message2, outputBits) {
            return new Keccak(bits2, padding, outputBits).update(message2)[outputType]();
          };
        };
        var createCshakeOutputMethod = function(bits2, padding, outputType) {
          return function(message2, outputBits, n, s2) {
            return methods["cshake" + bits2].update(message2, outputBits, n, s2)[outputType]();
          };
        };
        var createKmacOutputMethod = function(bits2, padding, outputType) {
          return function(key, message2, outputBits, s2) {
            return methods["kmac" + bits2].update(key, message2, outputBits, s2)[outputType]();
          };
        };
        var createOutputMethods = function(method, createMethod2, bits2, padding) {
          for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
            var type = OUTPUT_TYPES[i2];
            method[type] = createMethod2(bits2, padding, type);
          }
          return method;
        };
        var createMethod = function(bits2, padding) {
          var method = createOutputMethod(bits2, padding, "hex");
          method.create = function() {
            return new Keccak(bits2, padding, bits2);
          };
          method.update = function(message2) {
            return method.create().update(message2);
          };
          return createOutputMethods(method, createOutputMethod, bits2, padding);
        };
        var createShakeMethod = function(bits2, padding) {
          var method = createShakeOutputMethod(bits2, padding, "hex");
          method.create = function(outputBits) {
            return new Keccak(bits2, padding, outputBits);
          };
          method.update = function(message2, outputBits) {
            return method.create(outputBits).update(message2);
          };
          return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
        };
        var createCshakeMethod = function(bits2, padding) {
          var w2 = CSHAKE_BYTEPAD[bits2];
          var method = createCshakeOutputMethod(bits2, padding, "hex");
          method.create = function(outputBits, n, s2) {
            if (empty22(n) && empty22(s2)) {
              return methods["shake" + bits2].create(outputBits);
            } else {
              return new Keccak(bits2, padding, outputBits).bytepad([n, s2], w2);
            }
          };
          method.update = function(message2, outputBits, n, s2) {
            return method.create(outputBits, n, s2).update(message2);
          };
          return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
        };
        var createKmacMethod = function(bits2, padding) {
          var w2 = CSHAKE_BYTEPAD[bits2];
          var method = createKmacOutputMethod(bits2, padding, "hex");
          method.create = function(key, outputBits, s2) {
            return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s2], w2).bytepad([key], w2);
          };
          method.update = function(key, message2, outputBits, s2) {
            return method.create(key, outputBits, s2).update(message2);
          };
          return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
        };
        var algorithms = [
          { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
          { name: "sha3", padding: PADDING, bits: BITS, createMethod },
          { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
          { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
          { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
        ];
        var methods = {}, methodNames = [];
        for (var i = 0; i < algorithms.length; ++i) {
          var algorithm = algorithms[i];
          var bits = algorithm.bits;
          for (var j = 0; j < bits.length; ++j) {
            var methodName = algorithm.name + "_" + bits[j];
            methodNames.push(methodName);
            methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
            if (algorithm.name !== "sha3") {
              var newMethodName = algorithm.name + bits[j];
              methodNames.push(newMethodName);
              methods[newMethodName] = methods[methodName];
            }
          }
        }
        function Keccak(bits2, padding, outputBits) {
          this.blocks = [];
          this.s = [];
          this.padding = padding;
          this.outputBits = outputBits;
          this.reset = true;
          this.finalized = false;
          this.block = 0;
          this.start = 0;
          this.blockCount = 1600 - (bits2 << 1) >> 5;
          this.byteCount = this.blockCount << 2;
          this.outputBlocks = outputBits >> 5;
          this.extraBytes = (outputBits & 31) >> 3;
          for (var i2 = 0; i2 < 50; ++i2) {
            this.s[i2] = 0;
          }
        }
        Keccak.prototype.update = function(message2) {
          if (this.finalized) {
            throw new Error(FINALIZE_ERROR);
          }
          var result = formatMessage(message2);
          message2 = result[0];
          var isString = result[1];
          var blocks = this.blocks, byteCount = this.byteCount, length21 = message2.length, blockCount = this.blockCount, index = 0, s2 = this.s, i2, code18;
          while (index < length21) {
            if (this.reset) {
              this.reset = false;
              blocks[0] = this.block;
              for (i2 = 1; i2 < blockCount + 1; ++i2) {
                blocks[i2] = 0;
              }
            }
            if (isString) {
              for (i2 = this.start; index < length21 && i2 < byteCount; ++index) {
                code18 = message2.charCodeAt(index);
                if (code18 < 128) {
                  blocks[i2 >> 2] |= code18 << SHIFT[i2++ & 3];
                } else if (code18 < 2048) {
                  blocks[i2 >> 2] |= (192 | code18 >> 6) << SHIFT[i2++ & 3];
                  blocks[i2 >> 2] |= (128 | code18 & 63) << SHIFT[i2++ & 3];
                } else if (code18 < 55296 || code18 >= 57344) {
                  blocks[i2 >> 2] |= (224 | code18 >> 12) << SHIFT[i2++ & 3];
                  blocks[i2 >> 2] |= (128 | code18 >> 6 & 63) << SHIFT[i2++ & 3];
                  blocks[i2 >> 2] |= (128 | code18 & 63) << SHIFT[i2++ & 3];
                } else {
                  code18 = 65536 + ((code18 & 1023) << 10 | message2.charCodeAt(++index) & 1023);
                  blocks[i2 >> 2] |= (240 | code18 >> 18) << SHIFT[i2++ & 3];
                  blocks[i2 >> 2] |= (128 | code18 >> 12 & 63) << SHIFT[i2++ & 3];
                  blocks[i2 >> 2] |= (128 | code18 >> 6 & 63) << SHIFT[i2++ & 3];
                  blocks[i2 >> 2] |= (128 | code18 & 63) << SHIFT[i2++ & 3];
                }
              }
            } else {
              for (i2 = this.start; index < length21 && i2 < byteCount; ++index) {
                blocks[i2 >> 2] |= message2[index] << SHIFT[i2++ & 3];
              }
            }
            this.lastByteIndex = i2;
            if (i2 >= byteCount) {
              this.start = i2 - byteCount;
              this.block = blocks[blockCount];
              for (i2 = 0; i2 < blockCount; ++i2) {
                s2[i2] ^= blocks[i2];
              }
              f(s2);
              this.reset = true;
            } else {
              this.start = i2;
            }
          }
          return this;
        };
        Keccak.prototype.encode = function(x, right) {
          var o = x & 255, n = 1;
          var bytes2 = [o];
          x = x >> 8;
          o = x & 255;
          while (o > 0) {
            bytes2.unshift(o);
            x = x >> 8;
            o = x & 255;
            ++n;
          }
          if (right) {
            bytes2.push(n);
          } else {
            bytes2.unshift(n);
          }
          this.update(bytes2);
          return bytes2.length;
        };
        Keccak.prototype.encodeString = function(str) {
          var result = formatMessage(str);
          str = result[0];
          var isString = result[1];
          var bytes2 = 0, length21 = str.length;
          if (isString) {
            for (var i2 = 0; i2 < str.length; ++i2) {
              var code18 = str.charCodeAt(i2);
              if (code18 < 128) {
                bytes2 += 1;
              } else if (code18 < 2048) {
                bytes2 += 2;
              } else if (code18 < 55296 || code18 >= 57344) {
                bytes2 += 3;
              } else {
                code18 = 65536 + ((code18 & 1023) << 10 | str.charCodeAt(++i2) & 1023);
                bytes2 += 4;
              }
            }
          } else {
            bytes2 = length21;
          }
          bytes2 += this.encode(bytes2 * 8);
          this.update(str);
          return bytes2;
        };
        Keccak.prototype.bytepad = function(strs, w2) {
          var bytes2 = this.encode(w2);
          for (var i2 = 0; i2 < strs.length; ++i2) {
            bytes2 += this.encodeString(strs[i2]);
          }
          var paddingBytes = (w2 - bytes2 % w2) % w2;
          var zeros = [];
          zeros.length = paddingBytes;
          this.update(zeros);
          return this;
        };
        Keccak.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
          blocks[i2 >> 2] |= this.padding[i2 & 3];
          if (this.lastByteIndex === this.byteCount) {
            blocks[0] = blocks[blockCount];
            for (i2 = 1; i2 < blockCount + 1; ++i2) {
              blocks[i2] = 0;
            }
          }
          blocks[blockCount - 1] |= 2147483648;
          for (i2 = 0; i2 < blockCount; ++i2) {
            s2[i2] ^= blocks[i2];
          }
          f(s2);
        };
        Keccak.prototype.toString = Keccak.prototype.hex = function() {
          this.finalize();
          var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
          var hex = "", block;
          while (j2 < outputBlocks) {
            for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
              block = s2[i2];
              hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
            }
            if (j2 % blockCount === 0) {
              s2 = cloneArray2(s2);
              f(s2);
              i2 = 0;
            }
          }
          if (extraBytes) {
            block = s2[i2];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
            if (extraBytes > 1) {
              hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
            }
            if (extraBytes > 2) {
              hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
            }
          }
          return hex;
        };
        Keccak.prototype.arrayBuffer = function() {
          this.finalize();
          var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
          var bytes2 = this.outputBits >> 3;
          var buffer;
          if (extraBytes) {
            buffer = new ArrayBuffer(outputBlocks + 1 << 2);
          } else {
            buffer = new ArrayBuffer(bytes2);
          }
          var array = new Uint32Array(buffer);
          while (j2 < outputBlocks) {
            for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
              array[j2] = s2[i2];
            }
            if (j2 % blockCount === 0) {
              s2 = cloneArray2(s2);
              f(s2);
            }
          }
          if (extraBytes) {
            array[j2] = s2[i2];
            buffer = buffer.slice(0, bytes2);
          }
          return buffer;
        };
        Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
        Keccak.prototype.digest = Keccak.prototype.array = function() {
          this.finalize();
          var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
          var array = [], offset, block;
          while (j2 < outputBlocks) {
            for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
              offset = j2 << 2;
              block = s2[i2];
              array[offset] = block & 255;
              array[offset + 1] = block >> 8 & 255;
              array[offset + 2] = block >> 16 & 255;
              array[offset + 3] = block >> 24 & 255;
            }
            if (j2 % blockCount === 0) {
              s2 = cloneArray2(s2);
              f(s2);
            }
          }
          if (extraBytes) {
            offset = j2 << 2;
            block = s2[i2];
            array[offset] = block & 255;
            if (extraBytes > 1) {
              array[offset + 1] = block >> 8 & 255;
            }
            if (extraBytes > 2) {
              array[offset + 2] = block >> 16 & 255;
            }
          }
          return array;
        };
        function Kmac(bits2, padding, outputBits) {
          Keccak.call(this, bits2, padding, outputBits);
        }
        Kmac.prototype = new Keccak();
        Kmac.prototype.finalize = function() {
          this.encode(this.outputBits, true);
          return Keccak.prototype.finalize.call(this);
        };
        var f = function(s2) {
          var h2, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
          for (n = 0; n < 48; n += 2) {
            c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
            c1 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
            c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
            c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
            c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
            c5 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
            c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
            c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
            c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
            c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
            h2 = c8 ^ (c2 << 1 | c3 >>> 31);
            l = c9 ^ (c3 << 1 | c2 >>> 31);
            s2[0] ^= h2;
            s2[1] ^= l;
            s2[10] ^= h2;
            s2[11] ^= l;
            s2[20] ^= h2;
            s2[21] ^= l;
            s2[30] ^= h2;
            s2[31] ^= l;
            s2[40] ^= h2;
            s2[41] ^= l;
            h2 = c0 ^ (c4 << 1 | c5 >>> 31);
            l = c1 ^ (c5 << 1 | c4 >>> 31);
            s2[2] ^= h2;
            s2[3] ^= l;
            s2[12] ^= h2;
            s2[13] ^= l;
            s2[22] ^= h2;
            s2[23] ^= l;
            s2[32] ^= h2;
            s2[33] ^= l;
            s2[42] ^= h2;
            s2[43] ^= l;
            h2 = c2 ^ (c6 << 1 | c7 >>> 31);
            l = c3 ^ (c7 << 1 | c6 >>> 31);
            s2[4] ^= h2;
            s2[5] ^= l;
            s2[14] ^= h2;
            s2[15] ^= l;
            s2[24] ^= h2;
            s2[25] ^= l;
            s2[34] ^= h2;
            s2[35] ^= l;
            s2[44] ^= h2;
            s2[45] ^= l;
            h2 = c4 ^ (c8 << 1 | c9 >>> 31);
            l = c5 ^ (c9 << 1 | c8 >>> 31);
            s2[6] ^= h2;
            s2[7] ^= l;
            s2[16] ^= h2;
            s2[17] ^= l;
            s2[26] ^= h2;
            s2[27] ^= l;
            s2[36] ^= h2;
            s2[37] ^= l;
            s2[46] ^= h2;
            s2[47] ^= l;
            h2 = c6 ^ (c0 << 1 | c1 >>> 31);
            l = c7 ^ (c1 << 1 | c0 >>> 31);
            s2[8] ^= h2;
            s2[9] ^= l;
            s2[18] ^= h2;
            s2[19] ^= l;
            s2[28] ^= h2;
            s2[29] ^= l;
            s2[38] ^= h2;
            s2[39] ^= l;
            s2[48] ^= h2;
            s2[49] ^= l;
            b0 = s2[0];
            b1 = s2[1];
            b32 = s2[11] << 4 | s2[10] >>> 28;
            b33 = s2[10] << 4 | s2[11] >>> 28;
            b14 = s2[20] << 3 | s2[21] >>> 29;
            b15 = s2[21] << 3 | s2[20] >>> 29;
            b46 = s2[31] << 9 | s2[30] >>> 23;
            b47 = s2[30] << 9 | s2[31] >>> 23;
            b28 = s2[40] << 18 | s2[41] >>> 14;
            b29 = s2[41] << 18 | s2[40] >>> 14;
            b20 = s2[2] << 1 | s2[3] >>> 31;
            b21 = s2[3] << 1 | s2[2] >>> 31;
            b2 = s2[13] << 12 | s2[12] >>> 20;
            b3 = s2[12] << 12 | s2[13] >>> 20;
            b34 = s2[22] << 10 | s2[23] >>> 22;
            b35 = s2[23] << 10 | s2[22] >>> 22;
            b16 = s2[33] << 13 | s2[32] >>> 19;
            b17 = s2[32] << 13 | s2[33] >>> 19;
            b48 = s2[42] << 2 | s2[43] >>> 30;
            b49 = s2[43] << 2 | s2[42] >>> 30;
            b40 = s2[5] << 30 | s2[4] >>> 2;
            b41 = s2[4] << 30 | s2[5] >>> 2;
            b22 = s2[14] << 6 | s2[15] >>> 26;
            b23 = s2[15] << 6 | s2[14] >>> 26;
            b4 = s2[25] << 11 | s2[24] >>> 21;
            b5 = s2[24] << 11 | s2[25] >>> 21;
            b36 = s2[34] << 15 | s2[35] >>> 17;
            b37 = s2[35] << 15 | s2[34] >>> 17;
            b18 = s2[45] << 29 | s2[44] >>> 3;
            b19 = s2[44] << 29 | s2[45] >>> 3;
            b10 = s2[6] << 28 | s2[7] >>> 4;
            b11 = s2[7] << 28 | s2[6] >>> 4;
            b42 = s2[17] << 23 | s2[16] >>> 9;
            b43 = s2[16] << 23 | s2[17] >>> 9;
            b24 = s2[26] << 25 | s2[27] >>> 7;
            b25 = s2[27] << 25 | s2[26] >>> 7;
            b6 = s2[36] << 21 | s2[37] >>> 11;
            b7 = s2[37] << 21 | s2[36] >>> 11;
            b38 = s2[47] << 24 | s2[46] >>> 8;
            b39 = s2[46] << 24 | s2[47] >>> 8;
            b30 = s2[8] << 27 | s2[9] >>> 5;
            b31 = s2[9] << 27 | s2[8] >>> 5;
            b12 = s2[18] << 20 | s2[19] >>> 12;
            b13 = s2[19] << 20 | s2[18] >>> 12;
            b44 = s2[29] << 7 | s2[28] >>> 25;
            b45 = s2[28] << 7 | s2[29] >>> 25;
            b26 = s2[38] << 8 | s2[39] >>> 24;
            b27 = s2[39] << 8 | s2[38] >>> 24;
            b8 = s2[48] << 14 | s2[49] >>> 18;
            b9 = s2[49] << 14 | s2[48] >>> 18;
            s2[0] = b0 ^ ~b2 & b4;
            s2[1] = b1 ^ ~b3 & b5;
            s2[10] = b10 ^ ~b12 & b14;
            s2[11] = b11 ^ ~b13 & b15;
            s2[20] = b20 ^ ~b22 & b24;
            s2[21] = b21 ^ ~b23 & b25;
            s2[30] = b30 ^ ~b32 & b34;
            s2[31] = b31 ^ ~b33 & b35;
            s2[40] = b40 ^ ~b42 & b44;
            s2[41] = b41 ^ ~b43 & b45;
            s2[2] = b2 ^ ~b4 & b6;
            s2[3] = b3 ^ ~b5 & b7;
            s2[12] = b12 ^ ~b14 & b16;
            s2[13] = b13 ^ ~b15 & b17;
            s2[22] = b22 ^ ~b24 & b26;
            s2[23] = b23 ^ ~b25 & b27;
            s2[32] = b32 ^ ~b34 & b36;
            s2[33] = b33 ^ ~b35 & b37;
            s2[42] = b42 ^ ~b44 & b46;
            s2[43] = b43 ^ ~b45 & b47;
            s2[4] = b4 ^ ~b6 & b8;
            s2[5] = b5 ^ ~b7 & b9;
            s2[14] = b14 ^ ~b16 & b18;
            s2[15] = b15 ^ ~b17 & b19;
            s2[24] = b24 ^ ~b26 & b28;
            s2[25] = b25 ^ ~b27 & b29;
            s2[34] = b34 ^ ~b36 & b38;
            s2[35] = b35 ^ ~b37 & b39;
            s2[44] = b44 ^ ~b46 & b48;
            s2[45] = b45 ^ ~b47 & b49;
            s2[6] = b6 ^ ~b8 & b0;
            s2[7] = b7 ^ ~b9 & b1;
            s2[16] = b16 ^ ~b18 & b10;
            s2[17] = b17 ^ ~b19 & b11;
            s2[26] = b26 ^ ~b28 & b20;
            s2[27] = b27 ^ ~b29 & b21;
            s2[36] = b36 ^ ~b38 & b30;
            s2[37] = b37 ^ ~b39 & b31;
            s2[46] = b46 ^ ~b48 & b40;
            s2[47] = b47 ^ ~b49 & b41;
            s2[8] = b8 ^ ~b0 & b2;
            s2[9] = b9 ^ ~b1 & b3;
            s2[18] = b18 ^ ~b10 & b12;
            s2[19] = b19 ^ ~b11 & b13;
            s2[28] = b28 ^ ~b20 & b22;
            s2[29] = b29 ^ ~b21 & b23;
            s2[38] = b38 ^ ~b30 & b32;
            s2[39] = b39 ^ ~b31 & b33;
            s2[48] = b48 ^ ~b40 & b42;
            s2[49] = b49 ^ ~b41 & b43;
            s2[0] ^= RC[n];
            s2[1] ^= RC[n + 1];
          }
        };
        if (COMMON_JS) {
          module2.exports = methods;
        } else {
          for (i = 0; i < methodNames.length; ++i) {
            root[methodNames[i]] = methods[methodNames[i]];
          }
          if (AMD) {
            define(function() {
              return methods;
            });
          }
        }
      })();
    }
  });

  // ../node_modules/hi-base32/src/base32.js
  var require_base32 = __commonJS({
    "../node_modules/hi-base32/src/base32.js"(exports2, module2) {
      (function() {
        "use strict";
        var root = typeof window === "object" ? window : {};
        var NODE_JS = !root.HI_BASE32_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = global;
        }
        var COMMON_JS = !root.HI_BASE32_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
        var AMD = typeof define === "function" && define.amd;
        var BASE32_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split("");
        var BASE32_DECODE_CHAR = {
          "A": 0,
          "B": 1,
          "C": 2,
          "D": 3,
          "E": 4,
          "F": 5,
          "G": 6,
          "H": 7,
          "I": 8,
          "J": 9,
          "K": 10,
          "L": 11,
          "M": 12,
          "N": 13,
          "O": 14,
          "P": 15,
          "Q": 16,
          "R": 17,
          "S": 18,
          "T": 19,
          "U": 20,
          "V": 21,
          "W": 22,
          "X": 23,
          "Y": 24,
          "Z": 25,
          "2": 26,
          "3": 27,
          "4": 28,
          "5": 29,
          "6": 30,
          "7": 31
        };
        var blocks = [0, 0, 0, 0, 0, 0, 0, 0];
        var throwInvalidUtf8 = function(position, partial) {
          if (partial.length > 10) {
            partial = "..." + partial.substr(-10);
          }
          var err = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + position + " bytes: " + partial + " <-");
          err.position = position;
          throw err;
        };
        var toUtf8String = function(bytes2) {
          var str = "", length21 = bytes2.length, i = 0, followingChars = 0, b, c;
          while (i < length21) {
            b = bytes2[i++];
            if (b <= 127) {
              str += String.fromCharCode(b);
              continue;
            } else if (b > 191 && b <= 223) {
              c = b & 31;
              followingChars = 1;
            } else if (b <= 239) {
              c = b & 15;
              followingChars = 2;
            } else if (b <= 247) {
              c = b & 7;
              followingChars = 3;
            } else {
              throwInvalidUtf8(i, str);
            }
            for (var j = 0; j < followingChars; ++j) {
              b = bytes2[i++];
              if (b < 128 || b > 191) {
                throwInvalidUtf8(i, str);
              }
              c <<= 6;
              c += b & 63;
            }
            if (c >= 55296 && c <= 57343) {
              throwInvalidUtf8(i, str);
            }
            if (c > 1114111) {
              throwInvalidUtf8(i, str);
            }
            if (c <= 65535) {
              str += String.fromCharCode(c);
            } else {
              c -= 65536;
              str += String.fromCharCode((c >> 10) + 55296);
              str += String.fromCharCode((c & 1023) + 56320);
            }
          }
          return str;
        };
        var decodeAsBytes = function(base32Str) {
          if (base32Str === "") {
            return [];
          } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
            throw new Error("Invalid base32 characters");
          }
          base32Str = base32Str.replace(/=/g, "");
          var v1, v2, v3, v42, v5, v6, v7, v8, bytes2 = [], index = 0, length21 = base32Str.length;
          for (var i = 0, count = length21 >> 3 << 3; i < count; ) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            bytes2[index++] = (v1 << 3 | v2 >>> 2) & 255;
            bytes2[index++] = (v2 << 6 | v3 << 1 | v42 >>> 4) & 255;
            bytes2[index++] = (v42 << 4 | v5 >>> 1) & 255;
            bytes2[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
            bytes2[index++] = (v7 << 5 | v8) & 255;
          }
          var remain = length21 - count;
          if (remain === 2) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            bytes2[index++] = (v1 << 3 | v2 >>> 2) & 255;
          } else if (remain === 4) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            bytes2[index++] = (v1 << 3 | v2 >>> 2) & 255;
            bytes2[index++] = (v2 << 6 | v3 << 1 | v42 >>> 4) & 255;
          } else if (remain === 5) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            bytes2[index++] = (v1 << 3 | v2 >>> 2) & 255;
            bytes2[index++] = (v2 << 6 | v3 << 1 | v42 >>> 4) & 255;
            bytes2[index++] = (v42 << 4 | v5 >>> 1) & 255;
          } else if (remain === 7) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            bytes2[index++] = (v1 << 3 | v2 >>> 2) & 255;
            bytes2[index++] = (v2 << 6 | v3 << 1 | v42 >>> 4) & 255;
            bytes2[index++] = (v42 << 4 | v5 >>> 1) & 255;
            bytes2[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
          }
          return bytes2;
        };
        var encodeAscii = function(str) {
          var v1, v2, v3, v42, v5, base32Str = "", length21 = str.length;
          for (var i = 0, count = parseInt(length21 / 5) * 5; i < count; ) {
            v1 = str.charCodeAt(i++);
            v2 = str.charCodeAt(i++);
            v3 = str.charCodeAt(i++);
            v42 = str.charCodeAt(i++);
            v5 = str.charCodeAt(i++);
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v42 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
          }
          var remain = length21 - count;
          if (remain === 1) {
            v1 = str.charCodeAt(i);
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
          } else if (remain === 2) {
            v1 = str.charCodeAt(i++);
            v2 = str.charCodeAt(i);
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
          } else if (remain === 3) {
            v1 = str.charCodeAt(i++);
            v2 = str.charCodeAt(i++);
            v3 = str.charCodeAt(i);
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
          } else if (remain === 4) {
            v1 = str.charCodeAt(i++);
            v2 = str.charCodeAt(i++);
            v3 = str.charCodeAt(i++);
            v42 = str.charCodeAt(i);
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[v42 << 3 & 31] + "=";
          }
          return base32Str;
        };
        var encodeUtf8 = function(str) {
          var v1, v2, v3, v42, v5, code18, end = false, base32Str = "", index = 0, i, start2 = 0, bytes2 = 0, length21 = str.length;
          if (str === "") {
            return base32Str;
          }
          do {
            blocks[0] = blocks[5];
            blocks[1] = blocks[6];
            blocks[2] = blocks[7];
            for (i = start2; index < length21 && i < 5; ++index) {
              code18 = str.charCodeAt(index);
              if (code18 < 128) {
                blocks[i++] = code18;
              } else if (code18 < 2048) {
                blocks[i++] = 192 | code18 >> 6;
                blocks[i++] = 128 | code18 & 63;
              } else if (code18 < 55296 || code18 >= 57344) {
                blocks[i++] = 224 | code18 >> 12;
                blocks[i++] = 128 | code18 >> 6 & 63;
                blocks[i++] = 128 | code18 & 63;
              } else {
                code18 = 65536 + ((code18 & 1023) << 10 | str.charCodeAt(++index) & 1023);
                blocks[i++] = 240 | code18 >> 18;
                blocks[i++] = 128 | code18 >> 12 & 63;
                blocks[i++] = 128 | code18 >> 6 & 63;
                blocks[i++] = 128 | code18 & 63;
              }
            }
            bytes2 += i - start2;
            start2 = i - 5;
            if (index === length21) {
              ++index;
            }
            if (index > length21 && i < 6) {
              end = true;
            }
            v1 = blocks[0];
            if (i > 4) {
              v2 = blocks[1];
              v3 = blocks[2];
              v42 = blocks[3];
              v5 = blocks[4];
              base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v42 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
            } else if (i === 1) {
              base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
            } else if (i === 2) {
              v2 = blocks[1];
              base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
            } else if (i === 3) {
              v2 = blocks[1];
              v3 = blocks[2];
              base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
            } else {
              v2 = blocks[1];
              v3 = blocks[2];
              v42 = blocks[3];
              base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[v42 << 3 & 31] + "=";
            }
          } while (!end);
          return base32Str;
        };
        var encodeBytes = function(bytes2) {
          var v1, v2, v3, v42, v5, base32Str = "", length21 = bytes2.length;
          for (var i = 0, count = parseInt(length21 / 5) * 5; i < count; ) {
            v1 = bytes2[i++];
            v2 = bytes2[i++];
            v3 = bytes2[i++];
            v42 = bytes2[i++];
            v5 = bytes2[i++];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v42 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
          }
          var remain = length21 - count;
          if (remain === 1) {
            v1 = bytes2[i];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
          } else if (remain === 2) {
            v1 = bytes2[i++];
            v2 = bytes2[i];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
          } else if (remain === 3) {
            v1 = bytes2[i++];
            v2 = bytes2[i++];
            v3 = bytes2[i];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
          } else if (remain === 4) {
            v1 = bytes2[i++];
            v2 = bytes2[i++];
            v3 = bytes2[i++];
            v42 = bytes2[i];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[v42 << 3 & 31] + "=";
          }
          return base32Str;
        };
        var encode79 = function(input, asciiOnly) {
          var notString = typeof input !== "string";
          if (notString && input.constructor === ArrayBuffer) {
            input = new Uint8Array(input);
          }
          if (notString) {
            return encodeBytes(input);
          } else if (asciiOnly) {
            return encodeAscii(input);
          } else {
            return encodeUtf8(input);
          }
        };
        var decode99 = function(base32Str, asciiOnly) {
          if (!asciiOnly) {
            return toUtf8String(decodeAsBytes(base32Str));
          }
          if (base32Str === "") {
            return "";
          } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
            throw new Error("Invalid base32 characters");
          }
          var v1, v2, v3, v42, v5, v6, v7, v8, str = "", length21 = base32Str.indexOf("=");
          if (length21 === -1) {
            length21 = base32Str.length;
          }
          for (var i = 0, count = length21 >> 3 << 3; i < count; ) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v42 >>> 4) & 255) + String.fromCharCode((v42 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255) + String.fromCharCode((v7 << 5 | v8) & 255);
          }
          var remain = length21 - count;
          if (remain === 2) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255);
          } else if (remain === 4) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v42 >>> 4) & 255);
          } else if (remain === 5) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v42 >>> 4) & 255) + String.fromCharCode((v42 << 4 | v5 >>> 1) & 255);
          } else if (remain === 7) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
            str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v42 >>> 4) & 255) + String.fromCharCode((v42 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255);
          }
          return str;
        };
        var exports3 = {
          encode: encode79,
          decode: decode99
        };
        decode99.asBytes = decodeAsBytes;
        if (COMMON_JS) {
          module2.exports = exports3;
        } else {
          root.base32 = exports3;
          if (AMD) {
            define(function() {
              return exports3;
            });
          }
        }
      })();
    }
  });

  // ../node_modules/@protobufjs/aspromise/index.js
  var require_aspromise = __commonJS({
    "../node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
      "use strict";
      module2.exports = asPromise;
      function asPromise(fn, ctx) {
        var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
        while (index < arguments.length)
          params[offset++] = arguments[index++];
        return new Promise(function executor(resolve, reject) {
          params[offset] = function callback(err) {
            if (pending) {
              pending = false;
              if (err)
                reject(err);
              else {
                var params2 = new Array(arguments.length - 1), offset2 = 0;
                while (offset2 < params2.length)
                  params2[offset2++] = arguments[offset2];
                resolve.apply(null, params2);
              }
            }
          };
          try {
            fn.apply(ctx || null, params);
          } catch (err) {
            if (pending) {
              pending = false;
              reject(err);
            }
          }
        });
      }
    }
  });

  // ../node_modules/@protobufjs/base64/index.js
  var require_base64 = __commonJS({
    "../node_modules/@protobufjs/base64/index.js"(exports2) {
      "use strict";
      var base6420 = exports2;
      base6420.length = function length21(string19) {
        var p = string19.length;
        if (!p)
          return 0;
        var n = 0;
        while (--p % 4 > 1 && string19.charAt(p) === "=")
          ++n;
        return Math.ceil(string19.length * 3) / 4 - n;
      };
      var b64 = new Array(64);
      var s64 = new Array(123);
      for (i = 0; i < 64; )
        s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
      var i;
      base6420.encode = function encode79(buffer, start2, end) {
        var parts = null, chunk = [];
        var i2 = 0, j = 0, t;
        while (start2 < end) {
          var b = buffer[start2++];
          switch (j) {
            case 0:
              chunk[i2++] = b64[b >> 2];
              t = (b & 3) << 4;
              j = 1;
              break;
            case 1:
              chunk[i2++] = b64[t | b >> 4];
              t = (b & 15) << 2;
              j = 2;
              break;
            case 2:
              chunk[i2++] = b64[t | b >> 6];
              chunk[i2++] = b64[b & 63];
              j = 0;
              break;
          }
          if (i2 > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i2 = 0;
          }
        }
        if (j) {
          chunk[i2++] = b64[t];
          chunk[i2++] = 61;
          if (j === 1)
            chunk[i2++] = 61;
        }
        if (parts) {
          if (i2)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i2));
      };
      var invalidEncoding = "invalid encoding";
      base6420.decode = function decode99(string19, buffer, offset) {
        var start2 = offset;
        var j = 0, t;
        for (var i2 = 0; i2 < string19.length; ) {
          var c = string19.charCodeAt(i2++);
          if (c === 61 && j > 1)
            break;
          if ((c = s64[c]) === void 0)
            throw Error(invalidEncoding);
          switch (j) {
            case 0:
              t = c;
              j = 1;
              break;
            case 1:
              buffer[offset++] = t << 2 | (c & 48) >> 4;
              t = c;
              j = 2;
              break;
            case 2:
              buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
              t = c;
              j = 3;
              break;
            case 3:
              buffer[offset++] = (t & 3) << 6 | c;
              j = 0;
              break;
          }
        }
        if (j === 1)
          throw Error(invalidEncoding);
        return offset - start2;
      };
      base6420.test = function test(string19) {
        return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string19);
      };
    }
  });

  // ../node_modules/@protobufjs/eventemitter/index.js
  var require_eventemitter = __commonJS({
    "../node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
      "use strict";
      module2.exports = EventEmitter2;
      function EventEmitter2() {
        this._listeners = {};
      }
      EventEmitter2.prototype.on = function on(evt, fn, ctx) {
        (this._listeners[evt] || (this._listeners[evt] = [])).push({
          fn,
          ctx: ctx || this
        });
        return this;
      };
      EventEmitter2.prototype.off = function off(evt, fn) {
        if (evt === void 0)
          this._listeners = {};
        else {
          if (fn === void 0)
            this._listeners[evt] = [];
          else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length; )
              if (listeners[i].fn === fn)
                listeners.splice(i, 1);
              else
                ++i;
          }
        }
        return this;
      };
      EventEmitter2.prototype.emit = function emit(evt) {
        var listeners = this._listeners[evt];
        if (listeners) {
          var args = [], i = 1;
          for (; i < arguments.length; )
            args.push(arguments[i++]);
          for (i = 0; i < listeners.length; )
            listeners[i].fn.apply(listeners[i++].ctx, args);
        }
        return this;
      };
    }
  });

  // ../node_modules/@protobufjs/float/index.js
  var require_float = __commonJS({
    "../node_modules/@protobufjs/float/index.js"(exports2, module2) {
      "use strict";
      module2.exports = factory(factory);
      function factory(exports3) {
        if (typeof Float32Array !== "undefined") (function() {
          var f322 = new Float32Array([-0]), f8b2 = new Uint8Array(f322.buffer), le = f8b2[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f322[0] = val;
            buf[pos] = f8b2[0];
            buf[pos + 1] = f8b2[1];
            buf[pos + 2] = f8b2[2];
            buf[pos + 3] = f8b2[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f322[0] = val;
            buf[pos] = f8b2[3];
            buf[pos + 1] = f8b2[2];
            buf[pos + 2] = f8b2[1];
            buf[pos + 3] = f8b2[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b2[0] = buf[pos];
            f8b2[1] = buf[pos + 1];
            f8b2[2] = buf[pos + 2];
            f8b2[3] = buf[pos + 3];
            return f322[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b2[3] = buf[pos];
            f8b2[2] = buf[pos + 1];
            f8b2[1] = buf[pos + 2];
            f8b2[0] = buf[pos + 3];
            return f322[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
        else (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign3 = val < 0 ? 1 : 0;
            if (sign3)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign3 << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign3 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign3 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign3 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign3 * Infinity : exponent === 0 ? sign3 * 1401298464324817e-60 * mantissa : sign3 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
        if (typeof Float64Array !== "undefined") (function() {
          var f642 = new Float64Array([-0]), f8b2 = new Uint8Array(f642.buffer), le = f8b2[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f642[0] = val;
            buf[pos] = f8b2[0];
            buf[pos + 1] = f8b2[1];
            buf[pos + 2] = f8b2[2];
            buf[pos + 3] = f8b2[3];
            buf[pos + 4] = f8b2[4];
            buf[pos + 5] = f8b2[5];
            buf[pos + 6] = f8b2[6];
            buf[pos + 7] = f8b2[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f642[0] = val;
            buf[pos] = f8b2[7];
            buf[pos + 1] = f8b2[6];
            buf[pos + 2] = f8b2[5];
            buf[pos + 3] = f8b2[4];
            buf[pos + 4] = f8b2[3];
            buf[pos + 5] = f8b2[2];
            buf[pos + 6] = f8b2[1];
            buf[pos + 7] = f8b2[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b2[0] = buf[pos];
            f8b2[1] = buf[pos + 1];
            f8b2[2] = buf[pos + 2];
            f8b2[3] = buf[pos + 3];
            f8b2[4] = buf[pos + 4];
            f8b2[5] = buf[pos + 5];
            f8b2[6] = buf[pos + 6];
            f8b2[7] = buf[pos + 7];
            return f642[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b2[7] = buf[pos];
            f8b2[6] = buf[pos + 1];
            f8b2[5] = buf[pos + 2];
            f8b2[4] = buf[pos + 3];
            f8b2[3] = buf[pos + 4];
            f8b2[2] = buf[pos + 5];
            f8b2[1] = buf[pos + 6];
            f8b2[0] = buf[pos + 7];
            return f642[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
        else (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign3 = val < 0 ? 1 : 0;
            if (sign3)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign3 << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign3 << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign3 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign3 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign3 * Infinity : exponent === 0 ? sign3 * 5e-324 * mantissa : sign3 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
        return exports3;
      }
      function writeUintLE(val, buf, pos) {
        buf[pos] = val & 255;
        buf[pos + 1] = val >>> 8 & 255;
        buf[pos + 2] = val >>> 16 & 255;
        buf[pos + 3] = val >>> 24;
      }
      function writeUintBE(val, buf, pos) {
        buf[pos] = val >>> 24;
        buf[pos + 1] = val >>> 16 & 255;
        buf[pos + 2] = val >>> 8 & 255;
        buf[pos + 3] = val & 255;
      }
      function readUintLE(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
      }
      function readUintBE(buf, pos) {
        return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
      }
    }
  });

  // ../node_modules/@protobufjs/inquire/index.js
  var require_inquire = __commonJS({
    "../node_modules/@protobufjs/inquire/index.js"(exports, module) {
      "use strict";
      module.exports = inquire;
      function inquire(moduleName) {
        try {
          var mod = eval("quire".replace(/^/, "re"))(moduleName);
          if (mod && (mod.length || Object.keys(mod).length))
            return mod;
        } catch (e) {
        }
        return null;
      }
    }
  });

  // ../node_modules/@protobufjs/utf8/index.js
  var require_utf8 = __commonJS({
    "../node_modules/@protobufjs/utf8/index.js"(exports2) {
      "use strict";
      var utf8 = exports2;
      utf8.length = function utf8_length(string19) {
        var len = 0, c = 0;
        for (var i = 0; i < string19.length; ++i) {
          c = string19.charCodeAt(i);
          if (c < 128)
            len += 1;
          else if (c < 2048)
            len += 2;
          else if ((c & 64512) === 55296 && (string19.charCodeAt(i + 1) & 64512) === 56320) {
            ++i;
            len += 4;
          } else
            len += 3;
        }
        return len;
      };
      utf8.read = function utf8_read(buffer, start2, end) {
        var len = end - start2;
        if (len < 1)
          return "";
        var parts = null, chunk = [], i = 0, t;
        while (start2 < end) {
          t = buffer[start2++];
          if (t < 128)
            chunk[i++] = t;
          else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start2++] & 63;
          else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start2++] & 63) << 12 | (buffer[start2++] & 63) << 6 | buffer[start2++] & 63) - 65536;
            chunk[i++] = 55296 + (t >> 10);
            chunk[i++] = 56320 + (t & 1023);
          } else
            chunk[i++] = (t & 15) << 12 | (buffer[start2++] & 63) << 6 | buffer[start2++] & 63;
          if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
          }
        }
        if (parts) {
          if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i));
      };
      utf8.write = function utf8_write(string19, buffer, offset) {
        var start2 = offset, c1, c2;
        for (var i = 0; i < string19.length; ++i) {
          c1 = string19.charCodeAt(i);
          if (c1 < 128) {
            buffer[offset++] = c1;
          } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6 | 192;
            buffer[offset++] = c1 & 63 | 128;
          } else if ((c1 & 64512) === 55296 && ((c2 = string19.charCodeAt(i + 1)) & 64512) === 56320) {
            c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
            ++i;
            buffer[offset++] = c1 >> 18 | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
          } else {
            buffer[offset++] = c1 >> 12 | 224;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
          }
        }
        return offset - start2;
      };
    }
  });

  // ../node_modules/@protobufjs/pool/index.js
  var require_pool = __commonJS({
    "../node_modules/@protobufjs/pool/index.js"(exports2, module2) {
      "use strict";
      module2.exports = pool2;
      function pool2(alloc8, slice, size) {
        var SIZE = size || 8192;
        var MAX = SIZE >>> 1;
        var slab = null;
        var offset = SIZE;
        return function pool_alloc(size2) {
          if (size2 < 1 || size2 > MAX)
            return alloc8(size2);
          if (offset + size2 > SIZE) {
            slab = alloc8(SIZE);
            offset = 0;
          }
          var buf = slice.call(slab, offset, offset += size2);
          if (offset & 7)
            offset = (offset | 7) + 1;
          return buf;
        };
      }
    }
  });

  // ../node_modules/protobufjs/src/util/longbits.js
  var require_longbits = __commonJS({
    "../node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
      "use strict";
      module2.exports = LongBits2;
      var util = require_minimal();
      function LongBits2(lo, hi) {
        this.lo = lo >>> 0;
        this.hi = hi >>> 0;
      }
      var zero2 = LongBits2.zero = new LongBits2(0, 0);
      zero2.toNumber = function() {
        return 0;
      };
      zero2.zzEncode = zero2.zzDecode = function() {
        return this;
      };
      zero2.length = function() {
        return 1;
      };
      var zeroHash = LongBits2.zeroHash = "\0\0\0\0\0\0\0\0";
      LongBits2.fromNumber = function fromNumber(value) {
        if (value === 0)
          return zero2;
        var sign3 = value < 0;
        if (sign3)
          value = -value;
        var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
        if (sign3) {
          hi = ~hi >>> 0;
          lo = ~lo >>> 0;
          if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
              hi = 0;
          }
        }
        return new LongBits2(lo, hi);
      };
      LongBits2.from = function from39(value) {
        if (typeof value === "number")
          return LongBits2.fromNumber(value);
        if (util.isString(value)) {
          if (util.Long)
            value = util.Long.fromString(value);
          else
            return LongBits2.fromNumber(parseInt(value, 10));
        }
        return value.low || value.high ? new LongBits2(value.low >>> 0, value.high >>> 0) : zero2;
      };
      LongBits2.prototype.toNumber = function toNumber(unsigned) {
        if (!unsigned && this.hi >>> 31) {
          var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
          if (!lo)
            hi = hi + 1 >>> 0;
          return -(lo + hi * 4294967296);
        }
        return this.lo + this.hi * 4294967296;
      };
      LongBits2.prototype.toLong = function toLong(unsigned) {
        return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
      };
      var charCodeAt = String.prototype.charCodeAt;
      LongBits2.fromHash = function fromHash(hash2) {
        if (hash2 === zeroHash)
          return zero2;
        return new LongBits2(
          (charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0,
          (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0
        );
      };
      LongBits2.prototype.toHash = function toHash() {
        return String.fromCharCode(
          this.lo & 255,
          this.lo >>> 8 & 255,
          this.lo >>> 16 & 255,
          this.lo >>> 24,
          this.hi & 255,
          this.hi >>> 8 & 255,
          this.hi >>> 16 & 255,
          this.hi >>> 24
        );
      };
      LongBits2.prototype.zzEncode = function zzEncode() {
        var mask = this.hi >> 31;
        this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
        this.lo = (this.lo << 1 ^ mask) >>> 0;
        return this;
      };
      LongBits2.prototype.zzDecode = function zzDecode() {
        var mask = -(this.lo & 1);
        this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
        this.hi = (this.hi >>> 1 ^ mask) >>> 0;
        return this;
      };
      LongBits2.prototype.length = function length21() {
        var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
        return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
      };
    }
  });

  // ../node_modules/protobufjs/src/util/minimal.js
  var require_minimal = __commonJS({
    "../node_modules/protobufjs/src/util/minimal.js"(exports2) {
      "use strict";
      var util = exports2;
      util.asPromise = require_aspromise();
      util.base64 = require_base64();
      util.EventEmitter = require_eventemitter();
      util.float = require_float();
      util.inquire = require_inquire();
      util.utf8 = require_utf8();
      util.pool = require_pool();
      util.LongBits = require_longbits();
      util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
      util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
      util.emptyArray = Object.freeze ? Object.freeze([]) : (
        /* istanbul ignore next */
        []
      );
      util.emptyObject = Object.freeze ? Object.freeze({}) : (
        /* istanbul ignore next */
        {}
      );
      util.isInteger = Number.isInteger || /* istanbul ignore next */
      function isInteger2(value) {
        return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
      };
      util.isString = function isString(value) {
        return typeof value === "string" || value instanceof String;
      };
      util.isObject = function isObject(value) {
        return value && typeof value === "object";
      };
      util.isset = /**
       * Checks if a property on a message is considered to be present.
       * @param {Object} obj Plain object or message instance
       * @param {string} prop Property name
       * @returns {boolean} `true` if considered to be present, otherwise `false`
       */
      util.isSet = function isSet(obj, prop) {
        var value = obj[prop];
        if (value != null && obj.hasOwnProperty(prop))
          return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
        return false;
      };
      util.Buffer = (function() {
        try {
          var Buffer2 = util.inquire("buffer").Buffer;
          return Buffer2.prototype.utf8Write ? Buffer2 : (
            /* istanbul ignore next */
            null
          );
        } catch (e) {
          return null;
        }
      })();
      util._Buffer_from = null;
      util._Buffer_allocUnsafe = null;
      util.newBuffer = function newBuffer(sizeOrArray) {
        return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
      };
      util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      util.Long = /* istanbul ignore next */
      util.global.dcodeIO && /* istanbul ignore next */
      util.global.dcodeIO.Long || /* istanbul ignore next */
      util.global.Long || util.inquire("long");
      util.key2Re = /^true|false|0|1$/;
      util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
      util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
      util.longToHash = function longToHash(value) {
        return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
      };
      util.longFromHash = function longFromHash(hash2, unsigned) {
        var bits = util.LongBits.fromHash(hash2);
        if (util.Long)
          return util.Long.fromBits(bits.lo, bits.hi, unsigned);
        return bits.toNumber(Boolean(unsigned));
      };
      function merge3(dst, src22, ifNotSet) {
        for (var keys = Object.keys(src22), i = 0; i < keys.length; ++i)
          if (dst[keys[i]] === void 0 || !ifNotSet)
            dst[keys[i]] = src22[keys[i]];
        return dst;
      }
      util.merge = merge3;
      util.lcFirst = function lcFirst(str) {
        return str.charAt(0).toLowerCase() + str.substring(1);
      };
      function newError(name19) {
        function CustomError(message2, properties) {
          if (!(this instanceof CustomError))
            return new CustomError(message2, properties);
          Object.defineProperty(this, "message", { get: function() {
            return message2;
          } });
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, CustomError);
          else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });
          if (properties)
            merge3(this, properties);
        }
        CustomError.prototype = Object.create(Error.prototype, {
          constructor: {
            value: CustomError,
            writable: true,
            enumerable: false,
            configurable: true
          },
          name: {
            get: function get() {
              return name19;
            },
            set: void 0,
            enumerable: false,
            // configurable: false would accurately preserve the behavior of
            // the original, but I'm guessing that was not intentional.
            // For an actual error subclass, this property would
            // be configurable.
            configurable: true
          },
          toString: {
            value: function value() {
              return this.name + ": " + this.message;
            },
            writable: true,
            enumerable: false,
            configurable: true
          }
        });
        return CustomError;
      }
      util.newError = newError;
      util.ProtocolError = newError("ProtocolError");
      util.oneOfGetter = function getOneOf(fieldNames) {
        var fieldMap = {};
        for (var i = 0; i < fieldNames.length; ++i)
          fieldMap[fieldNames[i]] = 1;
        return function() {
          for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
            if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
              return keys[i2];
        };
      };
      util.oneOfSetter = function setOneOf(fieldNames) {
        return function(name19) {
          for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name19)
              delete this[fieldNames[i]];
        };
      };
      util.toJSONOptions = {
        longs: String,
        enums: String,
        bytes: String,
        json: true
      };
      util._configure = function() {
        var Buffer2 = util.Buffer;
        if (!Buffer2) {
          util._Buffer_from = util._Buffer_allocUnsafe = null;
          return;
        }
        util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
        function Buffer_from(value, encoding) {
          return new Buffer2(value, encoding);
        };
        util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
          return new Buffer2(size);
        };
      };
    }
  });

  // ../node_modules/protobufjs/src/writer.js
  var require_writer = __commonJS({
    "../node_modules/protobufjs/src/writer.js"(exports2, module2) {
      "use strict";
      module2.exports = Writer;
      var util = require_minimal();
      var BufferWriter;
      var LongBits2 = util.LongBits;
      var base6420 = util.base64;
      var utf8 = util.utf8;
      function Op2(fn, len, val) {
        this.fn = fn;
        this.len = len;
        this.next = void 0;
        this.val = val;
      }
      function noop2() {
      }
      function State2(writer) {
        this.head = writer.head;
        this.tail = writer.tail;
        this.len = writer.len;
        this.next = writer.states;
      }
      function Writer() {
        this.len = 0;
        this.head = new Op2(noop2, 0, 0);
        this.tail = this.head;
        this.states = null;
      }
      var create19 = function create20() {
        return util.Buffer ? function create_buffer_setup() {
          return (Writer.create = function create_buffer() {
            return new BufferWriter();
          })();
        } : function create_array() {
          return new Writer();
        };
      };
      Writer.create = create19();
      Writer.alloc = function alloc8(size) {
        return new util.Array(size);
      };
      if (util.Array !== Array)
        Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
      Writer.prototype._push = function push(fn, len, val) {
        this.tail = this.tail.next = new Op2(fn, len, val);
        this.len += len;
        return this;
      };
      function writeByte2(val, buf, pos) {
        buf[pos] = val & 255;
      }
      function writeVarint322(val, buf, pos) {
        while (val > 127) {
          buf[pos++] = val & 127 | 128;
          val >>>= 7;
        }
        buf[pos] = val;
      }
      function VarintOp2(len, val) {
        this.len = len;
        this.next = void 0;
        this.val = val;
      }
      VarintOp2.prototype = Object.create(Op2.prototype);
      VarintOp2.prototype.fn = writeVarint322;
      Writer.prototype.uint32 = function write_uint32(value) {
        this.len += (this.tail = this.tail.next = new VarintOp2(
          (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
          value
        )).len;
        return this;
      };
      Writer.prototype.int32 = function write_int32(value) {
        return value < 0 ? this._push(writeVarint642, 10, LongBits2.fromNumber(value)) : this.uint32(value);
      };
      Writer.prototype.sint32 = function write_sint32(value) {
        return this.uint32((value << 1 ^ value >> 31) >>> 0);
      };
      function writeVarint642(val, buf, pos) {
        while (val.hi) {
          buf[pos++] = val.lo & 127 | 128;
          val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
          val.hi >>>= 7;
        }
        while (val.lo > 127) {
          buf[pos++] = val.lo & 127 | 128;
          val.lo = val.lo >>> 7;
        }
        buf[pos++] = val.lo;
      }
      Writer.prototype.uint64 = function write_uint64(value) {
        var bits = LongBits2.from(value);
        return this._push(writeVarint642, bits.length(), bits);
      };
      Writer.prototype.int64 = Writer.prototype.uint64;
      Writer.prototype.sint64 = function write_sint64(value) {
        var bits = LongBits2.from(value).zzEncode();
        return this._push(writeVarint642, bits.length(), bits);
      };
      Writer.prototype.bool = function write_bool(value) {
        return this._push(writeByte2, 1, value ? 1 : 0);
      };
      function writeFixed322(val, buf, pos) {
        buf[pos] = val & 255;
        buf[pos + 1] = val >>> 8 & 255;
        buf[pos + 2] = val >>> 16 & 255;
        buf[pos + 3] = val >>> 24;
      }
      Writer.prototype.fixed32 = function write_fixed32(value) {
        return this._push(writeFixed322, 4, value >>> 0);
      };
      Writer.prototype.sfixed32 = Writer.prototype.fixed32;
      Writer.prototype.fixed64 = function write_fixed64(value) {
        var bits = LongBits2.from(value);
        return this._push(writeFixed322, 4, bits.lo)._push(writeFixed322, 4, bits.hi);
      };
      Writer.prototype.sfixed64 = Writer.prototype.fixed64;
      Writer.prototype.float = function write_float(value) {
        return this._push(util.float.writeFloatLE, 4, value);
      };
      Writer.prototype.double = function write_double(value) {
        return this._push(util.float.writeDoubleLE, 8, value);
      };
      var writeBytes2 = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
          buf[pos + i] = val[i];
      };
      Writer.prototype.bytes = function write_bytes(value) {
        var len = value.length >>> 0;
        if (!len)
          return this._push(writeByte2, 1, 0);
        if (util.isString(value)) {
          var buf = Writer.alloc(len = base6420.length(value));
          base6420.decode(value, buf, 0);
          value = buf;
        }
        return this.uint32(len)._push(writeBytes2, len, value);
      };
      Writer.prototype.string = function write_string(value) {
        var len = utf8.length(value);
        return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte2, 1, 0);
      };
      Writer.prototype.fork = function fork() {
        this.states = new State2(this);
        this.head = this.tail = new Op2(noop2, 0, 0);
        this.len = 0;
        return this;
      };
      Writer.prototype.reset = function reset() {
        if (this.states) {
          this.head = this.states.head;
          this.tail = this.states.tail;
          this.len = this.states.len;
          this.states = this.states.next;
        } else {
          this.head = this.tail = new Op2(noop2, 0, 0);
          this.len = 0;
        }
        return this;
      };
      Writer.prototype.ldelim = function ldelim() {
        var head = this.head, tail = this.tail, len = this.len;
        this.reset().uint32(len);
        if (len) {
          this.tail.next = head.next;
          this.tail = tail;
          this.len += len;
        }
        return this;
      };
      Writer.prototype.finish = function finish() {
        var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
        while (head) {
          head.fn(head.val, buf, pos);
          pos += head.len;
          head = head.next;
        }
        return buf;
      };
      Writer._configure = function(BufferWriter_) {
        BufferWriter = BufferWriter_;
        Writer.create = create19();
        BufferWriter._configure();
      };
    }
  });

  // ../node_modules/protobufjs/src/writer_buffer.js
  var require_writer_buffer = __commonJS({
    "../node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
      "use strict";
      module2.exports = BufferWriter;
      var Writer = require_writer();
      (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
      var util = require_minimal();
      function BufferWriter() {
        Writer.call(this);
      }
      BufferWriter._configure = function() {
        BufferWriter.alloc = util._Buffer_allocUnsafe;
        BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos);
        } : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy)
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
        };
      };
      BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
        if (util.isString(value))
          value = util._Buffer_from(value, "base64");
        var len = value.length >>> 0;
        this.uint32(len);
        if (len)
          this._push(BufferWriter.writeBytesBuffer, len, value);
        return this;
      };
      function writeStringBuffer2(val, buf, pos) {
        if (val.length < 40)
          util.utf8.write(val, buf, pos);
        else if (buf.utf8Write)
          buf.utf8Write(val, pos);
        else
          buf.write(val, pos);
      }
      BufferWriter.prototype.string = function write_string_buffer(value) {
        var len = util.Buffer.byteLength(value);
        this.uint32(len);
        if (len)
          this._push(writeStringBuffer2, len, value);
        return this;
      };
      BufferWriter._configure();
    }
  });

  // ../node_modules/protobufjs/src/reader.js
  var require_reader = __commonJS({
    "../node_modules/protobufjs/src/reader.js"(exports2, module2) {
      "use strict";
      module2.exports = Reader;
      var util = require_minimal();
      var BufferReader;
      var LongBits2 = util.LongBits;
      var utf8 = util.utf8;
      function indexOutOfRange2(reader, writeLength) {
        return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
      }
      function Reader(buffer) {
        this.buf = buffer;
        this.pos = 0;
        this.len = buffer.length;
      }
      var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
          return new Reader(buffer);
        throw Error("illegal buffer");
      } : function create_array2(buffer) {
        if (Array.isArray(buffer))
          return new Reader(buffer);
        throw Error("illegal buffer");
      };
      var create19 = function create20() {
        return util.Buffer ? function create_buffer_setup(buffer) {
          return (Reader.create = function create_buffer(buffer2) {
            return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
          })(buffer);
        } : create_array;
      };
      Reader.create = create19();
      Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
      util.Array.prototype.slice;
      Reader.prototype.uint32 = /* @__PURE__ */ (function read_uint32_setup() {
        var value = 4294967295;
        return function read_uint32() {
          value = (this.buf[this.pos] & 127) >>> 0;
          if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
          if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
          if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
          if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
          if (this.buf[this.pos++] < 128) return value;
          if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange2(this, 10);
          }
          return value;
        };
      })();
      Reader.prototype.int32 = function read_int32() {
        return this.uint32() | 0;
      };
      Reader.prototype.sint32 = function read_sint32() {
        var value = this.uint32();
        return value >>> 1 ^ -(value & 1) | 0;
      };
      function readLongVarint() {
        var bits = new LongBits2(0, 0);
        var i = 0;
        if (this.len - this.pos > 4) {
          for (; i < 4; ++i) {
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
          i = 0;
        } else {
          for (; i < 3; ++i) {
            if (this.pos >= this.len)
              throw indexOutOfRange2(this);
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
          bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
          return bits;
        }
        if (this.len - this.pos > 4) {
          for (; i < 5; ++i) {
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
        } else {
          for (; i < 5; ++i) {
            if (this.pos >= this.len)
              throw indexOutOfRange2(this);
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
        }
        throw Error("invalid varint encoding");
      }
      Reader.prototype.bool = function read_bool() {
        return this.uint32() !== 0;
      };
      function readFixed32_end(buf, end) {
        return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
      }
      Reader.prototype.fixed32 = function read_fixed32() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange2(this, 4);
        return readFixed32_end(this.buf, this.pos += 4);
      };
      Reader.prototype.sfixed32 = function read_sfixed32() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange2(this, 4);
        return readFixed32_end(this.buf, this.pos += 4) | 0;
      };
      function readFixed64() {
        if (this.pos + 8 > this.len)
          throw indexOutOfRange2(this, 8);
        return new LongBits2(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
      }
      Reader.prototype.float = function read_float() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange2(this, 4);
        var value = util.float.readFloatLE(this.buf, this.pos);
        this.pos += 4;
        return value;
      };
      Reader.prototype.double = function read_double() {
        if (this.pos + 8 > this.len)
          throw indexOutOfRange2(this, 4);
        var value = util.float.readDoubleLE(this.buf, this.pos);
        this.pos += 8;
        return value;
      };
      Reader.prototype.bytes = function read_bytes() {
        var length21 = this.uint32(), start2 = this.pos, end = this.pos + length21;
        if (end > this.len)
          throw indexOutOfRange2(this, length21);
        this.pos += length21;
        if (Array.isArray(this.buf))
          return this.buf.slice(start2, end);
        if (start2 === end) {
          var nativeBuffer = util.Buffer;
          return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
        }
        return this._slice.call(this.buf, start2, end);
      };
      Reader.prototype.string = function read_string() {
        var bytes2 = this.bytes();
        return utf8.read(bytes2, 0, bytes2.length);
      };
      Reader.prototype.skip = function skip(length21) {
        if (typeof length21 === "number") {
          if (this.pos + length21 > this.len)
            throw indexOutOfRange2(this, length21);
          this.pos += length21;
        } else {
          do {
            if (this.pos >= this.len)
              throw indexOutOfRange2(this);
          } while (this.buf[this.pos++] & 128);
        }
        return this;
      };
      Reader.prototype.skipType = function(wireType) {
        switch (wireType) {
          case 0:
            this.skip();
            break;
          case 1:
            this.skip(8);
            break;
          case 2:
            this.skip(this.uint32());
            break;
          case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
              this.skipType(wireType);
            }
            break;
          case 5:
            this.skip(4);
            break;
          /* istanbul ignore next */
          default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
        }
        return this;
      };
      Reader._configure = function(BufferReader_) {
        BufferReader = BufferReader_;
        Reader.create = create19();
        BufferReader._configure();
        var fn = util.Long ? "toLong" : (
          /* istanbul ignore next */
          "toNumber"
        );
        util.merge(Reader.prototype, {
          int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
          },
          uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
          },
          sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
          },
          fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
          },
          sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
          }
        });
      };
    }
  });

  // ../node_modules/protobufjs/src/reader_buffer.js
  var require_reader_buffer = __commonJS({
    "../node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
      "use strict";
      module2.exports = BufferReader;
      var Reader = require_reader();
      (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
      var util = require_minimal();
      function BufferReader(buffer) {
        Reader.call(this, buffer);
      }
      BufferReader._configure = function() {
        if (util.Buffer)
          BufferReader.prototype._slice = util.Buffer.prototype.slice;
      };
      BufferReader.prototype.string = function read_string_buffer() {
        var len = this.uint32();
        return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
      };
      BufferReader._configure();
    }
  });

  // ../node_modules/protobufjs/src/rpc/service.js
  var require_service = __commonJS({
    "../node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
      "use strict";
      module2.exports = Service;
      var util = require_minimal();
      (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
      function Service(rpcImpl, requestDelimited, responseDelimited) {
        if (typeof rpcImpl !== "function")
          throw TypeError("rpcImpl must be a function");
        util.EventEmitter.call(this);
        this.rpcImpl = rpcImpl;
        this.requestDelimited = Boolean(requestDelimited);
        this.responseDelimited = Boolean(responseDelimited);
      }
      Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request2, callback) {
        if (!request2)
          throw TypeError("request must be specified");
        var self2 = this;
        if (!callback)
          return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request2);
        if (!self2.rpcImpl) {
          setTimeout(function() {
            callback(Error("already ended"));
          }, 0);
          return void 0;
        }
        try {
          return self2.rpcImpl(
            method,
            requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request2).finish(),
            function rpcCallback(err, response) {
              if (err) {
                self2.emit("error", err, method);
                return callback(err);
              }
              if (response === null) {
                self2.end(
                  /* endedByRPC */
                  true
                );
                return void 0;
              }
              if (!(response instanceof responseCtor)) {
                try {
                  response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
                } catch (err2) {
                  self2.emit("error", err2, method);
                  return callback(err2);
                }
              }
              self2.emit("data", response, method);
              return callback(null, response);
            }
          );
        } catch (err) {
          self2.emit("error", err, method);
          setTimeout(function() {
            callback(err);
          }, 0);
          return void 0;
        }
      };
      Service.prototype.end = function end(endedByRPC) {
        if (this.rpcImpl) {
          if (!endedByRPC)
            this.rpcImpl(null, null, null);
          this.rpcImpl = null;
          this.emit("end").off();
        }
        return this;
      };
    }
  });

  // ../node_modules/protobufjs/src/rpc.js
  var require_rpc = __commonJS({
    "../node_modules/protobufjs/src/rpc.js"(exports2) {
      "use strict";
      var rpc = exports2;
      rpc.Service = require_service();
    }
  });

  // ../node_modules/protobufjs/src/roots.js
  var require_roots = __commonJS({
    "../node_modules/protobufjs/src/roots.js"(exports2, module2) {
      "use strict";
      module2.exports = {};
    }
  });

  // ../node_modules/protobufjs/src/index-minimal.js
  var require_index_minimal = __commonJS({
    "../node_modules/protobufjs/src/index-minimal.js"(exports2) {
      "use strict";
      var protobuf2 = exports2;
      protobuf2.build = "minimal";
      protobuf2.Writer = require_writer();
      protobuf2.BufferWriter = require_writer_buffer();
      protobuf2.Reader = require_reader();
      protobuf2.BufferReader = require_reader_buffer();
      protobuf2.util = require_minimal();
      protobuf2.rpc = require_rpc();
      protobuf2.roots = require_roots();
      protobuf2.configure = configure;
      function configure() {
        protobuf2.util._configure();
        protobuf2.Writer._configure(protobuf2.BufferWriter);
        protobuf2.Reader._configure(protobuf2.BufferReader);
      }
      configure();
    }
  });

  // ../node_modules/@protobufjs/codegen/index.js
  var require_codegen = __commonJS({
    "../node_modules/@protobufjs/codegen/index.js"(exports2, module2) {
      "use strict";
      module2.exports = codegen;
      function codegen(functionParams, functionName) {
        if (typeof functionParams === "string") {
          functionName = functionParams;
          functionParams = void 0;
        }
        var body = [];
        function Codegen(formatStringOrScope) {
          if (typeof formatStringOrScope !== "string") {
            var source = toString29();
            if (codegen.verbose)
              console.log("codegen: " + source);
            source = "return " + source;
            if (formatStringOrScope) {
              var scopeKeys = Object.keys(formatStringOrScope), scopeParams = new Array(scopeKeys.length + 1), scopeValues = new Array(scopeKeys.length), scopeOffset = 0;
              while (scopeOffset < scopeKeys.length) {
                scopeParams[scopeOffset] = scopeKeys[scopeOffset];
                scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
              }
              scopeParams[scopeOffset] = source;
              return Function.apply(null, scopeParams).apply(null, scopeValues);
            }
            return Function(source)();
          }
          var formatParams = new Array(arguments.length - 1), formatOffset = 0;
          while (formatOffset < formatParams.length)
            formatParams[formatOffset] = arguments[++formatOffset];
          formatOffset = 0;
          formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
            var value = formatParams[formatOffset++];
            switch ($1) {
              case "d":
              case "f":
                return String(Number(value));
              case "i":
                return String(Math.floor(value));
              case "j":
                return JSON.stringify(value);
              case "s":
                return String(value);
            }
            return "%";
          });
          if (formatOffset !== formatParams.length)
            throw Error("parameter count mismatch");
          body.push(formatStringOrScope);
          return Codegen;
        }
        function toString29(functionNameOverride) {
          return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
        }
        Codegen.toString = toString29;
        return Codegen;
      }
      codegen.verbose = false;
    }
  });

  // ../node_modules/@protobufjs/fetch/index.js
  var require_fetch = __commonJS({
    "../node_modules/@protobufjs/fetch/index.js"(exports2, module2) {
      "use strict";
      module2.exports = fetch2;
      var asPromise = require_aspromise();
      var inquire2 = require_inquire();
      var fs = inquire2("fs");
      function fetch2(filename, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        } else if (!options)
          options = {};
        if (!callback)
          return asPromise(fetch2, this, filename, options);
        if (!options.xhr && fs && fs.readFile)
          return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
            return err && typeof XMLHttpRequest !== "undefined" ? fetch2.xhr(filename, options, callback) : err ? callback(err) : callback(null, options.binary ? contents : contents.toString("utf8"));
          });
        return fetch2.xhr(filename, options, callback);
      }
      fetch2.xhr = function fetch_xhr(filename, options, callback) {
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function fetchOnReadyStateChange() {
          if (xhr.readyState !== 4)
            return void 0;
          if (xhr.status !== 0 && xhr.status !== 200)
            return callback(Error("status " + xhr.status));
          if (options.binary) {
            var buffer = xhr.response;
            if (!buffer) {
              buffer = [];
              for (var i = 0; i < xhr.responseText.length; ++i)
                buffer.push(xhr.responseText.charCodeAt(i) & 255);
            }
            return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
          }
          return callback(null, xhr.responseText);
        };
        if (options.binary) {
          if ("overrideMimeType" in xhr)
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
          xhr.responseType = "arraybuffer";
        }
        xhr.open("GET", filename);
        xhr.send();
      };
    }
  });

  // ../node_modules/@protobufjs/path/index.js
  var require_path = __commonJS({
    "../node_modules/@protobufjs/path/index.js"(exports2) {
      "use strict";
      var path = exports2;
      var isAbsolute = (
        /**
         * Tests if the specified path is absolute.
         * @param {string} path Path to test
         * @returns {boolean} `true` if path is absolute
         */
        path.isAbsolute = function isAbsolute2(path2) {
          return /^(?:\/|\w+:)/.test(path2);
        }
      );
      var normalize = (
        /**
         * Normalizes the specified path.
         * @param {string} path Path to normalize
         * @returns {string} Normalized path
         */
        path.normalize = function normalize2(path2) {
          path2 = path2.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
          var parts = path2.split("/"), absolute = isAbsolute(path2), prefix = "";
          if (absolute)
            prefix = parts.shift() + "/";
          for (var i = 0; i < parts.length; ) {
            if (parts[i] === "..") {
              if (i > 0 && parts[i - 1] !== "..")
                parts.splice(--i, 2);
              else if (absolute)
                parts.splice(i, 1);
              else
                ++i;
            } else if (parts[i] === ".")
              parts.splice(i, 1);
            else
              ++i;
          }
          return prefix + parts.join("/");
        }
      );
      path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
        if (!alreadyNormalized)
          includePath = normalize(includePath);
        if (isAbsolute(includePath))
          return includePath;
        if (!alreadyNormalized)
          originPath = normalize(originPath);
        return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
      };
    }
  });

  // ../node_modules/protobufjs/src/namespace.js
  var require_namespace = __commonJS({
    "../node_modules/protobufjs/src/namespace.js"(exports2, module2) {
      "use strict";
      module2.exports = Namespace;
      var ReflectionObject = require_object();
      ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";
      var Field4 = require_field();
      var util = require_util();
      var OneOf = require_oneof();
      var Type;
      var Service;
      var Enum;
      Namespace.fromJSON = function fromJSON(name19, json) {
        return new Namespace(name19, json.options).addJSON(json.nested);
      };
      function arrayToJSON(array, toJSONOptions) {
        if (!(array && array.length))
          return void 0;
        var obj = {};
        for (var i = 0; i < array.length; ++i)
          obj[array[i].name] = array[i].toJSON(toJSONOptions);
        return obj;
      }
      Namespace.arrayToJSON = arrayToJSON;
      Namespace.isReservedId = function isReservedId(reserved, id) {
        if (reserved) {
          for (var i = 0; i < reserved.length; ++i)
            if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
              return true;
        }
        return false;
      };
      Namespace.isReservedName = function isReservedName(reserved, name19) {
        if (reserved) {
          for (var i = 0; i < reserved.length; ++i)
            if (reserved[i] === name19)
              return true;
        }
        return false;
      };
      function Namespace(name19, options) {
        ReflectionObject.call(this, name19, options);
        this.nested = void 0;
        this._nestedArray = null;
        this._lookupCache = {};
        this._needsRecursiveFeatureResolution = true;
        this._needsRecursiveResolve = true;
      }
      function clearCache(namespace) {
        namespace._nestedArray = null;
        namespace._lookupCache = {};
        var parent = namespace;
        while (parent = parent.parent) {
          parent._lookupCache = {};
        }
        return namespace;
      }
      Object.defineProperty(Namespace.prototype, "nestedArray", {
        get: function() {
          return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
        }
      });
      Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
        return util.toObject([
          "options",
          this.options,
          "nested",
          arrayToJSON(this.nestedArray, toJSONOptions)
        ]);
      };
      Namespace.prototype.addJSON = function addJSON(nestedJson) {
        var ns = this;
        if (nestedJson) {
          for (var names2 = Object.keys(nestedJson), i = 0, nested; i < names2.length; ++i) {
            nested = nestedJson[names2[i]];
            ns.add(
              // most to least likely
              (nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : nested.id !== void 0 ? Field4.fromJSON : Namespace.fromJSON)(names2[i], nested)
            );
          }
        }
        return this;
      };
      Namespace.prototype.get = function get(name19) {
        return this.nested && this.nested[name19] || null;
      };
      Namespace.prototype.getEnum = function getEnum(name19) {
        if (this.nested && this.nested[name19] instanceof Enum)
          return this.nested[name19].values;
        throw Error("no such enum: " + name19);
      };
      Namespace.prototype.add = function add4(object) {
        if (!(object instanceof Field4 && object.extend !== void 0 || object instanceof Type || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))
          throw TypeError("object must be a valid nested object");
        if (!this.nested)
          this.nested = {};
        else {
          var prev = this.get(object.name);
          if (prev) {
            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
              var nested = prev.nestedArray;
              for (var i = 0; i < nested.length; ++i)
                object.add(nested[i]);
              this.remove(prev);
              if (!this.nested)
                this.nested = {};
              object.setOptions(prev.options, true);
            } else
              throw Error("duplicate name '" + object.name + "' in " + this);
          }
        }
        this.nested[object.name] = object;
        if (!(this instanceof Type || this instanceof Service || this instanceof Enum || this instanceof Field4)) {
          if (!object._edition) {
            object._edition = object._defaultEdition;
          }
        }
        this._needsRecursiveFeatureResolution = true;
        this._needsRecursiveResolve = true;
        var parent = this;
        while (parent = parent.parent) {
          parent._needsRecursiveFeatureResolution = true;
          parent._needsRecursiveResolve = true;
        }
        object.onAdd(this);
        return clearCache(this);
      };
      Namespace.prototype.remove = function remove(object) {
        if (!(object instanceof ReflectionObject))
          throw TypeError("object must be a ReflectionObject");
        if (object.parent !== this)
          throw Error(object + " is not a member of " + this);
        delete this.nested[object.name];
        if (!Object.keys(this.nested).length)
          this.nested = void 0;
        object.onRemove(this);
        return clearCache(this);
      };
      Namespace.prototype.define = function define2(path, json) {
        if (util.isString(path))
          path = path.split(".");
        else if (!Array.isArray(path))
          throw TypeError("illegal path");
        if (path && path.length && path[0] === "")
          throw Error("path must be relative");
        var ptr = this;
        while (path.length > 0) {
          var part = path.shift();
          if (ptr.nested && ptr.nested[part]) {
            ptr = ptr.nested[part];
            if (!(ptr instanceof Namespace))
              throw Error("path conflicts with non-namespace objects");
          } else
            ptr.add(ptr = new Namespace(part));
        }
        if (json)
          ptr.addJSON(json);
        return ptr;
      };
      Namespace.prototype.resolveAll = function resolveAll() {
        if (!this._needsRecursiveResolve) return this;
        this._resolveFeaturesRecursive(this._edition);
        var nested = this.nestedArray, i = 0;
        this.resolve();
        while (i < nested.length)
          if (nested[i] instanceof Namespace)
            nested[i++].resolveAll();
          else
            nested[i++].resolve();
        this._needsRecursiveResolve = false;
        return this;
      };
      Namespace.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {
        if (!this._needsRecursiveFeatureResolution) return this;
        this._needsRecursiveFeatureResolution = false;
        edition = this._edition || edition;
        ReflectionObject.prototype._resolveFeaturesRecursive.call(this, edition);
        this.nestedArray.forEach((nested) => {
          nested._resolveFeaturesRecursive(edition);
        });
        return this;
      };
      Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {
        if (typeof filterTypes === "boolean") {
          parentAlreadyChecked = filterTypes;
          filterTypes = void 0;
        } else if (filterTypes && !Array.isArray(filterTypes))
          filterTypes = [filterTypes];
        if (util.isString(path) && path.length) {
          if (path === ".")
            return this.root;
          path = path.split(".");
        } else if (!path.length)
          return this;
        var flatPath = path.join(".");
        if (path[0] === "")
          return this.root.lookup(path.slice(1), filterTypes);
        var found = this.root._fullyQualifiedObjects && this.root._fullyQualifiedObjects["." + flatPath];
        if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {
          return found;
        }
        found = this._lookupImpl(path, flatPath);
        if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {
          return found;
        }
        if (parentAlreadyChecked)
          return null;
        var current = this;
        while (current.parent) {
          found = current.parent._lookupImpl(path, flatPath);
          if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {
            return found;
          }
          current = current.parent;
        }
        return null;
      };
      Namespace.prototype._lookupImpl = function lookup(path, flatPath) {
        if (Object.prototype.hasOwnProperty.call(this._lookupCache, flatPath)) {
          return this._lookupCache[flatPath];
        }
        var found = this.get(path[0]);
        var exact = null;
        if (found) {
          if (path.length === 1) {
            exact = found;
          } else if (found instanceof Namespace) {
            path = path.slice(1);
            exact = found._lookupImpl(path, path.join("."));
          }
        } else {
          for (var i = 0; i < this.nestedArray.length; ++i)
            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i]._lookupImpl(path, flatPath)))
              exact = found;
        }
        this._lookupCache[flatPath] = exact;
        return exact;
      };
      Namespace.prototype.lookupType = function lookupType(path) {
        var found = this.lookup(path, [Type]);
        if (!found)
          throw Error("no such type: " + path);
        return found;
      };
      Namespace.prototype.lookupEnum = function lookupEnum(path) {
        var found = this.lookup(path, [Enum]);
        if (!found)
          throw Error("no such Enum '" + path + "' in " + this);
        return found;
      };
      Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
        var found = this.lookup(path, [Type, Enum]);
        if (!found)
          throw Error("no such Type or Enum '" + path + "' in " + this);
        return found;
      };
      Namespace.prototype.lookupService = function lookupService(path) {
        var found = this.lookup(path, [Service]);
        if (!found)
          throw Error("no such Service '" + path + "' in " + this);
        return found;
      };
      Namespace._configure = function(Type_, Service_, Enum_) {
        Type = Type_;
        Service = Service_;
        Enum = Enum_;
      };
    }
  });

  // ../node_modules/protobufjs/src/mapfield.js
  var require_mapfield = __commonJS({
    "../node_modules/protobufjs/src/mapfield.js"(exports2, module2) {
      "use strict";
      module2.exports = MapField;
      var Field4 = require_field();
      ((MapField.prototype = Object.create(Field4.prototype)).constructor = MapField).className = "MapField";
      var types = require_types();
      var util = require_util();
      function MapField(name19, id, keyType, type, options, comment) {
        Field4.call(this, name19, id, type, void 0, void 0, options, comment);
        if (!util.isString(keyType))
          throw TypeError("keyType must be a string");
        this.keyType = keyType;
        this.resolvedKeyType = null;
        this.map = true;
      }
      MapField.fromJSON = function fromJSON(name19, json) {
        return new MapField(name19, json.id, json.keyType, json.type, json.options, json.comment);
      };
      MapField.prototype.toJSON = function toJSON(toJSONOptions) {
        var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
        return util.toObject([
          "keyType",
          this.keyType,
          "type",
          this.type,
          "id",
          this.id,
          "extend",
          this.extend,
          "options",
          this.options,
          "comment",
          keepComments ? this.comment : void 0
        ]);
      };
      MapField.prototype.resolve = function resolve() {
        if (this.resolved)
          return this;
        if (types.mapKey[this.keyType] === void 0)
          throw Error("invalid key type: " + this.keyType);
        return Field4.prototype.resolve.call(this);
      };
      MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
        if (typeof fieldValueType === "function")
          fieldValueType = util.decorateType(fieldValueType).name;
        else if (fieldValueType && typeof fieldValueType === "object")
          fieldValueType = util.decorateEnum(fieldValueType).name;
        return function mapFieldDecorator(prototype, fieldName) {
          util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
        };
      };
    }
  });

  // ../node_modules/protobufjs/src/method.js
  var require_method = __commonJS({
    "../node_modules/protobufjs/src/method.js"(exports2, module2) {
      "use strict";
      module2.exports = Method;
      var ReflectionObject = require_object();
      ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";
      var util = require_util();
      function Method(name19, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {
        if (util.isObject(requestStream)) {
          options = requestStream;
          requestStream = responseStream = void 0;
        } else if (util.isObject(responseStream)) {
          options = responseStream;
          responseStream = void 0;
        }
        if (!(type === void 0 || util.isString(type)))
          throw TypeError("type must be a string");
        if (!util.isString(requestType))
          throw TypeError("requestType must be a string");
        if (!util.isString(responseType))
          throw TypeError("responseType must be a string");
        ReflectionObject.call(this, name19, options);
        this.type = type || "rpc";
        this.requestType = requestType;
        this.requestStream = requestStream ? true : void 0;
        this.responseType = responseType;
        this.responseStream = responseStream ? true : void 0;
        this.resolvedRequestType = null;
        this.resolvedResponseType = null;
        this.comment = comment;
        this.parsedOptions = parsedOptions;
      }
      Method.fromJSON = function fromJSON(name19, json) {
        return new Method(name19, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
      };
      Method.prototype.toJSON = function toJSON(toJSONOptions) {
        var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
        return util.toObject([
          "type",
          this.type !== "rpc" && /* istanbul ignore next */
          this.type || void 0,
          "requestType",
          this.requestType,
          "requestStream",
          this.requestStream,
          "responseType",
          this.responseType,
          "responseStream",
          this.responseStream,
          "options",
          this.options,
          "comment",
          keepComments ? this.comment : void 0,
          "parsedOptions",
          this.parsedOptions
        ]);
      };
      Method.prototype.resolve = function resolve() {
        if (this.resolved)
          return this;
        this.resolvedRequestType = this.parent.lookupType(this.requestType);
        this.resolvedResponseType = this.parent.lookupType(this.responseType);
        return ReflectionObject.prototype.resolve.call(this);
      };
    }
  });

  // ../node_modules/protobufjs/src/service.js
  var require_service2 = __commonJS({
    "../node_modules/protobufjs/src/service.js"(exports2, module2) {
      "use strict";
      module2.exports = Service;
      var Namespace = require_namespace();
      ((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";
      var Method = require_method();
      var util = require_util();
      var rpc = require_rpc();
      function Service(name19, options) {
        Namespace.call(this, name19, options);
        this.methods = {};
        this._methodsArray = null;
      }
      Service.fromJSON = function fromJSON(name19, json) {
        var service = new Service(name19, json.options);
        if (json.methods)
          for (var names2 = Object.keys(json.methods), i = 0; i < names2.length; ++i)
            service.add(Method.fromJSON(names2[i], json.methods[names2[i]]));
        if (json.nested)
          service.addJSON(json.nested);
        if (json.edition)
          service._edition = json.edition;
        service.comment = json.comment;
        service._defaultEdition = "proto3";
        return service;
      };
      Service.prototype.toJSON = function toJSON(toJSONOptions) {
        var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
        var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
        return util.toObject([
          "edition",
          this._editionToJSON(),
          "options",
          inherited && inherited.options || void 0,
          "methods",
          Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */
          {},
          "nested",
          inherited && inherited.nested || void 0,
          "comment",
          keepComments ? this.comment : void 0
        ]);
      };
      Object.defineProperty(Service.prototype, "methodsArray", {
        get: function() {
          return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
        }
      });
      function clearCache(service) {
        service._methodsArray = null;
        return service;
      }
      Service.prototype.get = function get(name19) {
        return this.methods[name19] || Namespace.prototype.get.call(this, name19);
      };
      Service.prototype.resolveAll = function resolveAll() {
        if (!this._needsRecursiveResolve) return this;
        Namespace.prototype.resolve.call(this);
        var methods = this.methodsArray;
        for (var i = 0; i < methods.length; ++i)
          methods[i].resolve();
        return this;
      };
      Service.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {
        if (!this._needsRecursiveFeatureResolution) return this;
        edition = this._edition || edition;
        Namespace.prototype._resolveFeaturesRecursive.call(this, edition);
        this.methodsArray.forEach((method) => {
          method._resolveFeaturesRecursive(edition);
        });
        return this;
      };
      Service.prototype.add = function add4(object) {
        if (this.get(object.name))
          throw Error("duplicate name '" + object.name + "' in " + this);
        if (object instanceof Method) {
          this.methods[object.name] = object;
          object.parent = this;
          return clearCache(this);
        }
        return Namespace.prototype.add.call(this, object);
      };
      Service.prototype.remove = function remove(object) {
        if (object instanceof Method) {
          if (this.methods[object.name] !== object)
            throw Error(object + " is not a member of " + this);
          delete this.methods[object.name];
          object.parent = null;
          return clearCache(this);
        }
        return Namespace.prototype.remove.call(this, object);
      };
      Service.prototype.create = function create19(rpcImpl, requestDelimited, responseDelimited) {
        var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
        for (var i = 0, method; i < /* initializes */
        this.methodsArray.length; ++i) {
          var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
          rpcService[methodName] = util.codegen(["r", "c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
            m: method,
            q: method.resolvedRequestType.ctor,
            s: method.resolvedResponseType.ctor
          });
        }
        return rpcService;
      };
    }
  });

  // ../node_modules/protobufjs/src/message.js
  var require_message = __commonJS({
    "../node_modules/protobufjs/src/message.js"(exports2, module2) {
      "use strict";
      module2.exports = Message;
      var util = require_minimal();
      function Message(properties) {
        if (properties)
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            this[keys[i]] = properties[keys[i]];
      }
      Message.create = function create19(properties) {
        return this.$type.create(properties);
      };
      Message.encode = function encode79(message2, writer) {
        return this.$type.encode(message2, writer);
      };
      Message.encodeDelimited = function encodeDelimited(message2, writer) {
        return this.$type.encodeDelimited(message2, writer);
      };
      Message.decode = function decode99(reader) {
        return this.$type.decode(reader);
      };
      Message.decodeDelimited = function decodeDelimited(reader) {
        return this.$type.decodeDelimited(reader);
      };
      Message.verify = function verify2(message2) {
        return this.$type.verify(message2);
      };
      Message.fromObject = function fromObject(object) {
        return this.$type.fromObject(object);
      };
      Message.toObject = function toObject(message2, options) {
        return this.$type.toObject(message2, options);
      };
      Message.prototype.toJSON = function toJSON() {
        return this.$type.toObject(this, util.toJSONOptions);
      };
    }
  });

  // ../node_modules/protobufjs/src/decoder.js
  var require_decoder = __commonJS({
    "../node_modules/protobufjs/src/decoder.js"(exports2, module2) {
      "use strict";
      module2.exports = decoder;
      var Enum = require_enum();
      var types = require_types();
      var util = require_util();
      function missing(field) {
        return "missing required '" + field.name + "'";
      }
      function decoder(mtype) {
        var gen = util.codegen(["r", "l", "e"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field2) {
          return field2.map;
        }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()")("if(t===e)")("break")("switch(t>>>3){");
        var i = 0;
        for (; i < /* initializes */
        mtype.fieldsArray.length; ++i) {
          var field = mtype._fieldsArray[i].resolve(), type = field.resolvedType instanceof Enum ? "int32" : field.type, ref = "m" + util.safeProp(field.name);
          gen("case %i: {", field.id);
          if (field.map) {
            gen("if(%s===util.emptyObject)", ref)("%s={}", ref)("var c2 = r.uint32()+r.pos");
            if (types.defaults[field.keyType] !== void 0) gen("k=%j", types.defaults[field.keyType]);
            else gen("k=null");
            if (types.defaults[type] !== void 0) gen("value=%j", types.defaults[type]);
            else gen("value=null");
            gen("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", field.keyType)("case 2:");
            if (types.basic[type] === void 0) gen("value=types[%i].decode(r,r.uint32())", i);
            else gen("value=r.%s()", type);
            gen("break")("default:")("r.skipType(tag2&7)")("break")("}")("}");
            if (types.long[field.keyType] !== void 0) gen('%s[typeof k==="object"?util.longToHash(k):k]=value', ref);
            else gen("%s[k]=value", ref);
          } else if (field.repeated) {
            gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref);
            if (types.packed[type] !== void 0) gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref, type)("}else");
            if (types.basic[type] === void 0) gen(field.delimited ? "%s.push(types[%i].decode(r,undefined,((t&~7)|4)))" : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
            else gen("%s.push(r.%s())", ref, type);
          } else if (types.basic[type] === void 0) gen(field.delimited ? "%s=types[%i].decode(r,undefined,((t&~7)|4))" : "%s=types[%i].decode(r,r.uint32())", ref, i);
          else gen("%s=r.%s()", ref, type);
          gen("break")("}");
        }
        gen("default:")("r.skipType(t&7)")("break")("}")("}");
        for (i = 0; i < mtype._fieldsArray.length; ++i) {
          var rfield = mtype._fieldsArray[i];
          if (rfield.required) gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
        }
        return gen("return m");
      }
    }
  });

  // ../node_modules/protobufjs/src/verifier.js
  var require_verifier = __commonJS({
    "../node_modules/protobufjs/src/verifier.js"(exports2, module2) {
      "use strict";
      module2.exports = verifier;
      var Enum = require_enum();
      var util = require_util();
      function invalid(field, expected) {
        return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:" + field.keyType + "}" : "") + " expected";
      }
      function genVerifyValue(gen, field, fieldIndex, ref) {
        if (field.resolvedType) {
          if (field.resolvedType instanceof Enum) {
            gen("switch(%s){", ref)("default:")("return%j", invalid(field, "enum value"));
            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen("case %i:", field.resolvedType.values[keys[j]]);
            gen("break")("}");
          } else {
            gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")("return%j+e", field.name + ".")("}");
          }
        } else {
          switch (field.type) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32":
              gen("if(!util.isInteger(%s))", ref)("return%j", invalid(field, "integer"));
              break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64":
              gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)("return%j", invalid(field, "integer|Long"));
              break;
            case "float":
            case "double":
              gen('if(typeof %s!=="number")', ref)("return%j", invalid(field, "number"));
              break;
            case "bool":
              gen('if(typeof %s!=="boolean")', ref)("return%j", invalid(field, "boolean"));
              break;
            case "string":
              gen("if(!util.isString(%s))", ref)("return%j", invalid(field, "string"));
              break;
            case "bytes":
              gen('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', ref, ref, ref)("return%j", invalid(field, "buffer"));
              break;
          }
        }
        return gen;
      }
      function genVerifyKey(gen, field, ref) {
        switch (field.keyType) {
          case "int32":
          case "uint32":
          case "sint32":
          case "fixed32":
          case "sfixed32":
            gen("if(!util.key32Re.test(%s))", ref)("return%j", invalid(field, "integer key"));
            break;
          case "int64":
          case "uint64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(!util.key64Re.test(%s))", ref)("return%j", invalid(field, "integer|Long key"));
            break;
          case "bool":
            gen("if(!util.key2Re.test(%s))", ref)("return%j", invalid(field, "boolean key"));
            break;
        }
        return gen;
      }
      function verifier(mtype) {
        var gen = util.codegen(["m"], mtype.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected");
        var oneofs = mtype.oneofsArray, seenFirstField = {};
        if (oneofs.length) gen("var p={}");
        for (var i = 0; i < /* initializes */
        mtype.fieldsArray.length; ++i) {
          var field = mtype._fieldsArray[i].resolve(), ref = "m" + util.safeProp(field.name);
          if (field.optional) gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name);
          if (field.map) {
            gen("if(!util.isObject(%s))", ref)("return%j", invalid(field, "object"))("var k=Object.keys(%s)", ref)("for(var i=0;i<k.length;++i){");
            genVerifyKey(gen, field, "k[i]");
            genVerifyValue(gen, field, i, ref + "[k[i]]")("}");
          } else if (field.repeated) {
            gen("if(!Array.isArray(%s))", ref)("return%j", invalid(field, "array"))("for(var i=0;i<%s.length;++i){", ref);
            genVerifyValue(gen, field, i, ref + "[i]")("}");
          } else {
            if (field.partOf) {
              var oneofProp = util.safeProp(field.partOf.name);
              if (seenFirstField[field.partOf.name] === 1) gen("if(p%s===1)", oneofProp)("return%j", field.partOf.name + ": multiple values");
              seenFirstField[field.partOf.name] = 1;
              gen("p%s=1", oneofProp);
            }
            genVerifyValue(gen, field, i, ref);
          }
          if (field.optional) gen("}");
        }
        return gen("return null");
      }
    }
  });

  // ../node_modules/protobufjs/src/converter.js
  var require_converter = __commonJS({
    "../node_modules/protobufjs/src/converter.js"(exports2) {
      "use strict";
      var converter = exports2;
      var Enum = require_enum();
      var util = require_util();
      function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
        var defaultAlreadyEmitted = false;
        if (field.resolvedType) {
          if (field.resolvedType instanceof Enum) {
            gen("switch(d%s){", prop);
            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
              if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) {
                gen("default:")('if(typeof(d%s)==="number"){m%s=d%s;break}', prop, prop, prop);
                if (!field.repeated) gen("break");
                defaultAlreadyEmitted = true;
              }
              gen("case%j:", keys[i])("case %i:", values[keys[i]])("m%s=%j", prop, values[keys[i]])("break");
            }
            gen("}");
          } else gen('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
        } else {
          var isUnsigned = false;
          switch (field.type) {
            case "double":
            case "float":
              gen("m%s=Number(d%s)", prop, prop);
              break;
            case "uint32":
            case "fixed32":
              gen("m%s=d%s>>>0", prop, prop);
              break;
            case "int32":
            case "sint32":
            case "sfixed32":
              gen("m%s=d%s|0", prop, prop);
              break;
            case "uint64":
              isUnsigned = true;
            // eslint-disable-next-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64":
              gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)('else if(typeof d%s==="string")', prop)("m%s=parseInt(d%s,10)", prop, prop)('else if(typeof d%s==="number")', prop)("m%s=d%s", prop, prop)('else if(typeof d%s==="object")', prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
              break;
            case "bytes":
              gen('if(typeof d%s==="string")', prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length >= 0)", prop)("m%s=d%s", prop, prop);
              break;
            case "string":
              gen("m%s=String(d%s)", prop, prop);
              break;
            case "bool":
              gen("m%s=Boolean(d%s)", prop, prop);
              break;
          }
        }
        return gen;
      }
      converter.fromObject = function fromObject(mtype) {
        var fields = mtype.fieldsArray;
        var gen = util.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
        if (!fields.length) return gen("return new this.ctor");
        gen("var m=new this.ctor");
        for (var i = 0; i < fields.length; ++i) {
          var field = fields[i].resolve(), prop = util.safeProp(field.name);
          if (field.map) {
            gen("if(d%s){", prop)('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
            genValuePartial_fromObject(
              gen,
              field,
              /* not sorted */
              i,
              prop + "[ks[i]]"
            )("}")("}");
          } else if (field.repeated) {
            gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
            genValuePartial_fromObject(
              gen,
              field,
              /* not sorted */
              i,
              prop + "[i]"
            )("}")("}");
          } else {
            if (!(field.resolvedType instanceof Enum)) gen("if(d%s!=null){", prop);
            genValuePartial_fromObject(
              gen,
              field,
              /* not sorted */
              i,
              prop
            );
            if (!(field.resolvedType instanceof Enum)) gen("}");
          }
        }
        return gen("return m");
      };
      function genValuePartial_toObject(gen, field, fieldIndex, prop) {
        if (field.resolvedType) {
          if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);
          else gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
        } else {
          var isUnsigned = false;
          switch (field.type) {
            case "double":
            case "float":
              gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
              break;
            case "uint64":
              isUnsigned = true;
            // eslint-disable-next-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64":
              gen('if(typeof m%s==="number")', prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
              break;
            case "bytes":
              gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
              break;
            default:
              gen("d%s=m%s", prop, prop);
              break;
          }
        }
        return gen;
      }
      converter.toObject = function toObject(mtype) {
        var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
        if (!fields.length)
          return util.codegen()("return {}");
        var gen = util.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
        var repeatedFields = [], mapFields = [], normalFields = [], i = 0;
        for (; i < fields.length; ++i)
          if (!fields[i].partOf)
            (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);
        if (repeatedFields.length) {
          gen("if(o.arrays||o.defaults){");
          for (i = 0; i < repeatedFields.length; ++i) gen("d%s=[]", util.safeProp(repeatedFields[i].name));
          gen("}");
        }
        if (mapFields.length) {
          gen("if(o.objects||o.defaults){");
          for (i = 0; i < mapFields.length; ++i) gen("d%s={}", util.safeProp(mapFields[i].name));
          gen("}");
        }
        if (normalFields.length) {
          gen("if(o.defaults){");
          for (i = 0; i < normalFields.length; ++i) {
            var field = normalFields[i], prop = util.safeProp(field.name);
            if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
            else if (field.long) gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
            else if (field.bytes) {
              var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
              gen("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))("else{")("d%s=%s", prop, arrayDefault)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)("}");
            } else gen("d%s=%j", prop, field.typeDefault);
          }
          gen("}");
        }
        var hasKs2 = false;
        for (i = 0; i < fields.length; ++i) {
          var field = fields[i], index = mtype._fieldsArray.indexOf(field), prop = util.safeProp(field.name);
          if (field.map) {
            if (!hasKs2) {
              hasKs2 = true;
              gen("var ks2");
            }
            gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
            genValuePartial_toObject(
              gen,
              field,
              /* sorted */
              index,
              prop + "[ks2[j]]"
            )("}");
          } else if (field.repeated) {
            gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
            genValuePartial_toObject(
              gen,
              field,
              /* sorted */
              index,
              prop + "[j]"
            )("}");
          } else {
            gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name);
            genValuePartial_toObject(
              gen,
              field,
              /* sorted */
              index,
              prop
            );
            if (field.partOf) gen("if(o.oneofs)")("d%s=%j", util.safeProp(field.partOf.name), field.name);
          }
          gen("}");
        }
        return gen("return d");
      };
    }
  });

  // ../node_modules/protobufjs/src/wrappers.js
  var require_wrappers = __commonJS({
    "../node_modules/protobufjs/src/wrappers.js"(exports2) {
      "use strict";
      var wrappers = exports2;
      var Message = require_message();
      wrappers[".google.protobuf.Any"] = {
        fromObject: function(object) {
          if (object && object["@type"]) {
            var name19 = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
            var type = this.lookup(name19);
            if (type) {
              var type_url = object["@type"].charAt(0) === "." ? object["@type"].slice(1) : object["@type"];
              if (type_url.indexOf("/") === -1) {
                type_url = "/" + type_url;
              }
              return this.create({
                type_url,
                value: type.encode(type.fromObject(object)).finish()
              });
            }
          }
          return this.fromObject(object);
        },
        toObject: function(message2, options) {
          var googleApi = "type.googleapis.com/";
          var prefix = "";
          var name19 = "";
          if (options && options.json && message2.type_url && message2.value) {
            name19 = message2.type_url.substring(message2.type_url.lastIndexOf("/") + 1);
            prefix = message2.type_url.substring(0, message2.type_url.lastIndexOf("/") + 1);
            var type = this.lookup(name19);
            if (type)
              message2 = type.decode(message2.value);
          }
          if (!(message2 instanceof this.ctor) && message2 instanceof Message) {
            var object = message2.$type.toObject(message2, options);
            var messageName = message2.$type.fullName[0] === "." ? message2.$type.fullName.slice(1) : message2.$type.fullName;
            if (prefix === "") {
              prefix = googleApi;
            }
            name19 = prefix + messageName;
            object["@type"] = name19;
            return object;
          }
          return this.toObject(message2, options);
        }
      };
    }
  });

  // ../node_modules/protobufjs/src/type.js
  var require_type = __commonJS({
    "../node_modules/protobufjs/src/type.js"(exports2, module2) {
      "use strict";
      module2.exports = Type;
      var Namespace = require_namespace();
      ((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";
      var Enum = require_enum();
      var OneOf = require_oneof();
      var Field4 = require_field();
      var MapField = require_mapfield();
      var Service = require_service2();
      var Message = require_message();
      var Reader = require_reader();
      var Writer = require_writer();
      var util = require_util();
      var encoder3 = require_encoder();
      var decoder = require_decoder();
      var verifier = require_verifier();
      var converter = require_converter();
      var wrappers = require_wrappers();
      function Type(name19, options) {
        Namespace.call(this, name19, options);
        this.fields = {};
        this.oneofs = void 0;
        this.extensions = void 0;
        this.reserved = void 0;
        this.group = void 0;
        this._fieldsById = null;
        this._fieldsArray = null;
        this._oneofsArray = null;
        this._ctor = null;
      }
      Object.defineProperties(Type.prototype, {
        /**
         * Message fields by id.
         * @name Type#fieldsById
         * @type {Object.<number,Field>}
         * @readonly
         */
        fieldsById: {
          get: function() {
            if (this._fieldsById)
              return this._fieldsById;
            this._fieldsById = {};
            for (var names2 = Object.keys(this.fields), i = 0; i < names2.length; ++i) {
              var field = this.fields[names2[i]], id = field.id;
              if (this._fieldsById[id])
                throw Error("duplicate id " + id + " in " + this);
              this._fieldsById[id] = field;
            }
            return this._fieldsById;
          }
        },
        /**
         * Fields of this message as an array for iteration.
         * @name Type#fieldsArray
         * @type {Field[]}
         * @readonly
         */
        fieldsArray: {
          get: function() {
            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
          }
        },
        /**
         * Oneofs of this message as an array for iteration.
         * @name Type#oneofsArray
         * @type {OneOf[]}
         * @readonly
         */
        oneofsArray: {
          get: function() {
            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
          }
        },
        /**
         * The registered constructor, if any registered, otherwise a generic constructor.
         * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
         * @name Type#ctor
         * @type {Constructor<{}>}
         */
        ctor: {
          get: function() {
            return this._ctor || (this.ctor = Type.generateConstructor(this)());
          },
          set: function(ctor) {
            var prototype = ctor.prototype;
            if (!(prototype instanceof Message)) {
              (ctor.prototype = new Message()).constructor = ctor;
              util.merge(ctor.prototype, prototype);
            }
            ctor.$type = ctor.prototype.$type = this;
            util.merge(ctor, Message, true);
            this._ctor = ctor;
            var i = 0;
            for (; i < /* initializes */
            this.fieldsArray.length; ++i)
              this._fieldsArray[i].resolve();
            var ctorProperties = {};
            for (i = 0; i < /* initializes */
            this.oneofsArray.length; ++i)
              ctorProperties[this._oneofsArray[i].resolve().name] = {
                get: util.oneOfGetter(this._oneofsArray[i].oneof),
                set: util.oneOfSetter(this._oneofsArray[i].oneof)
              };
            if (i)
              Object.defineProperties(ctor.prototype, ctorProperties);
          }
        }
      });
      Type.generateConstructor = function generateConstructor(mtype) {
        var gen = util.codegen(["p"], mtype.name);
        for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
          if ((field = mtype._fieldsArray[i]).map) gen("this%s={}", util.safeProp(field.name));
          else if (field.repeated) gen("this%s=[]", util.safeProp(field.name));
        return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
      };
      function clearCache(type) {
        type._fieldsById = type._fieldsArray = type._oneofsArray = null;
        delete type.encode;
        delete type.decode;
        delete type.verify;
        return type;
      }
      Type.fromJSON = function fromJSON(name19, json) {
        var type = new Type(name19, json.options);
        type.extensions = json.extensions;
        type.reserved = json.reserved;
        var names2 = Object.keys(json.fields), i = 0;
        for (; i < names2.length; ++i)
          type.add(
            (typeof json.fields[names2[i]].keyType !== "undefined" ? MapField.fromJSON : Field4.fromJSON)(names2[i], json.fields[names2[i]])
          );
        if (json.oneofs)
          for (names2 = Object.keys(json.oneofs), i = 0; i < names2.length; ++i)
            type.add(OneOf.fromJSON(names2[i], json.oneofs[names2[i]]));
        if (json.nested)
          for (names2 = Object.keys(json.nested), i = 0; i < names2.length; ++i) {
            var nested = json.nested[names2[i]];
            type.add(
              // most to least likely
              (nested.id !== void 0 ? Field4.fromJSON : nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : Namespace.fromJSON)(names2[i], nested)
            );
          }
        if (json.extensions && json.extensions.length)
          type.extensions = json.extensions;
        if (json.reserved && json.reserved.length)
          type.reserved = json.reserved;
        if (json.group)
          type.group = true;
        if (json.comment)
          type.comment = json.comment;
        if (json.edition)
          type._edition = json.edition;
        type._defaultEdition = "proto3";
        return type;
      };
      Type.prototype.toJSON = function toJSON(toJSONOptions) {
        var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
        var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
        return util.toObject([
          "edition",
          this._editionToJSON(),
          "options",
          inherited && inherited.options || void 0,
          "oneofs",
          Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
          "fields",
          Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {
            return !obj.declaringField;
          }), toJSONOptions) || {},
          "extensions",
          this.extensions && this.extensions.length ? this.extensions : void 0,
          "reserved",
          this.reserved && this.reserved.length ? this.reserved : void 0,
          "group",
          this.group || void 0,
          "nested",
          inherited && inherited.nested || void 0,
          "comment",
          keepComments ? this.comment : void 0
        ]);
      };
      Type.prototype.resolveAll = function resolveAll() {
        if (!this._needsRecursiveResolve) return this;
        Namespace.prototype.resolveAll.call(this);
        var oneofs = this.oneofsArray;
        i = 0;
        while (i < oneofs.length)
          oneofs[i++].resolve();
        var fields = this.fieldsArray, i = 0;
        while (i < fields.length)
          fields[i++].resolve();
        return this;
      };
      Type.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {
        if (!this._needsRecursiveFeatureResolution) return this;
        edition = this._edition || edition;
        Namespace.prototype._resolveFeaturesRecursive.call(this, edition);
        this.oneofsArray.forEach((oneof) => {
          oneof._resolveFeatures(edition);
        });
        this.fieldsArray.forEach((field) => {
          field._resolveFeatures(edition);
        });
        return this;
      };
      Type.prototype.get = function get(name19) {
        return this.fields[name19] || this.oneofs && this.oneofs[name19] || this.nested && this.nested[name19] || null;
      };
      Type.prototype.add = function add4(object) {
        if (this.get(object.name))
          throw Error("duplicate name '" + object.name + "' in " + this);
        if (object instanceof Field4 && object.extend === void 0) {
          if (this._fieldsById ? (
            /* istanbul ignore next */
            this._fieldsById[object.id]
          ) : this.fieldsById[object.id])
            throw Error("duplicate id " + object.id + " in " + this);
          if (this.isReservedId(object.id))
            throw Error("id " + object.id + " is reserved in " + this);
          if (this.isReservedName(object.name))
            throw Error("name '" + object.name + "' is reserved in " + this);
          if (object.parent)
            object.parent.remove(object);
          this.fields[object.name] = object;
          object.message = this;
          object.onAdd(this);
          return clearCache(this);
        }
        if (object instanceof OneOf) {
          if (!this.oneofs)
            this.oneofs = {};
          this.oneofs[object.name] = object;
          object.onAdd(this);
          return clearCache(this);
        }
        return Namespace.prototype.add.call(this, object);
      };
      Type.prototype.remove = function remove(object) {
        if (object instanceof Field4 && object.extend === void 0) {
          if (!this.fields || this.fields[object.name] !== object)
            throw Error(object + " is not a member of " + this);
          delete this.fields[object.name];
          object.parent = null;
          object.onRemove(this);
          return clearCache(this);
        }
        if (object instanceof OneOf) {
          if (!this.oneofs || this.oneofs[object.name] !== object)
            throw Error(object + " is not a member of " + this);
          delete this.oneofs[object.name];
          object.parent = null;
          object.onRemove(this);
          return clearCache(this);
        }
        return Namespace.prototype.remove.call(this, object);
      };
      Type.prototype.isReservedId = function isReservedId(id) {
        return Namespace.isReservedId(this.reserved, id);
      };
      Type.prototype.isReservedName = function isReservedName(name19) {
        return Namespace.isReservedName(this.reserved, name19);
      };
      Type.prototype.create = function create19(properties) {
        return new this.ctor(properties);
      };
      Type.prototype.setup = function setup3() {
        var fullName = this.fullName, types = [];
        for (var i = 0; i < /* initializes */
        this.fieldsArray.length; ++i)
          types.push(this._fieldsArray[i].resolve().resolvedType);
        this.encode = encoder3(this)({
          Writer,
          types,
          util
        });
        this.decode = decoder(this)({
          Reader,
          types,
          util
        });
        this.verify = verifier(this)({
          types,
          util
        });
        this.fromObject = converter.fromObject(this)({
          types,
          util
        });
        this.toObject = converter.toObject(this)({
          types,
          util
        });
        var wrapper = wrappers[fullName];
        if (wrapper) {
          var originalThis = Object.create(this);
          originalThis.fromObject = this.fromObject;
          this.fromObject = wrapper.fromObject.bind(originalThis);
          originalThis.toObject = this.toObject;
          this.toObject = wrapper.toObject.bind(originalThis);
        }
        return this;
      };
      Type.prototype.encode = function encode_setup(message2, writer) {
        return this.setup().encode(message2, writer);
      };
      Type.prototype.encodeDelimited = function encodeDelimited(message2, writer) {
        return this.encode(message2, writer && writer.len ? writer.fork() : writer).ldelim();
      };
      Type.prototype.decode = function decode_setup(reader, length21) {
        return this.setup().decode(reader, length21);
      };
      Type.prototype.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof Reader))
          reader = Reader.create(reader);
        return this.decode(reader, reader.uint32());
      };
      Type.prototype.verify = function verify_setup(message2) {
        return this.setup().verify(message2);
      };
      Type.prototype.fromObject = function fromObject(object) {
        return this.setup().fromObject(object);
      };
      Type.prototype.toObject = function toObject(message2, options) {
        return this.setup().toObject(message2, options);
      };
      Type.d = function decorateType(typeName) {
        return function typeDecorator(target) {
          util.decorateType(target, typeName);
        };
      };
    }
  });

  // ../node_modules/protobufjs/src/root.js
  var require_root = __commonJS({
    "../node_modules/protobufjs/src/root.js"(exports2, module2) {
      "use strict";
      module2.exports = Root;
      var Namespace = require_namespace();
      ((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";
      var Field4 = require_field();
      var Enum = require_enum();
      var OneOf = require_oneof();
      var util = require_util();
      var Type;
      var parse2;
      var common;
      function Root(options) {
        Namespace.call(this, "", options);
        this.deferred = [];
        this.files = [];
        this._edition = "proto2";
        this._fullyQualifiedObjects = {};
      }
      Root.fromJSON = function fromJSON(json, root) {
        if (!root)
          root = new Root();
        if (json.options)
          root.setOptions(json.options);
        return root.addJSON(json.nested).resolveAll();
      };
      Root.prototype.resolvePath = util.path.resolve;
      Root.prototype.fetch = util.fetch;
      function SYNC() {
      }
      Root.prototype.load = function load2(filename, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = void 0;
        }
        var self2 = this;
        if (!callback) {
          return util.asPromise(load2, self2, filename, options);
        }
        var sync = callback === SYNC;
        function finish(err, root) {
          if (!callback) {
            return;
          }
          if (sync) {
            throw err;
          }
          if (root) {
            root.resolveAll();
          }
          var cb = callback;
          callback = null;
          cb(err, root);
        }
        function getBundledFileName(filename2) {
          var idx = filename2.lastIndexOf("google/protobuf/");
          if (idx > -1) {
            var altname = filename2.substring(idx);
            if (altname in common) return altname;
          }
          return null;
        }
        function process2(filename2, source) {
          try {
            if (util.isString(source) && source.charAt(0) === "{")
              source = JSON.parse(source);
            if (!util.isString(source))
              self2.setOptions(source.options).addJSON(source.nested);
            else {
              parse2.filename = filename2;
              var parsed = parse2(source, self2, options), resolved2, i2 = 0;
              if (parsed.imports) {
                for (; i2 < parsed.imports.length; ++i2)
                  if (resolved2 = getBundledFileName(parsed.imports[i2]) || self2.resolvePath(filename2, parsed.imports[i2]))
                    fetch2(resolved2);
              }
              if (parsed.weakImports) {
                for (i2 = 0; i2 < parsed.weakImports.length; ++i2)
                  if (resolved2 = getBundledFileName(parsed.weakImports[i2]) || self2.resolvePath(filename2, parsed.weakImports[i2]))
                    fetch2(resolved2, true);
              }
            }
          } catch (err) {
            finish(err);
          }
          if (!sync && !queued) {
            finish(null, self2);
          }
        }
        function fetch2(filename2, weak) {
          filename2 = getBundledFileName(filename2) || filename2;
          if (self2.files.indexOf(filename2) > -1) {
            return;
          }
          self2.files.push(filename2);
          if (filename2 in common) {
            if (sync) {
              process2(filename2, common[filename2]);
            } else {
              ++queued;
              setTimeout(function() {
                --queued;
                process2(filename2, common[filename2]);
              });
            }
            return;
          }
          if (sync) {
            var source;
            try {
              source = util.fs.readFileSync(filename2).toString("utf8");
            } catch (err) {
              if (!weak)
                finish(err);
              return;
            }
            process2(filename2, source);
          } else {
            ++queued;
            self2.fetch(filename2, function(err, source2) {
              --queued;
              if (!callback) {
                return;
              }
              if (err) {
                if (!weak)
                  finish(err);
                else if (!queued)
                  finish(null, self2);
                return;
              }
              process2(filename2, source2);
            });
          }
        }
        var queued = 0;
        if (util.isString(filename)) {
          filename = [filename];
        }
        for (var i = 0, resolved; i < filename.length; ++i)
          if (resolved = self2.resolvePath("", filename[i]))
            fetch2(resolved);
        if (sync) {
          self2.resolveAll();
          return self2;
        }
        if (!queued) {
          finish(null, self2);
        }
        return self2;
      };
      Root.prototype.loadSync = function loadSync(filename, options) {
        if (!util.isNode)
          throw Error("not supported");
        return this.load(filename, options, SYNC);
      };
      Root.prototype.resolveAll = function resolveAll() {
        if (!this._needsRecursiveResolve) return this;
        if (this.deferred.length)
          throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
            return "'extend " + field.extend + "' in " + field.parent.fullName;
          }).join(", "));
        return Namespace.prototype.resolveAll.call(this);
      };
      var exposeRe = /^[A-Z]/;
      function tryHandleExtension(root, field) {
        var extendedType = field.parent.lookup(field.extend);
        if (extendedType) {
          var sisterField = new Field4(field.fullName, field.id, field.type, field.rule, void 0, field.options);
          if (extendedType.get(sisterField.name)) {
            return true;
          }
          sisterField.declaringField = field;
          field.extensionField = sisterField;
          extendedType.add(sisterField);
          return true;
        }
        return false;
      }
      Root.prototype._handleAdd = function _handleAdd(object) {
        if (object instanceof Field4) {
          if (
            /* an extension field (implies not part of a oneof) */
            object.extend !== void 0 && /* not already handled */
            !object.extensionField
          ) {
            if (!tryHandleExtension(this, object))
              this.deferred.push(object);
          }
        } else if (object instanceof Enum) {
          if (exposeRe.test(object.name))
            object.parent[object.name] = object.values;
        } else if (!(object instanceof OneOf)) {
          if (object instanceof Type)
            for (var i = 0; i < this.deferred.length; )
              if (tryHandleExtension(this, this.deferred[i]))
                this.deferred.splice(i, 1);
              else
                ++i;
          for (var j = 0; j < /* initializes */
          object.nestedArray.length; ++j)
            this._handleAdd(object._nestedArray[j]);
          if (exposeRe.test(object.name))
            object.parent[object.name] = object;
        }
        if (object instanceof Type || object instanceof Enum || object instanceof Field4) {
          this._fullyQualifiedObjects[object.fullName] = object;
        }
      };
      Root.prototype._handleRemove = function _handleRemove(object) {
        if (object instanceof Field4) {
          if (
            /* an extension field */
            object.extend !== void 0
          ) {
            if (
              /* already handled */
              object.extensionField
            ) {
              object.extensionField.parent.remove(object.extensionField);
              object.extensionField = null;
            } else {
              var index = this.deferred.indexOf(object);
              if (index > -1)
                this.deferred.splice(index, 1);
            }
          }
        } else if (object instanceof Enum) {
          if (exposeRe.test(object.name))
            delete object.parent[object.name];
        } else if (object instanceof Namespace) {
          for (var i = 0; i < /* initializes */
          object.nestedArray.length; ++i)
            this._handleRemove(object._nestedArray[i]);
          if (exposeRe.test(object.name))
            delete object.parent[object.name];
        }
        delete this._fullyQualifiedObjects[object.fullName];
      };
      Root._configure = function(Type_, parse_, common_) {
        Type = Type_;
        parse2 = parse_;
        common = common_;
      };
    }
  });

  // ../node_modules/protobufjs/src/util.js
  var require_util = __commonJS({
    "../node_modules/protobufjs/src/util.js"(exports2, module2) {
      "use strict";
      var util = module2.exports = require_minimal();
      var roots = require_roots();
      var Type;
      var Enum;
      util.codegen = require_codegen();
      util.fetch = require_fetch();
      util.path = require_path();
      util.fs = util.inquire("fs");
      util.toArray = function toArray(object) {
        if (object) {
          var keys = Object.keys(object), array = new Array(keys.length), index = 0;
          while (index < keys.length)
            array[index] = object[keys[index++]];
          return array;
        }
        return [];
      };
      util.toObject = function toObject(array) {
        var object = {}, index = 0;
        while (index < array.length) {
          var key = array[index++], val = array[index++];
          if (val !== void 0)
            object[key] = val;
        }
        return object;
      };
      var safePropBackslashRe = /\\/g;
      var safePropQuoteRe = /"/g;
      util.isReserved = function isReserved(name19) {
        return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name19);
      };
      util.safeProp = function safeProp(prop) {
        if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
          return '["' + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, '\\"') + '"]';
        return "." + prop;
      };
      util.ucFirst = function ucFirst(str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
      };
      var camelCaseRe = /_([a-z])/g;
      util.camelCase = function camelCase(str) {
        return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {
          return $1.toUpperCase();
        });
      };
      util.compareFieldsById = function compareFieldsById(a, b) {
        return a.id - b.id;
      };
      util.decorateType = function decorateType(ctor, typeName) {
        if (ctor.$type) {
          if (typeName && ctor.$type.name !== typeName) {
            util.decorateRoot.remove(ctor.$type);
            ctor.$type.name = typeName;
            util.decorateRoot.add(ctor.$type);
          }
          return ctor.$type;
        }
        if (!Type)
          Type = require_type();
        var type = new Type(typeName || ctor.name);
        util.decorateRoot.add(type);
        type.ctor = ctor;
        Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
        Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
        return type;
      };
      var decorateEnumIndex = 0;
      util.decorateEnum = function decorateEnum(object) {
        if (object.$type)
          return object.$type;
        if (!Enum)
          Enum = require_enum();
        var enm = new Enum("Enum" + decorateEnumIndex++, object);
        util.decorateRoot.add(enm);
        Object.defineProperty(object, "$type", { value: enm, enumerable: false });
        return enm;
      };
      util.setProperty = function setProperty(dst, path, value, ifNotSet) {
        function setProp(dst2, path2, value2) {
          var part = path2.shift();
          if (part === "__proto__" || part === "prototype") {
            return dst2;
          }
          if (path2.length > 0) {
            dst2[part] = setProp(dst2[part] || {}, path2, value2);
          } else {
            var prevValue = dst2[part];
            if (prevValue && ifNotSet)
              return dst2;
            if (prevValue)
              value2 = [].concat(prevValue).concat(value2);
            dst2[part] = value2;
          }
          return dst2;
        }
        if (typeof dst !== "object")
          throw TypeError("dst must be an object");
        if (!path)
          throw TypeError("path must be specified");
        path = path.split(".");
        return setProp(dst, path, value);
      };
      Object.defineProperty(util, "decorateRoot", {
        get: function() {
          return roots["decorated"] || (roots["decorated"] = new (require_root())());
        }
      });
    }
  });

  // ../node_modules/protobufjs/src/types.js
  var require_types = __commonJS({
    "../node_modules/protobufjs/src/types.js"(exports2) {
      "use strict";
      var types = exports2;
      var util = require_util();
      var s2 = [
        "double",
        // 0
        "float",
        // 1
        "int32",
        // 2
        "uint32",
        // 3
        "sint32",
        // 4
        "fixed32",
        // 5
        "sfixed32",
        // 6
        "int64",
        // 7
        "uint64",
        // 8
        "sint64",
        // 9
        "fixed64",
        // 10
        "sfixed64",
        // 11
        "bool",
        // 12
        "string",
        // 13
        "bytes"
        // 14
      ];
      function bake(values, offset) {
        var i = 0, o = {};
        offset |= 0;
        while (i < values.length) o[s2[i + offset]] = values[i++];
        return o;
      }
      types.basic = bake([
        /* double   */
        1,
        /* float    */
        5,
        /* int32    */
        0,
        /* uint32   */
        0,
        /* sint32   */
        0,
        /* fixed32  */
        5,
        /* sfixed32 */
        5,
        /* int64    */
        0,
        /* uint64   */
        0,
        /* sint64   */
        0,
        /* fixed64  */
        1,
        /* sfixed64 */
        1,
        /* bool     */
        0,
        /* string   */
        2,
        /* bytes    */
        2
      ]);
      types.defaults = bake([
        /* double   */
        0,
        /* float    */
        0,
        /* int32    */
        0,
        /* uint32   */
        0,
        /* sint32   */
        0,
        /* fixed32  */
        0,
        /* sfixed32 */
        0,
        /* int64    */
        0,
        /* uint64   */
        0,
        /* sint64   */
        0,
        /* fixed64  */
        0,
        /* sfixed64 */
        0,
        /* bool     */
        false,
        /* string   */
        "",
        /* bytes    */
        util.emptyArray,
        /* message  */
        null
      ]);
      types.long = bake([
        /* int64    */
        0,
        /* uint64   */
        0,
        /* sint64   */
        0,
        /* fixed64  */
        1,
        /* sfixed64 */
        1
      ], 7);
      types.mapKey = bake([
        /* int32    */
        0,
        /* uint32   */
        0,
        /* sint32   */
        0,
        /* fixed32  */
        5,
        /* sfixed32 */
        5,
        /* int64    */
        0,
        /* uint64   */
        0,
        /* sint64   */
        0,
        /* fixed64  */
        1,
        /* sfixed64 */
        1,
        /* bool     */
        0,
        /* string   */
        2
      ], 2);
      types.packed = bake([
        /* double   */
        1,
        /* float    */
        5,
        /* int32    */
        0,
        /* uint32   */
        0,
        /* sint32   */
        0,
        /* fixed32  */
        5,
        /* sfixed32 */
        5,
        /* int64    */
        0,
        /* uint64   */
        0,
        /* sint64   */
        0,
        /* fixed64  */
        1,
        /* sfixed64 */
        1,
        /* bool     */
        0
      ]);
    }
  });

  // ../node_modules/protobufjs/src/field.js
  var require_field = __commonJS({
    "../node_modules/protobufjs/src/field.js"(exports2, module2) {
      "use strict";
      module2.exports = Field4;
      var ReflectionObject = require_object();
      ((Field4.prototype = Object.create(ReflectionObject.prototype)).constructor = Field4).className = "Field";
      var Enum = require_enum();
      var types = require_types();
      var util = require_util();
      var Type;
      var ruleRe = /^required|optional|repeated$/;
      Field4.fromJSON = function fromJSON(name19, json) {
        var field = new Field4(name19, json.id, json.type, json.rule, json.extend, json.options, json.comment);
        if (json.edition)
          field._edition = json.edition;
        field._defaultEdition = "proto3";
        return field;
      };
      function Field4(name19, id, type, rule, extend, options, comment) {
        if (util.isObject(rule)) {
          comment = extend;
          options = rule;
          rule = extend = void 0;
        } else if (util.isObject(extend)) {
          comment = options;
          options = extend;
          extend = void 0;
        }
        ReflectionObject.call(this, name19, options);
        if (!util.isInteger(id) || id < 0)
          throw TypeError("id must be a non-negative integer");
        if (!util.isString(type))
          throw TypeError("type must be a string");
        if (rule !== void 0 && !ruleRe.test(rule = rule.toString().toLowerCase()))
          throw TypeError("rule must be a string rule");
        if (extend !== void 0 && !util.isString(extend))
          throw TypeError("extend must be a string");
        if (rule === "proto3_optional") {
          rule = "optional";
        }
        this.rule = rule && rule !== "optional" ? rule : void 0;
        this.type = type;
        this.id = id;
        this.extend = extend || void 0;
        this.repeated = rule === "repeated";
        this.map = false;
        this.message = null;
        this.partOf = null;
        this.typeDefault = null;
        this.defaultValue = null;
        this.long = util.Long ? types.long[type] !== void 0 : (
          /* istanbul ignore next */
          false
        );
        this.bytes = type === "bytes";
        this.resolvedType = null;
        this.extensionField = null;
        this.declaringField = null;
        this.comment = comment;
      }
      Object.defineProperty(Field4.prototype, "required", {
        get: function() {
          return this._features.field_presence === "LEGACY_REQUIRED";
        }
      });
      Object.defineProperty(Field4.prototype, "optional", {
        get: function() {
          return !this.required;
        }
      });
      Object.defineProperty(Field4.prototype, "delimited", {
        get: function() {
          return this.resolvedType instanceof Type && this._features.message_encoding === "DELIMITED";
        }
      });
      Object.defineProperty(Field4.prototype, "packed", {
        get: function() {
          return this._features.repeated_field_encoding === "PACKED";
        }
      });
      Object.defineProperty(Field4.prototype, "hasPresence", {
        get: function() {
          if (this.repeated || this.map) {
            return false;
          }
          return this.partOf || // oneofs
          this.declaringField || this.extensionField || // extensions
          this._features.field_presence !== "IMPLICIT";
        }
      });
      Field4.prototype.setOption = function setOption(name19, value, ifNotSet) {
        return ReflectionObject.prototype.setOption.call(this, name19, value, ifNotSet);
      };
      Field4.prototype.toJSON = function toJSON(toJSONOptions) {
        var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
        return util.toObject([
          "edition",
          this._editionToJSON(),
          "rule",
          this.rule !== "optional" && this.rule || void 0,
          "type",
          this.type,
          "id",
          this.id,
          "extend",
          this.extend,
          "options",
          this.options,
          "comment",
          keepComments ? this.comment : void 0
        ]);
      };
      Field4.prototype.resolve = function resolve() {
        if (this.resolved)
          return this;
        if ((this.typeDefault = types.defaults[this.type]) === void 0) {
          this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
          if (this.resolvedType instanceof Type)
            this.typeDefault = null;
          else
            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]];
        } else if (this.options && this.options.proto3_optional) {
          this.typeDefault = null;
        }
        if (this.options && this.options["default"] != null) {
          this.typeDefault = this.options["default"];
          if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
            this.typeDefault = this.resolvedType.values[this.typeDefault];
        }
        if (this.options) {
          if (this.options.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof Enum))
            delete this.options.packed;
          if (!Object.keys(this.options).length)
            this.options = void 0;
        }
        if (this.long) {
          this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
          if (Object.freeze)
            Object.freeze(this.typeDefault);
        } else if (this.bytes && typeof this.typeDefault === "string") {
          var buf;
          if (util.base64.test(this.typeDefault))
            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
          else
            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
          this.typeDefault = buf;
        }
        if (this.map)
          this.defaultValue = util.emptyObject;
        else if (this.repeated)
          this.defaultValue = util.emptyArray;
        else
          this.defaultValue = this.typeDefault;
        if (this.parent instanceof Type)
          this.parent.ctor.prototype[this.name] = this.defaultValue;
        return ReflectionObject.prototype.resolve.call(this);
      };
      Field4.prototype._inferLegacyProtoFeatures = function _inferLegacyProtoFeatures(edition) {
        if (edition !== "proto2" && edition !== "proto3") {
          return {};
        }
        var features = {};
        if (this.rule === "required") {
          features.field_presence = "LEGACY_REQUIRED";
        }
        if (this.parent && types.defaults[this.type] === void 0) {
          var type = this.parent.get(this.type.split(".").pop());
          if (type && type instanceof Type && type.group) {
            features.message_encoding = "DELIMITED";
          }
        }
        if (this.getOption("packed") === true) {
          features.repeated_field_encoding = "PACKED";
        } else if (this.getOption("packed") === false) {
          features.repeated_field_encoding = "EXPANDED";
        }
        return features;
      };
      Field4.prototype._resolveFeatures = function _resolveFeatures(edition) {
        return ReflectionObject.prototype._resolveFeatures.call(this, this._edition || edition);
      };
      Field4.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
        if (typeof fieldType === "function")
          fieldType = util.decorateType(fieldType).name;
        else if (fieldType && typeof fieldType === "object")
          fieldType = util.decorateEnum(fieldType).name;
        return function fieldDecorator(prototype, fieldName) {
          util.decorateType(prototype.constructor).add(new Field4(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
        };
      };
      Field4._configure = function configure(Type_) {
        Type = Type_;
      };
    }
  });

  // ../node_modules/protobufjs/src/oneof.js
  var require_oneof = __commonJS({
    "../node_modules/protobufjs/src/oneof.js"(exports2, module2) {
      "use strict";
      module2.exports = OneOf;
      var ReflectionObject = require_object();
      ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";
      var Field4 = require_field();
      var util = require_util();
      function OneOf(name19, fieldNames, options, comment) {
        if (!Array.isArray(fieldNames)) {
          options = fieldNames;
          fieldNames = void 0;
        }
        ReflectionObject.call(this, name19, options);
        if (!(fieldNames === void 0 || Array.isArray(fieldNames)))
          throw TypeError("fieldNames must be an Array");
        this.oneof = fieldNames || [];
        this.fieldsArray = [];
        this.comment = comment;
      }
      OneOf.fromJSON = function fromJSON(name19, json) {
        return new OneOf(name19, json.oneof, json.options, json.comment);
      };
      OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
        var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
        return util.toObject([
          "options",
          this.options,
          "oneof",
          this.oneof,
          "comment",
          keepComments ? this.comment : void 0
        ]);
      };
      function addFieldsToParent(oneof) {
        if (oneof.parent) {
          for (var i = 0; i < oneof.fieldsArray.length; ++i)
            if (!oneof.fieldsArray[i].parent)
              oneof.parent.add(oneof.fieldsArray[i]);
        }
      }
      OneOf.prototype.add = function add4(field) {
        if (!(field instanceof Field4))
          throw TypeError("field must be a Field");
        if (field.parent && field.parent !== this.parent)
          field.parent.remove(field);
        this.oneof.push(field.name);
        this.fieldsArray.push(field);
        field.partOf = this;
        addFieldsToParent(this);
        return this;
      };
      OneOf.prototype.remove = function remove(field) {
        if (!(field instanceof Field4))
          throw TypeError("field must be a Field");
        var index = this.fieldsArray.indexOf(field);
        if (index < 0)
          throw Error(field + " is not a member of " + this);
        this.fieldsArray.splice(index, 1);
        index = this.oneof.indexOf(field.name);
        if (index > -1)
          this.oneof.splice(index, 1);
        field.partOf = null;
        return this;
      };
      OneOf.prototype.onAdd = function onAdd(parent) {
        ReflectionObject.prototype.onAdd.call(this, parent);
        var self2 = this;
        for (var i = 0; i < this.oneof.length; ++i) {
          var field = parent.get(this.oneof[i]);
          if (field && !field.partOf) {
            field.partOf = self2;
            self2.fieldsArray.push(field);
          }
        }
        addFieldsToParent(this);
      };
      OneOf.prototype.onRemove = function onRemove(parent) {
        for (var i = 0, field; i < this.fieldsArray.length; ++i)
          if ((field = this.fieldsArray[i]).parent)
            field.parent.remove(field);
        ReflectionObject.prototype.onRemove.call(this, parent);
      };
      Object.defineProperty(OneOf.prototype, "isProto3Optional", {
        get: function() {
          if (this.fieldsArray == null || this.fieldsArray.length !== 1) {
            return false;
          }
          var field = this.fieldsArray[0];
          return field.options != null && field.options["proto3_optional"] === true;
        }
      });
      OneOf.d = function decorateOneOf() {
        var fieldNames = new Array(arguments.length), index = 0;
        while (index < arguments.length)
          fieldNames[index] = arguments[index++];
        return function oneOfDecorator(prototype, oneofName) {
          util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
          Object.defineProperty(prototype, oneofName, {
            get: util.oneOfGetter(fieldNames),
            set: util.oneOfSetter(fieldNames)
          });
        };
      };
    }
  });

  // ../node_modules/protobufjs/src/object.js
  var require_object = __commonJS({
    "../node_modules/protobufjs/src/object.js"(exports2, module2) {
      "use strict";
      module2.exports = ReflectionObject;
      ReflectionObject.className = "ReflectionObject";
      var OneOf = require_oneof();
      var util = require_util();
      var Root;
      var editions2023Defaults = { enum_type: "OPEN", field_presence: "EXPLICIT", json_format: "ALLOW", message_encoding: "LENGTH_PREFIXED", repeated_field_encoding: "PACKED", utf8_validation: "VERIFY" };
      var proto2Defaults = { enum_type: "CLOSED", field_presence: "EXPLICIT", json_format: "LEGACY_BEST_EFFORT", message_encoding: "LENGTH_PREFIXED", repeated_field_encoding: "EXPANDED", utf8_validation: "NONE" };
      var proto3Defaults = { enum_type: "OPEN", field_presence: "IMPLICIT", json_format: "ALLOW", message_encoding: "LENGTH_PREFIXED", repeated_field_encoding: "PACKED", utf8_validation: "VERIFY" };
      function ReflectionObject(name19, options) {
        if (!util.isString(name19))
          throw TypeError("name must be a string");
        if (options && !util.isObject(options))
          throw TypeError("options must be an object");
        this.options = options;
        this.parsedOptions = null;
        this.name = name19;
        this._edition = null;
        this._defaultEdition = "proto2";
        this._features = {};
        this._featuresResolved = false;
        this.parent = null;
        this.resolved = false;
        this.comment = null;
        this.filename = null;
      }
      Object.defineProperties(ReflectionObject.prototype, {
        /**
         * Reference to the root namespace.
         * @name ReflectionObject#root
         * @type {Root}
         * @readonly
         */
        root: {
          get: function() {
            var ptr = this;
            while (ptr.parent !== null)
              ptr = ptr.parent;
            return ptr;
          }
        },
        /**
         * Full name including leading dot.
         * @name ReflectionObject#fullName
         * @type {string}
         * @readonly
         */
        fullName: {
          get: function() {
            var path = [this.name], ptr = this.parent;
            while (ptr) {
              path.unshift(ptr.name);
              ptr = ptr.parent;
            }
            return path.join(".");
          }
        }
      });
      ReflectionObject.prototype.toJSON = /* istanbul ignore next */
      function toJSON() {
        throw Error();
      };
      ReflectionObject.prototype.onAdd = function onAdd(parent) {
        if (this.parent && this.parent !== parent)
          this.parent.remove(this);
        this.parent = parent;
        this.resolved = false;
        var root = parent.root;
        if (root instanceof Root)
          root._handleAdd(this);
      };
      ReflectionObject.prototype.onRemove = function onRemove(parent) {
        var root = parent.root;
        if (root instanceof Root)
          root._handleRemove(this);
        this.parent = null;
        this.resolved = false;
      };
      ReflectionObject.prototype.resolve = function resolve() {
        if (this.resolved)
          return this;
        if (this.root instanceof Root)
          this.resolved = true;
        return this;
      };
      ReflectionObject.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {
        return this._resolveFeatures(this._edition || edition);
      };
      ReflectionObject.prototype._resolveFeatures = function _resolveFeatures(edition) {
        if (this._featuresResolved) {
          return;
        }
        var defaults = {};
        if (!edition) {
          throw new Error("Unknown edition for " + this.fullName);
        }
        var protoFeatures = Object.assign(
          this.options ? Object.assign({}, this.options.features) : {},
          this._inferLegacyProtoFeatures(edition)
        );
        if (this._edition) {
          if (edition === "proto2") {
            defaults = Object.assign({}, proto2Defaults);
          } else if (edition === "proto3") {
            defaults = Object.assign({}, proto3Defaults);
          } else if (edition === "2023") {
            defaults = Object.assign({}, editions2023Defaults);
          } else {
            throw new Error("Unknown edition: " + edition);
          }
          this._features = Object.assign(defaults, protoFeatures || {});
          this._featuresResolved = true;
          return;
        }
        if (this.partOf instanceof OneOf) {
          var lexicalParentFeaturesCopy = Object.assign({}, this.partOf._features);
          this._features = Object.assign(lexicalParentFeaturesCopy, protoFeatures || {});
        } else if (this.declaringField) {
        } else if (this.parent) {
          var parentFeaturesCopy = Object.assign({}, this.parent._features);
          this._features = Object.assign(parentFeaturesCopy, protoFeatures || {});
        } else {
          throw new Error("Unable to find a parent for " + this.fullName);
        }
        if (this.extensionField) {
          this.extensionField._features = this._features;
        }
        this._featuresResolved = true;
      };
      ReflectionObject.prototype._inferLegacyProtoFeatures = function _inferLegacyProtoFeatures() {
        return {};
      };
      ReflectionObject.prototype.getOption = function getOption(name19) {
        if (this.options)
          return this.options[name19];
        return void 0;
      };
      ReflectionObject.prototype.setOption = function setOption(name19, value, ifNotSet) {
        if (!this.options)
          this.options = {};
        if (/^features\./.test(name19)) {
          util.setProperty(this.options, name19, value, ifNotSet);
        } else if (!ifNotSet || this.options[name19] === void 0) {
          if (this.getOption(name19) !== value) this.resolved = false;
          this.options[name19] = value;
        }
        return this;
      };
      ReflectionObject.prototype.setParsedOption = function setParsedOption(name19, value, propName) {
        if (!this.parsedOptions) {
          this.parsedOptions = [];
        }
        var parsedOptions = this.parsedOptions;
        if (propName) {
          var opt = parsedOptions.find(function(opt2) {
            return Object.prototype.hasOwnProperty.call(opt2, name19);
          });
          if (opt) {
            var newValue = opt[name19];
            util.setProperty(newValue, propName, value);
          } else {
            opt = {};
            opt[name19] = util.setProperty({}, propName, value);
            parsedOptions.push(opt);
          }
        } else {
          var newOpt = {};
          newOpt[name19] = value;
          parsedOptions.push(newOpt);
        }
        return this;
      };
      ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
        if (options)
          for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
            this.setOption(keys[i], options[keys[i]], ifNotSet);
        return this;
      };
      ReflectionObject.prototype.toString = function toString29() {
        var className = this.constructor.className, fullName = this.fullName;
        if (fullName.length)
          return className + " " + fullName;
        return className;
      };
      ReflectionObject.prototype._editionToJSON = function _editionToJSON() {
        if (!this._edition || this._edition === "proto3") {
          return void 0;
        }
        return this._edition;
      };
      ReflectionObject._configure = function(Root_) {
        Root = Root_;
      };
    }
  });

  // ../node_modules/protobufjs/src/enum.js
  var require_enum = __commonJS({
    "../node_modules/protobufjs/src/enum.js"(exports2, module2) {
      "use strict";
      module2.exports = Enum;
      var ReflectionObject = require_object();
      ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";
      var Namespace = require_namespace();
      var util = require_util();
      function Enum(name19, values, options, comment, comments, valuesOptions) {
        ReflectionObject.call(this, name19, options);
        if (values && typeof values !== "object")
          throw TypeError("values must be an object");
        this.valuesById = {};
        this.values = Object.create(this.valuesById);
        this.comment = comment;
        this.comments = comments || {};
        this.valuesOptions = valuesOptions;
        this._valuesFeatures = {};
        this.reserved = void 0;
        if (values) {
          for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
            if (typeof values[keys[i]] === "number")
              this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];
        }
      }
      Enum.prototype._resolveFeatures = function _resolveFeatures(edition) {
        edition = this._edition || edition;
        ReflectionObject.prototype._resolveFeatures.call(this, edition);
        Object.keys(this.values).forEach((key) => {
          var parentFeaturesCopy = Object.assign({}, this._features);
          this._valuesFeatures[key] = Object.assign(parentFeaturesCopy, this.valuesOptions && this.valuesOptions[key] && this.valuesOptions[key].features);
        });
        return this;
      };
      Enum.fromJSON = function fromJSON(name19, json) {
        var enm = new Enum(name19, json.values, json.options, json.comment, json.comments);
        enm.reserved = json.reserved;
        if (json.edition)
          enm._edition = json.edition;
        enm._defaultEdition = "proto3";
        return enm;
      };
      Enum.prototype.toJSON = function toJSON(toJSONOptions) {
        var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
        return util.toObject([
          "edition",
          this._editionToJSON(),
          "options",
          this.options,
          "valuesOptions",
          this.valuesOptions,
          "values",
          this.values,
          "reserved",
          this.reserved && this.reserved.length ? this.reserved : void 0,
          "comment",
          keepComments ? this.comment : void 0,
          "comments",
          keepComments ? this.comments : void 0
        ]);
      };
      Enum.prototype.add = function add4(name19, id, comment, options) {
        if (!util.isString(name19))
          throw TypeError("name must be a string");
        if (!util.isInteger(id))
          throw TypeError("id must be an integer");
        if (this.values[name19] !== void 0)
          throw Error("duplicate name '" + name19 + "' in " + this);
        if (this.isReservedId(id))
          throw Error("id " + id + " is reserved in " + this);
        if (this.isReservedName(name19))
          throw Error("name '" + name19 + "' is reserved in " + this);
        if (this.valuesById[id] !== void 0) {
          if (!(this.options && this.options.allow_alias))
            throw Error("duplicate id " + id + " in " + this);
          this.values[name19] = id;
        } else
          this.valuesById[this.values[name19] = id] = name19;
        if (options) {
          if (this.valuesOptions === void 0)
            this.valuesOptions = {};
          this.valuesOptions[name19] = options || null;
        }
        this.comments[name19] = comment || null;
        return this;
      };
      Enum.prototype.remove = function remove(name19) {
        if (!util.isString(name19))
          throw TypeError("name must be a string");
        var val = this.values[name19];
        if (val == null)
          throw Error("name '" + name19 + "' does not exist in " + this);
        delete this.valuesById[val];
        delete this.values[name19];
        delete this.comments[name19];
        if (this.valuesOptions)
          delete this.valuesOptions[name19];
        return this;
      };
      Enum.prototype.isReservedId = function isReservedId(id) {
        return Namespace.isReservedId(this.reserved, id);
      };
      Enum.prototype.isReservedName = function isReservedName(name19) {
        return Namespace.isReservedName(this.reserved, name19);
      };
    }
  });

  // ../node_modules/protobufjs/src/encoder.js
  var require_encoder = __commonJS({
    "../node_modules/protobufjs/src/encoder.js"(exports2, module2) {
      "use strict";
      module2.exports = encoder3;
      var Enum = require_enum();
      var types = require_types();
      var util = require_util();
      function genTypePartial(gen, field, fieldIndex, ref) {
        return field.delimited ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
      }
      function encoder3(mtype) {
        var gen = util.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
        var i, ref;
        var fields = (
          /* initializes */
          mtype.fieldsArray.slice().sort(util.compareFieldsById)
        );
        for (var i = 0; i < fields.length; ++i) {
          var field = fields[i].resolve(), index = mtype._fieldsArray.indexOf(field), type = field.resolvedType instanceof Enum ? "int32" : field.type, wireType = types.basic[type];
          ref = "m" + util.safeProp(field.name);
          if (field.map) {
            gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
            if (wireType === void 0) gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref);
            else gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
            gen("}")("}");
          } else if (field.repeated) {
            gen("if(%s!=null&&%s.length){", ref, ref);
            if (field.packed && types.packed[type] !== void 0) {
              gen("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref)("w.%s(%s[i])", type, ref)("w.ldelim()");
            } else {
              gen("for(var i=0;i<%s.length;++i)", ref);
              if (wireType === void 0)
                genTypePartial(gen, field, index, ref + "[i]");
              else gen("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);
            }
            gen("}");
          } else {
            if (field.optional) gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name);
            if (wireType === void 0)
              genTypePartial(gen, field, index, ref);
            else gen("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);
          }
        }
        return gen("return w");
      }
    }
  });

  // ../node_modules/protobufjs/src/index-light.js
  var require_index_light = __commonJS({
    "../node_modules/protobufjs/src/index-light.js"(exports2, module2) {
      "use strict";
      var protobuf2 = module2.exports = require_index_minimal();
      protobuf2.build = "light";
      function load2(filename, root, callback) {
        if (typeof root === "function") {
          callback = root;
          root = new protobuf2.Root();
        } else if (!root)
          root = new protobuf2.Root();
        return root.load(filename, callback);
      }
      protobuf2.load = load2;
      function loadSync(filename, root) {
        if (!root)
          root = new protobuf2.Root();
        return root.loadSync(filename);
      }
      protobuf2.loadSync = loadSync;
      protobuf2.encoder = require_encoder();
      protobuf2.decoder = require_decoder();
      protobuf2.verifier = require_verifier();
      protobuf2.converter = require_converter();
      protobuf2.ReflectionObject = require_object();
      protobuf2.Namespace = require_namespace();
      protobuf2.Root = require_root();
      protobuf2.Enum = require_enum();
      protobuf2.Type = require_type();
      protobuf2.Field = require_field();
      protobuf2.OneOf = require_oneof();
      protobuf2.MapField = require_mapfield();
      protobuf2.Service = require_service2();
      protobuf2.Method = require_method();
      protobuf2.Message = require_message();
      protobuf2.wrappers = require_wrappers();
      protobuf2.types = require_types();
      protobuf2.util = require_util();
      protobuf2.ReflectionObject._configure(protobuf2.Root);
      protobuf2.Namespace._configure(protobuf2.Type, protobuf2.Service, protobuf2.Enum);
      protobuf2.Root._configure(protobuf2.Type);
      protobuf2.Field._configure(protobuf2.Type);
    }
  });

  // ../node_modules/protobufjs/src/tokenize.js
  var require_tokenize = __commonJS({
    "../node_modules/protobufjs/src/tokenize.js"(exports2, module2) {
      "use strict";
      module2.exports = tokenize;
      var delimRe = /[\s{}=;:[\],'"()<>]/g;
      var stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g;
      var stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;
      var setCommentRe = /^ *[*/]+ */;
      var setCommentAltRe = /^\s*\*?\/*/;
      var setCommentSplitRe = /\n/g;
      var whitespaceRe = /\s/;
      var unescapeRe = /\\(.?)/g;
      var unescapeMap = {
        "0": "\0",
        "r": "\r",
        "n": "\n",
        "t": "	"
      };
      function unescape(str) {
        return str.replace(unescapeRe, function($0, $1) {
          switch ($1) {
            case "\\":
            case "":
              return $1;
            default:
              return unescapeMap[$1] || "";
          }
        });
      }
      tokenize.unescape = unescape;
      function tokenize(source, alternateCommentMode) {
        source = source.toString();
        var offset = 0, length21 = source.length, line = 1, lastCommentLine = 0, comments = {};
        var stack = [];
        var stringDelim = null;
        function illegal(subject) {
          return Error("illegal " + subject + " (line " + line + ")");
        }
        function readString2() {
          var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
          re.lastIndex = offset - 1;
          var match = re.exec(source);
          if (!match)
            throw illegal("string");
          offset = re.lastIndex;
          push(stringDelim);
          stringDelim = null;
          return unescape(match[1]);
        }
        function charAt(pos) {
          return source.charAt(pos);
        }
        function setComment(start2, end, isLeading) {
          var comment = {
            type: source.charAt(start2++),
            lineEmpty: false,
            leading: isLeading
          };
          var lookback;
          if (alternateCommentMode) {
            lookback = 2;
          } else {
            lookback = 3;
          }
          var commentOffset = start2 - lookback, c;
          do {
            if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === "\n") {
              comment.lineEmpty = true;
              break;
            }
          } while (c === " " || c === "	");
          var lines = source.substring(start2, end).split(setCommentSplitRe);
          for (var i = 0; i < lines.length; ++i)
            lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "").trim();
          comment.text = lines.join("\n").trim();
          comments[line] = comment;
          lastCommentLine = line;
        }
        function isDoubleSlashCommentLine(startOffset) {
          var endOffset = findEndOfLine(startOffset);
          var lineText = source.substring(startOffset, endOffset);
          var isComment = /^\s*\/\//.test(lineText);
          return isComment;
        }
        function findEndOfLine(cursor) {
          var endOffset = cursor;
          while (endOffset < length21 && charAt(endOffset) !== "\n") {
            endOffset++;
          }
          return endOffset;
        }
        function next() {
          if (stack.length > 0)
            return stack.shift();
          if (stringDelim)
            return readString2();
          var repeat, prev, curr, start2, isDoc, isLeadingComment = offset === 0;
          do {
            if (offset === length21)
              return null;
            repeat = false;
            while (whitespaceRe.test(curr = charAt(offset))) {
              if (curr === "\n") {
                isLeadingComment = true;
                ++line;
              }
              if (++offset === length21)
                return null;
            }
            if (charAt(offset) === "/") {
              if (++offset === length21) {
                throw illegal("comment");
              }
              if (charAt(offset) === "/") {
                if (!alternateCommentMode) {
                  isDoc = charAt(start2 = offset + 1) === "/";
                  while (charAt(++offset) !== "\n") {
                    if (offset === length21) {
                      return null;
                    }
                  }
                  ++offset;
                  if (isDoc) {
                    setComment(start2, offset - 1, isLeadingComment);
                    isLeadingComment = true;
                  }
                  ++line;
                  repeat = true;
                } else {
                  start2 = offset;
                  isDoc = false;
                  if (isDoubleSlashCommentLine(offset - 1)) {
                    isDoc = true;
                    do {
                      offset = findEndOfLine(offset);
                      if (offset === length21) {
                        break;
                      }
                      offset++;
                      if (!isLeadingComment) {
                        break;
                      }
                    } while (isDoubleSlashCommentLine(offset));
                  } else {
                    offset = Math.min(length21, findEndOfLine(offset) + 1);
                  }
                  if (isDoc) {
                    setComment(start2, offset, isLeadingComment);
                    isLeadingComment = true;
                  }
                  line++;
                  repeat = true;
                }
              } else if ((curr = charAt(offset)) === "*") {
                start2 = offset + 1;
                isDoc = alternateCommentMode || charAt(start2) === "*";
                do {
                  if (curr === "\n") {
                    ++line;
                  }
                  if (++offset === length21) {
                    throw illegal("comment");
                  }
                  prev = curr;
                  curr = charAt(offset);
                } while (prev !== "*" || curr !== "/");
                ++offset;
                if (isDoc) {
                  setComment(start2, offset - 2, isLeadingComment);
                  isLeadingComment = true;
                }
                repeat = true;
              } else {
                return "/";
              }
            }
          } while (repeat);
          var end = offset;
          delimRe.lastIndex = 0;
          var delim = delimRe.test(charAt(end++));
          if (!delim)
            while (end < length21 && !delimRe.test(charAt(end)))
              ++end;
          var token = source.substring(offset, offset = end);
          if (token === '"' || token === "'")
            stringDelim = token;
          return token;
        }
        function push(token) {
          stack.push(token);
        }
        function peek() {
          if (!stack.length) {
            var token = next();
            if (token === null)
              return null;
            push(token);
          }
          return stack[0];
        }
        function skip(expected, optional2) {
          var actual = peek(), equals49 = actual === expected;
          if (equals49) {
            next();
            return true;
          }
          if (!optional2)
            throw illegal("token '" + actual + "', '" + expected + "' expected");
          return false;
        }
        function cmnt(trailingLine) {
          var ret = null;
          var comment;
          if (trailingLine === void 0) {
            comment = comments[line - 1];
            delete comments[line - 1];
            if (comment && (alternateCommentMode || comment.type === "*" || comment.lineEmpty)) {
              ret = comment.leading ? comment.text : null;
            }
          } else {
            if (lastCommentLine < trailingLine) {
              peek();
            }
            comment = comments[trailingLine];
            delete comments[trailingLine];
            if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === "/")) {
              ret = comment.leading ? null : comment.text;
            }
          }
          return ret;
        }
        return Object.defineProperty({
          next,
          peek,
          push,
          skip,
          cmnt
        }, "line", {
          get: function() {
            return line;
          }
        });
      }
    }
  });

  // ../node_modules/protobufjs/src/parse.js
  var require_parse = __commonJS({
    "../node_modules/protobufjs/src/parse.js"(exports2, module2) {
      "use strict";
      module2.exports = parse2;
      parse2.filename = null;
      parse2.defaults = { keepCase: false };
      var tokenize = require_tokenize();
      var Root = require_root();
      var Type = require_type();
      var Field4 = require_field();
      var MapField = require_mapfield();
      var OneOf = require_oneof();
      var Enum = require_enum();
      var Service = require_service2();
      var Method = require_method();
      var ReflectionObject = require_object();
      var types = require_types();
      var util = require_util();
      var base10Re = /^[1-9][0-9]*$/;
      var base10NegRe = /^-?[1-9][0-9]*$/;
      var base16Re = /^0[x][0-9a-fA-F]+$/;
      var base16NegRe = /^-?0[x][0-9a-fA-F]+$/;
      var base8Re = /^0[0-7]+$/;
      var base8NegRe = /^-?0[0-7]+$/;
      var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
      var nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
      var typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;
      function parse2(source, root, options) {
        if (!(root instanceof Root)) {
          options = root;
          root = new Root();
        }
        if (!options)
          options = parse2.defaults;
        var preferTrailingComment = options.preferTrailingComment || false;
        var tn = tokenize(source, options.alternateCommentMode || false), next = tn.next, push = tn.push, peek = tn.peek, skip = tn.skip, cmnt = tn.cmnt;
        var head = true, pkg, imports, weakImports, edition = "proto2";
        var ptr = root;
        var topLevelObjects = [];
        var topLevelOptions = {};
        var applyCase = options.keepCase ? function(name19) {
          return name19;
        } : util.camelCase;
        function resolveFileFeatures() {
          topLevelObjects.forEach((obj) => {
            obj._edition = edition;
            Object.keys(topLevelOptions).forEach((opt) => {
              if (obj.getOption(opt) !== void 0) return;
              obj.setOption(opt, topLevelOptions[opt], true);
            });
          });
        }
        function illegal(token2, name19, insideTryCatch) {
          var filename = parse2.filename;
          if (!insideTryCatch)
            parse2.filename = null;
          return Error("illegal " + (name19 || "token") + " '" + token2 + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
        }
        function readString2() {
          var values = [], token2;
          do {
            if ((token2 = next()) !== '"' && token2 !== "'")
              throw illegal(token2);
            values.push(next());
            skip(token2);
            token2 = peek();
          } while (token2 === '"' || token2 === "'");
          return values.join("");
        }
        function readValue(acceptTypeRef) {
          var token2 = next();
          switch (token2) {
            case "'":
            case '"':
              push(token2);
              return readString2();
            case "true":
            case "TRUE":
              return true;
            case "false":
            case "FALSE":
              return false;
          }
          try {
            return parseNumber(
              token2,
              /* insideTryCatch */
              true
            );
          } catch (e) {
            if (acceptTypeRef && typeRefRe.test(token2))
              return token2;
            throw illegal(token2, "value");
          }
        }
        function readRanges(target, acceptStrings) {
          var token2, start2;
          do {
            if (acceptStrings && ((token2 = peek()) === '"' || token2 === "'")) {
              var str = readString2();
              target.push(str);
              if (edition >= 2023) {
                throw illegal(str, "id");
              }
            } else {
              try {
                target.push([start2 = parseId(next()), skip("to", true) ? parseId(next()) : start2]);
              } catch (err) {
                if (acceptStrings && typeRefRe.test(token2) && edition >= 2023) {
                  target.push(token2);
                } else {
                  throw err;
                }
              }
            }
          } while (skip(",", true));
          var dummy = { options: void 0 };
          dummy.setOption = function(name19, value) {
            if (this.options === void 0) this.options = {};
            this.options[name19] = value;
          };
          ifBlock(
            dummy,
            function parseRange_block(token3) {
              if (token3 === "option") {
                parseOption(dummy, token3);
                skip(";");
              } else
                throw illegal(token3);
            },
            function parseRange_line() {
              parseInlineOptions(dummy);
            }
          );
        }
        function parseNumber(token2, insideTryCatch) {
          var sign3 = 1;
          if (token2.charAt(0) === "-") {
            sign3 = -1;
            token2 = token2.substring(1);
          }
          switch (token2) {
            case "inf":
            case "INF":
            case "Inf":
              return sign3 * Infinity;
            case "nan":
            case "NAN":
            case "Nan":
            case "NaN":
              return NaN;
            case "0":
              return 0;
          }
          if (base10Re.test(token2))
            return sign3 * parseInt(token2, 10);
          if (base16Re.test(token2))
            return sign3 * parseInt(token2, 16);
          if (base8Re.test(token2))
            return sign3 * parseInt(token2, 8);
          if (numberRe.test(token2))
            return sign3 * parseFloat(token2);
          throw illegal(token2, "number", insideTryCatch);
        }
        function parseId(token2, acceptNegative) {
          switch (token2) {
            case "max":
            case "MAX":
            case "Max":
              return 536870911;
            case "0":
              return 0;
          }
          if (!acceptNegative && token2.charAt(0) === "-")
            throw illegal(token2, "id");
          if (base10NegRe.test(token2))
            return parseInt(token2, 10);
          if (base16NegRe.test(token2))
            return parseInt(token2, 16);
          if (base8NegRe.test(token2))
            return parseInt(token2, 8);
          throw illegal(token2, "id");
        }
        function parsePackage() {
          if (pkg !== void 0)
            throw illegal("package");
          pkg = next();
          if (!typeRefRe.test(pkg))
            throw illegal(pkg, "name");
          ptr = ptr.define(pkg);
          skip(";");
        }
        function parseImport() {
          var token2 = peek();
          var whichImports;
          switch (token2) {
            case "weak":
              whichImports = weakImports || (weakImports = []);
              next();
              break;
            case "public":
              next();
            // eslint-disable-next-line no-fallthrough
            default:
              whichImports = imports || (imports = []);
              break;
          }
          token2 = readString2();
          skip(";");
          whichImports.push(token2);
        }
        function parseSyntax() {
          skip("=");
          edition = readString2();
          if (edition < 2023)
            throw illegal(edition, "syntax");
          skip(";");
        }
        function parseEdition() {
          skip("=");
          edition = readString2();
          const supportedEditions = ["2023"];
          if (!supportedEditions.includes(edition))
            throw illegal(edition, "edition");
          skip(";");
        }
        function parseCommon(parent, token2) {
          switch (token2) {
            case "option":
              parseOption(parent, token2);
              skip(";");
              return true;
            case "message":
              parseType(parent, token2);
              return true;
            case "enum":
              parseEnum(parent, token2);
              return true;
            case "service":
              parseService(parent, token2);
              return true;
            case "extend":
              parseExtension(parent, token2);
              return true;
          }
          return false;
        }
        function ifBlock(obj, fnIf, fnElse) {
          var trailingLine = tn.line;
          if (obj) {
            if (typeof obj.comment !== "string") {
              obj.comment = cmnt();
            }
            obj.filename = parse2.filename;
          }
          if (skip("{", true)) {
            var token2;
            while ((token2 = next()) !== "}")
              fnIf(token2);
            skip(";", true);
          } else {
            if (fnElse)
              fnElse();
            skip(";");
            if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
              obj.comment = cmnt(trailingLine) || obj.comment;
          }
        }
        function parseType(parent, token2) {
          if (!nameRe.test(token2 = next()))
            throw illegal(token2, "type name");
          var type = new Type(token2);
          ifBlock(type, function parseType_block(token3) {
            if (parseCommon(type, token3))
              return;
            switch (token3) {
              case "map":
                parseMapField(type, token3);
                break;
              case "required":
                if (edition !== "proto2")
                  throw illegal(token3);
              /* eslint-disable no-fallthrough */
              case "repeated":
                parseField(type, token3);
                break;
              case "optional":
                if (edition === "proto3") {
                  parseField(type, "proto3_optional");
                } else if (edition !== "proto2") {
                  throw illegal(token3);
                } else {
                  parseField(type, "optional");
                }
                break;
              case "oneof":
                parseOneOf(type, token3);
                break;
              case "extensions":
                readRanges(type.extensions || (type.extensions = []));
                break;
              case "reserved":
                readRanges(type.reserved || (type.reserved = []), true);
                break;
              default:
                if (edition === "proto2" || !typeRefRe.test(token3)) {
                  throw illegal(token3);
                }
                push(token3);
                parseField(type, "optional");
                break;
            }
          });
          parent.add(type);
          if (parent === ptr) {
            topLevelObjects.push(type);
          }
        }
        function parseField(parent, rule, extend) {
          var type = next();
          if (type === "group") {
            parseGroup(parent, rule);
            return;
          }
          while (type.endsWith(".") || peek().startsWith(".")) {
            type += next();
          }
          if (!typeRefRe.test(type))
            throw illegal(type, "type");
          var name19 = next();
          if (!nameRe.test(name19))
            throw illegal(name19, "name");
          name19 = applyCase(name19);
          skip("=");
          var field = new Field4(name19, parseId(next()), type, rule, extend);
          ifBlock(field, function parseField_block(token2) {
            if (token2 === "option") {
              parseOption(field, token2);
              skip(";");
            } else
              throw illegal(token2);
          }, function parseField_line() {
            parseInlineOptions(field);
          });
          if (rule === "proto3_optional") {
            var oneof = new OneOf("_" + name19);
            field.setOption("proto3_optional", true);
            oneof.add(field);
            parent.add(oneof);
          } else {
            parent.add(field);
          }
          if (parent === ptr) {
            topLevelObjects.push(field);
          }
        }
        function parseGroup(parent, rule) {
          if (edition >= 2023) {
            throw illegal("group");
          }
          var name19 = next();
          if (!nameRe.test(name19))
            throw illegal(name19, "name");
          var fieldName = util.lcFirst(name19);
          if (name19 === fieldName)
            name19 = util.ucFirst(name19);
          skip("=");
          var id = parseId(next());
          var type = new Type(name19);
          type.group = true;
          var field = new Field4(fieldName, id, name19, rule);
          field.filename = parse2.filename;
          ifBlock(type, function parseGroup_block(token2) {
            switch (token2) {
              case "option":
                parseOption(type, token2);
                skip(";");
                break;
              case "required":
              case "repeated":
                parseField(type, token2);
                break;
              case "optional":
                if (edition === "proto3") {
                  parseField(type, "proto3_optional");
                } else {
                  parseField(type, "optional");
                }
                break;
              case "message":
                parseType(type, token2);
                break;
              case "enum":
                parseEnum(type, token2);
                break;
              case "reserved":
                readRanges(type.reserved || (type.reserved = []), true);
                break;
              /* istanbul ignore next */
              default:
                throw illegal(token2);
            }
          });
          parent.add(type).add(field);
        }
        function parseMapField(parent) {
          skip("<");
          var keyType = next();
          if (types.mapKey[keyType] === void 0)
            throw illegal(keyType, "type");
          skip(",");
          var valueType = next();
          if (!typeRefRe.test(valueType))
            throw illegal(valueType, "type");
          skip(">");
          var name19 = next();
          if (!nameRe.test(name19))
            throw illegal(name19, "name");
          skip("=");
          var field = new MapField(applyCase(name19), parseId(next()), keyType, valueType);
          ifBlock(field, function parseMapField_block(token2) {
            if (token2 === "option") {
              parseOption(field, token2);
              skip(";");
            } else
              throw illegal(token2);
          }, function parseMapField_line() {
            parseInlineOptions(field);
          });
          parent.add(field);
        }
        function parseOneOf(parent, token2) {
          if (!nameRe.test(token2 = next()))
            throw illegal(token2, "name");
          var oneof = new OneOf(applyCase(token2));
          ifBlock(oneof, function parseOneOf_block(token3) {
            if (token3 === "option") {
              parseOption(oneof, token3);
              skip(";");
            } else {
              push(token3);
              parseField(oneof, "optional");
            }
          });
          parent.add(oneof);
        }
        function parseEnum(parent, token2) {
          if (!nameRe.test(token2 = next()))
            throw illegal(token2, "name");
          var enm = new Enum(token2);
          ifBlock(enm, function parseEnum_block(token3) {
            switch (token3) {
              case "option":
                parseOption(enm, token3);
                skip(";");
                break;
              case "reserved":
                readRanges(enm.reserved || (enm.reserved = []), true);
                if (enm.reserved === void 0) enm.reserved = [];
                break;
              default:
                parseEnumValue(enm, token3);
            }
          });
          parent.add(enm);
          if (parent === ptr) {
            topLevelObjects.push(enm);
          }
        }
        function parseEnumValue(parent, token2) {
          if (!nameRe.test(token2))
            throw illegal(token2, "name");
          skip("=");
          var value = parseId(next(), true), dummy = {
            options: void 0
          };
          dummy.getOption = function(name19) {
            return this.options[name19];
          };
          dummy.setOption = function(name19, value2) {
            ReflectionObject.prototype.setOption.call(dummy, name19, value2);
          };
          dummy.setParsedOption = function() {
            return void 0;
          };
          ifBlock(dummy, function parseEnumValue_block(token3) {
            if (token3 === "option") {
              parseOption(dummy, token3);
              skip(";");
            } else
              throw illegal(token3);
          }, function parseEnumValue_line() {
            parseInlineOptions(dummy);
          });
          parent.add(token2, value, dummy.comment, dummy.parsedOptions || dummy.options);
        }
        function parseOption(parent, token2) {
          var option;
          var propName;
          var isOption = true;
          if (token2 === "option") {
            token2 = next();
          }
          while (token2 !== "=") {
            if (token2 === "(") {
              var parensValue = next();
              skip(")");
              token2 = "(" + parensValue + ")";
            }
            if (isOption) {
              isOption = false;
              if (token2.includes(".") && !token2.includes("(")) {
                var tokens = token2.split(".");
                option = tokens[0] + ".";
                token2 = tokens[1];
                continue;
              }
              option = token2;
            } else {
              propName = propName ? propName += token2 : token2;
            }
            token2 = next();
          }
          var name19 = propName ? option.concat(propName) : option;
          var optionValue = parseOptionValue(parent, name19);
          propName = propName && propName[0] === "." ? propName.slice(1) : propName;
          option = option && option[option.length - 1] === "." ? option.slice(0, -1) : option;
          setParsedOption(parent, option, optionValue, propName);
        }
        function parseOptionValue(parent, name19) {
          if (skip("{", true)) {
            var objectResult = {};
            while (!skip("}", true)) {
              if (!nameRe.test(token = next())) {
                throw illegal(token, "name");
              }
              if (token === null) {
                throw illegal(token, "end of input");
              }
              var value;
              var propName = token;
              skip(":", true);
              if (peek() === "{") {
                value = parseOptionValue(parent, name19 + "." + token);
              } else if (peek() === "[") {
                value = [];
                var lastValue;
                if (skip("[", true)) {
                  do {
                    lastValue = readValue(true);
                    value.push(lastValue);
                  } while (skip(",", true));
                  skip("]");
                  if (typeof lastValue !== "undefined") {
                    setOption(parent, name19 + "." + token, lastValue);
                  }
                }
              } else {
                value = readValue(true);
                setOption(parent, name19 + "." + token, value);
              }
              var prevValue = objectResult[propName];
              if (prevValue)
                value = [].concat(prevValue).concat(value);
              objectResult[propName] = value;
              skip(",", true);
              skip(";", true);
            }
            return objectResult;
          }
          var simpleValue = readValue(true);
          setOption(parent, name19, simpleValue);
          return simpleValue;
        }
        function setOption(parent, name19, value) {
          if (ptr === parent && /^features\./.test(name19)) {
            topLevelOptions[name19] = value;
            return;
          }
          if (parent.setOption)
            parent.setOption(name19, value);
        }
        function setParsedOption(parent, name19, value, propName) {
          if (parent.setParsedOption)
            parent.setParsedOption(name19, value, propName);
        }
        function parseInlineOptions(parent) {
          if (skip("[", true)) {
            do {
              parseOption(parent, "option");
            } while (skip(",", true));
            skip("]");
          }
          return parent;
        }
        function parseService(parent, token2) {
          if (!nameRe.test(token2 = next()))
            throw illegal(token2, "service name");
          var service = new Service(token2);
          ifBlock(service, function parseService_block(token3) {
            if (parseCommon(service, token3)) {
              return;
            }
            if (token3 === "rpc")
              parseMethod(service, token3);
            else
              throw illegal(token3);
          });
          parent.add(service);
          if (parent === ptr) {
            topLevelObjects.push(service);
          }
        }
        function parseMethod(parent, token2) {
          var commentText = cmnt();
          var type = token2;
          if (!nameRe.test(token2 = next()))
            throw illegal(token2, "name");
          var name19 = token2, requestType, requestStream, responseType, responseStream;
          skip("(");
          if (skip("stream", true))
            requestStream = true;
          if (!typeRefRe.test(token2 = next()))
            throw illegal(token2);
          requestType = token2;
          skip(")");
          skip("returns");
          skip("(");
          if (skip("stream", true))
            responseStream = true;
          if (!typeRefRe.test(token2 = next()))
            throw illegal(token2);
          responseType = token2;
          skip(")");
          var method = new Method(name19, type, requestType, responseType, requestStream, responseStream);
          method.comment = commentText;
          ifBlock(method, function parseMethod_block(token3) {
            if (token3 === "option") {
              parseOption(method, token3);
              skip(";");
            } else
              throw illegal(token3);
          });
          parent.add(method);
        }
        function parseExtension(parent, token2) {
          if (!typeRefRe.test(token2 = next()))
            throw illegal(token2, "reference");
          var reference = token2;
          ifBlock(null, function parseExtension_block(token3) {
            switch (token3) {
              case "required":
              case "repeated":
                parseField(parent, token3, reference);
                break;
              case "optional":
                if (edition === "proto3") {
                  parseField(parent, "proto3_optional", reference);
                } else {
                  parseField(parent, "optional", reference);
                }
                break;
              default:
                if (edition === "proto2" || !typeRefRe.test(token3))
                  throw illegal(token3);
                push(token3);
                parseField(parent, "optional", reference);
                break;
            }
          });
        }
        var token;
        while ((token = next()) !== null) {
          switch (token) {
            case "package":
              if (!head)
                throw illegal(token);
              parsePackage();
              break;
            case "import":
              if (!head)
                throw illegal(token);
              parseImport();
              break;
            case "syntax":
              if (!head)
                throw illegal(token);
              parseSyntax();
              break;
            case "edition":
              if (!head)
                throw illegal(token);
              parseEdition();
              break;
            case "option":
              parseOption(ptr, token);
              skip(";", true);
              break;
            default:
              if (parseCommon(ptr, token)) {
                head = false;
                continue;
              }
              throw illegal(token);
          }
        }
        resolveFileFeatures();
        parse2.filename = null;
        return {
          "package": pkg,
          "imports": imports,
          weakImports,
          root
        };
      }
    }
  });

  // ../node_modules/protobufjs/src/common.js
  var require_common2 = __commonJS({
    "../node_modules/protobufjs/src/common.js"(exports2, module2) {
      "use strict";
      module2.exports = common;
      var commonRe = /\/|\./;
      function common(name19, json) {
        if (!commonRe.test(name19)) {
          name19 = "google/protobuf/" + name19 + ".proto";
          json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
        }
        common[name19] = json;
      }
      common("any", {
        /**
         * Properties of a google.protobuf.Any message.
         * @interface IAny
         * @type {Object}
         * @property {string} [typeUrl]
         * @property {Uint8Array} [bytes]
         * @memberof common
         */
        Any: {
          fields: {
            type_url: {
              type: "string",
              id: 1
            },
            value: {
              type: "bytes",
              id: 2
            }
          }
        }
      });
      var timeType;
      common("duration", {
        /**
         * Properties of a google.protobuf.Duration message.
         * @interface IDuration
         * @type {Object}
         * @property {number|Long} [seconds]
         * @property {number} [nanos]
         * @memberof common
         */
        Duration: timeType = {
          fields: {
            seconds: {
              type: "int64",
              id: 1
            },
            nanos: {
              type: "int32",
              id: 2
            }
          }
        }
      });
      common("timestamp", {
        /**
         * Properties of a google.protobuf.Timestamp message.
         * @interface ITimestamp
         * @type {Object}
         * @property {number|Long} [seconds]
         * @property {number} [nanos]
         * @memberof common
         */
        Timestamp: timeType
      });
      common("empty", {
        /**
         * Properties of a google.protobuf.Empty message.
         * @interface IEmpty
         * @memberof common
         */
        Empty: {
          fields: {}
        }
      });
      common("struct", {
        /**
         * Properties of a google.protobuf.Struct message.
         * @interface IStruct
         * @type {Object}
         * @property {Object.<string,IValue>} [fields]
         * @memberof common
         */
        Struct: {
          fields: {
            fields: {
              keyType: "string",
              type: "Value",
              id: 1
            }
          }
        },
        /**
         * Properties of a google.protobuf.Value message.
         * @interface IValue
         * @type {Object}
         * @property {string} [kind]
         * @property {0} [nullValue]
         * @property {number} [numberValue]
         * @property {string} [stringValue]
         * @property {boolean} [boolValue]
         * @property {IStruct} [structValue]
         * @property {IListValue} [listValue]
         * @memberof common
         */
        Value: {
          oneofs: {
            kind: {
              oneof: [
                "nullValue",
                "numberValue",
                "stringValue",
                "boolValue",
                "structValue",
                "listValue"
              ]
            }
          },
          fields: {
            nullValue: {
              type: "NullValue",
              id: 1
            },
            numberValue: {
              type: "double",
              id: 2
            },
            stringValue: {
              type: "string",
              id: 3
            },
            boolValue: {
              type: "bool",
              id: 4
            },
            structValue: {
              type: "Struct",
              id: 5
            },
            listValue: {
              type: "ListValue",
              id: 6
            }
          }
        },
        NullValue: {
          values: {
            NULL_VALUE: 0
          }
        },
        /**
         * Properties of a google.protobuf.ListValue message.
         * @interface IListValue
         * @type {Object}
         * @property {Array.<IValue>} [values]
         * @memberof common
         */
        ListValue: {
          fields: {
            values: {
              rule: "repeated",
              type: "Value",
              id: 1
            }
          }
        }
      });
      common("wrappers", {
        /**
         * Properties of a google.protobuf.DoubleValue message.
         * @interface IDoubleValue
         * @type {Object}
         * @property {number} [value]
         * @memberof common
         */
        DoubleValue: {
          fields: {
            value: {
              type: "double",
              id: 1
            }
          }
        },
        /**
         * Properties of a google.protobuf.FloatValue message.
         * @interface IFloatValue
         * @type {Object}
         * @property {number} [value]
         * @memberof common
         */
        FloatValue: {
          fields: {
            value: {
              type: "float",
              id: 1
            }
          }
        },
        /**
         * Properties of a google.protobuf.Int64Value message.
         * @interface IInt64Value
         * @type {Object}
         * @property {number|Long} [value]
         * @memberof common
         */
        Int64Value: {
          fields: {
            value: {
              type: "int64",
              id: 1
            }
          }
        },
        /**
         * Properties of a google.protobuf.UInt64Value message.
         * @interface IUInt64Value
         * @type {Object}
         * @property {number|Long} [value]
         * @memberof common
         */
        UInt64Value: {
          fields: {
            value: {
              type: "uint64",
              id: 1
            }
          }
        },
        /**
         * Properties of a google.protobuf.Int32Value message.
         * @interface IInt32Value
         * @type {Object}
         * @property {number} [value]
         * @memberof common
         */
        Int32Value: {
          fields: {
            value: {
              type: "int32",
              id: 1
            }
          }
        },
        /**
         * Properties of a google.protobuf.UInt32Value message.
         * @interface IUInt32Value
         * @type {Object}
         * @property {number} [value]
         * @memberof common
         */
        UInt32Value: {
          fields: {
            value: {
              type: "uint32",
              id: 1
            }
          }
        },
        /**
         * Properties of a google.protobuf.BoolValue message.
         * @interface IBoolValue
         * @type {Object}
         * @property {boolean} [value]
         * @memberof common
         */
        BoolValue: {
          fields: {
            value: {
              type: "bool",
              id: 1
            }
          }
        },
        /**
         * Properties of a google.protobuf.StringValue message.
         * @interface IStringValue
         * @type {Object}
         * @property {string} [value]
         * @memberof common
         */
        StringValue: {
          fields: {
            value: {
              type: "string",
              id: 1
            }
          }
        },
        /**
         * Properties of a google.protobuf.BytesValue message.
         * @interface IBytesValue
         * @type {Object}
         * @property {Uint8Array} [value]
         * @memberof common
         */
        BytesValue: {
          fields: {
            value: {
              type: "bytes",
              id: 1
            }
          }
        }
      });
      common("field_mask", {
        /**
         * Properties of a google.protobuf.FieldMask message.
         * @interface IDoubleValue
         * @type {Object}
         * @property {number} [value]
         * @memberof common
         */
        FieldMask: {
          fields: {
            paths: {
              rule: "repeated",
              type: "string",
              id: 1
            }
          }
        }
      });
      common.get = function get(file) {
        return common[file] || null;
      };
    }
  });

  // ../node_modules/protobufjs/src/index.js
  var require_src = __commonJS({
    "../node_modules/protobufjs/src/index.js"(exports2, module2) {
      "use strict";
      var protobuf2 = module2.exports = require_index_light();
      protobuf2.build = "full";
      protobuf2.tokenize = require_tokenize();
      protobuf2.parse = require_parse();
      protobuf2.common = require_common2();
      protobuf2.Root._configure(protobuf2.Type, protobuf2.parse, protobuf2.common);
    }
  });

  // ../node_modules/protobufjs/index.js
  var require_protobufjs = __commonJS({
    "../node_modules/protobufjs/index.js"(exports2, module2) {
      "use strict";
      module2.exports = require_src();
    }
  });

  // src/mobile.ts
  var mobile_exports = {};
  __export(mobile_exports, {
    connectedPeers: () => connectedPeers,
    isAvailable: () => isAvailable,
    send: () => send,
    setLogger: () => setLogger,
    setup: () => setup2
  });

  // ../node_modules/@waku/proto/dist/generated/message.js
  var message_exports = {};
  __export(message_exports, {
    RateLimitProof: () => RateLimitProof,
    WakuMessage: () => WakuMessage
  });

  // ../node_modules/uint8-varint/node_modules/uint8arrays/dist/src/alloc.js
  function allocUnsafe(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/uint8-varint/dist/src/index.js
  var N1 = Math.pow(2, 7);
  var N2 = Math.pow(2, 14);
  var N3 = Math.pow(2, 21);
  var N4 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var MSB = 128;
  var REST = 127;
  function encodingLength(value) {
    if (value < N1) {
      return 1;
    }
    if (value < N2) {
      return 2;
    }
    if (value < N3) {
      return 3;
    }
    if (value < N4) {
      return 4;
    }
    if (value < N5) {
      return 5;
    }
    if (value < N6) {
      return 6;
    }
    if (value < N7) {
      return 7;
    }
    if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {
      throw new RangeError("Could not encode varint");
    }
    return 8;
  }
  function encodeUint8Array(value, buf, offset = 0) {
    switch (encodingLength(value)) {
      case 8: {
        buf[offset++] = value & 255 | MSB;
        value /= 128;
      }
      case 7: {
        buf[offset++] = value & 255 | MSB;
        value /= 128;
      }
      case 6: {
        buf[offset++] = value & 255 | MSB;
        value /= 128;
      }
      case 5: {
        buf[offset++] = value & 255 | MSB;
        value /= 128;
      }
      case 4: {
        buf[offset++] = value & 255 | MSB;
        value >>>= 7;
      }
      case 3: {
        buf[offset++] = value & 255 | MSB;
        value >>>= 7;
      }
      case 2: {
        buf[offset++] = value & 255 | MSB;
        value >>>= 7;
      }
      case 1: {
        buf[offset++] = value & 255;
        value >>>= 7;
        break;
      }
      default:
        throw new Error("unreachable");
    }
    return buf;
  }
  function encodeUint8ArrayList(value, buf, offset = 0) {
    switch (encodingLength(value)) {
      case 8: {
        buf.set(offset++, value & 255 | MSB);
        value /= 128;
      }
      case 7: {
        buf.set(offset++, value & 255 | MSB);
        value /= 128;
      }
      case 6: {
        buf.set(offset++, value & 255 | MSB);
        value /= 128;
      }
      case 5: {
        buf.set(offset++, value & 255 | MSB);
        value /= 128;
      }
      case 4: {
        buf.set(offset++, value & 255 | MSB);
        value >>>= 7;
      }
      case 3: {
        buf.set(offset++, value & 255 | MSB);
        value >>>= 7;
      }
      case 2: {
        buf.set(offset++, value & 255 | MSB);
        value >>>= 7;
      }
      case 1: {
        buf.set(offset++, value & 255);
        value >>>= 7;
        break;
      }
      default:
        throw new Error("unreachable");
    }
    return buf;
  }
  function decodeUint8Array(buf, offset) {
    let b = buf[offset];
    let res = 0;
    res += b & REST;
    if (b < MSB) {
      return res;
    }
    b = buf[offset + 1];
    res += (b & REST) << 7;
    if (b < MSB) {
      return res;
    }
    b = buf[offset + 2];
    res += (b & REST) << 14;
    if (b < MSB) {
      return res;
    }
    b = buf[offset + 3];
    res += (b & REST) << 21;
    if (b < MSB) {
      return res;
    }
    b = buf[offset + 4];
    res += (b & REST) * N4;
    if (b < MSB) {
      return res;
    }
    b = buf[offset + 5];
    res += (b & REST) * N5;
    if (b < MSB) {
      return res;
    }
    b = buf[offset + 6];
    res += (b & REST) * N6;
    if (b < MSB) {
      return res;
    }
    b = buf[offset + 7];
    res += (b & REST) * N7;
    if (b < MSB) {
      return res;
    }
    throw new RangeError("Could not decode varint");
  }
  function decodeUint8ArrayList(buf, offset) {
    let b = buf.get(offset);
    let res = 0;
    res += b & REST;
    if (b < MSB) {
      return res;
    }
    b = buf.get(offset + 1);
    res += (b & REST) << 7;
    if (b < MSB) {
      return res;
    }
    b = buf.get(offset + 2);
    res += (b & REST) << 14;
    if (b < MSB) {
      return res;
    }
    b = buf.get(offset + 3);
    res += (b & REST) << 21;
    if (b < MSB) {
      return res;
    }
    b = buf.get(offset + 4);
    res += (b & REST) * N4;
    if (b < MSB) {
      return res;
    }
    b = buf.get(offset + 5);
    res += (b & REST) * N5;
    if (b < MSB) {
      return res;
    }
    b = buf.get(offset + 6);
    res += (b & REST) * N6;
    if (b < MSB) {
      return res;
    }
    b = buf.get(offset + 7);
    res += (b & REST) * N7;
    if (b < MSB) {
      return res;
    }
    throw new RangeError("Could not decode varint");
  }
  function encode(value, buf, offset = 0) {
    if (buf == null) {
      buf = allocUnsafe(encodingLength(value));
    }
    if (buf instanceof Uint8Array) {
      return encodeUint8Array(value, buf, offset);
    } else {
      return encodeUint8ArrayList(value, buf, offset);
    }
  }
  function decode(buf, offset = 0) {
    if (buf instanceof Uint8Array) {
      return decodeUint8Array(buf, offset);
    } else {
      return decodeUint8ArrayList(buf, offset);
    }
  }

  // ../node_modules/protons-runtime/dist/src/utils/float.js
  var f32 = new Float32Array([-0]);
  var f8b = new Uint8Array(f32.buffer);
  function writeFloatLE(val, buf, pos) {
    f32[0] = val;
    buf[pos] = f8b[0];
    buf[pos + 1] = f8b[1];
    buf[pos + 2] = f8b[2];
    buf[pos + 3] = f8b[3];
  }
  function readFloatLE(buf, pos) {
    f8b[0] = buf[pos];
    f8b[1] = buf[pos + 1];
    f8b[2] = buf[pos + 2];
    f8b[3] = buf[pos + 3];
    return f32[0];
  }
  var f64 = new Float64Array([-0]);
  var d8b = new Uint8Array(f64.buffer);
  function writeDoubleLE(val, buf, pos) {
    f64[0] = val;
    buf[pos] = d8b[0];
    buf[pos + 1] = d8b[1];
    buf[pos + 2] = d8b[2];
    buf[pos + 3] = d8b[3];
    buf[pos + 4] = d8b[4];
    buf[pos + 5] = d8b[5];
    buf[pos + 6] = d8b[6];
    buf[pos + 7] = d8b[7];
  }
  function readDoubleLE(buf, pos) {
    d8b[0] = buf[pos];
    d8b[1] = buf[pos + 1];
    d8b[2] = buf[pos + 2];
    d8b[3] = buf[pos + 3];
    d8b[4] = buf[pos + 4];
    d8b[5] = buf[pos + 5];
    d8b[6] = buf[pos + 6];
    d8b[7] = buf[pos + 7];
    return f64[0];
  }

  // ../node_modules/protons-runtime/dist/src/utils/longbits.js
  var MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
  var MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);
  var LongBits = class _LongBits {
    lo;
    hi;
    constructor(lo, hi) {
      this.lo = lo | 0;
      this.hi = hi | 0;
    }
    /**
     * Converts this long bits to a possibly unsafe JavaScript number
     */
    toNumber(unsigned = false) {
      if (!unsigned && this.hi >>> 31 > 0) {
        const lo = ~this.lo + 1 >>> 0;
        let hi = ~this.hi >>> 0;
        if (lo === 0) {
          hi = hi + 1 >>> 0;
        }
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    }
    /**
     * Converts this long bits to a bigint
     */
    toBigInt(unsigned = false) {
      if (unsigned) {
        return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
      }
      if (this.hi >>> 31 !== 0) {
        const lo = ~this.lo + 1 >>> 0;
        let hi = ~this.hi >>> 0;
        if (lo === 0) {
          hi = hi + 1 >>> 0;
        }
        return -(BigInt(lo) + (BigInt(hi) << 32n));
      }
      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
    }
    /**
     * Converts this long bits to a string
     */
    toString(unsigned = false) {
      return this.toBigInt(unsigned).toString();
    }
    /**
     * Zig-zag encodes this long bits
     */
    zzEncode() {
      const mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    }
    /**
     * Zig-zag decodes this long bits
     */
    zzDecode() {
      const mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    }
    /**
     * Calculates the length of this longbits when encoded as a varint.
     */
    length() {
      const part0 = this.lo;
      const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0;
      const part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    }
    /**
     * Constructs new long bits from the specified number
     */
    static fromBigInt(value) {
      if (value === 0n) {
        return zero;
      }
      if (value < MAX_SAFE_NUMBER_INTEGER && value > MIN_SAFE_NUMBER_INTEGER) {
        return this.fromNumber(Number(value));
      }
      const negative = value < 0n;
      if (negative) {
        value = -value;
      }
      let hi = value >> 32n;
      let lo = value - (hi << 32n);
      if (negative) {
        hi = ~hi | 0n;
        lo = ~lo | 0n;
        if (++lo > TWO_32) {
          lo = 0n;
          if (++hi > TWO_32) {
            hi = 0n;
          }
        }
      }
      return new _LongBits(Number(lo), Number(hi));
    }
    /**
     * Constructs new long bits from the specified number
     */
    static fromNumber(value) {
      if (value === 0) {
        return zero;
      }
      const sign3 = value < 0;
      if (sign3) {
        value = -value;
      }
      let lo = value >>> 0;
      let hi = (value - lo) / 4294967296 >>> 0;
      if (sign3) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295) {
            hi = 0;
          }
        }
      }
      return new _LongBits(lo, hi);
    }
    /**
     * Constructs new long bits from a number, long or string
     */
    static from(value) {
      if (typeof value === "number") {
        return _LongBits.fromNumber(value);
      }
      if (typeof value === "bigint") {
        return _LongBits.fromBigInt(value);
      }
      if (typeof value === "string") {
        return _LongBits.fromBigInt(BigInt(value));
      }
      return value.low != null || value.high != null ? new _LongBits(value.low >>> 0, value.high >>> 0) : zero;
    }
  };
  var zero = new LongBits(0, 0);
  zero.toBigInt = function() {
    return 0n;
  };
  zero.zzEncode = zero.zzDecode = function() {
    return this;
  };
  zero.length = function() {
    return 1;
  };
  var TWO_32 = 4294967296n;

  // ../node_modules/protons-runtime/dist/src/utils/utf8.js
  function length(string19) {
    let len = 0;
    let c = 0;
    for (let i = 0; i < string19.length; ++i) {
      c = string19.charCodeAt(i);
      if (c < 128) {
        len += 1;
      } else if (c < 2048) {
        len += 2;
      } else if ((c & 64512) === 55296 && (string19.charCodeAt(i + 1) & 64512) === 56320) {
        ++i;
        len += 4;
      } else {
        len += 3;
      }
    }
    return len;
  }
  function read(buffer, start2, end) {
    const len = end - start2;
    if (len < 1) {
      return "";
    }
    let parts;
    const chunk = [];
    let i = 0;
    let t;
    while (start2 < end) {
      t = buffer[start2++];
      if (t < 128) {
        chunk[i++] = t;
      } else if (t > 191 && t < 224) {
        chunk[i++] = (t & 31) << 6 | buffer[start2++] & 63;
      } else if (t > 239 && t < 365) {
        t = ((t & 7) << 18 | (buffer[start2++] & 63) << 12 | (buffer[start2++] & 63) << 6 | buffer[start2++] & 63) - 65536;
        chunk[i++] = 55296 + (t >> 10);
        chunk[i++] = 56320 + (t & 1023);
      } else {
        chunk[i++] = (t & 15) << 12 | (buffer[start2++] & 63) << 6 | buffer[start2++] & 63;
      }
      if (i > 8191) {
        (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i = 0;
      }
    }
    if (parts != null) {
      if (i > 0) {
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
      }
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
  }
  function write(string19, buffer, offset) {
    const start2 = offset;
    let c1;
    let c2;
    for (let i = 0; i < string19.length; ++i) {
      c1 = string19.charCodeAt(i);
      if (c1 < 128) {
        buffer[offset++] = c1;
      } else if (c1 < 2048) {
        buffer[offset++] = c1 >> 6 | 192;
        buffer[offset++] = c1 & 63 | 128;
      } else if ((c1 & 64512) === 55296 && ((c2 = string19.charCodeAt(i + 1)) & 64512) === 56320) {
        c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
        ++i;
        buffer[offset++] = c1 >> 18 | 240;
        buffer[offset++] = c1 >> 12 & 63 | 128;
        buffer[offset++] = c1 >> 6 & 63 | 128;
        buffer[offset++] = c1 & 63 | 128;
      } else {
        buffer[offset++] = c1 >> 12 | 224;
        buffer[offset++] = c1 >> 6 & 63 | 128;
        buffer[offset++] = c1 & 63 | 128;
      }
    }
    return offset - start2;
  }

  // ../node_modules/protons-runtime/dist/src/utils/reader.js
  function indexOutOfRange(reader, writeLength) {
    return RangeError(`index out of range: ${reader.pos} + ${writeLength ?? 1} > ${reader.len}`);
  }
  function readFixed32End(buf, end) {
    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
  }
  var Uint8ArrayReader = class {
    buf;
    pos;
    len;
    _slice = Uint8Array.prototype.subarray;
    constructor(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    /**
     * Reads a varint as an unsigned 32 bit value
     */
    uint32() {
      let value = 4294967295;
      value = (this.buf[this.pos] & 127) >>> 0;
      if (this.buf[this.pos++] < 128) {
        return value;
      }
      value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
      if (this.buf[this.pos++] < 128) {
        return value;
      }
      value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
      if (this.buf[this.pos++] < 128) {
        return value;
      }
      value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
      if (this.buf[this.pos++] < 128) {
        return value;
      }
      value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
      if (this.buf[this.pos++] < 128) {
        return value;
      }
      if ((this.pos += 5) > this.len) {
        this.pos = this.len;
        throw indexOutOfRange(this, 10);
      }
      return value;
    }
    /**
     * Reads a varint as a signed 32 bit value
     */
    int32() {
      return this.uint32() | 0;
    }
    /**
     * Reads a zig-zag encoded varint as a signed 32 bit value
     */
    sint32() {
      const value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    }
    /**
     * Reads a varint as a boolean
     */
    bool() {
      return this.uint32() !== 0;
    }
    /**
     * Reads fixed 32 bits as an unsigned 32 bit integer
     */
    fixed32() {
      if (this.pos + 4 > this.len) {
        throw indexOutOfRange(this, 4);
      }
      const res = readFixed32End(this.buf, this.pos += 4);
      return res;
    }
    /**
     * Reads fixed 32 bits as a signed 32 bit integer
     */
    sfixed32() {
      if (this.pos + 4 > this.len) {
        throw indexOutOfRange(this, 4);
      }
      const res = readFixed32End(this.buf, this.pos += 4) | 0;
      return res;
    }
    /**
     * Reads a float (32 bit) as a number
     */
    float() {
      if (this.pos + 4 > this.len) {
        throw indexOutOfRange(this, 4);
      }
      const value = readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    }
    /**
     * Reads a double (64 bit float) as a number
     */
    double() {
      if (this.pos + 8 > this.len) {
        throw indexOutOfRange(this, 4);
      }
      const value = readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    }
    /**
     * Reads a sequence of bytes preceded by its length as a varint
     */
    bytes() {
      const length21 = this.uint32();
      const start2 = this.pos;
      const end = this.pos + length21;
      if (end > this.len) {
        throw indexOutOfRange(this, length21);
      }
      this.pos += length21;
      return start2 === end ? new Uint8Array(0) : this.buf.subarray(start2, end);
    }
    /**
     * Reads a string preceded by its byte length as a varint
     */
    string() {
      const bytes2 = this.bytes();
      return read(bytes2, 0, bytes2.length);
    }
    /**
     * Skips the specified number of bytes if specified, otherwise skips a varint
     */
    skip(length21) {
      if (typeof length21 === "number") {
        if (this.pos + length21 > this.len) {
          throw indexOutOfRange(this, length21);
        }
        this.pos += length21;
      } else {
        do {
          if (this.pos >= this.len) {
            throw indexOutOfRange(this);
          }
        } while ((this.buf[this.pos++] & 128) !== 0);
      }
      return this;
    }
    /**
     * Skips the next element of the specified wire type
     */
    skipType(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        /* istanbul ignore next */
        default:
          throw Error(`invalid wire type ${wireType} at offset ${this.pos}`);
      }
      return this;
    }
    readLongVarint() {
      const bits = new LongBits(0, 0);
      let i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128) {
            return bits;
          }
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits;
        }
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len) {
            throw indexOutOfRange(this);
          }
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128) {
            return bits;
          }
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128) {
            return bits;
          }
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len) {
            throw indexOutOfRange(this);
          }
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128) {
            return bits;
          }
        }
      }
      throw Error("invalid varint encoding");
    }
    readFixed64() {
      if (this.pos + 8 > this.len) {
        throw indexOutOfRange(this, 8);
      }
      const lo = readFixed32End(this.buf, this.pos += 4);
      const hi = readFixed32End(this.buf, this.pos += 4);
      return new LongBits(lo, hi);
    }
    /**
     * Reads a varint as a signed 64 bit value
     */
    int64() {
      return this.readLongVarint().toBigInt();
    }
    /**
     * Reads a varint as a signed 64 bit value returned as a possibly unsafe
     * JavaScript number
     */
    int64Number() {
      return this.readLongVarint().toNumber();
    }
    /**
     * Reads a varint as a signed 64 bit value returned as a string
     */
    int64String() {
      return this.readLongVarint().toString();
    }
    /**
     * Reads a varint as an unsigned 64 bit value
     */
    uint64() {
      return this.readLongVarint().toBigInt(true);
    }
    /**
     * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe
     * JavaScript number
     */
    uint64Number() {
      const value = decodeUint8Array(this.buf, this.pos);
      this.pos += encodingLength(value);
      return value;
    }
    /**
     * Reads a varint as an unsigned 64 bit value returned as a string
     */
    uint64String() {
      return this.readLongVarint().toString(true);
    }
    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value
     */
    sint64() {
      return this.readLongVarint().zzDecode().toBigInt();
    }
    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
     * possibly unsafe JavaScript number
     */
    sint64Number() {
      return this.readLongVarint().zzDecode().toNumber();
    }
    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
     * string
     */
    sint64String() {
      return this.readLongVarint().zzDecode().toString();
    }
    /**
     * Reads fixed 64 bits
     */
    fixed64() {
      return this.readFixed64().toBigInt();
    }
    /**
     * Reads fixed 64 bits returned as a possibly unsafe JavaScript number
     */
    fixed64Number() {
      return this.readFixed64().toNumber();
    }
    /**
     * Reads fixed 64 bits returned as a string
     */
    fixed64String() {
      return this.readFixed64().toString();
    }
    /**
     * Reads zig-zag encoded fixed 64 bits
     */
    sfixed64() {
      return this.readFixed64().toBigInt();
    }
    /**
     * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe
     * JavaScript number
     */
    sfixed64Number() {
      return this.readFixed64().toNumber();
    }
    /**
     * Reads zig-zag encoded fixed 64 bits returned as a string
     */
    sfixed64String() {
      return this.readFixed64().toString();
    }
  };
  function createReader(buf) {
    return new Uint8ArrayReader(buf instanceof Uint8Array ? buf : buf.subarray());
  }

  // ../node_modules/protons-runtime/dist/src/decode.js
  function decodeMessage(buf, codec, opts) {
    const reader = createReader(buf);
    return codec.decode(reader, void 0, opts);
  }

  // ../node_modules/protons-runtime/node_modules/uint8arrays/dist/src/alloc.js
  function allocUnsafe2(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports = {};
  __export(base10_exports, {
    base10: () => base10
  });

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/bytes.js
  var empty = new Uint8Array(0);
  function equals(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function fromString(str) {
    return new TextEncoder().encode(str);
  }
  function toString(b) {
    return new TextDecoder().decode(b);
  }

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/vendor/base-x.js
  function base(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src = base;
  var _brrp__multiformats_scope_baseX = src;
  var base_x_default = _brrp__multiformats_scope_baseX;

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base.js
  var Encoder = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or(this, decoder);
    }
  };
  var ComposedDecoder = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or(left, right) {
    return new ComposedDecoder({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder(name19, prefix, baseEncode);
      this.decoder = new Decoder(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec(name19, prefix, encode79, decode99);
  }
  function baseX({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default(alphabet18, name19);
    return from({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce(decode99(text))
    });
  }
  function decode2(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode2(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc4648({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx(alphabet18);
    return from({
      prefix,
      name: name19,
      encode(input) {
        return encode2(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode2(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base10.js
  var base10 = baseX({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports = {};
  __export(base16_exports, {
    base16: () => base16,
    base16upper: () => base16upper
  });
  var base16 = rfc4648({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper = rfc4648({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports = {};
  __export(base2_exports, {
    base2: () => base2
  });
  var base2 = rfc4648({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports = {};
  __export(base256emoji_exports, {
    base256emoji: () => base256emoji
  });
  var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars = alphabet.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
  }, []);
  function encode3(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars[c];
      return p;
    }, "");
  }
  function decode3(str) {
    const byts = [];
    for (const char of str) {
      const codePoint = char.codePointAt(0);
      if (codePoint == null) {
        throw new Error(`Invalid character: ${char}`);
      }
      const byt = alphabetCharsToBytes[codePoint];
      if (byt == null) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji = from({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode3,
    decode: decode3
  });

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports = {};
  __export(base32_exports, {
    base32: () => base32,
    base32hex: () => base32hex,
    base32hexpad: () => base32hexpad,
    base32hexpadupper: () => base32hexpadupper,
    base32hexupper: () => base32hexupper,
    base32pad: () => base32pad,
    base32padupper: () => base32padupper,
    base32upper: () => base32upper,
    base32z: () => base32z
  });
  var base32 = rfc4648({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper = rfc4648({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad = rfc4648({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper = rfc4648({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex = rfc4648({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper = rfc4648({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad = rfc4648({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper = rfc4648({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z = rfc4648({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports = {};
  __export(base36_exports, {
    base36: () => base36,
    base36upper: () => base36upper
  });
  var base36 = baseX({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper = baseX({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports = {};
  __export(base58_exports, {
    base58btc: () => base58btc,
    base58flickr: () => base58flickr
  });
  var base58btc = baseX({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr = baseX({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports = {};
  __export(base64_exports, {
    base64: () => base64,
    base64pad: () => base64pad,
    base64url: () => base64url,
    base64urlpad: () => base64urlpad
  });
  var base64 = rfc4648({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad = rfc4648({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url = rfc4648({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad = rfc4648({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports = {};
  __export(base8_exports, {
    base8: () => base8
  });
  var base8 = rfc4648({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports = {};
  __export(identity_exports, {
    identity: () => identity
  });
  var identity = from({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString(buf),
    decode: (str) => fromString(str)
  });

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/codecs/json.js
  var textEncoder = new TextEncoder();
  var textDecoder = new TextDecoder();

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports2 = {};
  __export(identity_exports2, {
    identity: () => identity2
  });

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_1 = encode4;
  var MSB2 = 128;
  var REST2 = 127;
  var MSBALL = ~REST2;
  var INT = Math.pow(2, 31);
  function encode4(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB2;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB2;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode4.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode4 = read2;
  var MSB$1 = 128;
  var REST$1 = 127;
  function read2(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read2.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1);
    read2.bytes = counter - offset;
    return res;
  }
  var N12 = Math.pow(2, 7);
  var N22 = Math.pow(2, 14);
  var N32 = Math.pow(2, 21);
  var N42 = Math.pow(2, 28);
  var N52 = Math.pow(2, 35);
  var N62 = Math.pow(2, 42);
  var N72 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);
  var length2 = function(value) {
    return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
  };
  var varint = {
    encode: encode_1,
    decode: decode4,
    encodingLength: length2
  };
  var _brrp_varint = varint;
  var varint_default = _brrp_varint;

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/varint.js
  function decode5(data, offset = 0) {
    const code18 = varint_default.decode(data, offset);
    return [code18, varint_default.decode.bytes];
  }
  function encodeTo(int, target, offset = 0) {
    varint_default.encode(int, target, offset);
    return target;
  }
  function encodingLength2(int) {
    return varint_default.encodingLength(int);
  }

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/hashes/digest.js
  function create(code18, digest18) {
    const size = digest18.byteLength;
    const sizeOffset = encodingLength2(code18);
    const digestOffset = sizeOffset + encodingLength2(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo(code18, bytes2, 0);
    encodeTo(size, bytes2, sizeOffset);
    bytes2.set(digest18, digestOffset);
    return new Digest(code18, size, digest18, bytes2);
  }
  function decode6(multihash) {
    const bytes2 = coerce(multihash);
    const [code18, sizeOffset] = decode5(bytes2);
    const [size, digestOffset] = decode5(bytes2.subarray(sizeOffset));
    const digest18 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest18.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest(code18, size, digest18, bytes2);
  }
  function equals2(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals(a.bytes, data.bytes);
    }
  }
  var Digest = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code18, size, digest18, bytes2) {
      this.code = code18;
      this.size = size;
      this.digest = digest18;
      this.bytes = bytes2;
    }
  };

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/hashes/identity.js
  var code = 0;
  var name = "identity";
  var encode5 = coerce;
  function digest(input) {
    return create(code, encode5(input));
  }
  var identity2 = { code, name, encode: encode5, digest };

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports = {};
  __export(sha2_browser_exports, {
    sha256: () => sha256,
    sha512: () => sha512
  });

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/hashes/hasher.js
  function from2({ name: name19, code: code18, encode: encode79 }) {
    return new Hasher(name19, code18, encode79);
  }
  var Hasher = class {
    name;
    code;
    encode;
    constructor(name19, code18, encode79) {
      this.name = name19;
      this.code = code18;
      this.encode = encode79;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create(this.code, result) : result.then((digest18) => create(this.code, digest18));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  function sha(name19) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name19, data));
  }
  var sha256 = from2({
    name: "sha2-256",
    code: 18,
    encode: sha("SHA-256")
  });
  var sha512 = from2({
    name: "sha2-512",
    code: 19,
    encode: sha("SHA-512")
  });

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/cid.js
  function format(link, base37) {
    const { bytes: bytes2, version: version5 } = link;
    switch (version5) {
      case 0:
        return toStringV0(bytes2, baseCache(link), base37 ?? base58btc.encoder);
      default:
        return toStringV1(bytes2, baseCache(link), base37 ?? base32.encoder);
    }
  }
  var cache = /* @__PURE__ */ new WeakMap();
  function baseCache(cid) {
    const baseCache19 = cache.get(cid);
    if (baseCache19 == null) {
      const baseCache20 = /* @__PURE__ */ new Map();
      cache.set(cid, baseCache20);
      return baseCache20;
    }
    return baseCache19;
  }
  var CID = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version5, code18, multihash, bytes2) {
      this.code = code18;
      this.version = version5;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code18, multihash } = this;
          if (code18 !== DAG_PB_CODE) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code18, digest: digest18 } = this.multihash;
          const multihash = create(code18, digest18);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals2(self2.multihash, unknown.multihash);
    }
    toString(base37) {
      return format(this, base37);
    }
    toJSON() {
      return { "/": format(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version5, code: code18, multihash, bytes: bytes2 } = value;
        return new _CID(version5, code18, multihash, bytes2 ?? encodeCID(version5, code18, multihash.bytes));
      } else if (value[cidSymbol] === true) {
        const { version: version5, multihash, code: code18 } = value;
        const digest18 = decode6(multihash);
        return _CID.create(version5, code18, digest18);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version5, code18, digest18) {
      if (typeof code18 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest18.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version5) {
        case 0: {
          if (code18 !== DAG_PB_CODE) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
          } else {
            return new _CID(version5, code18, digest18, digest18.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID(version5, code18, digest18.bytes);
          return new _CID(version5, code18, digest18, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest18) {
      return _CID.create(0, DAG_PB_CODE, digest18);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code18, digest18) {
      return _CID.create(1, code18, digest18);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes2) {
      const [cid, remainder] = _CID.decodeFirst(bytes2);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes2) {
      const specs = _CID.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest18 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest18) : _CID.createV1(specs.codec, digest18);
      return [cid, bytes2.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length21] = decode5(initialBytes.subarray(offset));
        offset += length21;
        return i;
      };
      let version5 = next();
      let codec = DAG_PB_CODE;
      if (version5 === 18) {
        version5 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version5 !== 0 && version5 !== 1) {
        throw new RangeError(`Invalid CID version ${version5}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version5, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base37) {
      const [prefix, bytes2] = parseCIDtoBytes(source, base37);
      const cid = _CID.decode(bytes2);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes(source, base37) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base37 ?? base58btc;
        return [
          base58btc.prefix,
          decoder.decode(`${base58btc.prefix}${source}`)
        ];
      }
      case base58btc.prefix: {
        const decoder = base37 ?? base58btc;
        return [base58btc.prefix, decoder.decode(source)];
      }
      case base32.prefix: {
        const decoder = base37 ?? base32;
        return [base32.prefix, decoder.decode(source)];
      }
      case base36.prefix: {
        const decoder = base37 ?? base36;
        return [base36.prefix, decoder.decode(source)];
      }
      default: {
        if (base37 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base37.decode(source)];
      }
    }
  }
  function toStringV0(bytes2, cache20, base37) {
    const { prefix } = base37;
    if (prefix !== base58btc.prefix) {
      throw Error(`Cannot string encode V0 in ${base37.name} encoding`);
    }
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2).slice(1);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV1(bytes2, cache20, base37) {
    const { prefix } = base37;
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE = 112;
  var SHA_256_CODE = 18;
  function encodeCID(version5, code18, multihash) {
    const codeOffset = encodingLength2(version5);
    const hashOffset = codeOffset + encodingLength2(code18);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo(version5, bytes2, 0);
    encodeTo(code18, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  }
  var cidSymbol = Symbol.for("@ipld/js-cid/CID");

  // ../node_modules/protons-runtime/node_modules/multiformats/dist/src/basics.js
  var bases = { ...identity_exports, ...base2_exports, ...base8_exports, ...base10_exports, ...base16_exports, ...base32_exports, ...base36_exports, ...base58_exports, ...base64_exports, ...base256emoji_exports };
  var hashes = { ...sha2_browser_exports, ...identity_exports2 };

  // ../node_modules/protons-runtime/node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec(name19, prefix, encode79, decode99) {
    return {
      name: name19,
      prefix,
      encoder: {
        name: name19,
        prefix,
        encode: encode79
      },
      decoder: {
        decode: decode99
      }
    };
  }
  var string = createCodec("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder3 = new TextEncoder();
    return encoder3.encode(str.substring(1));
  });
  var ascii = createCodec("ascii", "a", (buf) => {
    let string19 = "a";
    for (let i = 0; i < buf.length; i++) {
      string19 += String.fromCharCode(buf[i]);
    }
    return string19;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe2(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  var BASES = {
    utf8: string,
    "utf-8": string,
    hex: bases.base16,
    latin1: ascii,
    ascii,
    binary: ascii,
    ...bases
  };
  var bases_default = BASES;

  // ../node_modules/protons-runtime/node_modules/uint8arrays/dist/src/from-string.js
  function fromString2(string19, encoding = "utf8") {
    const base37 = bases_default[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.decoder.decode(`${base37.prefix}${string19}`);
  }

  // ../node_modules/protons-runtime/dist/src/utils/pool.js
  function pool(size) {
    const SIZE = size ?? 8192;
    const MAX = SIZE >>> 1;
    let slab;
    let offset = SIZE;
    return function poolAlloc(size2) {
      if (size2 < 1 || size2 > MAX) {
        return allocUnsafe2(size2);
      }
      if (offset + size2 > SIZE) {
        slab = allocUnsafe2(SIZE);
        offset = 0;
      }
      const buf = slab.subarray(offset, offset += size2);
      if ((offset & 7) !== 0) {
        offset = (offset | 7) + 1;
      }
      return buf;
    };
  }

  // ../node_modules/protons-runtime/dist/src/utils/writer.js
  var Op = class {
    /**
     * Function to call
     */
    fn;
    /**
     * Value byte length
     */
    len;
    /**
     * Next operation
     */
    next;
    /**
     * Value to write
     */
    val;
    constructor(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
  };
  function noop() {
  }
  var State = class {
    /**
     * Current head
     */
    head;
    /**
     * Current tail
     */
    tail;
    /**
     * Current buffer length
     */
    len;
    /**
     * Next state
     */
    next;
    constructor(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
  };
  var bufferPool = pool();
  function alloc(size) {
    if (globalThis.Buffer != null) {
      return allocUnsafe2(size);
    }
    return bufferPool(size);
  }
  var Uint8ArrayWriter = class {
    /**
     * Current length
     */
    len;
    /**
     * Operations head
     */
    head;
    /**
     * Operations tail
     */
    tail;
    /**
     * Linked forked states
     */
    states;
    constructor() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    /**
     * Pushes a new operation to the queue
     */
    _push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    }
    /**
     * Writes an unsigned 32 bit value as a varint
     */
    uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
      return this;
    }
    /**
     * Writes a signed 32 bit value as a varint`
     */
    int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    }
    /**
     * Writes a 32 bit value as a varint, zig-zag encoded
     */
    sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    }
    /**
     * Writes an unsigned 64 bit value as a varint
     */
    uint64(value) {
      const bits = LongBits.fromBigInt(value);
      return this._push(writeVarint64, bits.length(), bits);
    }
    /**
     * Writes an unsigned 64 bit value as a varint
     */
    uint64Number(value) {
      return this._push(encodeUint8Array, encodingLength(value), value);
    }
    /**
     * Writes an unsigned 64 bit value as a varint
     */
    uint64String(value) {
      return this.uint64(BigInt(value));
    }
    /**
     * Writes a signed 64 bit value as a varint
     */
    int64(value) {
      return this.uint64(value);
    }
    /**
     * Writes a signed 64 bit value as a varint
     */
    int64Number(value) {
      return this.uint64Number(value);
    }
    /**
     * Writes a signed 64 bit value as a varint
     */
    int64String(value) {
      return this.uint64String(value);
    }
    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded
     */
    sint64(value) {
      const bits = LongBits.fromBigInt(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    }
    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded
     */
    sint64Number(value) {
      const bits = LongBits.fromNumber(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    }
    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded
     */
    sint64String(value) {
      return this.sint64(BigInt(value));
    }
    /**
     * Writes a boolish value as a varint
     */
    bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    }
    /**
     * Writes an unsigned 32 bit value as fixed 32 bits
     */
    fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    }
    /**
     * Writes a signed 32 bit value as fixed 32 bits
     */
    sfixed32(value) {
      return this.fixed32(value);
    }
    /**
     * Writes an unsigned 64 bit value as fixed 64 bits
     */
    fixed64(value) {
      const bits = LongBits.fromBigInt(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    }
    /**
     * Writes an unsigned 64 bit value as fixed 64 bits
     */
    fixed64Number(value) {
      const bits = LongBits.fromNumber(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    }
    /**
     * Writes an unsigned 64 bit value as fixed 64 bits
     */
    fixed64String(value) {
      return this.fixed64(BigInt(value));
    }
    /**
     * Writes a signed 64 bit value as fixed 64 bits
     */
    sfixed64(value) {
      return this.fixed64(value);
    }
    /**
     * Writes a signed 64 bit value as fixed 64 bits
     */
    sfixed64Number(value) {
      return this.fixed64Number(value);
    }
    /**
     * Writes a signed 64 bit value as fixed 64 bits
     */
    sfixed64String(value) {
      return this.fixed64String(value);
    }
    /**
     * Writes a float (32 bit)
     */
    float(value) {
      return this._push(writeFloatLE, 4, value);
    }
    /**
     * Writes a double (64 bit float).
     *
     * @function
     * @param {number} value - Value to write
     * @returns {Writer} `this`
     */
    double(value) {
      return this._push(writeDoubleLE, 8, value);
    }
    /**
     * Writes a sequence of bytes
     */
    bytes(value) {
      const len = value.length >>> 0;
      if (len === 0) {
        return this._push(writeByte, 1, 0);
      }
      return this.uint32(len)._push(writeBytes, len, value);
    }
    /**
     * Writes a string
     */
    string(value) {
      const len = length(value);
      return len !== 0 ? this.uint32(len)._push(write, len, value) : this._push(writeByte, 1, 0);
    }
    /**
     * Forks this writer's state by pushing it to a stack.
     * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
     */
    fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    }
    /**
     * Resets this instance to the last state
     */
    reset() {
      if (this.states != null) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    }
    /**
     * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
     */
    ldelim() {
      const head = this.head;
      const tail = this.tail;
      const len = this.len;
      this.reset().uint32(len);
      if (len !== 0) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    }
    /**
     * Finishes the write operation
     */
    finish() {
      let head = this.head.next;
      const buf = alloc(this.len);
      let pos = 0;
      while (head != null) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    }
  };
  function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
  }
  function writeVarint32(val, buf, pos) {
    while (val > 127) {
      buf[pos++] = val & 127 | 128;
      val >>>= 7;
    }
    buf[pos] = val;
  }
  var VarintOp = class extends Op {
    next;
    constructor(len, val) {
      super(writeVarint32, len, val);
      this.next = void 0;
    }
  };
  function writeVarint64(val, buf, pos) {
    while (val.hi !== 0) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
      val.hi >>>= 7;
    }
    while (val.lo > 127) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
  }
  function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  function writeBytes(val, buf, pos) {
    buf.set(val, pos);
  }
  if (globalThis.Buffer != null) {
    Uint8ArrayWriter.prototype.bytes = function(value) {
      const len = value.length >>> 0;
      this.uint32(len);
      if (len > 0) {
        this._push(writeBytesBuffer, len, value);
      }
      return this;
    };
    Uint8ArrayWriter.prototype.string = function(value) {
      const len = globalThis.Buffer.byteLength(value);
      this.uint32(len);
      if (len > 0) {
        this._push(writeStringBuffer, len, value);
      }
      return this;
    };
  }
  function writeBytesBuffer(val, buf, pos) {
    buf.set(val, pos);
  }
  function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) {
      write(val, buf, pos);
    } else if (buf.utf8Write != null) {
      buf.utf8Write(val, pos);
    } else {
      buf.set(fromString2(val), pos);
    }
  }
  function createWriter() {
    return new Uint8ArrayWriter();
  }

  // ../node_modules/protons-runtime/dist/src/encode.js
  function encodeMessage(message2, codec) {
    const w2 = createWriter();
    codec.encode(message2, w2, {
      lengthDelimited: false
    });
    return w2.finish();
  }

  // ../node_modules/protons-runtime/dist/src/codec.js
  var CODEC_TYPES;
  (function(CODEC_TYPES2) {
    CODEC_TYPES2[CODEC_TYPES2["VARINT"] = 0] = "VARINT";
    CODEC_TYPES2[CODEC_TYPES2["BIT64"] = 1] = "BIT64";
    CODEC_TYPES2[CODEC_TYPES2["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
    CODEC_TYPES2[CODEC_TYPES2["START_GROUP"] = 3] = "START_GROUP";
    CODEC_TYPES2[CODEC_TYPES2["END_GROUP"] = 4] = "END_GROUP";
    CODEC_TYPES2[CODEC_TYPES2["BIT32"] = 5] = "BIT32";
  })(CODEC_TYPES || (CODEC_TYPES = {}));
  function createCodec2(name19, type, encode79, decode99) {
    return {
      name: name19,
      type,
      encode: encode79,
      decode: decode99
    };
  }

  // ../node_modules/protons-runtime/dist/src/codecs/enum.js
  function enumeration(v) {
    function findValue(val) {
      if (v[val.toString()] == null) {
        throw new Error("Invalid enum value");
      }
      return v[val];
    }
    const encode79 = function enumEncode(val, writer) {
      const enumValue = findValue(val);
      writer.int32(enumValue);
    };
    const decode99 = function enumDecode(reader) {
      const val = reader.int32();
      return findValue(val);
    };
    return createCodec2("enum", CODEC_TYPES.VARINT, encode79, decode99);
  }

  // ../node_modules/protons-runtime/dist/src/codecs/message.js
  function message(encode79, decode99) {
    return createCodec2("message", CODEC_TYPES.LENGTH_DELIMITED, encode79, decode99);
  }

  // ../node_modules/protons-runtime/dist/src/index.js
  var MaxLengthError = class extends Error {
    /**
     * This will be removed in a future release
     *
     * @deprecated use the `.name` property instead
     */
    code = "ERR_MAX_LENGTH";
    name = "MaxLengthError";
  };
  var MaxSizeError = class extends Error {
    /**
     * This will be removed in a future release
     *
     * @deprecated use the `.name` property instead
     */
    code = "ERR_MAX_SIZE";
    name = "MaxSizeError";
  };

  // ../node_modules/uint8arrays/esm/src/util/as-uint8array.js
  function asUint8Array(buf) {
    if (globalThis.Buffer != null) {
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }
    return buf;
  }

  // ../node_modules/uint8arrays/esm/src/alloc.js
  function alloc2(size = 0) {
    if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {
      return asUint8Array(globalThis.Buffer.alloc(size));
    }
    return new Uint8Array(size);
  }

  // ../node_modules/@waku/proto/dist/generated/message.js
  var RateLimitProof;
  (function(RateLimitProof6) {
    let _codec;
    RateLimitProof6.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.proof != null && obj.proof.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.proof);
          }
          if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
            w2.uint32(18);
            w2.bytes(obj.merkleRoot);
          }
          if (obj.epoch != null && obj.epoch.byteLength > 0) {
            w2.uint32(26);
            w2.bytes(obj.epoch);
          }
          if (obj.shareX != null && obj.shareX.byteLength > 0) {
            w2.uint32(34);
            w2.bytes(obj.shareX);
          }
          if (obj.shareY != null && obj.shareY.byteLength > 0) {
            w2.uint32(42);
            w2.bytes(obj.shareY);
          }
          if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
            w2.uint32(50);
            w2.bytes(obj.nullifier);
          }
          if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
            w2.uint32(58);
            w2.bytes(obj.rlnIdentifier);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            proof: alloc2(0),
            merkleRoot: alloc2(0),
            epoch: alloc2(0),
            shareX: alloc2(0),
            shareY: alloc2(0),
            nullifier: alloc2(0),
            rlnIdentifier: alloc2(0)
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.proof = reader.bytes();
                break;
              }
              case 2: {
                obj.merkleRoot = reader.bytes();
                break;
              }
              case 3: {
                obj.epoch = reader.bytes();
                break;
              }
              case 4: {
                obj.shareX = reader.bytes();
                break;
              }
              case 5: {
                obj.shareY = reader.bytes();
                break;
              }
              case 6: {
                obj.nullifier = reader.bytes();
                break;
              }
              case 7: {
                obj.rlnIdentifier = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    RateLimitProof6.encode = (obj) => {
      return encodeMessage(obj, RateLimitProof6.codec());
    };
    RateLimitProof6.decode = (buf, opts) => {
      return decodeMessage(buf, RateLimitProof6.codec(), opts);
    };
  })(RateLimitProof || (RateLimitProof = {}));
  var WakuMessage;
  (function(WakuMessage6) {
    let _codec;
    WakuMessage6.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.payload != null && obj.payload.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.payload);
          }
          if (obj.contentTopic != null && obj.contentTopic !== "") {
            w2.uint32(18);
            w2.string(obj.contentTopic);
          }
          if (obj.version != null) {
            w2.uint32(24);
            w2.uint32(obj.version);
          }
          if (obj.timestamp != null) {
            w2.uint32(80);
            w2.sint64(obj.timestamp);
          }
          if (obj.meta != null) {
            w2.uint32(90);
            w2.bytes(obj.meta);
          }
          if (obj.rateLimitProof != null) {
            w2.uint32(170);
            RateLimitProof.codec().encode(obj.rateLimitProof, w2);
          }
          if (obj.ephemeral != null) {
            w2.uint32(248);
            w2.bool(obj.ephemeral);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            payload: alloc2(0),
            contentTopic: ""
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.payload = reader.bytes();
                break;
              }
              case 2: {
                obj.contentTopic = reader.string();
                break;
              }
              case 3: {
                obj.version = reader.uint32();
                break;
              }
              case 10: {
                obj.timestamp = reader.sint64();
                break;
              }
              case 11: {
                obj.meta = reader.bytes();
                break;
              }
              case 21: {
                obj.rateLimitProof = RateLimitProof.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.rateLimitProof
                });
                break;
              }
              case 31: {
                obj.ephemeral = reader.bool();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    WakuMessage6.encode = (obj) => {
      return encodeMessage(obj, WakuMessage6.codec());
    };
    WakuMessage6.decode = (buf, opts) => {
      return decodeMessage(buf, WakuMessage6.codec(), opts);
    };
  })(WakuMessage || (WakuMessage = {}));

  // ../node_modules/@waku/proto/dist/generated/filter.js
  var FilterRequest;
  (function(FilterRequest2) {
    let ContentFilter;
    (function(ContentFilter2) {
      let _codec2;
      ContentFilter2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w2, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w2.fork();
            }
            if (obj.contentTopic != null && obj.contentTopic !== "") {
              w2.uint32(10);
              w2.string(obj.contentTopic);
            }
            if (opts.lengthDelimited !== false) {
              w2.ldelim();
            }
          }, (reader, length21, opts = {}) => {
            const obj = {
              contentTopic: ""
            };
            const end = length21 == null ? reader.len : reader.pos + length21;
            while (reader.pos < end) {
              const tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  obj.contentTopic = reader.string();
                  break;
                }
                default: {
                  reader.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      ContentFilter2.encode = (obj) => {
        return encodeMessage(obj, ContentFilter2.codec());
      };
      ContentFilter2.decode = (buf, opts) => {
        return decodeMessage(buf, ContentFilter2.codec(), opts);
      };
    })(ContentFilter = FilterRequest2.ContentFilter || (FilterRequest2.ContentFilter = {}));
    let _codec;
    FilterRequest2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.subscribe != null && obj.subscribe !== false) {
            w2.uint32(8);
            w2.bool(obj.subscribe);
          }
          if (obj.topic != null && obj.topic !== "") {
            w2.uint32(18);
            w2.string(obj.topic);
          }
          if (obj.contentFilters != null) {
            for (const value of obj.contentFilters) {
              w2.uint32(26);
              FilterRequest2.ContentFilter.codec().encode(value, w2);
            }
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            subscribe: false,
            topic: "",
            contentFilters: []
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.subscribe = reader.bool();
                break;
              }
              case 2: {
                obj.topic = reader.string();
                break;
              }
              case 3: {
                if (opts.limits?.contentFilters != null && obj.contentFilters.length === opts.limits.contentFilters) {
                  throw new MaxLengthError('Decode error - map field "contentFilters" had too many elements');
                }
                obj.contentFilters.push(FilterRequest2.ContentFilter.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.contentFilters$
                }));
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    FilterRequest2.encode = (obj) => {
      return encodeMessage(obj, FilterRequest2.codec());
    };
    FilterRequest2.decode = (buf, opts) => {
      return decodeMessage(buf, FilterRequest2.codec(), opts);
    };
  })(FilterRequest || (FilterRequest = {}));
  var MessagePush;
  (function(MessagePush3) {
    let _codec;
    MessagePush3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.messages != null) {
            for (const value of obj.messages) {
              w2.uint32(10);
              WakuMessage2.codec().encode(value, w2);
            }
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            messages: []
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (opts.limits?.messages != null && obj.messages.length === opts.limits.messages) {
                  throw new MaxLengthError('Decode error - map field "messages" had too many elements');
                }
                obj.messages.push(WakuMessage2.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.messages$
                }));
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    MessagePush3.encode = (obj) => {
      return encodeMessage(obj, MessagePush3.codec());
    };
    MessagePush3.decode = (buf, opts) => {
      return decodeMessage(buf, MessagePush3.codec(), opts);
    };
  })(MessagePush || (MessagePush = {}));
  var FilterRpc;
  (function(FilterRpc2) {
    let _codec;
    FilterRpc2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.requestId != null && obj.requestId !== "") {
            w2.uint32(10);
            w2.string(obj.requestId);
          }
          if (obj.request != null) {
            w2.uint32(18);
            FilterRequest.codec().encode(obj.request, w2);
          }
          if (obj.push != null) {
            w2.uint32(26);
            MessagePush.codec().encode(obj.push, w2);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            requestId: ""
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.requestId = reader.string();
                break;
              }
              case 2: {
                obj.request = FilterRequest.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.request
                });
                break;
              }
              case 3: {
                obj.push = MessagePush.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.push
                });
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    FilterRpc2.encode = (obj) => {
      return encodeMessage(obj, FilterRpc2.codec());
    };
    FilterRpc2.decode = (buf, opts) => {
      return decodeMessage(buf, FilterRpc2.codec(), opts);
    };
  })(FilterRpc || (FilterRpc = {}));
  var RateLimitProof2;
  (function(RateLimitProof6) {
    let _codec;
    RateLimitProof6.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.proof != null && obj.proof.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.proof);
          }
          if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
            w2.uint32(18);
            w2.bytes(obj.merkleRoot);
          }
          if (obj.epoch != null && obj.epoch.byteLength > 0) {
            w2.uint32(26);
            w2.bytes(obj.epoch);
          }
          if (obj.shareX != null && obj.shareX.byteLength > 0) {
            w2.uint32(34);
            w2.bytes(obj.shareX);
          }
          if (obj.shareY != null && obj.shareY.byteLength > 0) {
            w2.uint32(42);
            w2.bytes(obj.shareY);
          }
          if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
            w2.uint32(50);
            w2.bytes(obj.nullifier);
          }
          if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
            w2.uint32(58);
            w2.bytes(obj.rlnIdentifier);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            proof: alloc2(0),
            merkleRoot: alloc2(0),
            epoch: alloc2(0),
            shareX: alloc2(0),
            shareY: alloc2(0),
            nullifier: alloc2(0),
            rlnIdentifier: alloc2(0)
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.proof = reader.bytes();
                break;
              }
              case 2: {
                obj.merkleRoot = reader.bytes();
                break;
              }
              case 3: {
                obj.epoch = reader.bytes();
                break;
              }
              case 4: {
                obj.shareX = reader.bytes();
                break;
              }
              case 5: {
                obj.shareY = reader.bytes();
                break;
              }
              case 6: {
                obj.nullifier = reader.bytes();
                break;
              }
              case 7: {
                obj.rlnIdentifier = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    RateLimitProof6.encode = (obj) => {
      return encodeMessage(obj, RateLimitProof6.codec());
    };
    RateLimitProof6.decode = (buf, opts) => {
      return decodeMessage(buf, RateLimitProof6.codec(), opts);
    };
  })(RateLimitProof2 || (RateLimitProof2 = {}));
  var WakuMessage2;
  (function(WakuMessage6) {
    let _codec;
    WakuMessage6.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.payload != null && obj.payload.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.payload);
          }
          if (obj.contentTopic != null && obj.contentTopic !== "") {
            w2.uint32(18);
            w2.string(obj.contentTopic);
          }
          if (obj.version != null) {
            w2.uint32(24);
            w2.uint32(obj.version);
          }
          if (obj.timestamp != null) {
            w2.uint32(80);
            w2.sint64(obj.timestamp);
          }
          if (obj.meta != null) {
            w2.uint32(90);
            w2.bytes(obj.meta);
          }
          if (obj.rateLimitProof != null) {
            w2.uint32(170);
            RateLimitProof2.codec().encode(obj.rateLimitProof, w2);
          }
          if (obj.ephemeral != null) {
            w2.uint32(248);
            w2.bool(obj.ephemeral);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            payload: alloc2(0),
            contentTopic: ""
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.payload = reader.bytes();
                break;
              }
              case 2: {
                obj.contentTopic = reader.string();
                break;
              }
              case 3: {
                obj.version = reader.uint32();
                break;
              }
              case 10: {
                obj.timestamp = reader.sint64();
                break;
              }
              case 11: {
                obj.meta = reader.bytes();
                break;
              }
              case 21: {
                obj.rateLimitProof = RateLimitProof2.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.rateLimitProof
                });
                break;
              }
              case 31: {
                obj.ephemeral = reader.bool();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    WakuMessage6.encode = (obj) => {
      return encodeMessage(obj, WakuMessage6.codec());
    };
    WakuMessage6.decode = (buf, opts) => {
      return decodeMessage(buf, WakuMessage6.codec(), opts);
    };
  })(WakuMessage2 || (WakuMessage2 = {}));

  // ../node_modules/@waku/proto/dist/generated/topic_only_message.js
  var TopicOnlyMessage;
  (function(TopicOnlyMessage2) {
    let _codec;
    TopicOnlyMessage2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.contentTopic != null && obj.contentTopic !== "") {
            w2.uint32(18);
            w2.string(obj.contentTopic);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            contentTopic: ""
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 2: {
                obj.contentTopic = reader.string();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    TopicOnlyMessage2.encode = (obj) => {
      return encodeMessage(obj, TopicOnlyMessage2.codec());
    };
    TopicOnlyMessage2.decode = (buf, opts) => {
      return decodeMessage(buf, TopicOnlyMessage2.codec(), opts);
    };
  })(TopicOnlyMessage || (TopicOnlyMessage = {}));

  // ../node_modules/@waku/proto/dist/generated/filter_v2.js
  var filter_v2_exports = {};
  __export(filter_v2_exports, {
    FilterSubscribeRequest: () => FilterSubscribeRequest,
    FilterSubscribeResponse: () => FilterSubscribeResponse,
    MessagePush: () => MessagePush2,
    RateLimitProof: () => RateLimitProof3,
    WakuMessage: () => WakuMessage3
  });
  var FilterSubscribeRequest;
  (function(FilterSubscribeRequest2) {
    let FilterSubscribeType;
    (function(FilterSubscribeType2) {
      FilterSubscribeType2["SUBSCRIBER_PING"] = "SUBSCRIBER_PING";
      FilterSubscribeType2["SUBSCRIBE"] = "SUBSCRIBE";
      FilterSubscribeType2["UNSUBSCRIBE"] = "UNSUBSCRIBE";
      FilterSubscribeType2["UNSUBSCRIBE_ALL"] = "UNSUBSCRIBE_ALL";
    })(FilterSubscribeType = FilterSubscribeRequest2.FilterSubscribeType || (FilterSubscribeRequest2.FilterSubscribeType = {}));
    let __FilterSubscribeTypeValues;
    (function(__FilterSubscribeTypeValues2) {
      __FilterSubscribeTypeValues2[__FilterSubscribeTypeValues2["SUBSCRIBER_PING"] = 0] = "SUBSCRIBER_PING";
      __FilterSubscribeTypeValues2[__FilterSubscribeTypeValues2["SUBSCRIBE"] = 1] = "SUBSCRIBE";
      __FilterSubscribeTypeValues2[__FilterSubscribeTypeValues2["UNSUBSCRIBE"] = 2] = "UNSUBSCRIBE";
      __FilterSubscribeTypeValues2[__FilterSubscribeTypeValues2["UNSUBSCRIBE_ALL"] = 3] = "UNSUBSCRIBE_ALL";
    })(__FilterSubscribeTypeValues || (__FilterSubscribeTypeValues = {}));
    (function(FilterSubscribeType2) {
      FilterSubscribeType2.codec = () => {
        return enumeration(__FilterSubscribeTypeValues);
      };
    })(FilterSubscribeType = FilterSubscribeRequest2.FilterSubscribeType || (FilterSubscribeRequest2.FilterSubscribeType = {}));
    let _codec;
    FilterSubscribeRequest2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.requestId != null && obj.requestId !== "") {
            w2.uint32(10);
            w2.string(obj.requestId);
          }
          if (obj.filterSubscribeType != null && __FilterSubscribeTypeValues[obj.filterSubscribeType] !== 0) {
            w2.uint32(16);
            FilterSubscribeRequest2.FilterSubscribeType.codec().encode(obj.filterSubscribeType, w2);
          }
          if (obj.pubsubTopic != null) {
            w2.uint32(82);
            w2.string(obj.pubsubTopic);
          }
          if (obj.contentTopics != null) {
            for (const value of obj.contentTopics) {
              w2.uint32(90);
              w2.string(value);
            }
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            requestId: "",
            filterSubscribeType: FilterSubscribeType.SUBSCRIBER_PING,
            contentTopics: []
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.requestId = reader.string();
                break;
              }
              case 2: {
                obj.filterSubscribeType = FilterSubscribeRequest2.FilterSubscribeType.codec().decode(reader);
                break;
              }
              case 10: {
                obj.pubsubTopic = reader.string();
                break;
              }
              case 11: {
                if (opts.limits?.contentTopics != null && obj.contentTopics.length === opts.limits.contentTopics) {
                  throw new MaxLengthError('Decode error - map field "contentTopics" had too many elements');
                }
                obj.contentTopics.push(reader.string());
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    FilterSubscribeRequest2.encode = (obj) => {
      return encodeMessage(obj, FilterSubscribeRequest2.codec());
    };
    FilterSubscribeRequest2.decode = (buf, opts) => {
      return decodeMessage(buf, FilterSubscribeRequest2.codec(), opts);
    };
  })(FilterSubscribeRequest || (FilterSubscribeRequest = {}));
  var FilterSubscribeResponse;
  (function(FilterSubscribeResponse3) {
    let _codec;
    FilterSubscribeResponse3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.requestId != null && obj.requestId !== "") {
            w2.uint32(10);
            w2.string(obj.requestId);
          }
          if (obj.statusCode != null && obj.statusCode !== 0) {
            w2.uint32(80);
            w2.uint32(obj.statusCode);
          }
          if (obj.statusDesc != null) {
            w2.uint32(90);
            w2.string(obj.statusDesc);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            requestId: "",
            statusCode: 0
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.requestId = reader.string();
                break;
              }
              case 10: {
                obj.statusCode = reader.uint32();
                break;
              }
              case 11: {
                obj.statusDesc = reader.string();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    FilterSubscribeResponse3.encode = (obj) => {
      return encodeMessage(obj, FilterSubscribeResponse3.codec());
    };
    FilterSubscribeResponse3.decode = (buf, opts) => {
      return decodeMessage(buf, FilterSubscribeResponse3.codec(), opts);
    };
  })(FilterSubscribeResponse || (FilterSubscribeResponse = {}));
  var MessagePush2;
  (function(MessagePush3) {
    let _codec;
    MessagePush3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.wakuMessage != null) {
            w2.uint32(10);
            WakuMessage3.codec().encode(obj.wakuMessage, w2);
          }
          if (obj.pubsubTopic != null) {
            w2.uint32(18);
            w2.string(obj.pubsubTopic);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {};
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.wakuMessage = WakuMessage3.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.wakuMessage
                });
                break;
              }
              case 2: {
                obj.pubsubTopic = reader.string();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    MessagePush3.encode = (obj) => {
      return encodeMessage(obj, MessagePush3.codec());
    };
    MessagePush3.decode = (buf, opts) => {
      return decodeMessage(buf, MessagePush3.codec(), opts);
    };
  })(MessagePush2 || (MessagePush2 = {}));
  var RateLimitProof3;
  (function(RateLimitProof6) {
    let _codec;
    RateLimitProof6.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.proof != null && obj.proof.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.proof);
          }
          if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
            w2.uint32(18);
            w2.bytes(obj.merkleRoot);
          }
          if (obj.epoch != null && obj.epoch.byteLength > 0) {
            w2.uint32(26);
            w2.bytes(obj.epoch);
          }
          if (obj.shareX != null && obj.shareX.byteLength > 0) {
            w2.uint32(34);
            w2.bytes(obj.shareX);
          }
          if (obj.shareY != null && obj.shareY.byteLength > 0) {
            w2.uint32(42);
            w2.bytes(obj.shareY);
          }
          if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
            w2.uint32(50);
            w2.bytes(obj.nullifier);
          }
          if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
            w2.uint32(58);
            w2.bytes(obj.rlnIdentifier);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            proof: alloc2(0),
            merkleRoot: alloc2(0),
            epoch: alloc2(0),
            shareX: alloc2(0),
            shareY: alloc2(0),
            nullifier: alloc2(0),
            rlnIdentifier: alloc2(0)
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.proof = reader.bytes();
                break;
              }
              case 2: {
                obj.merkleRoot = reader.bytes();
                break;
              }
              case 3: {
                obj.epoch = reader.bytes();
                break;
              }
              case 4: {
                obj.shareX = reader.bytes();
                break;
              }
              case 5: {
                obj.shareY = reader.bytes();
                break;
              }
              case 6: {
                obj.nullifier = reader.bytes();
                break;
              }
              case 7: {
                obj.rlnIdentifier = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    RateLimitProof6.encode = (obj) => {
      return encodeMessage(obj, RateLimitProof6.codec());
    };
    RateLimitProof6.decode = (buf, opts) => {
      return decodeMessage(buf, RateLimitProof6.codec(), opts);
    };
  })(RateLimitProof3 || (RateLimitProof3 = {}));
  var WakuMessage3;
  (function(WakuMessage6) {
    let _codec;
    WakuMessage6.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.payload != null && obj.payload.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.payload);
          }
          if (obj.contentTopic != null && obj.contentTopic !== "") {
            w2.uint32(18);
            w2.string(obj.contentTopic);
          }
          if (obj.version != null) {
            w2.uint32(24);
            w2.uint32(obj.version);
          }
          if (obj.timestamp != null) {
            w2.uint32(80);
            w2.sint64(obj.timestamp);
          }
          if (obj.meta != null) {
            w2.uint32(90);
            w2.bytes(obj.meta);
          }
          if (obj.rateLimitProof != null) {
            w2.uint32(170);
            RateLimitProof3.codec().encode(obj.rateLimitProof, w2);
          }
          if (obj.ephemeral != null) {
            w2.uint32(248);
            w2.bool(obj.ephemeral);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            payload: alloc2(0),
            contentTopic: ""
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.payload = reader.bytes();
                break;
              }
              case 2: {
                obj.contentTopic = reader.string();
                break;
              }
              case 3: {
                obj.version = reader.uint32();
                break;
              }
              case 10: {
                obj.timestamp = reader.sint64();
                break;
              }
              case 11: {
                obj.meta = reader.bytes();
                break;
              }
              case 21: {
                obj.rateLimitProof = RateLimitProof3.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.rateLimitProof
                });
                break;
              }
              case 31: {
                obj.ephemeral = reader.bool();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    WakuMessage6.encode = (obj) => {
      return encodeMessage(obj, WakuMessage6.codec());
    };
    WakuMessage6.decode = (buf, opts) => {
      return decodeMessage(buf, WakuMessage6.codec(), opts);
    };
  })(WakuMessage3 || (WakuMessage3 = {}));

  // ../node_modules/@waku/proto/dist/generated/light_push.js
  var light_push_exports = {};
  __export(light_push_exports, {
    LightPushRequestV3: () => LightPushRequestV3,
    LightPushResponseV3: () => LightPushResponseV3,
    PushRequest: () => PushRequest,
    PushResponse: () => PushResponse,
    PushRpc: () => PushRpc,
    RateLimitProof: () => RateLimitProof4,
    WakuMessage: () => WakuMessage4
  });
  var PushRequest;
  (function(PushRequest2) {
    let _codec;
    PushRequest2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.pubsubTopic != null && obj.pubsubTopic !== "") {
            w2.uint32(10);
            w2.string(obj.pubsubTopic);
          }
          if (obj.message != null) {
            w2.uint32(18);
            WakuMessage4.codec().encode(obj.message, w2);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            pubsubTopic: ""
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.pubsubTopic = reader.string();
                break;
              }
              case 2: {
                obj.message = WakuMessage4.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.message
                });
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PushRequest2.encode = (obj) => {
      return encodeMessage(obj, PushRequest2.codec());
    };
    PushRequest2.decode = (buf, opts) => {
      return decodeMessage(buf, PushRequest2.codec(), opts);
    };
  })(PushRequest || (PushRequest = {}));
  var PushResponse;
  (function(PushResponse2) {
    let _codec;
    PushResponse2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.isSuccess != null && obj.isSuccess !== false) {
            w2.uint32(8);
            w2.bool(obj.isSuccess);
          }
          if (obj.info != null) {
            w2.uint32(18);
            w2.string(obj.info);
          }
          if (obj.statusCode != null) {
            w2.uint32(80);
            w2.uint32(obj.statusCode);
          }
          if (obj.statusDesc != null) {
            w2.uint32(90);
            w2.string(obj.statusDesc);
          }
          if (obj.relayPeerCount != null) {
            w2.uint32(96);
            w2.uint32(obj.relayPeerCount);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            isSuccess: false
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.isSuccess = reader.bool();
                break;
              }
              case 2: {
                obj.info = reader.string();
                break;
              }
              case 10: {
                obj.statusCode = reader.uint32();
                break;
              }
              case 11: {
                obj.statusDesc = reader.string();
                break;
              }
              case 12: {
                obj.relayPeerCount = reader.uint32();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PushResponse2.encode = (obj) => {
      return encodeMessage(obj, PushResponse2.codec());
    };
    PushResponse2.decode = (buf, opts) => {
      return decodeMessage(buf, PushResponse2.codec(), opts);
    };
  })(PushResponse || (PushResponse = {}));
  var PushRpc;
  (function(PushRpc3) {
    let _codec;
    PushRpc3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.requestId != null && obj.requestId !== "") {
            w2.uint32(10);
            w2.string(obj.requestId);
          }
          if (obj.request != null) {
            w2.uint32(18);
            PushRequest.codec().encode(obj.request, w2);
          }
          if (obj.response != null) {
            w2.uint32(26);
            PushResponse.codec().encode(obj.response, w2);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            requestId: ""
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.requestId = reader.string();
                break;
              }
              case 2: {
                obj.request = PushRequest.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.request
                });
                break;
              }
              case 3: {
                obj.response = PushResponse.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.response
                });
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PushRpc3.encode = (obj) => {
      return encodeMessage(obj, PushRpc3.codec());
    };
    PushRpc3.decode = (buf, opts) => {
      return decodeMessage(buf, PushRpc3.codec(), opts);
    };
  })(PushRpc || (PushRpc = {}));
  var LightPushRequestV3;
  (function(LightPushRequestV32) {
    let _codec;
    LightPushRequestV32.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.requestId != null && obj.requestId !== "") {
            w2.uint32(10);
            w2.string(obj.requestId);
          }
          if (obj.pubsubTopic != null) {
            w2.uint32(162);
            w2.string(obj.pubsubTopic);
          }
          if (obj.message != null) {
            w2.uint32(170);
            WakuMessage4.codec().encode(obj.message, w2);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            requestId: ""
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.requestId = reader.string();
                break;
              }
              case 20: {
                obj.pubsubTopic = reader.string();
                break;
              }
              case 21: {
                obj.message = WakuMessage4.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.message
                });
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    LightPushRequestV32.encode = (obj) => {
      return encodeMessage(obj, LightPushRequestV32.codec());
    };
    LightPushRequestV32.decode = (buf, opts) => {
      return decodeMessage(buf, LightPushRequestV32.codec(), opts);
    };
  })(LightPushRequestV3 || (LightPushRequestV3 = {}));
  var LightPushResponseV3;
  (function(LightPushResponseV32) {
    let _codec;
    LightPushResponseV32.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.requestId != null && obj.requestId !== "") {
            w2.uint32(10);
            w2.string(obj.requestId);
          }
          if (obj.statusCode != null && obj.statusCode !== 0) {
            w2.uint32(80);
            w2.uint32(obj.statusCode);
          }
          if (obj.statusDesc != null) {
            w2.uint32(90);
            w2.string(obj.statusDesc);
          }
          if (obj.relayPeerCount != null) {
            w2.uint32(96);
            w2.uint32(obj.relayPeerCount);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            requestId: "",
            statusCode: 0
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.requestId = reader.string();
                break;
              }
              case 10: {
                obj.statusCode = reader.uint32();
                break;
              }
              case 11: {
                obj.statusDesc = reader.string();
                break;
              }
              case 12: {
                obj.relayPeerCount = reader.uint32();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    LightPushResponseV32.encode = (obj) => {
      return encodeMessage(obj, LightPushResponseV32.codec());
    };
    LightPushResponseV32.decode = (buf, opts) => {
      return decodeMessage(buf, LightPushResponseV32.codec(), opts);
    };
  })(LightPushResponseV3 || (LightPushResponseV3 = {}));
  var RateLimitProof4;
  (function(RateLimitProof6) {
    let _codec;
    RateLimitProof6.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.proof != null && obj.proof.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.proof);
          }
          if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
            w2.uint32(18);
            w2.bytes(obj.merkleRoot);
          }
          if (obj.epoch != null && obj.epoch.byteLength > 0) {
            w2.uint32(26);
            w2.bytes(obj.epoch);
          }
          if (obj.shareX != null && obj.shareX.byteLength > 0) {
            w2.uint32(34);
            w2.bytes(obj.shareX);
          }
          if (obj.shareY != null && obj.shareY.byteLength > 0) {
            w2.uint32(42);
            w2.bytes(obj.shareY);
          }
          if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
            w2.uint32(50);
            w2.bytes(obj.nullifier);
          }
          if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
            w2.uint32(58);
            w2.bytes(obj.rlnIdentifier);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            proof: alloc2(0),
            merkleRoot: alloc2(0),
            epoch: alloc2(0),
            shareX: alloc2(0),
            shareY: alloc2(0),
            nullifier: alloc2(0),
            rlnIdentifier: alloc2(0)
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.proof = reader.bytes();
                break;
              }
              case 2: {
                obj.merkleRoot = reader.bytes();
                break;
              }
              case 3: {
                obj.epoch = reader.bytes();
                break;
              }
              case 4: {
                obj.shareX = reader.bytes();
                break;
              }
              case 5: {
                obj.shareY = reader.bytes();
                break;
              }
              case 6: {
                obj.nullifier = reader.bytes();
                break;
              }
              case 7: {
                obj.rlnIdentifier = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    RateLimitProof6.encode = (obj) => {
      return encodeMessage(obj, RateLimitProof6.codec());
    };
    RateLimitProof6.decode = (buf, opts) => {
      return decodeMessage(buf, RateLimitProof6.codec(), opts);
    };
  })(RateLimitProof4 || (RateLimitProof4 = {}));
  var WakuMessage4;
  (function(WakuMessage6) {
    let _codec;
    WakuMessage6.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.payload != null && obj.payload.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.payload);
          }
          if (obj.contentTopic != null && obj.contentTopic !== "") {
            w2.uint32(18);
            w2.string(obj.contentTopic);
          }
          if (obj.version != null) {
            w2.uint32(24);
            w2.uint32(obj.version);
          }
          if (obj.timestamp != null) {
            w2.uint32(80);
            w2.sint64(obj.timestamp);
          }
          if (obj.meta != null) {
            w2.uint32(90);
            w2.bytes(obj.meta);
          }
          if (obj.rateLimitProof != null) {
            w2.uint32(170);
            RateLimitProof4.codec().encode(obj.rateLimitProof, w2);
          }
          if (obj.ephemeral != null) {
            w2.uint32(248);
            w2.bool(obj.ephemeral);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            payload: alloc2(0),
            contentTopic: ""
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.payload = reader.bytes();
                break;
              }
              case 2: {
                obj.contentTopic = reader.string();
                break;
              }
              case 3: {
                obj.version = reader.uint32();
                break;
              }
              case 10: {
                obj.timestamp = reader.sint64();
                break;
              }
              case 11: {
                obj.meta = reader.bytes();
                break;
              }
              case 21: {
                obj.rateLimitProof = RateLimitProof4.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.rateLimitProof
                });
                break;
              }
              case 31: {
                obj.ephemeral = reader.bool();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    WakuMessage6.encode = (obj) => {
      return encodeMessage(obj, WakuMessage6.codec());
    };
    WakuMessage6.decode = (buf, opts) => {
      return decodeMessage(buf, WakuMessage6.codec(), opts);
    };
  })(WakuMessage4 || (WakuMessage4 = {}));

  // ../node_modules/@waku/proto/dist/generated/store_v3.js
  var store_v3_exports = {};
  __export(store_v3_exports, {
    RateLimitProof: () => RateLimitProof5,
    StoreQueryRequest: () => StoreQueryRequest,
    StoreQueryResponse: () => StoreQueryResponse,
    WakuMessage: () => WakuMessage5,
    WakuMessageKeyValue: () => WakuMessageKeyValue
  });
  var WakuMessageKeyValue;
  (function(WakuMessageKeyValue2) {
    let _codec;
    WakuMessageKeyValue2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.messageHash != null) {
            w2.uint32(10);
            w2.bytes(obj.messageHash);
          }
          if (obj.message != null) {
            w2.uint32(18);
            WakuMessage5.codec().encode(obj.message, w2);
          }
          if (obj.pubsubTopic != null) {
            w2.uint32(26);
            w2.string(obj.pubsubTopic);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {};
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.messageHash = reader.bytes();
                break;
              }
              case 2: {
                obj.message = WakuMessage5.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.message
                });
                break;
              }
              case 3: {
                obj.pubsubTopic = reader.string();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    WakuMessageKeyValue2.encode = (obj) => {
      return encodeMessage(obj, WakuMessageKeyValue2.codec());
    };
    WakuMessageKeyValue2.decode = (buf, opts) => {
      return decodeMessage(buf, WakuMessageKeyValue2.codec(), opts);
    };
  })(WakuMessageKeyValue || (WakuMessageKeyValue = {}));
  var StoreQueryRequest;
  (function(StoreQueryRequest3) {
    let _codec;
    StoreQueryRequest3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.requestId != null && obj.requestId !== "") {
            w2.uint32(10);
            w2.string(obj.requestId);
          }
          if (obj.includeData != null && obj.includeData !== false) {
            w2.uint32(16);
            w2.bool(obj.includeData);
          }
          if (obj.pubsubTopic != null) {
            w2.uint32(82);
            w2.string(obj.pubsubTopic);
          }
          if (obj.contentTopics != null) {
            for (const value of obj.contentTopics) {
              w2.uint32(90);
              w2.string(value);
            }
          }
          if (obj.timeStart != null) {
            w2.uint32(96);
            w2.sint64(obj.timeStart);
          }
          if (obj.timeEnd != null) {
            w2.uint32(104);
            w2.sint64(obj.timeEnd);
          }
          if (obj.messageHashes != null) {
            for (const value of obj.messageHashes) {
              w2.uint32(162);
              w2.bytes(value);
            }
          }
          if (obj.paginationCursor != null) {
            w2.uint32(410);
            w2.bytes(obj.paginationCursor);
          }
          if (obj.paginationForward != null && obj.paginationForward !== false) {
            w2.uint32(416);
            w2.bool(obj.paginationForward);
          }
          if (obj.paginationLimit != null) {
            w2.uint32(424);
            w2.uint64(obj.paginationLimit);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            requestId: "",
            includeData: false,
            contentTopics: [],
            messageHashes: [],
            paginationForward: false
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.requestId = reader.string();
                break;
              }
              case 2: {
                obj.includeData = reader.bool();
                break;
              }
              case 10: {
                obj.pubsubTopic = reader.string();
                break;
              }
              case 11: {
                if (opts.limits?.contentTopics != null && obj.contentTopics.length === opts.limits.contentTopics) {
                  throw new MaxLengthError('Decode error - map field "contentTopics" had too many elements');
                }
                obj.contentTopics.push(reader.string());
                break;
              }
              case 12: {
                obj.timeStart = reader.sint64();
                break;
              }
              case 13: {
                obj.timeEnd = reader.sint64();
                break;
              }
              case 20: {
                if (opts.limits?.messageHashes != null && obj.messageHashes.length === opts.limits.messageHashes) {
                  throw new MaxLengthError('Decode error - map field "messageHashes" had too many elements');
                }
                obj.messageHashes.push(reader.bytes());
                break;
              }
              case 51: {
                obj.paginationCursor = reader.bytes();
                break;
              }
              case 52: {
                obj.paginationForward = reader.bool();
                break;
              }
              case 53: {
                obj.paginationLimit = reader.uint64();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    StoreQueryRequest3.encode = (obj) => {
      return encodeMessage(obj, StoreQueryRequest3.codec());
    };
    StoreQueryRequest3.decode = (buf, opts) => {
      return decodeMessage(buf, StoreQueryRequest3.codec(), opts);
    };
  })(StoreQueryRequest || (StoreQueryRequest = {}));
  var StoreQueryResponse;
  (function(StoreQueryResponse3) {
    let _codec;
    StoreQueryResponse3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.requestId != null && obj.requestId !== "") {
            w2.uint32(10);
            w2.string(obj.requestId);
          }
          if (obj.statusCode != null) {
            w2.uint32(80);
            w2.uint32(obj.statusCode);
          }
          if (obj.statusDesc != null) {
            w2.uint32(90);
            w2.string(obj.statusDesc);
          }
          if (obj.messages != null) {
            for (const value of obj.messages) {
              w2.uint32(162);
              WakuMessageKeyValue.codec().encode(value, w2);
            }
          }
          if (obj.paginationCursor != null) {
            w2.uint32(410);
            w2.bytes(obj.paginationCursor);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            requestId: "",
            messages: []
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.requestId = reader.string();
                break;
              }
              case 10: {
                obj.statusCode = reader.uint32();
                break;
              }
              case 11: {
                obj.statusDesc = reader.string();
                break;
              }
              case 20: {
                if (opts.limits?.messages != null && obj.messages.length === opts.limits.messages) {
                  throw new MaxLengthError('Decode error - map field "messages" had too many elements');
                }
                obj.messages.push(WakuMessageKeyValue.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.messages$
                }));
                break;
              }
              case 51: {
                obj.paginationCursor = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    StoreQueryResponse3.encode = (obj) => {
      return encodeMessage(obj, StoreQueryResponse3.codec());
    };
    StoreQueryResponse3.decode = (buf, opts) => {
      return decodeMessage(buf, StoreQueryResponse3.codec(), opts);
    };
  })(StoreQueryResponse || (StoreQueryResponse = {}));
  var RateLimitProof5;
  (function(RateLimitProof6) {
    let _codec;
    RateLimitProof6.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.proof != null && obj.proof.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.proof);
          }
          if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
            w2.uint32(18);
            w2.bytes(obj.merkleRoot);
          }
          if (obj.epoch != null && obj.epoch.byteLength > 0) {
            w2.uint32(26);
            w2.bytes(obj.epoch);
          }
          if (obj.shareX != null && obj.shareX.byteLength > 0) {
            w2.uint32(34);
            w2.bytes(obj.shareX);
          }
          if (obj.shareY != null && obj.shareY.byteLength > 0) {
            w2.uint32(42);
            w2.bytes(obj.shareY);
          }
          if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
            w2.uint32(50);
            w2.bytes(obj.nullifier);
          }
          if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
            w2.uint32(58);
            w2.bytes(obj.rlnIdentifier);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            proof: alloc2(0),
            merkleRoot: alloc2(0),
            epoch: alloc2(0),
            shareX: alloc2(0),
            shareY: alloc2(0),
            nullifier: alloc2(0),
            rlnIdentifier: alloc2(0)
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.proof = reader.bytes();
                break;
              }
              case 2: {
                obj.merkleRoot = reader.bytes();
                break;
              }
              case 3: {
                obj.epoch = reader.bytes();
                break;
              }
              case 4: {
                obj.shareX = reader.bytes();
                break;
              }
              case 5: {
                obj.shareY = reader.bytes();
                break;
              }
              case 6: {
                obj.nullifier = reader.bytes();
                break;
              }
              case 7: {
                obj.rlnIdentifier = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    RateLimitProof6.encode = (obj) => {
      return encodeMessage(obj, RateLimitProof6.codec());
    };
    RateLimitProof6.decode = (buf, opts) => {
      return decodeMessage(buf, RateLimitProof6.codec(), opts);
    };
  })(RateLimitProof5 || (RateLimitProof5 = {}));
  var WakuMessage5;
  (function(WakuMessage6) {
    let _codec;
    WakuMessage6.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.payload != null && obj.payload.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.payload);
          }
          if (obj.contentTopic != null && obj.contentTopic !== "") {
            w2.uint32(18);
            w2.string(obj.contentTopic);
          }
          if (obj.version != null) {
            w2.uint32(24);
            w2.uint32(obj.version);
          }
          if (obj.timestamp != null) {
            w2.uint32(80);
            w2.sint64(obj.timestamp);
          }
          if (obj.meta != null) {
            w2.uint32(90);
            w2.bytes(obj.meta);
          }
          if (obj.rateLimitProof != null) {
            w2.uint32(170);
            RateLimitProof5.codec().encode(obj.rateLimitProof, w2);
          }
          if (obj.ephemeral != null) {
            w2.uint32(248);
            w2.bool(obj.ephemeral);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            payload: alloc2(0),
            contentTopic: ""
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.payload = reader.bytes();
                break;
              }
              case 2: {
                obj.contentTopic = reader.string();
                break;
              }
              case 3: {
                obj.version = reader.uint32();
                break;
              }
              case 10: {
                obj.timestamp = reader.sint64();
                break;
              }
              case 11: {
                obj.meta = reader.bytes();
                break;
              }
              case 21: {
                obj.rateLimitProof = RateLimitProof5.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.rateLimitProof
                });
                break;
              }
              case 31: {
                obj.ephemeral = reader.bool();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    WakuMessage6.encode = (obj) => {
      return encodeMessage(obj, WakuMessage6.codec());
    };
    WakuMessage6.decode = (buf, opts) => {
      return decodeMessage(buf, WakuMessage6.codec(), opts);
    };
  })(WakuMessage5 || (WakuMessage5 = {}));

  // ../node_modules/@waku/proto/dist/generated/peer_exchange.js
  var peer_exchange_exports = {};
  __export(peer_exchange_exports, {
    PeerExchangeQuery: () => PeerExchangeQuery,
    PeerExchangeRPC: () => PeerExchangeRPC,
    PeerExchangeResponse: () => PeerExchangeResponse,
    PeerInfo: () => PeerInfo
  });
  var PeerInfo;
  (function(PeerInfo2) {
    let _codec;
    PeerInfo2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.enr != null) {
            w2.uint32(10);
            w2.bytes(obj.enr);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {};
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.enr = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PeerInfo2.encode = (obj) => {
      return encodeMessage(obj, PeerInfo2.codec());
    };
    PeerInfo2.decode = (buf, opts) => {
      return decodeMessage(buf, PeerInfo2.codec(), opts);
    };
  })(PeerInfo || (PeerInfo = {}));
  var PeerExchangeQuery;
  (function(PeerExchangeQuery2) {
    let _codec;
    PeerExchangeQuery2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.numPeers != null) {
            w2.uint32(8);
            w2.uint64(obj.numPeers);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {};
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.numPeers = reader.uint64();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PeerExchangeQuery2.encode = (obj) => {
      return encodeMessage(obj, PeerExchangeQuery2.codec());
    };
    PeerExchangeQuery2.decode = (buf, opts) => {
      return decodeMessage(buf, PeerExchangeQuery2.codec(), opts);
    };
  })(PeerExchangeQuery || (PeerExchangeQuery = {}));
  var PeerExchangeResponse;
  (function(PeerExchangeResponse2) {
    let _codec;
    PeerExchangeResponse2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.peerInfos != null) {
            for (const value of obj.peerInfos) {
              w2.uint32(10);
              PeerInfo.codec().encode(value, w2);
            }
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            peerInfos: []
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (opts.limits?.peerInfos != null && obj.peerInfos.length === opts.limits.peerInfos) {
                  throw new MaxLengthError('Decode error - map field "peerInfos" had too many elements');
                }
                obj.peerInfos.push(PeerInfo.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.peerInfos$
                }));
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PeerExchangeResponse2.encode = (obj) => {
      return encodeMessage(obj, PeerExchangeResponse2.codec());
    };
    PeerExchangeResponse2.decode = (buf, opts) => {
      return decodeMessage(buf, PeerExchangeResponse2.codec(), opts);
    };
  })(PeerExchangeResponse || (PeerExchangeResponse = {}));
  var PeerExchangeRPC;
  (function(PeerExchangeRPC3) {
    let _codec;
    PeerExchangeRPC3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.query != null) {
            w2.uint32(10);
            PeerExchangeQuery.codec().encode(obj.query, w2);
          }
          if (obj.response != null) {
            w2.uint32(18);
            PeerExchangeResponse.codec().encode(obj.response, w2);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {};
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.query = PeerExchangeQuery.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.query
                });
                break;
              }
              case 2: {
                obj.response = PeerExchangeResponse.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.response
                });
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PeerExchangeRPC3.encode = (obj) => {
      return encodeMessage(obj, PeerExchangeRPC3.codec());
    };
    PeerExchangeRPC3.decode = (buf, opts) => {
      return decodeMessage(buf, PeerExchangeRPC3.codec(), opts);
    };
  })(PeerExchangeRPC || (PeerExchangeRPC = {}));

  // ../node_modules/@waku/proto/dist/generated/metadata.js
  var metadata_exports = {};
  __export(metadata_exports, {
    WakuMetadataRequest: () => WakuMetadataRequest,
    WakuMetadataResponse: () => WakuMetadataResponse
  });
  var WakuMetadataRequest;
  (function(WakuMetadataRequest2) {
    let _codec;
    WakuMetadataRequest2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.clusterId != null) {
            w2.uint32(8);
            w2.uint32(obj.clusterId);
          }
          if (obj.shards != null) {
            for (const value of obj.shards) {
              w2.uint32(16);
              w2.uint32(value);
            }
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            shards: []
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.clusterId = reader.uint32();
                break;
              }
              case 2: {
                if (opts.limits?.shards != null && obj.shards.length === opts.limits.shards) {
                  throw new MaxLengthError('Decode error - map field "shards" had too many elements');
                }
                obj.shards.push(reader.uint32());
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    WakuMetadataRequest2.encode = (obj) => {
      return encodeMessage(obj, WakuMetadataRequest2.codec());
    };
    WakuMetadataRequest2.decode = (buf, opts) => {
      return decodeMessage(buf, WakuMetadataRequest2.codec(), opts);
    };
  })(WakuMetadataRequest || (WakuMetadataRequest = {}));
  var WakuMetadataResponse;
  (function(WakuMetadataResponse2) {
    let _codec;
    WakuMetadataResponse2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.clusterId != null) {
            w2.uint32(8);
            w2.uint32(obj.clusterId);
          }
          if (obj.shards != null) {
            for (const value of obj.shards) {
              w2.uint32(16);
              w2.uint32(value);
            }
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            shards: []
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.clusterId = reader.uint32();
                break;
              }
              case 2: {
                if (opts.limits?.shards != null && obj.shards.length === opts.limits.shards) {
                  throw new MaxLengthError('Decode error - map field "shards" had too many elements');
                }
                obj.shards.push(reader.uint32());
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    WakuMetadataResponse2.encode = (obj) => {
      return encodeMessage(obj, WakuMetadataResponse2.codec());
    };
    WakuMetadataResponse2.decode = (buf, opts) => {
      return decodeMessage(buf, WakuMetadataResponse2.codec(), opts);
    };
  })(WakuMetadataResponse || (WakuMetadataResponse = {}));

  // ../node_modules/@waku/proto/dist/generated/sds_message.js
  var HistoryEntry;
  (function(HistoryEntry2) {
    let _codec;
    HistoryEntry2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.messageId != null && obj.messageId !== "") {
            w2.uint32(10);
            w2.string(obj.messageId);
          }
          if (obj.retrievalHint != null) {
            w2.uint32(18);
            w2.bytes(obj.retrievalHint);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            messageId: ""
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.messageId = reader.string();
                break;
              }
              case 2: {
                obj.retrievalHint = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    HistoryEntry2.encode = (obj) => {
      return encodeMessage(obj, HistoryEntry2.codec());
    };
    HistoryEntry2.decode = (buf, opts) => {
      return decodeMessage(buf, HistoryEntry2.codec(), opts);
    };
  })(HistoryEntry || (HistoryEntry = {}));
  var SdsMessage;
  (function(SdsMessage2) {
    let _codec;
    SdsMessage2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.senderId != null && obj.senderId !== "") {
            w2.uint32(10);
            w2.string(obj.senderId);
          }
          if (obj.messageId != null && obj.messageId !== "") {
            w2.uint32(18);
            w2.string(obj.messageId);
          }
          if (obj.channelId != null && obj.channelId !== "") {
            w2.uint32(26);
            w2.string(obj.channelId);
          }
          if (obj.lamportTimestamp != null) {
            w2.uint32(80);
            w2.int32(obj.lamportTimestamp);
          }
          if (obj.causalHistory != null) {
            for (const value of obj.causalHistory) {
              w2.uint32(90);
              HistoryEntry.codec().encode(value, w2);
            }
          }
          if (obj.bloomFilter != null) {
            w2.uint32(98);
            w2.bytes(obj.bloomFilter);
          }
          if (obj.content != null) {
            w2.uint32(162);
            w2.bytes(obj.content);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            senderId: "",
            messageId: "",
            channelId: "",
            causalHistory: []
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.senderId = reader.string();
                break;
              }
              case 2: {
                obj.messageId = reader.string();
                break;
              }
              case 3: {
                obj.channelId = reader.string();
                break;
              }
              case 10: {
                obj.lamportTimestamp = reader.int32();
                break;
              }
              case 11: {
                if (opts.limits?.causalHistory != null && obj.causalHistory.length === opts.limits.causalHistory) {
                  throw new MaxLengthError('Decode error - map field "causalHistory" had too many elements');
                }
                obj.causalHistory.push(HistoryEntry.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.causalHistory$
                }));
                break;
              }
              case 12: {
                obj.bloomFilter = reader.bytes();
                break;
              }
              case 20: {
                obj.content = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    SdsMessage2.encode = (obj) => {
      return encodeMessage(obj, SdsMessage2.codec());
    };
    SdsMessage2.decode = (buf, opts) => {
      return decodeMessage(buf, SdsMessage2.codec(), opts);
    };
  })(SdsMessage || (SdsMessage = {}));

  // ../node_modules/@waku/utils/dist/common/is_defined.js
  function isDefined(value) {
    return Boolean(value);
  }

  // ../node_modules/@waku/utils/dist/common/random_subset.js
  function shuffle(arr) {
    if (arr.length <= 1) {
      return arr;
    }
    const randInt = () => {
      return Math.floor(Math.random() * Math.floor(arr.length));
    };
    for (let i = 0; i < arr.length; i++) {
      const j = randInt();
      const tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
    }
    return arr;
  }

  // ../node_modules/@waku/utils/dist/common/is_size_valid.js
  var MB = 1024 ** 2;
  var SIZE_CAP_IN_MB = 1;
  async function isMessageSizeUnderCap(encoder3, message2) {
    const buf = await encoder3.toWire(message2);
    if (!buf)
      return false;
    return isWireSizeUnderCap(buf);
  }
  var isWireSizeUnderCap = (buf) => buf.length / MB <= SIZE_CAP_IN_MB;

  // ../node_modules/@noble/hashes/esm/_assert.js
  function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`Wrong positive integer: ${n}`);
  }
  function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  }
  function hash(hash2) {
    if (typeof hash2 !== "function" || typeof hash2.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash2.outputLen);
    number(hash2.blockLen);
  }
  function exists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }

  // ../node_modules/@noble/hashes/esm/crypto.js
  var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

  // ../node_modules/@noble/hashes/esm/utils.js
  var u8a = (a) => a instanceof Uint8Array;
  var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  var rotr = (word, shift) => word << 32 - shift | word >>> shift;
  var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!isLE)
    throw new Error("Non little-endian hardware is not supported");
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    if (!u8a(data))
      throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
  }
  function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0;
    arrays.forEach((a) => {
      if (!u8a(a))
        throw new Error("Uint8Array expected");
      r.set(a, pad);
      pad += a.length;
    });
    return r;
  }
  var Hash = class {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  };
  var toStr = {}.toString;
  function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function randomBytes(bytesLength = 32) {
    if (crypto2 && typeof crypto2.getRandomValues === "function") {
      return crypto2.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }

  // ../node_modules/@noble/hashes/esm/_sha2.js
  function setBigUint64(view, byteOffset, value, isLE3) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE3);
    const _32n4 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n4 & _u32_max);
    const wl = Number(value & _u32_max);
    const h2 = isLE3 ? 4 : 0;
    const l = isLE3 ? 0 : 4;
    view.setUint32(byteOffset + h2, wh, isLE3);
    view.setUint32(byteOffset + l, wl, isLE3);
  }
  var SHA2 = class extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE3) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE3;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      exists(this);
      const { view, buffer, blockLen } = this;
      data = toBytes(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take2 = Math.min(blockLen - this.pos, len - pos);
        if (take2 === blockLen) {
          const dataView = createView(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take2), this.pos);
        this.pos += take2;
        pos += take2;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      exists(this);
      output(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE3 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE3);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE3);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length: length21, finished, destroyed, pos } = this;
      to.length = length21;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length21 % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  };

  // ../node_modules/@noble/hashes/esm/sha256.js
  var Chi = (a, b, c) => a & b ^ ~a & c;
  var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
  var SHA256_K = /* @__PURE__ */ new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var IV = /* @__PURE__ */ new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  var SHA256 = class extends SHA2 {
    constructor() {
      super(64, 32, 8, false);
      this.A = IV[0] | 0;
      this.B = IV[1] | 0;
      this.C = IV[2] | 0;
      this.D = IV[3] | 0;
      this.E = IV[4] | 0;
      this.F = IV[5] | 0;
      this.G = IV[6] | 0;
      this.H = IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      SHA256_W.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  };
  var sha2562 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports2 = {};
  __export(base10_exports2, {
    base10: () => base102
  });

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/bytes.js
  var empty2 = new Uint8Array(0);
  function equals3(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce2(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function fromString3(str) {
    return new TextEncoder().encode(str);
  }
  function toString2(b) {
    return new TextDecoder().decode(b);
  }

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/vendor/base-x.js
  function base3(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src2 = base3;
  var _brrp__multiformats_scope_baseX2 = src2;
  var base_x_default2 = _brrp__multiformats_scope_baseX2;

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/bases/base.js
  var Encoder2 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder2 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or2(this, decoder);
    }
  };
  var ComposedDecoder2 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or2(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or2(left, right) {
    return new ComposedDecoder2({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec2 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder2(name19, prefix, baseEncode);
      this.decoder = new Decoder2(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from3({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec2(name19, prefix, encode79, decode99);
  }
  function baseX2({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default2(alphabet18, name19);
    return from3({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce2(decode99(text))
    });
  }
  function decode7(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode6(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx2(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc46482({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx2(alphabet18);
    return from3({
      prefix,
      name: name19,
      encode(input) {
        return encode6(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode7(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/bases/base10.js
  var base102 = baseX2({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports2 = {};
  __export(base16_exports2, {
    base16: () => base162,
    base16upper: () => base16upper2
  });
  var base162 = rfc46482({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper2 = rfc46482({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports2 = {};
  __export(base2_exports2, {
    base2: () => base22
  });
  var base22 = rfc46482({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports2 = {};
  __export(base256emoji_exports2, {
    base256emoji: () => base256emoji2
  });
  var alphabet2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars2 = alphabet2.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes2 = alphabet2.reduce((p, c, i) => {
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
  }, []);
  function encode7(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars2[c];
      return p;
    }, "");
  }
  function decode8(str) {
    const byts = [];
    for (const char of str) {
      const codePoint = char.codePointAt(0);
      if (codePoint == null) {
        throw new Error(`Invalid character: ${char}`);
      }
      const byt = alphabetCharsToBytes2[codePoint];
      if (byt == null) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji2 = from3({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode7,
    decode: decode8
  });

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports2 = {};
  __export(base32_exports2, {
    base32: () => base322,
    base32hex: () => base32hex2,
    base32hexpad: () => base32hexpad2,
    base32hexpadupper: () => base32hexpadupper2,
    base32hexupper: () => base32hexupper2,
    base32pad: () => base32pad2,
    base32padupper: () => base32padupper2,
    base32upper: () => base32upper2,
    base32z: () => base32z2
  });
  var base322 = rfc46482({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper2 = rfc46482({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad2 = rfc46482({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper2 = rfc46482({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex2 = rfc46482({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper2 = rfc46482({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad2 = rfc46482({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper2 = rfc46482({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z2 = rfc46482({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports2 = {};
  __export(base36_exports2, {
    base36: () => base362,
    base36upper: () => base36upper2
  });
  var base362 = baseX2({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper2 = baseX2({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports2 = {};
  __export(base58_exports2, {
    base58btc: () => base58btc2,
    base58flickr: () => base58flickr2
  });
  var base58btc2 = baseX2({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr2 = baseX2({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports2 = {};
  __export(base64_exports2, {
    base64: () => base642,
    base64pad: () => base64pad2,
    base64url: () => base64url2,
    base64urlpad: () => base64urlpad2
  });
  var base642 = rfc46482({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad2 = rfc46482({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url2 = rfc46482({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad2 = rfc46482({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports2 = {};
  __export(base8_exports2, {
    base8: () => base82
  });
  var base82 = rfc46482({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports3 = {};
  __export(identity_exports3, {
    identity: () => identity3
  });
  var identity3 = from3({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString2(buf),
    decode: (str) => fromString3(str)
  });

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/codecs/json.js
  var textEncoder2 = new TextEncoder();
  var textDecoder2 = new TextDecoder();

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports4 = {};
  __export(identity_exports4, {
    identity: () => identity4
  });

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_12 = encode8;
  var MSB3 = 128;
  var REST3 = 127;
  var MSBALL2 = ~REST3;
  var INT2 = Math.pow(2, 31);
  function encode8(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT2) {
      out[offset++] = num & 255 | MSB3;
      num /= 128;
    }
    while (num & MSBALL2) {
      out[offset++] = num & 255 | MSB3;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode8.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode9 = read3;
  var MSB$12 = 128;
  var REST$12 = 127;
  function read3(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read3.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$12);
    read3.bytes = counter - offset;
    return res;
  }
  var N13 = Math.pow(2, 7);
  var N23 = Math.pow(2, 14);
  var N33 = Math.pow(2, 21);
  var N43 = Math.pow(2, 28);
  var N53 = Math.pow(2, 35);
  var N63 = Math.pow(2, 42);
  var N73 = Math.pow(2, 49);
  var N82 = Math.pow(2, 56);
  var N92 = Math.pow(2, 63);
  var length3 = function(value) {
    return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N53 ? 5 : value < N63 ? 6 : value < N73 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
  };
  var varint2 = {
    encode: encode_12,
    decode: decode9,
    encodingLength: length3
  };
  var _brrp_varint2 = varint2;
  var varint_default2 = _brrp_varint2;

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/varint.js
  function decode10(data, offset = 0) {
    const code18 = varint_default2.decode(data, offset);
    return [code18, varint_default2.decode.bytes];
  }
  function encodeTo2(int, target, offset = 0) {
    varint_default2.encode(int, target, offset);
    return target;
  }
  function encodingLength3(int) {
    return varint_default2.encodingLength(int);
  }

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/hashes/digest.js
  function create2(code18, digest18) {
    const size = digest18.byteLength;
    const sizeOffset = encodingLength3(code18);
    const digestOffset = sizeOffset + encodingLength3(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo2(code18, bytes2, 0);
    encodeTo2(size, bytes2, sizeOffset);
    bytes2.set(digest18, digestOffset);
    return new Digest2(code18, size, digest18, bytes2);
  }
  function decode11(multihash) {
    const bytes2 = coerce2(multihash);
    const [code18, sizeOffset] = decode10(bytes2);
    const [size, digestOffset] = decode10(bytes2.subarray(sizeOffset));
    const digest18 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest18.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest2(code18, size, digest18, bytes2);
  }
  function equals4(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals3(a.bytes, data.bytes);
    }
  }
  var Digest2 = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code18, size, digest18, bytes2) {
      this.code = code18;
      this.size = size;
      this.digest = digest18;
      this.bytes = bytes2;
    }
  };

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/hashes/identity.js
  var code2 = 0;
  var name2 = "identity";
  var encode9 = coerce2;
  function digest2(input, options) {
    if (options?.truncate != null && options.truncate !== input.byteLength) {
      if (options.truncate < 0 || options.truncate > input.byteLength) {
        throw new Error(`Invalid truncate option, must be less than or equal to ${input.byteLength}`);
      }
      input = input.subarray(0, options.truncate);
    }
    return create2(code2, encode9(input));
  }
  var identity4 = { code: code2, name: name2, encode: encode9, digest: digest2 };

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports2 = {};
  __export(sha2_browser_exports2, {
    sha256: () => sha2563,
    sha512: () => sha5122
  });

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/hashes/hasher.js
  var DEFAULT_MIN_DIGEST_LENGTH = 20;
  function from4({ name: name19, code: code18, encode: encode79, minDigestLength, maxDigestLength }) {
    return new Hasher2(name19, code18, encode79, minDigestLength, maxDigestLength);
  }
  var Hasher2 = class {
    name;
    code;
    encode;
    minDigestLength;
    maxDigestLength;
    constructor(name19, code18, encode79, minDigestLength, maxDigestLength) {
      this.name = name19;
      this.code = code18;
      this.encode = encode79;
      this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH;
      this.maxDigestLength = maxDigestLength;
    }
    digest(input, options) {
      if (options?.truncate != null) {
        if (options.truncate < this.minDigestLength) {
          throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);
        }
        if (this.maxDigestLength != null && options.truncate > this.maxDigestLength) {
          throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`);
        }
      }
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        if (result instanceof Uint8Array) {
          return createDigest(result, this.code, options?.truncate);
        }
        return result.then((digest18) => createDigest(digest18, this.code, options?.truncate));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  function createDigest(digest18, code18, truncate) {
    if (truncate != null && truncate !== digest18.byteLength) {
      if (truncate > digest18.byteLength) {
        throw new Error(`Invalid truncate option, must be less than or equal to ${digest18.byteLength}`);
      }
      digest18 = digest18.subarray(0, truncate);
    }
    return create2(code18, digest18);
  }

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  function sha2(name19) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name19, data));
  }
  var sha2563 = from4({
    name: "sha2-256",
    code: 18,
    encode: sha2("SHA-256")
  });
  var sha5122 = from4({
    name: "sha2-512",
    code: 19,
    encode: sha2("SHA-512")
  });

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/cid.js
  function format2(link, base37) {
    const { bytes: bytes2, version: version5 } = link;
    switch (version5) {
      case 0:
        return toStringV02(bytes2, baseCache2(link), base37 ?? base58btc2.encoder);
      default:
        return toStringV12(bytes2, baseCache2(link), base37 ?? base322.encoder);
    }
  }
  var cache2 = /* @__PURE__ */ new WeakMap();
  function baseCache2(cid) {
    const baseCache19 = cache2.get(cid);
    if (baseCache19 == null) {
      const baseCache20 = /* @__PURE__ */ new Map();
      cache2.set(cid, baseCache20);
      return baseCache20;
    }
    return baseCache19;
  }
  var CID2 = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version5, code18, multihash, bytes2) {
      this.code = code18;
      this.version = version5;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code18, multihash } = this;
          if (code18 !== DAG_PB_CODE2) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE2) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code18, digest: digest18 } = this.multihash;
          const multihash = create2(code18, digest18);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals4(self2.multihash, unknown.multihash);
    }
    toString(base37) {
      return format2(this, base37);
    }
    toJSON() {
      return { "/": format2(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version5, code: code18, multihash, bytes: bytes2 } = value;
        return new _CID(version5, code18, multihash, bytes2 ?? encodeCID2(version5, code18, multihash.bytes));
      } else if (value[cidSymbol2] === true) {
        const { version: version5, multihash, code: code18 } = value;
        const digest18 = decode11(multihash);
        return _CID.create(version5, code18, digest18);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version5, code18, digest18) {
      if (typeof code18 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest18.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version5) {
        case 0: {
          if (code18 !== DAG_PB_CODE2) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`);
          } else {
            return new _CID(version5, code18, digest18, digest18.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID2(version5, code18, digest18.bytes);
          return new _CID(version5, code18, digest18, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest18) {
      return _CID.create(0, DAG_PB_CODE2, digest18);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code18, digest18) {
      return _CID.create(1, code18, digest18);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes2) {
      const [cid, remainder] = _CID.decodeFirst(bytes2);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes2) {
      const specs = _CID.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce2(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest18 = new Digest2(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest18) : _CID.createV1(specs.codec, digest18);
      return [cid, bytes2.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length21] = decode10(initialBytes.subarray(offset));
        offset += length21;
        return i;
      };
      let version5 = next();
      let codec = DAG_PB_CODE2;
      if (version5 === 18) {
        version5 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version5 !== 0 && version5 !== 1) {
        throw new RangeError(`Invalid CID version ${version5}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version5, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base37) {
      const [prefix, bytes2] = parseCIDtoBytes2(source, base37);
      const cid = _CID.decode(bytes2);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache2(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes2(source, base37) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base37 ?? base58btc2;
        return [
          base58btc2.prefix,
          decoder.decode(`${base58btc2.prefix}${source}`)
        ];
      }
      case base58btc2.prefix: {
        const decoder = base37 ?? base58btc2;
        return [base58btc2.prefix, decoder.decode(source)];
      }
      case base322.prefix: {
        const decoder = base37 ?? base322;
        return [base322.prefix, decoder.decode(source)];
      }
      case base362.prefix: {
        const decoder = base37 ?? base362;
        return [base362.prefix, decoder.decode(source)];
      }
      default: {
        if (base37 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base37.decode(source)];
      }
    }
  }
  function toStringV02(bytes2, cache20, base37) {
    const { prefix } = base37;
    if (prefix !== base58btc2.prefix) {
      throw Error(`Cannot string encode V0 in ${base37.name} encoding`);
    }
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2).slice(1);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV12(bytes2, cache20, base37) {
    const { prefix } = base37;
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE2 = 112;
  var SHA_256_CODE2 = 18;
  function encodeCID2(version5, code18, multihash) {
    const codeOffset = encodingLength3(version5);
    const hashOffset = codeOffset + encodingLength3(code18);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo2(version5, bytes2, 0);
    encodeTo2(code18, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  }
  var cidSymbol2 = Symbol.for("@ipld/js-cid/CID");

  // ../node_modules/@waku/utils/node_modules/multiformats/dist/src/basics.js
  var bases2 = { ...identity_exports3, ...base2_exports2, ...base8_exports2, ...base10_exports2, ...base16_exports2, ...base32_exports2, ...base36_exports2, ...base58_exports2, ...base64_exports2, ...base256emoji_exports2 };
  var hashes2 = { ...sha2_browser_exports2, ...identity_exports4 };

  // ../node_modules/@waku/utils/node_modules/uint8arrays/dist/src/alloc.js
  function allocUnsafe3(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/@waku/utils/node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec3(name19, prefix, encode79, decode99) {
    return {
      name: name19,
      prefix,
      encoder: {
        name: name19,
        prefix,
        encode: encode79
      },
      decoder: {
        decode: decode99
      }
    };
  }
  var string2 = createCodec3("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder3 = new TextEncoder();
    return encoder3.encode(str.substring(1));
  });
  var ascii2 = createCodec3("ascii", "a", (buf) => {
    let string19 = "a";
    for (let i = 0; i < buf.length; i++) {
      string19 += String.fromCharCode(buf[i]);
    }
    return string19;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe3(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  var BASES2 = {
    utf8: string2,
    "utf-8": string2,
    hex: bases2.base16,
    latin1: ascii2,
    ascii: ascii2,
    binary: ascii2,
    ...bases2
  };
  var bases_default2 = BASES2;

  // ../node_modules/@waku/utils/node_modules/uint8arrays/dist/src/from-string.js
  function fromString4(string19, encoding = "utf8") {
    const base37 = bases_default2[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.decoder.decode(`${base37.prefix}${string19}`);
  }

  // ../node_modules/@waku/utils/node_modules/uint8arrays/dist/src/to-string.js
  function toString3(array, encoding = "utf8") {
    const base37 = bases_default2[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.encoder.encode(array).substring(1);
  }

  // ../node_modules/@waku/utils/dist/bytes/index.js
  function hexToBytes(hex) {
    if (typeof hex === "string") {
      const _hex = hex.replace(/^0x/i, "");
      return fromString4(_hex.toLowerCase(), "base16");
    }
    return hex;
  }
  function numberToBytes(value) {
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);
    if (typeof value === "number") {
      view.setFloat64(0, value, false);
    } else {
      view.setBigInt64(0, value, false);
    }
    return new Uint8Array(buffer);
  }
  var bytesToHex = (bytes2) => toString3(bytes2, "base16");
  var bytesToUtf8 = (b) => toString3(b, "utf8");
  var utf8ToBytes2 = (s2) => fromString4(s2, "utf8");
  function concat(byteArrays, totalLength) {
    const len = totalLength ?? byteArrays.reduce((acc, curr) => acc + curr.length, 0);
    const res = new Uint8Array(len);
    let offset = 0;
    for (const bytes2 of byteArrays) {
      res.set(bytes2, offset);
      offset += bytes2.length;
    }
    return res;
  }

  // ../node_modules/@waku/utils/dist/common/sharding/type_guards.js
  function isAutoSharding(config) {
    return "clusterId" in config && "numShardsInCluster" in config;
  }

  // ../node_modules/@waku/utils/dist/common/sharding/routing_info.js
  var BaseRoutingInfo = class {
    networkConfig;
    pubsubTopic;
    shardId;
    constructor(networkConfig, pubsubTopic, shardId) {
      this.networkConfig = networkConfig;
      this.pubsubTopic = pubsubTopic;
      this.shardId = shardId;
    }
  };
  var AutoShardingRoutingInfo = class _AutoShardingRoutingInfo extends BaseRoutingInfo {
    networkConfig;
    pubsubTopic;
    shardId;
    contentTopic;
    static fromContentTopic(contentTopic, networkConfig) {
      ensureValidContentTopic(contentTopic);
      const shardId = contentTopicToShardIndex(contentTopic, networkConfig.numShardsInCluster);
      const pubsubTopic = formatPubsubTopic(networkConfig.clusterId, shardId);
      return new _AutoShardingRoutingInfo(networkConfig, pubsubTopic, shardId, contentTopic);
    }
    /**
     * No checks are done with this constructor,
     * Be sure you check that the network config (auto vs static)
     * matches other parameters.
     */
    constructor(networkConfig, pubsubTopic, shardId, contentTopic) {
      super(networkConfig, pubsubTopic, shardId);
      this.networkConfig = networkConfig;
      this.pubsubTopic = pubsubTopic;
      this.shardId = shardId;
      this.contentTopic = contentTopic;
    }
    get clusterId() {
      return this.networkConfig.clusterId;
    }
    get isAutoSharding() {
      return true;
    }
    get isStaticSharding() {
      return false;
    }
  };
  var StaticShardingRoutingInfo = class _StaticShardingRoutingInfo extends BaseRoutingInfo {
    networkConfig;
    pubsubTopic;
    shardId;
    /**
     * Create Routing Info for static sharding network, using shard
     *
     * @param shardId
     * @param networkConfig
     */
    static fromShard(shardId, networkConfig) {
      const pubsubTopic = formatPubsubTopic(networkConfig.clusterId, shardId);
      return new _StaticShardingRoutingInfo(networkConfig, pubsubTopic, shardId);
    }
    /**
     * Create Routing Info for static sharding network, using pubsub topic
     *
     * @param pubsubTopic
     * @param networkConfig
     *
     * @throws if the pubsub topic is malformed, or does not match the network config
     */
    static fromPubsubTopic(pubsubTopic, networkConfig) {
      const { clusterId, shard } = pubsubTopicToSingleShardInfo(pubsubTopic);
      if (clusterId != networkConfig.clusterId)
        throw "Pubsub topic does not match network config's cluster id";
      return new _StaticShardingRoutingInfo(networkConfig, pubsubTopic, shard);
    }
    /**
     * No checks are done with this constructor,
     * Be sure you check that the network config (auto vs static)
     * matches other parameters.
     */
    constructor(networkConfig, pubsubTopic, shardId) {
      super(networkConfig, pubsubTopic, shardId);
      this.networkConfig = networkConfig;
      this.pubsubTopic = pubsubTopic;
      this.shardId = shardId;
    }
    get clusterId() {
      return this.networkConfig.clusterId;
    }
    get isAutoSharding() {
      return false;
    }
    get isStaticSharding() {
      return true;
    }
  };
  function createRoutingInfo(networkConfig, options) {
    if (isAutoSharding(networkConfig)) {
      if (options.contentTopic) {
        return AutoShardingRoutingInfo.fromContentTopic(options.contentTopic, networkConfig);
      }
      throw new Error("AutoSharding requires contentTopic");
    } else {
      if (options.shardId !== void 0) {
        return StaticShardingRoutingInfo.fromShard(options.shardId, networkConfig);
      } else if (options.pubsubTopic) {
        return StaticShardingRoutingInfo.fromPubsubTopic(options.pubsubTopic, networkConfig);
      }
      throw new Error("StaticSharding requires shardId or pubsubTopic");
    }
  }

  // ../node_modules/@waku/utils/dist/common/sharding/index.js
  var formatPubsubTopic = (clusterId, shard) => {
    return `/waku/2/rs/${clusterId}/${shard}`;
  };
  var pubsubTopicToSingleShardInfo = (pubsubTopics) => {
    const parts = pubsubTopics.split("/");
    if (parts.length != 6 || parts[1] !== "waku" || parts[2] !== "2" || parts[3] !== "rs")
      throw new Error("Invalid pubsub topic");
    const clusterId = parseInt(parts[4]);
    const shard = parseInt(parts[5]);
    if (isNaN(clusterId) || isNaN(shard))
      throw new Error("Invalid clusterId or shard");
    return {
      clusterId,
      shard
    };
  };
  function ensureValidContentTopic(contentTopic) {
    const parts = contentTopic.split("/");
    if (parts.length < 5 || parts.length > 6) {
      throw Error(`Content topic format is invalid: ${contentTopic}`);
    }
    let generation = 0;
    if (parts.length == 6) {
      generation = parseInt(parts[1]);
      if (isNaN(generation)) {
        throw new Error(`Invalid generation field in content topic: ${contentTopic}`);
      }
      if (generation > 0) {
        throw new Error(`Generation greater than 0 is not supported: ${contentTopic}`);
      }
    }
    const fields = parts.splice(-4);
    if (fields[0].length == 0) {
      throw new Error(`Application field cannot be empty: ${contentTopic}`);
    }
    if (fields[1].length == 0) {
      throw new Error(`Version field cannot be empty: ${contentTopic}`);
    }
    if (fields[2].length == 0) {
      throw new Error(`Topic name field cannot be empty: ${contentTopic}`);
    }
    if (fields[3].length == 0) {
      throw new Error(`Encoding field cannot be empty: ${contentTopic}`);
    }
    return {
      generation,
      application: fields[0],
      version: fields[1],
      topicName: fields[2],
      encoding: fields[3]
    };
  }
  function contentTopicToShardIndex(contentTopic, numShardsInCluster) {
    const { application, version: version5 } = ensureValidContentTopic(contentTopic);
    const digest18 = sha2562(concat([utf8ToBytes2(application), utf8ToBytes2(version5)]));
    const dataview = new DataView(digest18.buffer.slice(-8));
    return Number(dataview.getBigUint64(0, false) % BigInt(numShardsInCluster));
  }

  // ../node_modules/@waku/utils/dist/common/relay_shard_codec.js
  var decodeRelayShard = (bytes2) => {
    bytes2 = new Uint8Array(bytes2);
    if (bytes2.length < 3)
      throw new Error("Insufficient data");
    const view = new DataView(bytes2.buffer);
    const clusterId = view.getUint16(0);
    const shards = [];
    if (bytes2.length === 130) {
      for (let i = 0; i < 1024; i++) {
        const byteIndex = Math.floor(i / 8) + 2;
        const bitIndex = 7 - i % 8;
        if (view.getUint8(byteIndex) & 1 << bitIndex) {
          shards.push(i);
        }
      }
    } else {
      const numIndices = view.getUint8(2);
      for (let i = 0, offset = 3; i < numIndices; i++, offset += 2) {
        if (offset + 1 >= bytes2.length)
          throw new Error("Unexpected end of data");
        shards.push(view.getUint16(offset));
      }
    }
    return { clusterId, shards };
  };
  var encodeRelayShard = (shardInfo) => {
    const { clusterId, shards } = shardInfo;
    const totalLength = shards.length >= 64 ? 130 : 3 + 2 * shards.length;
    const buffer = new ArrayBuffer(totalLength);
    const view = new DataView(buffer);
    view.setUint16(0, clusterId);
    if (shards.length >= 64) {
      for (const index of shards) {
        const byteIndex = Math.floor(index / 8) + 2;
        const bitIndex = 7 - index % 8;
        view.setUint8(byteIndex, view.getUint8(byteIndex) | 1 << bitIndex);
      }
    } else {
      view.setUint8(2, shards.length);
      for (let i = 0, offset = 3; i < shards.length; i++, offset += 2) {
        view.setUint16(offset, shards[i]);
      }
    }
    return new Uint8Array(buffer);
  };

  // ../node_modules/@waku/utils/dist/logger.js
  var import_debug = __toESM(require_browser(), 1);
  var APP_NAME = "waku";
  var Logger = class _Logger {
    _info;
    _warn;
    _error;
    static createDebugNamespace(level, prefix) {
      return prefix ? `${APP_NAME}:${prefix}:${level}` : `${APP_NAME}:${level}`;
    }
    constructor(prefix) {
      this._info = (0, import_debug.default)(_Logger.createDebugNamespace("info", prefix));
      this._warn = (0, import_debug.default)(_Logger.createDebugNamespace("warn", prefix));
      this._error = (0, import_debug.default)(_Logger.createDebugNamespace("error", prefix));
    }
    get info() {
      return this._info;
    }
    get warn() {
      return this._warn;
    }
    get error() {
      return this._error;
    }
    log(level, ...args) {
      const logger5 = this[level] || this.log;
      logger5(...args);
    }
  };

  // ../node_modules/@waku/core/dist/lib/message/version_0.js
  var log = new Logger("message:version-0");
  var OneMillion = BigInt(1e6);
  var Version = 0;
  var DecodedMessage = class {
    pubsubTopic;
    proto;
    constructor(pubsubTopic, proto) {
      this.pubsubTopic = pubsubTopic;
      this.proto = proto;
    }
    get ephemeral() {
      return Boolean(this.proto.ephemeral);
    }
    get payload() {
      return this.proto.payload;
    }
    get contentTopic() {
      return this.proto.contentTopic;
    }
    get timestamp() {
      try {
        if (this.proto.timestamp) {
          const timestamp = this.proto.timestamp / OneMillion;
          return new Date(Number(timestamp));
        }
        return;
      } catch (e) {
        return;
      }
    }
    get meta() {
      return this.proto.meta;
    }
    get version() {
      return this.proto.version ?? Version;
    }
    get rateLimitProof() {
      return this.proto.rateLimitProof;
    }
  };
  var Encoder3 = class {
    contentTopic;
    ephemeral;
    routingInfo;
    metaSetter;
    constructor(contentTopic, ephemeral = false, routingInfo, metaSetter) {
      this.contentTopic = contentTopic;
      this.ephemeral = ephemeral;
      this.routingInfo = routingInfo;
      this.metaSetter = metaSetter;
      if (!contentTopic || contentTopic === "") {
        throw new Error("Content topic must be specified");
      }
    }
    get pubsubTopic() {
      return this.routingInfo.pubsubTopic;
    }
    async toWire(message2) {
      return message_exports.WakuMessage.encode(await this.toProtoObj(message2));
    }
    async toProtoObj(message2) {
      const timestamp = message2.timestamp ?? /* @__PURE__ */ new Date();
      const protoMessage = {
        payload: message2.payload,
        version: Version,
        contentTopic: this.contentTopic,
        timestamp: BigInt(timestamp.valueOf()) * OneMillion,
        meta: void 0,
        rateLimitProof: message2.rateLimitProof,
        ephemeral: this.ephemeral
      };
      if (this.metaSetter) {
        const meta = this.metaSetter(protoMessage);
        return { ...protoMessage, meta };
      }
      return protoMessage;
    }
  };
  function createEncoder({ contentTopic, routingInfo, ephemeral, metaSetter }) {
    return new Encoder3(contentTopic, ephemeral, routingInfo, metaSetter);
  }
  var Decoder3 = class {
    contentTopic;
    routingInfo;
    constructor(contentTopic, routingInfo) {
      this.contentTopic = contentTopic;
      this.routingInfo = routingInfo;
      if (!contentTopic || contentTopic === "") {
        throw new Error("Content topic must be specified");
      }
    }
    get pubsubTopic() {
      return this.routingInfo.pubsubTopic;
    }
    fromWireToProtoObj(bytes2) {
      const protoMessage = message_exports.WakuMessage.decode(bytes2);
      return Promise.resolve({
        payload: protoMessage.payload,
        contentTopic: protoMessage.contentTopic,
        version: protoMessage.version ?? void 0,
        timestamp: protoMessage.timestamp ?? void 0,
        meta: protoMessage.meta ?? void 0,
        rateLimitProof: protoMessage.rateLimitProof ?? void 0,
        ephemeral: protoMessage.ephemeral ?? false
      });
    }
    async fromProtoObj(pubsubTopic, proto) {
      if (proto.version ?? 0 !== Version) {
        log.error("Failed to decode due to incorrect version, expected:", Version, ", actual:", proto.version);
        return Promise.resolve(void 0);
      }
      return new DecodedMessage(pubsubTopic, proto);
    }
  };
  function createDecoder(contentTopic, routingInfo) {
    return new Decoder3(contentTopic, routingInfo);
  }

  // ../node_modules/@waku/interfaces/dist/protocols.js
  var Protocols;
  (function(Protocols2) {
    Protocols2["Relay"] = "relay";
    Protocols2["Store"] = "store";
    Protocols2["LightPush"] = "lightpush";
    Protocols2["Filter"] = "filter";
  })(Protocols || (Protocols = {}));
  var ProtocolError;
  (function(ProtocolError3) {
    ProtocolError3["GENERIC_FAIL"] = "Generic error";
    ProtocolError3["REMOTE_PEER_REJECTED"] = "Remote peer rejected";
    ProtocolError3["DECODE_FAILED"] = "Failed to decode";
    ProtocolError3["NO_PEER_AVAILABLE"] = "No peer available";
    ProtocolError3["NO_STREAM_AVAILABLE"] = "No stream available";
    ProtocolError3["NO_RESPONSE"] = "No response received";
    ProtocolError3["ENCODE_FAILED"] = "Failed to encode";
    ProtocolError3["EMPTY_PAYLOAD"] = "Payload is empty";
    ProtocolError3["SIZE_TOO_BIG"] = "Size is too big";
    ProtocolError3["TOPIC_NOT_CONFIGURED"] = "Topic not configured";
    ProtocolError3["STREAM_ABORTED"] = "Stream aborted";
    ProtocolError3["RLN_PROOF_GENERATION"] = "Proof generation failed";
    ProtocolError3["TOPIC_DECODER_MISMATCH"] = "Topic decoder mismatch";
    ProtocolError3["INVALID_DECODER_TOPICS"] = "Invalid decoder topics";
  })(ProtocolError || (ProtocolError = {}));

  // ../node_modules/@waku/interfaces/dist/connection_manager.js
  var Tags;
  (function(Tags2) {
    Tags2["BOOTSTRAP"] = "bootstrap";
    Tags2["PEER_EXCHANGE"] = "peer-exchange";
    Tags2["PEER_CACHE"] = "peer-cache";
  })(Tags || (Tags = {}));
  var CONNECTION_LOCKED_TAG = "locked";

  // ../node_modules/@waku/interfaces/dist/dns_discovery.js
  var DNS_DISCOVERY_TAG = "@waku/bootstrap";

  // ../node_modules/@waku/interfaces/dist/constants.js
  var DEFAULT_CLUSTER_ID = 1;
  var DEFAULT_NUM_SHARDS = 8;
  var DefaultNetworkConfig = {
    clusterId: DEFAULT_CLUSTER_ID,
    numShardsInCluster: DEFAULT_NUM_SHARDS
  };

  // ../node_modules/@waku/interfaces/dist/health_status.js
  var HealthStatus;
  (function(HealthStatus2) {
    HealthStatus2["Unhealthy"] = "Unhealthy";
    HealthStatus2["MinimallyHealthy"] = "MinimallyHealthy";
    HealthStatus2["SufficientlyHealthy"] = "SufficientlyHealthy";
  })(HealthStatus || (HealthStatus = {}));

  // ../node_modules/it-all/dist/src/index.js
  function isAsyncIterable(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function all(source) {
    if (isAsyncIterable(source)) {
      return (async () => {
        const arr2 = [];
        for await (const entry of source) {
          arr2.push(entry);
        }
        return arr2;
      })();
    }
    const arr = [];
    for (const entry of source) {
      arr.push(entry);
    }
    return arr;
  }
  var src_default = all;

  // ../node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/alloc.js
  function alloc3(size = 0) {
    return new Uint8Array(size);
  }
  function allocUnsafe4(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/util/as-uint8array.js
  function asUint8Array2(buf) {
    return buf;
  }

  // ../node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/concat.js
  function concat2(arrays, length21) {
    if (length21 == null) {
      length21 = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output2 = allocUnsafe4(length21);
    let offset = 0;
    for (const arr of arrays) {
      output2.set(arr, offset);
      offset += arr.length;
    }
    return asUint8Array2(output2);
  }

  // ../node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/equals.js
  function equals5(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }

  // ../node_modules/uint8arraylist/dist/src/index.js
  var symbol = Symbol.for("@achingbrain/uint8arraylist");
  function findBufAndOffset(bufs, index) {
    if (index == null || index < 0) {
      throw new RangeError("index is out of bounds");
    }
    let offset = 0;
    for (const buf of bufs) {
      const bufEnd = offset + buf.byteLength;
      if (index < bufEnd) {
        return {
          buf,
          index: index - offset
        };
      }
      offset = bufEnd;
    }
    throw new RangeError("index is out of bounds");
  }
  function isUint8ArrayList(value) {
    return Boolean(value?.[symbol]);
  }
  var Uint8ArrayList = class _Uint8ArrayList {
    bufs;
    length;
    [symbol] = true;
    constructor(...data) {
      this.bufs = [];
      this.length = 0;
      if (data.length > 0) {
        this.appendAll(data);
      }
    }
    *[Symbol.iterator]() {
      yield* this.bufs;
    }
    get byteLength() {
      return this.length;
    }
    /**
     * Add one or more `bufs` to the end of this Uint8ArrayList
     */
    append(...bufs) {
      this.appendAll(bufs);
    }
    /**
     * Add all `bufs` to the end of this Uint8ArrayList
     */
    appendAll(bufs) {
      let length21 = 0;
      for (const buf of bufs) {
        if (buf instanceof Uint8Array) {
          length21 += buf.byteLength;
          this.bufs.push(buf);
        } else if (isUint8ArrayList(buf)) {
          length21 += buf.byteLength;
          this.bufs.push(...buf.bufs);
        } else {
          throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
        }
      }
      this.length += length21;
    }
    /**
     * Add one or more `bufs` to the start of this Uint8ArrayList
     */
    prepend(...bufs) {
      this.prependAll(bufs);
    }
    /**
     * Add all `bufs` to the start of this Uint8ArrayList
     */
    prependAll(bufs) {
      let length21 = 0;
      for (const buf of bufs.reverse()) {
        if (buf instanceof Uint8Array) {
          length21 += buf.byteLength;
          this.bufs.unshift(buf);
        } else if (isUint8ArrayList(buf)) {
          length21 += buf.byteLength;
          this.bufs.unshift(...buf.bufs);
        } else {
          throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
        }
      }
      this.length += length21;
    }
    /**
     * Read the value at `index`
     */
    get(index) {
      const res = findBufAndOffset(this.bufs, index);
      return res.buf[res.index];
    }
    /**
     * Set the value at `index` to `value`
     */
    set(index, value) {
      const res = findBufAndOffset(this.bufs, index);
      res.buf[res.index] = value;
    }
    /**
     * Copy bytes from `buf` to the index specified by `offset`
     */
    write(buf, offset = 0) {
      if (buf instanceof Uint8Array) {
        for (let i = 0; i < buf.length; i++) {
          this.set(offset + i, buf[i]);
        }
      } else if (isUint8ArrayList(buf)) {
        for (let i = 0; i < buf.length; i++) {
          this.set(offset + i, buf.get(i));
        }
      } else {
        throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    /**
     * Remove bytes from the front of the pool
     */
    consume(bytes2) {
      bytes2 = Math.trunc(bytes2);
      if (Number.isNaN(bytes2) || bytes2 <= 0) {
        return;
      }
      if (bytes2 === this.byteLength) {
        this.bufs = [];
        this.length = 0;
        return;
      }
      while (this.bufs.length > 0) {
        if (bytes2 >= this.bufs[0].byteLength) {
          bytes2 -= this.bufs[0].byteLength;
          this.length -= this.bufs[0].byteLength;
          this.bufs.shift();
        } else {
          this.bufs[0] = this.bufs[0].subarray(bytes2);
          this.length -= bytes2;
          break;
        }
      }
    }
    /**
     * Extracts a section of an array and returns a new array.
     *
     * This is a copy operation as it is with Uint8Arrays and Arrays
     * - note this is different to the behaviour of Node Buffers.
     */
    slice(beginInclusive, endExclusive) {
      const { bufs, length: length21 } = this._subList(beginInclusive, endExclusive);
      return concat2(bufs, length21);
    }
    /**
     * Returns a alloc from the given start and end element index.
     *
     * In the best case where the data extracted comes from a single Uint8Array
     * internally this is a no-copy operation otherwise it is a copy operation.
     */
    subarray(beginInclusive, endExclusive) {
      const { bufs, length: length21 } = this._subList(beginInclusive, endExclusive);
      if (bufs.length === 1) {
        return bufs[0];
      }
      return concat2(bufs, length21);
    }
    /**
     * Returns a allocList from the given start and end element index.
     *
     * This is a no-copy operation.
     */
    sublist(beginInclusive, endExclusive) {
      const { bufs, length: length21 } = this._subList(beginInclusive, endExclusive);
      const list = new _Uint8ArrayList();
      list.length = length21;
      list.bufs = [...bufs];
      return list;
    }
    _subList(beginInclusive, endExclusive) {
      beginInclusive = beginInclusive ?? 0;
      endExclusive = endExclusive ?? this.length;
      if (beginInclusive < 0) {
        beginInclusive = this.length + beginInclusive;
      }
      if (endExclusive < 0) {
        endExclusive = this.length + endExclusive;
      }
      if (beginInclusive < 0 || endExclusive > this.length) {
        throw new RangeError("index is out of bounds");
      }
      if (beginInclusive === endExclusive) {
        return { bufs: [], length: 0 };
      }
      if (beginInclusive === 0 && endExclusive === this.length) {
        return { bufs: this.bufs, length: this.length };
      }
      const bufs = [];
      let offset = 0;
      for (let i = 0; i < this.bufs.length; i++) {
        const buf = this.bufs[i];
        const bufStart = offset;
        const bufEnd = bufStart + buf.byteLength;
        offset = bufEnd;
        if (beginInclusive >= bufEnd) {
          continue;
        }
        const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
        const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
        if (sliceStartInBuf && sliceEndsInBuf) {
          if (beginInclusive === bufStart && endExclusive === bufEnd) {
            bufs.push(buf);
            break;
          }
          const start2 = beginInclusive - bufStart;
          bufs.push(buf.subarray(start2, start2 + (endExclusive - beginInclusive)));
          break;
        }
        if (sliceStartInBuf) {
          if (beginInclusive === 0) {
            bufs.push(buf);
            continue;
          }
          bufs.push(buf.subarray(beginInclusive - bufStart));
          continue;
        }
        if (sliceEndsInBuf) {
          if (endExclusive === bufEnd) {
            bufs.push(buf);
            break;
          }
          bufs.push(buf.subarray(0, endExclusive - bufStart));
          break;
        }
        bufs.push(buf);
      }
      return { bufs, length: endExclusive - beginInclusive };
    }
    indexOf(search, offset = 0) {
      if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {
        throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
      }
      const needle = search instanceof Uint8Array ? search : search.subarray();
      offset = Number(offset ?? 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const M = needle.byteLength;
      if (M === 0) {
        throw new TypeError("search must be at least 1 byte long");
      }
      const radix = 256;
      const rightmostPositions = new Int32Array(radix);
      for (let c = 0; c < radix; c++) {
        rightmostPositions[c] = -1;
      }
      for (let j = 0; j < M; j++) {
        rightmostPositions[needle[j]] = j;
      }
      const right = rightmostPositions;
      const lastIndex = this.byteLength - needle.byteLength;
      const lastPatIndex = needle.byteLength - 1;
      let skip;
      for (let i = offset; i <= lastIndex; i += skip) {
        skip = 0;
        for (let j = lastPatIndex; j >= 0; j--) {
          const char = this.get(i + j);
          if (needle[j] !== char) {
            skip = Math.max(1, j - right[char]);
            break;
          }
        }
        if (skip === 0) {
          return i;
        }
      }
      return -1;
    }
    getInt8(byteOffset) {
      const buf = this.subarray(byteOffset, byteOffset + 1);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getInt8(0);
    }
    setInt8(byteOffset, value) {
      const buf = allocUnsafe4(1);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setInt8(0, value);
      this.write(buf, byteOffset);
    }
    getInt16(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 2);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getInt16(0, littleEndian);
    }
    setInt16(byteOffset, value, littleEndian) {
      const buf = alloc3(2);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setInt16(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getInt32(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 4);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getInt32(0, littleEndian);
    }
    setInt32(byteOffset, value, littleEndian) {
      const buf = alloc3(4);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setInt32(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getBigInt64(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 8);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getBigInt64(0, littleEndian);
    }
    setBigInt64(byteOffset, value, littleEndian) {
      const buf = alloc3(8);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setBigInt64(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getUint8(byteOffset) {
      const buf = this.subarray(byteOffset, byteOffset + 1);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getUint8(0);
    }
    setUint8(byteOffset, value) {
      const buf = allocUnsafe4(1);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setUint8(0, value);
      this.write(buf, byteOffset);
    }
    getUint16(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 2);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getUint16(0, littleEndian);
    }
    setUint16(byteOffset, value, littleEndian) {
      const buf = alloc3(2);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setUint16(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getUint32(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 4);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getUint32(0, littleEndian);
    }
    setUint32(byteOffset, value, littleEndian) {
      const buf = alloc3(4);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setUint32(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getBigUint64(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 8);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getBigUint64(0, littleEndian);
    }
    setBigUint64(byteOffset, value, littleEndian) {
      const buf = alloc3(8);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setBigUint64(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getFloat32(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 4);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getFloat32(0, littleEndian);
    }
    setFloat32(byteOffset, value, littleEndian) {
      const buf = alloc3(4);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setFloat32(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getFloat64(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 8);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getFloat64(0, littleEndian);
    }
    setFloat64(byteOffset, value, littleEndian) {
      const buf = alloc3(8);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setFloat64(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    equals(other) {
      if (other == null) {
        return false;
      }
      if (!(other instanceof _Uint8ArrayList)) {
        return false;
      }
      if (other.bufs.length !== this.bufs.length) {
        return false;
      }
      for (let i = 0; i < this.bufs.length; i++) {
        if (!equals5(this.bufs[i], other.bufs[i])) {
          return false;
        }
      }
      return true;
    }
    /**
     * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this
     * method if you know the total size of all the Uint8Arrays ahead of time.
     */
    static fromUint8Arrays(bufs, length21) {
      const list = new _Uint8ArrayList();
      list.bufs = bufs;
      if (length21 == null) {
        length21 = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);
      }
      list.length = length21;
      return list;
    }
  };

  // ../node_modules/@waku/core/node_modules/uint8arrays/dist/src/alloc.js
  function allocUnsafe5(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/@waku/core/node_modules/it-length-prefixed/dist/src/utils.js
  function isAsyncIterable2(thing) {
    return thing[Symbol.asyncIterator] != null;
  }

  // ../node_modules/@waku/core/node_modules/it-length-prefixed/dist/src/encode.js
  var defaultEncoder = (length21) => {
    const lengthLength = encodingLength(length21);
    const lengthBuf = allocUnsafe5(lengthLength);
    encode(length21, lengthBuf);
    defaultEncoder.bytes = lengthLength;
    return lengthBuf;
  };
  defaultEncoder.bytes = 0;
  function encode10(source, options) {
    options = options ?? {};
    const encodeLength3 = options.lengthEncoder ?? defaultEncoder;
    function* maybeYield(chunk) {
      const length21 = encodeLength3(chunk.byteLength);
      if (length21 instanceof Uint8Array) {
        yield length21;
      } else {
        yield* length21;
      }
      if (chunk instanceof Uint8Array) {
        yield chunk;
      } else {
        yield* chunk;
      }
    }
    if (isAsyncIterable2(source)) {
      return (async function* () {
        for await (const chunk of source) {
          yield* maybeYield(chunk);
        }
      })();
    }
    return (function* () {
      for (const chunk of source) {
        yield* maybeYield(chunk);
      }
    })();
  }
  encode10.single = (chunk, options) => {
    options = options ?? {};
    const encodeLength3 = options.lengthEncoder ?? defaultEncoder;
    return new Uint8ArrayList(encodeLength3(chunk.byteLength), chunk);
  };

  // ../node_modules/@waku/core/node_modules/it-length-prefixed/dist/src/errors.js
  var InvalidMessageLengthError = class extends Error {
    name = "InvalidMessageLengthError";
    code = "ERR_INVALID_MSG_LENGTH";
  };
  var InvalidDataLengthError = class extends Error {
    name = "InvalidDataLengthError";
    code = "ERR_MSG_DATA_TOO_LONG";
  };
  var InvalidDataLengthLengthError = class extends Error {
    name = "InvalidDataLengthLengthError";
    code = "ERR_MSG_LENGTH_TOO_LONG";
  };
  var UnexpectedEOFError = class extends Error {
    name = "UnexpectedEOFError";
    code = "ERR_UNEXPECTED_EOF";
  };

  // ../node_modules/@waku/core/node_modules/it-length-prefixed/dist/src/decode.js
  var MAX_LENGTH_LENGTH = 8;
  var MAX_DATA_LENGTH = 1024 * 1024 * 4;
  var ReadMode;
  (function(ReadMode3) {
    ReadMode3[ReadMode3["LENGTH"] = 0] = "LENGTH";
    ReadMode3[ReadMode3["DATA"] = 1] = "DATA";
  })(ReadMode || (ReadMode = {}));
  var defaultDecoder = (buf) => {
    const length21 = decode(buf);
    defaultDecoder.bytes = encodingLength(length21);
    return length21;
  };
  defaultDecoder.bytes = 0;
  function decode12(source, options) {
    const buffer = new Uint8ArrayList();
    let mode = ReadMode.LENGTH;
    let dataLength = -1;
    const lengthDecoder = options?.lengthDecoder ?? defaultDecoder;
    const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH;
    const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH;
    function* maybeYield() {
      while (buffer.byteLength > 0) {
        if (mode === ReadMode.LENGTH) {
          try {
            dataLength = lengthDecoder(buffer);
            if (dataLength < 0) {
              throw new InvalidMessageLengthError("Invalid message length");
            }
            if (dataLength > maxDataLength) {
              throw new InvalidDataLengthError("Message length too long");
            }
            const dataLengthLength = lengthDecoder.bytes;
            buffer.consume(dataLengthLength);
            if (options?.onLength != null) {
              options.onLength(dataLength);
            }
            mode = ReadMode.DATA;
          } catch (err) {
            if (err instanceof RangeError) {
              if (buffer.byteLength > maxLengthLength) {
                throw new InvalidDataLengthLengthError("Message length length too long");
              }
              break;
            }
            throw err;
          }
        }
        if (mode === ReadMode.DATA) {
          if (buffer.byteLength < dataLength) {
            break;
          }
          const data = buffer.sublist(0, dataLength);
          buffer.consume(dataLength);
          if (options?.onData != null) {
            options.onData(data);
          }
          yield data;
          mode = ReadMode.LENGTH;
        }
      }
    }
    if (isAsyncIterable2(source)) {
      return (async function* () {
        for await (const buf of source) {
          buffer.append(buf);
          yield* maybeYield();
        }
        if (buffer.byteLength > 0) {
          throw new UnexpectedEOFError("Unexpected end of input");
        }
      })();
    }
    return (function* () {
      for (const buf of source) {
        buffer.append(buf);
        yield* maybeYield();
      }
      if (buffer.byteLength > 0) {
        throw new UnexpectedEOFError("Unexpected end of input");
      }
    })();
  }
  decode12.fromReader = (reader, options) => {
    let byteLength = 1;
    const varByteSource = (async function* () {
      while (true) {
        try {
          const { done, value } = await reader.next(byteLength);
          if (done === true) {
            return;
          }
          if (value != null) {
            yield value;
          }
        } catch (err) {
          if (err.code === "ERR_UNDER_READ") {
            return { done: true, value: null };
          }
          throw err;
        } finally {
          byteLength = 1;
        }
      }
    })();
    const onLength = (l) => {
      byteLength = l;
    };
    return decode12(varByteSource, {
      ...options ?? {},
      onLength
    });
  };

  // ../node_modules/p-defer/index.js
  function pDefer() {
    const deferred = {};
    deferred.promise = new Promise((resolve, reject) => {
      deferred.resolve = resolve;
      deferred.reject = reject;
    });
    return deferred;
  }

  // ../node_modules/it-pushable/dist/src/fifo.js
  var FixedFIFO = class {
    buffer;
    mask;
    top;
    btm;
    next;
    constructor(hwm) {
      if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
        throw new Error("Max size for a FixedFIFO should be a power of two");
      }
      this.buffer = new Array(hwm);
      this.mask = hwm - 1;
      this.top = 0;
      this.btm = 0;
      this.next = null;
    }
    push(data) {
      if (this.buffer[this.top] !== void 0) {
        return false;
      }
      this.buffer[this.top] = data;
      this.top = this.top + 1 & this.mask;
      return true;
    }
    shift() {
      const last = this.buffer[this.btm];
      if (last === void 0) {
        return void 0;
      }
      this.buffer[this.btm] = void 0;
      this.btm = this.btm + 1 & this.mask;
      return last;
    }
    isEmpty() {
      return this.buffer[this.btm] === void 0;
    }
  };
  var FIFO = class {
    size;
    hwm;
    head;
    tail;
    constructor(options = {}) {
      this.hwm = options.splitLimit ?? 16;
      this.head = new FixedFIFO(this.hwm);
      this.tail = this.head;
      this.size = 0;
    }
    calculateSize(obj) {
      if (obj?.byteLength != null) {
        return obj.byteLength;
      }
      return 1;
    }
    push(val) {
      if (val?.value != null) {
        this.size += this.calculateSize(val.value);
      }
      if (!this.head.push(val)) {
        const prev = this.head;
        this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
        this.head.push(val);
      }
    }
    shift() {
      let val = this.tail.shift();
      if (val === void 0 && this.tail.next != null) {
        const next = this.tail.next;
        this.tail.next = null;
        this.tail = next;
        val = this.tail.shift();
      }
      if (val?.value != null) {
        this.size -= this.calculateSize(val.value);
      }
      return val;
    }
    isEmpty() {
      return this.head.isEmpty();
    }
  };

  // ../node_modules/it-pushable/dist/src/index.js
  var AbortError = class extends Error {
    type;
    code;
    constructor(message2, code18) {
      super(message2 ?? "The operation was aborted");
      this.type = "aborted";
      this.code = code18 ?? "ABORT_ERR";
    }
  };
  function pushable(options = {}) {
    const getNext = (buffer) => {
      const next = buffer.shift();
      if (next == null) {
        return { done: true };
      }
      if (next.error != null) {
        throw next.error;
      }
      return {
        done: next.done === true,
        // @ts-expect-error if done is false, value will be present
        value: next.value
      };
    };
    return _pushable(getNext, options);
  }
  function _pushable(getNext, options) {
    options = options ?? {};
    let onEnd = options.onEnd;
    let buffer = new FIFO();
    let pushable2;
    let onNext;
    let ended;
    let drain2 = pDefer();
    const waitNext = async () => {
      try {
        if (!buffer.isEmpty()) {
          return getNext(buffer);
        }
        if (ended) {
          return { done: true };
        }
        return await new Promise((resolve, reject) => {
          onNext = (next) => {
            onNext = null;
            buffer.push(next);
            try {
              resolve(getNext(buffer));
            } catch (err) {
              reject(err);
            }
            return pushable2;
          };
        });
      } finally {
        if (buffer.isEmpty()) {
          queueMicrotask(() => {
            drain2.resolve();
            drain2 = pDefer();
          });
        }
      }
    };
    const bufferNext = (next) => {
      if (onNext != null) {
        return onNext(next);
      }
      buffer.push(next);
      return pushable2;
    };
    const bufferError = (err) => {
      buffer = new FIFO();
      if (onNext != null) {
        return onNext({ error: err });
      }
      buffer.push({ error: err });
      return pushable2;
    };
    const push = (value) => {
      if (ended) {
        return pushable2;
      }
      if (options?.objectMode !== true && value?.byteLength == null) {
        throw new Error("objectMode was not true but tried to push non-Uint8Array value");
      }
      return bufferNext({ done: false, value });
    };
    const end = (err) => {
      if (ended)
        return pushable2;
      ended = true;
      return err != null ? bufferError(err) : bufferNext({ done: true });
    };
    const _return = () => {
      buffer = new FIFO();
      end();
      return { done: true };
    };
    const _throw = (err) => {
      end(err);
      return { done: true };
    };
    pushable2 = {
      [Symbol.asyncIterator]() {
        return this;
      },
      next: waitNext,
      return: _return,
      throw: _throw,
      push,
      end,
      get readableLength() {
        return buffer.size;
      },
      onEmpty: async (options2) => {
        const signal = options2?.signal;
        signal?.throwIfAborted();
        if (buffer.isEmpty()) {
          return;
        }
        let cancel;
        let listener;
        if (signal != null) {
          cancel = new Promise((resolve, reject) => {
            listener = () => {
              reject(new AbortError());
            };
            signal.addEventListener("abort", listener);
          });
        }
        try {
          await Promise.race([
            drain2.promise,
            cancel
          ]);
        } finally {
          if (listener != null && signal != null) {
            signal?.removeEventListener("abort", listener);
          }
        }
      }
    };
    if (onEnd == null) {
      return pushable2;
    }
    const _pushable2 = pushable2;
    pushable2 = {
      [Symbol.asyncIterator]() {
        return this;
      },
      next() {
        return _pushable2.next();
      },
      throw(err) {
        _pushable2.throw(err);
        if (onEnd != null) {
          onEnd(err);
          onEnd = void 0;
        }
        return { done: true };
      },
      return() {
        _pushable2.return();
        if (onEnd != null) {
          onEnd();
          onEnd = void 0;
        }
        return { done: true };
      },
      push,
      end(err) {
        _pushable2.end(err);
        if (onEnd != null) {
          onEnd(err);
          onEnd = void 0;
        }
        return pushable2;
      },
      get readableLength() {
        return _pushable2.readableLength;
      },
      onEmpty: (opts) => {
        return _pushable2.onEmpty(opts);
      }
    };
    return pushable2;
  }

  // ../node_modules/race-signal/dist/src/index.js
  var AbortError2 = class extends Error {
    type;
    code;
    constructor(message2, code18, name19) {
      super(message2 ?? "The operation was aborted");
      this.type = "aborted";
      this.name = name19 ?? "AbortError";
      this.code = code18 ?? "ABORT_ERR";
    }
  };
  async function raceSignal(promise, signal, opts) {
    if (signal == null) {
      return promise;
    }
    if (signal.aborted) {
      promise.catch(() => {
      });
      return Promise.reject(new AbortError2(opts?.errorMessage, opts?.errorCode, opts?.errorName));
    }
    let listener;
    const error = new AbortError2(opts?.errorMessage, opts?.errorCode, opts?.errorName);
    try {
      return await Promise.race([
        promise,
        new Promise((resolve, reject) => {
          listener = () => {
            reject(error);
          };
          signal.addEventListener("abort", listener);
        })
      ]);
    } finally {
      if (listener != null) {
        signal.removeEventListener("abort", listener);
      }
    }
  }

  // ../node_modules/it-queueless-pushable/dist/src/index.js
  var QueuelessPushable = class {
    readNext;
    haveNext;
    ended;
    nextResult;
    error;
    constructor() {
      this.ended = false;
      this.readNext = pDefer();
      this.haveNext = pDefer();
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    async next() {
      if (this.nextResult == null) {
        await this.haveNext.promise;
      }
      if (this.nextResult == null) {
        throw new Error("HaveNext promise resolved but nextResult was undefined");
      }
      const nextResult = this.nextResult;
      this.nextResult = void 0;
      this.readNext.resolve();
      this.readNext = pDefer();
      return nextResult;
    }
    async throw(err) {
      this.ended = true;
      this.error = err;
      if (err != null) {
        this.haveNext.promise.catch(() => {
        });
        this.haveNext.reject(err);
      }
      const result = {
        done: true,
        value: void 0
      };
      return result;
    }
    async return() {
      const result = {
        done: true,
        value: void 0
      };
      this.ended = true;
      this.nextResult = result;
      this.haveNext.resolve();
      return result;
    }
    async push(value, options) {
      await this._push(value, options);
    }
    async end(err, options) {
      if (err != null) {
        await this.throw(err);
      } else {
        await this._push(void 0, options);
      }
    }
    async _push(value, options) {
      if (value != null && this.ended) {
        throw this.error ?? new Error("Cannot push value onto an ended pushable");
      }
      while (this.nextResult != null) {
        await this.readNext.promise;
      }
      if (value != null) {
        this.nextResult = { done: false, value };
      } else {
        this.ended = true;
        this.nextResult = { done: true, value: void 0 };
      }
      this.haveNext.resolve();
      this.haveNext = pDefer();
      await raceSignal(this.readNext.promise, options?.signal, options);
    }
  };
  function queuelessPushable() {
    return new QueuelessPushable();
  }

  // ../node_modules/it-merge/dist/src/index.js
  function isAsyncIterable3(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  async function addAllToPushable(sources, output2, signal) {
    try {
      await Promise.all(sources.map(async (source) => {
        for await (const item of source) {
          await output2.push(item, {
            signal
          });
          signal.throwIfAborted();
        }
      }));
      await output2.end(void 0, {
        signal
      });
    } catch (err) {
      await output2.end(err, {
        signal
      }).catch(() => {
      });
    }
  }
  async function* mergeSources(sources) {
    const controller = new AbortController();
    const output2 = queuelessPushable();
    addAllToPushable(sources, output2, controller.signal).catch(() => {
    });
    try {
      yield* output2;
    } finally {
      controller.abort();
    }
  }
  function* mergeSyncSources(syncSources) {
    for (const source of syncSources) {
      yield* source;
    }
  }
  function merge(...sources) {
    const syncSources = [];
    for (const source of sources) {
      if (!isAsyncIterable3(source)) {
        syncSources.push(source);
      }
    }
    if (syncSources.length === sources.length) {
      return mergeSyncSources(syncSources);
    }
    return mergeSources(sources);
  }
  var src_default2 = merge;

  // ../node_modules/it-pipe/dist/src/index.js
  function pipe(first, ...rest) {
    if (first == null) {
      throw new Error("Empty pipeline");
    }
    if (isDuplex(first)) {
      const duplex = first;
      first = () => duplex.source;
    } else if (isIterable(first) || isAsyncIterable4(first)) {
      const source = first;
      first = () => source;
    }
    const fns = [first, ...rest];
    if (fns.length > 1) {
      if (isDuplex(fns[fns.length - 1])) {
        fns[fns.length - 1] = fns[fns.length - 1].sink;
      }
    }
    if (fns.length > 2) {
      for (let i = 1; i < fns.length - 1; i++) {
        if (isDuplex(fns[i])) {
          fns[i] = duplexPipelineFn(fns[i]);
        }
      }
    }
    return rawPipe(...fns);
  }
  var rawPipe = (...fns) => {
    let res;
    while (fns.length > 0) {
      res = fns.shift()(res);
    }
    return res;
  };
  var isAsyncIterable4 = (obj) => {
    return obj?.[Symbol.asyncIterator] != null;
  };
  var isIterable = (obj) => {
    return obj?.[Symbol.iterator] != null;
  };
  var isDuplex = (obj) => {
    if (obj == null) {
      return false;
    }
    return obj.sink != null && obj.source != null;
  };
  var duplexPipelineFn = (duplex) => {
    return (source) => {
      const p = duplex.sink(source);
      if (p?.then != null) {
        const stream = pushable({
          objectMode: true
        });
        p.then(() => {
          stream.end();
        }, (err) => {
          stream.end(err);
        });
        let sourceWrap;
        const source2 = duplex.source;
        if (isAsyncIterable4(source2)) {
          sourceWrap = async function* () {
            yield* source2;
            stream.end();
          };
        } else if (isIterable(source2)) {
          sourceWrap = function* () {
            yield* source2;
            stream.end();
          };
        } else {
          throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
        }
        return src_default2(stream, sourceWrap());
      }
      return duplex.source;
    };
  };

  // ../node_modules/@waku/core/dist/lib/stream_manager/utils.js
  function selectOpenConnection(connections) {
    return connections.filter((c) => c.status === "open").sort((left, right) => right.timeline.open - left.timeline.open).at(0);
  }

  // ../node_modules/@waku/core/dist/lib/stream_manager/stream_manager.js
  var STREAM_LOCK_KEY = "consumed";
  var StreamManager = class {
    multicodec;
    libp2p;
    log;
    ongoingCreation = /* @__PURE__ */ new Set();
    streamPool = /* @__PURE__ */ new Map();
    constructor(multicodec, libp2p) {
      this.multicodec = multicodec;
      this.libp2p = libp2p;
      this.log = new Logger(`stream-manager:${multicodec}`);
      this.libp2p.events.addEventListener("peer:update", this.handlePeerUpdateStreamPool);
    }
    async getStream(peerId2) {
      try {
        const peerIdStr = peerId2.toString();
        const scheduledStream = this.streamPool.get(peerIdStr);
        if (scheduledStream) {
          this.streamPool.delete(peerIdStr);
          await scheduledStream;
        }
        const stream = this.getOpenStreamForCodec(peerId2) || await this.createStream(peerId2);
        if (!stream) {
          return;
        }
        this.log.info(`Using stream for peerId=${peerIdStr} multicodec=${this.multicodec}`);
        this.lockStream(peerIdStr, stream);
        return stream;
      } catch (error) {
        this.log.error(`Failed to getStream:`, error);
        return;
      }
    }
    async createStream(peerId2, retries = 0) {
      const connections = this.libp2p.connectionManager.getConnections(peerId2);
      const connection = selectOpenConnection(connections);
      if (!connection) {
        this.log.error(`Failed to get a connection to the peer peerId=${peerId2.toString()} multicodec=${this.multicodec}`);
        return;
      }
      let lastError;
      let stream;
      for (let i = 0; i < retries + 1; i++) {
        try {
          this.log.info(`Attempting to create a stream for peerId=${peerId2.toString()} multicodec=${this.multicodec}`);
          stream = await connection.newStream(this.multicodec);
          this.log.info(`Created stream for peerId=${peerId2.toString()} multicodec=${this.multicodec}`);
          break;
        } catch (error) {
          lastError = error;
        }
      }
      if (!stream) {
        this.log.error(`Failed to create a new stream for ${peerId2.toString()} -- ` + lastError);
        return;
      }
      return stream;
    }
    async createStreamWithLock(peer) {
      const peerId2 = peer.id.toString();
      if (this.ongoingCreation.has(peerId2)) {
        this.log.info(`Skipping creation of a stream due to lock for peerId=${peerId2} multicodec=${this.multicodec}`);
        return;
      }
      try {
        this.ongoingCreation.add(peerId2);
        await this.createStream(peer.id);
      } catch (error) {
        this.log.error(`Failed to createStreamWithLock:`, error);
      } finally {
        this.ongoingCreation.delete(peerId2);
      }
      return;
    }
    handlePeerUpdateStreamPool = (evt) => {
      const { peer } = evt.detail;
      if (!peer.protocols.includes(this.multicodec)) {
        return;
      }
      const stream = this.getOpenStreamForCodec(peer.id);
      if (stream) {
        return;
      }
      this.scheduleNewStream(peer);
    };
    scheduleNewStream(peer) {
      this.log.info(`Scheduling creation of a stream for peerId=${peer.id.toString()} multicodec=${this.multicodec}`);
      if (this.streamPool.has(peer.id.toString())) {
        this.streamPool.delete(peer.id.toString());
      }
      this.streamPool.set(peer.id.toString(), this.createStreamWithLock(peer));
    }
    getOpenStreamForCodec(peerId2) {
      const connections = this.libp2p.connectionManager.getConnections(peerId2);
      const connection = selectOpenConnection(connections);
      if (!connection) {
        this.log.info(`No open connection found for peerId=${peerId2.toString()} multicodec=${this.multicodec}`);
        return;
      }
      const stream = connection.streams.find((s2) => s2.protocol === this.multicodec);
      if (!stream) {
        this.log.info(`No open stream found for peerId=${peerId2.toString()} multicodec=${this.multicodec}`);
        return;
      }
      const isStreamUnusable = ["done", "closed", "closing"].includes(stream.writeStatus || "");
      if (isStreamUnusable || this.isStreamLocked(stream)) {
        this.log.info(`Stream for peerId=${peerId2.toString()} multicodec=${this.multicodec} is unusable`);
        return;
      }
      this.log.info(`Found open stream for peerId=${peerId2.toString()} multicodec=${this.multicodec}`);
      return stream;
    }
    lockStream(peerId2, stream) {
      this.log.info(`Locking stream for peerId:${peerId2}	streamId:${stream.id}`);
      stream.metadata[STREAM_LOCK_KEY] = true;
    }
    isStreamLocked(stream) {
      return !!stream.metadata[STREAM_LOCK_KEY];
    }
  };

  // ../node_modules/@waku/core/node_modules/uuid/dist/esm-browser/rng.js
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }

  // ../node_modules/@waku/core/node_modules/uuid/dist/esm-browser/stringify.js
  var byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
  }

  // ../node_modules/@waku/core/node_modules/uuid/dist/esm-browser/native.js
  var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  var native_default = {
    randomUUID
  };

  // ../node_modules/@waku/core/node_modules/uuid/dist/esm-browser/v4.js
  function v4(options, buf, offset) {
    if (native_default.randomUUID && !buf && !options) {
      return native_default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return unsafeStringify(rnds);
  }
  var v4_default = v4;

  // ../node_modules/@waku/core/dist/lib/filter/filter_rpc.js
  var FilterPushRpc = class _FilterPushRpc {
    proto;
    constructor(proto) {
      this.proto = proto;
    }
    static decode(bytes2) {
      const res = filter_v2_exports.MessagePush.decode(bytes2);
      return new _FilterPushRpc(res);
    }
    encode() {
      return filter_v2_exports.MessagePush.encode(this.proto);
    }
    get wakuMessage() {
      return this.proto.wakuMessage;
    }
    /**
     * Get the pubsub topic from the FilterPushRpc object.
     * @returns string
     */
    get pubsubTopic() {
      return this.proto.pubsubTopic;
    }
  };
  var FilterSubscribeRpc = class _FilterSubscribeRpc {
    proto;
    constructor(proto) {
      this.proto = proto;
    }
    static createSubscribeRequest(pubsubTopic, contentTopics) {
      return new _FilterSubscribeRpc({
        requestId: v4_default(),
        filterSubscribeType: filter_v2_exports.FilterSubscribeRequest.FilterSubscribeType.SUBSCRIBE,
        pubsubTopic,
        contentTopics
      });
    }
    static createUnsubscribeRequest(pubsubTopic, contentTopics) {
      return new _FilterSubscribeRpc({
        requestId: v4_default(),
        filterSubscribeType: filter_v2_exports.FilterSubscribeRequest.FilterSubscribeType.UNSUBSCRIBE,
        pubsubTopic,
        contentTopics
      });
    }
    static createUnsubscribeAllRequest(pubsubTopic) {
      return new _FilterSubscribeRpc({
        requestId: v4_default(),
        filterSubscribeType: filter_v2_exports.FilterSubscribeRequest.FilterSubscribeType.UNSUBSCRIBE_ALL,
        pubsubTopic,
        contentTopics: []
      });
    }
    static createSubscriberPingRequest() {
      return new _FilterSubscribeRpc({
        requestId: v4_default(),
        filterSubscribeType: filter_v2_exports.FilterSubscribeRequest.FilterSubscribeType.SUBSCRIBER_PING,
        pubsubTopic: "",
        contentTopics: []
      });
    }
    static decode(bytes2) {
      const res = filter_v2_exports.FilterSubscribeRequest.decode(bytes2);
      return new _FilterSubscribeRpc(res);
    }
    encode() {
      return filter_v2_exports.FilterSubscribeRequest.encode(this.proto);
    }
    get filterSubscribeType() {
      return this.proto.filterSubscribeType;
    }
    get requestId() {
      return this.proto.requestId;
    }
    get pubsubTopic() {
      return this.proto.pubsubTopic;
    }
    get contentTopics() {
      return this.proto.contentTopics;
    }
  };
  var FilterSubscribeResponse2 = class _FilterSubscribeResponse {
    proto;
    constructor(proto) {
      this.proto = proto;
    }
    static decode(bytes2) {
      const res = filter_v2_exports.FilterSubscribeResponse.decode(bytes2);
      return new _FilterSubscribeResponse(res);
    }
    encode() {
      return filter_v2_exports.FilterSubscribeResponse.encode(this.proto);
    }
    get statusCode() {
      return this.proto.statusCode;
    }
    get statusDesc() {
      return this.proto.statusDesc;
    }
    get requestId() {
      return this.proto.requestId;
    }
  };

  // ../node_modules/@waku/core/dist/lib/filter/filter.js
  var log2 = new Logger("filter-core");
  var FilterCodecs = {
    SUBSCRIBE: "/vac/waku/filter-subscribe/2.0.0-beta1",
    PUSH: "/vac/waku/filter-push/2.0.0-beta1"
  };
  var FilterCore = class {
    handleIncomingMessage;
    streamManager;
    multicodec = FilterCodecs.SUBSCRIBE;
    constructor(handleIncomingMessage, libp2p) {
      this.handleIncomingMessage = handleIncomingMessage;
      this.streamManager = new StreamManager(FilterCodecs.SUBSCRIBE, libp2p.components);
      libp2p.handle(FilterCodecs.PUSH, this.onRequest.bind(this), {
        maxInboundStreams: 100
      }).catch((e) => {
        log2.error("Failed to register ", FilterCodecs.PUSH, e);
      });
    }
    async subscribe(pubsubTopic, peerId2, contentTopics) {
      const stream = await this.streamManager.getStream(peerId2);
      if (!stream) {
        return {
          success: null,
          failure: {
            error: ProtocolError.NO_STREAM_AVAILABLE,
            peerId: peerId2
          }
        };
      }
      const request2 = FilterSubscribeRpc.createSubscribeRequest(pubsubTopic, contentTopics);
      let res;
      try {
        res = await pipe([request2.encode()], encode10, stream, decode12, async (source) => await src_default(source));
        if (!res?.length) {
          throw Error("Received no response from subscription request.");
        }
      } catch (error) {
        log2.error("Failed to send subscribe request", error);
        return {
          success: null,
          failure: {
            error: ProtocolError.GENERIC_FAIL,
            peerId: peerId2
          }
        };
      }
      const { statusCode, requestId, statusDesc } = FilterSubscribeResponse2.decode(res[0].slice());
      if (statusCode < 200 || statusCode >= 300) {
        log2.error(`Filter subscribe request ${requestId} failed with status code ${statusCode}: ${statusDesc}`);
        return {
          failure: {
            error: ProtocolError.REMOTE_PEER_REJECTED,
            peerId: peerId2
          },
          success: null
        };
      }
      return {
        failure: null,
        success: peerId2
      };
    }
    async unsubscribe(pubsubTopic, peerId2, contentTopics) {
      const stream = await this.streamManager.getStream(peerId2);
      if (!stream) {
        log2.error(`Failed to get a stream for remote peer:${peerId2.toString()}`);
        return {
          success: null,
          failure: {
            error: ProtocolError.NO_STREAM_AVAILABLE,
            peerId: peerId2
          }
        };
      }
      const unsubscribeRequest = FilterSubscribeRpc.createUnsubscribeRequest(pubsubTopic, contentTopics);
      try {
        await pipe([unsubscribeRequest.encode()], encode10, stream.sink);
      } catch (error) {
        log2.error("Failed to send unsubscribe request", error);
        return {
          success: null,
          failure: {
            error: ProtocolError.GENERIC_FAIL,
            peerId: peerId2
          }
        };
      }
      return {
        success: peerId2,
        failure: null
      };
    }
    async unsubscribeAll(pubsubTopic, peerId2) {
      const stream = await this.streamManager.getStream(peerId2);
      if (!stream) {
        log2.error(`Failed to get a stream for remote peer:${peerId2.toString()}`);
        return {
          success: null,
          failure: {
            error: ProtocolError.NO_STREAM_AVAILABLE,
            peerId: peerId2
          }
        };
      }
      const request2 = FilterSubscribeRpc.createUnsubscribeAllRequest(pubsubTopic);
      const res = await pipe([request2.encode()], encode10, stream, decode12, async (source) => await src_default(source));
      if (!res || !res.length) {
        return {
          failure: {
            error: ProtocolError.NO_RESPONSE,
            peerId: peerId2
          },
          success: null
        };
      }
      const { statusCode, requestId, statusDesc } = FilterSubscribeResponse2.decode(res[0].slice());
      if (statusCode < 200 || statusCode >= 300) {
        log2.error(`Filter unsubscribe all request ${requestId} failed with status code ${statusCode}: ${statusDesc}`);
        return {
          failure: {
            error: ProtocolError.REMOTE_PEER_REJECTED,
            peerId: peerId2
          },
          success: null
        };
      }
      return {
        failure: null,
        success: peerId2
      };
    }
    async ping(peerId2) {
      const stream = await this.streamManager.getStream(peerId2);
      if (!stream) {
        log2.error(`Failed to get a stream for remote peer:${peerId2.toString()}`);
        return {
          success: null,
          failure: {
            error: ProtocolError.NO_STREAM_AVAILABLE,
            peerId: peerId2
          }
        };
      }
      const request2 = FilterSubscribeRpc.createSubscriberPingRequest();
      let res;
      try {
        res = await pipe([request2.encode()], encode10, stream, decode12, async (source) => await src_default(source));
      } catch (error) {
        log2.error("Failed to send ping request", error);
        return {
          success: null,
          failure: {
            error: ProtocolError.GENERIC_FAIL,
            peerId: peerId2
          }
        };
      }
      if (!res || !res.length) {
        return {
          success: null,
          failure: {
            error: ProtocolError.NO_RESPONSE,
            peerId: peerId2
          }
        };
      }
      const { statusCode, requestId, statusDesc } = FilterSubscribeResponse2.decode(res[0].slice());
      if (statusCode < 200 || statusCode >= 300) {
        log2.error(`Filter ping request ${requestId} failed with status code ${statusCode}: ${statusDesc}`);
        return {
          success: null,
          failure: {
            error: ProtocolError.REMOTE_PEER_REJECTED,
            peerId: peerId2
          }
        };
      }
      return {
        success: peerId2,
        failure: null
      };
    }
    onRequest(streamData) {
      const { connection, stream } = streamData;
      const { remotePeer } = connection;
      log2.info(`Received message from ${remotePeer.toString()}`);
      try {
        pipe(stream, decode12, async (source) => {
          for await (const bytes2 of source) {
            const response = FilterPushRpc.decode(bytes2.slice());
            const { pubsubTopic, wakuMessage } = response;
            if (!wakuMessage) {
              log2.error("Received empty message");
              return;
            }
            if (!pubsubTopic) {
              log2.error("Pubsub topic missing from push message");
              return;
            }
            await this.handleIncomingMessage(pubsubTopic, wakuMessage, connection.remotePeer.toString());
          }
        }).then(() => {
          log2.info("Receiving pipe closed.");
        }, async (e) => {
          log2.error(`Error with receiving pipe on peer:${connection.remotePeer.toString()} -- stream:${stream.id} -- protocol:${stream.protocol}: `, e);
        });
      } catch (e) {
        log2.error("Error decoding message", e);
      }
    }
  };

  // ../node_modules/@waku/core/dist/lib/light_push/push_rpc.js
  var PushRpc2 = class _PushRpc {
    proto;
    constructor(proto) {
      this.proto = proto;
    }
    static createRequest(message2, pubsubTopic) {
      return new _PushRpc({
        requestId: v4_default(),
        request: {
          message: message2,
          pubsubTopic
        },
        response: void 0
      });
    }
    static decode(bytes2) {
      const res = light_push_exports.PushRpc.decode(bytes2);
      return new _PushRpc(res);
    }
    encode() {
      return light_push_exports.PushRpc.encode(this.proto);
    }
    get query() {
      return this.proto.request;
    }
    get response() {
      return this.proto.response;
    }
  };

  // ../node_modules/@waku/core/dist/lib/light_push/utils.js
  var RLN_GENERATION_PREFIX_ERROR = "could not generate rln proof";
  var RLN_MESSAGE_ID_PREFIX_ERROR = "could not get new message id to generate an rln proof";
  var RLN_REMOTE_VALIDATION = "RLN validation failed";
  var isRLNResponseError = (info) => {
    if (!info) {
      return false;
    }
    return info.includes(RLN_GENERATION_PREFIX_ERROR) || info.includes(RLN_MESSAGE_ID_PREFIX_ERROR) || info.includes(RLN_REMOTE_VALIDATION);
  };

  // ../node_modules/@waku/core/dist/lib/light_push/light_push.js
  var log3 = new Logger("light-push");
  var LightPushCodec = "/vac/waku/lightpush/2.0.0-beta1";
  var LightPushCore = class {
    streamManager;
    multicodec = LightPushCodec;
    constructor(libp2p) {
      this.streamManager = new StreamManager(LightPushCodec, libp2p.components);
    }
    async preparePushMessage(encoder3, message2) {
      try {
        if (!message2.payload || message2.payload.length === 0) {
          log3.error("Failed to send waku light push: payload is empty");
          return { query: null, error: ProtocolError.EMPTY_PAYLOAD };
        }
        if (!await isMessageSizeUnderCap(encoder3, message2)) {
          log3.error("Failed to send waku light push: message is bigger than 1MB");
          return { query: null, error: ProtocolError.SIZE_TOO_BIG };
        }
        const protoMessage = await encoder3.toProtoObj(message2);
        if (!protoMessage) {
          log3.error("Failed to encode to protoMessage, aborting push");
          return {
            query: null,
            error: ProtocolError.ENCODE_FAILED
          };
        }
        const query = PushRpc2.createRequest(protoMessage, encoder3.pubsubTopic);
        return { query, error: null };
      } catch (error) {
        log3.error("Failed to prepare push message", error);
        return {
          query: null,
          error: ProtocolError.GENERIC_FAIL
        };
      }
    }
    async send(encoder3, message2, peerId2) {
      const { query, error: preparationError } = await this.preparePushMessage(encoder3, message2);
      if (preparationError || !query) {
        return {
          success: null,
          failure: {
            error: preparationError,
            peerId: peerId2
          }
        };
      }
      const stream = await this.streamManager.getStream(peerId2);
      if (!stream) {
        log3.error(`Failed to get a stream for remote peer:${peerId2.toString()}`);
        return {
          success: null,
          failure: {
            error: ProtocolError.NO_STREAM_AVAILABLE,
            peerId: peerId2
          }
        };
      }
      let res;
      try {
        res = await pipe([query.encode()], encode10, stream, decode12, async (source) => await src_default(source));
      } catch (err) {
        log3.error("Failed to send waku light push request", err);
        return {
          success: null,
          failure: {
            error: ProtocolError.STREAM_ABORTED,
            peerId: peerId2
          }
        };
      }
      const bytes2 = new Uint8ArrayList();
      res.forEach((chunk) => {
        bytes2.append(chunk);
      });
      let response;
      try {
        response = PushRpc2.decode(bytes2).response;
      } catch (err) {
        log3.error("Failed to decode push reply", err);
        return {
          success: null,
          failure: {
            error: ProtocolError.DECODE_FAILED,
            peerId: peerId2
          }
        };
      }
      if (!response) {
        log3.error("Remote peer fault: No response in PushRPC");
        return {
          success: null,
          failure: {
            error: ProtocolError.NO_RESPONSE,
            peerId: peerId2
          }
        };
      }
      if (isRLNResponseError(response.info)) {
        log3.error("Remote peer fault: RLN generation");
        return {
          success: null,
          failure: {
            error: ProtocolError.RLN_PROOF_GENERATION,
            peerId: peerId2
          }
        };
      }
      if (!response.isSuccess) {
        log3.error("Remote peer rejected the message: ", response.info);
        return {
          success: null,
          failure: {
            error: ProtocolError.REMOTE_PEER_REJECTED,
            peerId: peerId2
          }
        };
      }
      return { success: peerId2, failure: null };
    }
  };

  // ../node_modules/@waku/core/dist/lib/to_proto_message.js
  var EmptyMessage = {
    payload: new Uint8Array(),
    contentTopic: "",
    version: void 0,
    timestamp: void 0,
    meta: void 0,
    rateLimitProof: void 0,
    ephemeral: void 0
  };
  function toProtoMessage(wire) {
    return { ...EmptyMessage, ...wire };
  }

  // ../node_modules/@waku/core/dist/lib/store/rpc.js
  var DEFAULT_PAGE_SIZE = 20;
  var MAX_PAGE_SIZE = 100;
  var MAX_TIME_RANGE = 24 * 60 * 60 * 1e3;
  var ONE_MILLION = 1e6;
  var StoreQueryRequest2 = class _StoreQueryRequest {
    proto;
    constructor(proto) {
      this.proto = proto;
    }
    static create(params) {
      const request2 = new _StoreQueryRequest({
        ...params,
        contentTopics: params.contentTopics || [],
        requestId: v4_default(),
        timeStart: params.timeStart ? BigInt(params.timeStart.getTime() * ONE_MILLION) : void 0,
        timeEnd: params.timeEnd ? BigInt(params.timeEnd.getTime() * ONE_MILLION) : void 0,
        messageHashes: params.messageHashes || [],
        paginationLimit: params.paginationLimit ? BigInt(params.paginationLimit) : void 0
      });
      const isHashQuery = params.messageHashes && params.messageHashes.length > 0;
      const hasContentTopics = params.contentTopics && params.contentTopics.length > 0;
      const hasTimeFilter = params.timeStart || params.timeEnd;
      if (isHashQuery) {
        if (hasContentTopics || hasTimeFilter) {
          throw new Error("Message hash lookup queries cannot include content filter criteria (contentTopics, timeStart, or timeEnd)");
        }
      } else {
        if (params.pubsubTopic && (!params.contentTopics || params.contentTopics.length === 0) || !params.pubsubTopic && params.contentTopics && params.contentTopics.length > 0) {
          throw new Error("Both pubsubTopic and contentTopics must be set together for content-filtered queries");
        }
      }
      return request2;
    }
    static decode(bytes2) {
      const res = store_v3_exports.StoreQueryRequest.decode(bytes2);
      return new _StoreQueryRequest(res);
    }
    encode() {
      return store_v3_exports.StoreQueryRequest.encode(this.proto);
    }
  };
  var StoreQueryResponse2 = class _StoreQueryResponse {
    proto;
    constructor(proto) {
      this.proto = proto;
    }
    static decode(bytes2) {
      const res = store_v3_exports.StoreQueryResponse.decode(bytes2);
      return new _StoreQueryResponse(res);
    }
    encode() {
      return store_v3_exports.StoreQueryResponse.encode(this.proto);
    }
    get statusCode() {
      return this.proto.statusCode;
    }
    get statusDesc() {
      return this.proto.statusDesc;
    }
    get messages() {
      return this.proto.messages;
    }
    get paginationCursor() {
      return this.proto.paginationCursor;
    }
  };

  // ../node_modules/@waku/core/dist/lib/store/store.js
  var log4 = new Logger("store");
  var StoreCodec = "/vac/waku/store-query/3.0.0";
  var StoreCore = class {
    streamManager;
    multicodec = StoreCodec;
    constructor(libp2p) {
      this.streamManager = new StreamManager(StoreCodec, libp2p.components);
    }
    get maxTimeLimit() {
      return MAX_TIME_RANGE;
    }
    async *queryPerPage(queryOpts, decoders4, peerId2) {
      if (queryOpts.timeStart && queryOpts.timeEnd) {
        const timeDiff = queryOpts.timeEnd.getTime() - queryOpts.timeStart.getTime();
        if (timeDiff > MAX_TIME_RANGE) {
          throw new Error("Time range bigger than 24h");
        }
      }
      const isHashQuery = queryOpts.messageHashes && queryOpts.messageHashes.length > 0;
      if (!isHashQuery && queryOpts.contentTopics && queryOpts.contentTopics.toString() !== Array.from(decoders4.keys()).toString()) {
        throw new Error("Internal error, the decoders should match the query's content topics");
      }
      let currentCursor = queryOpts.paginationCursor;
      while (true) {
        const storeQueryRequest = StoreQueryRequest2.create({
          ...queryOpts,
          paginationCursor: currentCursor
        });
        log4.info("Sending store query request:", {
          hasMessageHashes: !!queryOpts.messageHashes?.length,
          messageHashCount: queryOpts.messageHashes?.length,
          pubsubTopic: queryOpts.pubsubTopic,
          contentTopics: queryOpts.contentTopics
        });
        const stream = await this.streamManager.getStream(peerId2);
        if (!stream) {
          log4.error(`Failed to get a stream for remote peer:${peerId2.toString()}`);
          break;
        }
        const res = await pipe([storeQueryRequest.encode()], encode10, stream, decode12, async (source) => await src_default(source));
        const bytes2 = new Uint8ArrayList();
        res.forEach((chunk) => {
          bytes2.append(chunk);
        });
        const storeQueryResponse = StoreQueryResponse2.decode(bytes2);
        if (!storeQueryResponse.statusCode || storeQueryResponse.statusCode >= 300) {
          const errorMessage = `Store query failed with status code: ${storeQueryResponse.statusCode}, description: ${storeQueryResponse.statusDesc}`;
          log4.error(errorMessage);
          throw new Error(errorMessage);
        }
        if (!storeQueryResponse.messages || !storeQueryResponse.messages.length) {
          log4.warn("Stopping pagination due to empty messages in response");
          break;
        }
        log4.info(`${storeQueryResponse.messages.length} messages retrieved from store`);
        const decodedMessages = storeQueryResponse.messages.map((protoMsg) => {
          if (!protoMsg.message) {
            return Promise.resolve(void 0);
          }
          const contentTopic = protoMsg.message.contentTopic;
          if (contentTopic) {
            const decoder = decoders4.get(contentTopic);
            if (decoder) {
              return decoder.fromProtoObj(protoMsg.pubsubTopic || "", toProtoMessage(protoMsg.message));
            }
          }
          return Promise.resolve(void 0);
        });
        yield decodedMessages;
        if (queryOpts.paginationForward) {
          currentCursor = storeQueryResponse.messages[storeQueryResponse.messages.length - 1].messageHash;
        } else {
          currentCursor = storeQueryResponse.messages[0].messageHash;
        }
        if (storeQueryResponse.messages.length > MAX_PAGE_SIZE && storeQueryResponse.messages.length < (queryOpts.paginationLimit || DEFAULT_PAGE_SIZE)) {
          break;
        }
      }
    }
  };

  // ../node_modules/@waku/core/dist/lib/connection_manager/connection_limiter.js
  var log5 = new Logger("connection-limiter");
  var DEFAULT_CONNECTION_MONITOR_INTERVAL = 5 * 1e3;
  var ConnectionLimiter = class {
    libp2p;
    events;
    networkMonitor;
    dialer;
    connectionMonitorInterval = null;
    options;
    constructor(options) {
      this.libp2p = options.libp2p;
      this.events = options.events;
      this.networkMonitor = options.networkMonitor;
      this.dialer = options.dialer;
      this.options = options.options;
      this.onWakuConnectionEvent = this.onWakuConnectionEvent.bind(this);
      this.onDisconnectedEvent = this.onDisconnectedEvent.bind(this);
    }
    start() {
      void this.dialPeersFromStore();
      if (this.options.enableAutoRecovery && this.connectionMonitorInterval === null) {
        this.connectionMonitorInterval = setInterval(() => void this.maintainConnections(), DEFAULT_CONNECTION_MONITOR_INTERVAL);
      }
      this.events.addEventListener("waku:connection", this.onWakuConnectionEvent);
      this.libp2p.addEventListener("peer:disconnect", this.onDisconnectedEvent);
    }
    stop() {
      this.events.removeEventListener("waku:connection", this.onWakuConnectionEvent);
      this.libp2p.removeEventListener("peer:disconnect", this.onDisconnectedEvent);
      if (this.connectionMonitorInterval) {
        clearInterval(this.connectionMonitorInterval);
        this.connectionMonitorInterval = null;
      }
    }
    onWakuConnectionEvent() {
      if (!this.options.enableAutoRecovery) {
        log5.info(`Auto recovery is disabled, skipping`);
        return;
      }
      if (this.networkMonitor.isBrowserConnected()) {
        void this.dialPeersFromStore();
      }
    }
    async maintainConnections() {
      await this.maintainConnectionsCount();
      await this.maintainBootstrapConnections();
    }
    async onDisconnectedEvent() {
      if (this.libp2p.getConnections().length === 0) {
        log5.info(`No connections, dialing peers from store`);
        await this.dialPeersFromStore();
      }
    }
    async maintainConnectionsCount() {
      log5.info(`Maintaining connections count`);
      const connections = this.libp2p.getConnections();
      if (connections.length <= this.options.maxConnections) {
        log5.info(`Node has less than max connections ${this.options.maxConnections}, trying to dial more peers`);
        const peers = await this.getPrioritizedPeers();
        if (peers.length === 0) {
          log5.info(`No peers to dial, node is utilizing all known peers`);
          return;
        }
        const promises = peers.slice(0, this.options.maxConnections - connections.length).map((p) => this.dialer.dial(p.id));
        await Promise.all(promises);
        return;
      }
      log5.info(`Node has more than max connections ${this.options.maxConnections}, dropping connections`);
      try {
        const connectionsToDrop = connections.filter((c) => !c.tags.includes(CONNECTION_LOCKED_TAG)).slice(this.options.maxConnections);
        if (connectionsToDrop.length === 0) {
          log5.info(`No connections to drop, skipping`);
          return;
        }
        const promises = connectionsToDrop.map((c) => this.libp2p.hangUp(c.remotePeer));
        await Promise.all(promises);
        log5.info(`Dropped ${connectionsToDrop.length} connections`);
      } catch (error) {
        log5.error(`Unexpected error while maintaining connections`, error);
      }
    }
    async maintainBootstrapConnections() {
      log5.info(`Maintaining bootstrap connections`);
      const bootstrapPeers = await this.getBootstrapPeers();
      if (bootstrapPeers.length <= this.options.maxBootstrapPeers) {
        return;
      }
      try {
        const peersToDrop = bootstrapPeers.slice(this.options.maxBootstrapPeers);
        log5.info(`Dropping ${peersToDrop.length} bootstrap connections because node has more than max bootstrap connections ${this.options.maxBootstrapPeers}`);
        const promises = peersToDrop.map((p) => this.libp2p.hangUp(p.id));
        await Promise.all(promises);
        log5.info(`Dropped ${peersToDrop.length} bootstrap connections`);
      } catch (error) {
        log5.error(`Unexpected error while maintaining bootstrap connections`, error);
      }
    }
    async dialPeersFromStore() {
      log5.info(`Dialing peers from store`);
      try {
        const peers = await this.getPrioritizedPeers();
        if (peers.length === 0) {
          log5.info(`No peers to dial, skipping`);
          return;
        }
        const promises = peers.map((p) => this.dialer.dial(p.id));
        log5.info(`Dialing ${peers.length} peers from store`);
        await Promise.all(promises);
        log5.info(`Dialed ${promises.length} peers from store`);
      } catch (error) {
        log5.error(`Unexpected error while dialing peer store peers`, error);
      }
    }
    /**
     * Returns a list of peers ordered by priority:
     * - bootstrap peers
     * - peers from peer exchange
     * - peers from peer cache (last because we are not sure that locally stored information is up to date)
     */
    async getPrioritizedPeers() {
      const allPeers = await this.libp2p.peerStore.all();
      const allConnections = this.libp2p.getConnections();
      log5.info(`Found ${allPeers.length} peers in store, and found ${allConnections.length} connections`);
      const notConnectedPeers = allPeers.filter((p) => !allConnections.some((c) => c.remotePeer.equals(p.id)) && p.addresses.some((a) => a.multiaddr.toString().includes("wss") || a.multiaddr.toString().includes("ws")));
      const bootstrapPeers = notConnectedPeers.filter((p) => p.tags.has(Tags.BOOTSTRAP));
      const peerExchangePeers = notConnectedPeers.filter((p) => p.tags.has(Tags.PEER_EXCHANGE));
      const localStorePeers = notConnectedPeers.filter((p) => p.tags.has(Tags.PEER_CACHE));
      return [...bootstrapPeers, ...peerExchangePeers, ...localStorePeers];
    }
    async getBootstrapPeers() {
      const peers = await Promise.all(this.libp2p.getConnections().map((conn) => conn.remotePeer).map((id) => this.getPeer(id)));
      const bootstrapPeers = peers.filter((peer) => peer && peer.tags.has(Tags.BOOTSTRAP));
      return bootstrapPeers;
    }
    async getPeer(peerId2) {
      try {
        return await this.libp2p.peerStore.get(peerId2);
      } catch (error) {
        log5.error(`Failed to get peer ${peerId2}, error: ${error}`);
        return null;
      }
    }
  };

  // ../node_modules/@waku/core/dist/lib/connection_manager/dialer.js
  var log6 = new Logger("dialer");
  var Dialer = class {
    libp2p;
    shardReader;
    options;
    dialingQueue = [];
    dialHistory = /* @__PURE__ */ new Map();
    failedDials = /* @__PURE__ */ new Map();
    dialingInterval = null;
    isProcessing = false;
    isImmediateDialing = false;
    constructor(options) {
      this.libp2p = options.libp2p;
      this.shardReader = options.shardReader;
      this.options = options.options;
    }
    start() {
      log6.info("Starting dialer");
      if (!this.dialingInterval) {
        this.dialingInterval = setInterval(() => {
          void this.processQueue();
        }, 500);
      }
      this.dialHistory.clear();
      this.failedDials.clear();
    }
    stop() {
      log6.info("Stopping dialer");
      if (this.dialingInterval) {
        clearInterval(this.dialingInterval);
        this.dialingInterval = null;
      }
      this.dialHistory.clear();
      this.failedDials.clear();
    }
    async dial(peerId2) {
      const shouldSkip = await this.shouldSkipPeer(peerId2);
      if (shouldSkip) {
        log6.info(`Skipping peer: ${peerId2}`);
        return;
      }
      const isEmptyQueue = this.dialingQueue.length === 0;
      const isNotDialing = !this.isProcessing && !this.isImmediateDialing;
      if (isEmptyQueue && isNotDialing) {
        this.isImmediateDialing = true;
        log6.info("Dialed peer immediately");
        await this.dialPeer(peerId2);
        this.isImmediateDialing = false;
        log6.info("Released immediate dial lock");
      } else {
        this.dialingQueue.push(peerId2);
        log6.info(`Added peer to dialing queue, queue size: ${this.dialingQueue.length}`);
      }
    }
    async processQueue() {
      if (this.dialingQueue.length === 0 || this.isProcessing) {
        return;
      }
      this.isProcessing = true;
      try {
        const peersToDial = this.dialingQueue.slice(0, this.options.maxDialingPeers);
        this.dialingQueue = this.dialingQueue.slice(peersToDial.length);
        log6.info(`Processing dial queue: dialing ${peersToDial.length} peers, ${this.dialingQueue.length} remaining in queue`);
        await Promise.all(peersToDial.map((peerId2) => this.dialPeer(peerId2)));
      } finally {
        this.isProcessing = false;
      }
    }
    async dialPeer(peerId2) {
      try {
        log6.info(`Dialing peer from queue: ${peerId2}`);
        await this.libp2p.dial(peerId2);
        this.dialHistory.set(peerId2.toString(), Date.now());
        this.failedDials.delete(peerId2.toString());
        log6.info(`Successfully dialed peer from queue: ${peerId2}`);
      } catch (error) {
        log6.error(`Error dialing peer ${peerId2}`, error);
        this.failedDials.set(peerId2.toString(), Date.now());
      }
    }
    async shouldSkipPeer(peerId2) {
      const hasConnection = this.libp2p.getPeers().some((p) => p.equals(peerId2));
      if (hasConnection) {
        log6.info(`Skipping peer ${peerId2} - already connected`);
        return true;
      }
      if (this.isRecentlyDialed(peerId2)) {
        log6.info(`Skipping peer ${peerId2} - already dialed in the last 10 seconds`);
        return true;
      }
      if (this.isRecentlyFailed(peerId2)) {
        log6.info(`Skipping peer ${peerId2} - recently failed to dial`);
        return true;
      }
      try {
        const hasShardInfo = await this.shardReader.hasShardInfo(peerId2);
        if (!hasShardInfo) {
          log6.info(`Skipping peer ${peerId2} - no shard info`);
          return false;
        }
        const isOnSameCluster = await this.shardReader.isPeerOnCluster(peerId2);
        if (!isOnSameCluster) {
          log6.info(`Skipping peer ${peerId2} - not on same cluster`);
          return true;
        }
        return false;
      } catch (error) {
        log6.error(`Error checking shard info for peer ${peerId2}`, error);
        return true;
      }
    }
    isRecentlyDialed(peerId2) {
      const lastDialed = this.dialHistory.get(peerId2.toString());
      if (lastDialed && Date.now() - lastDialed < this.options.dialCooldown * 1e3) {
        return true;
      }
      return false;
    }
    isRecentlyFailed(peerId2) {
      const lastFailed = this.failedDials.get(peerId2.toString());
      if (lastFailed && Date.now() - lastFailed < this.options.failedDialCooldown * 1e3) {
        return true;
      }
      return false;
    }
  };

  // ../node_modules/@waku/core/dist/lib/connection_manager/discovery_dialer.js
  var log7 = new Logger("discovery-dialer");
  var DiscoveryDialer = class {
    libp2p;
    dialer;
    constructor(options) {
      this.libp2p = options.libp2p;
      this.dialer = options.dialer;
      this.onPeerDiscovery = this.onPeerDiscovery.bind(this);
    }
    start() {
      this.libp2p.addEventListener("peer:discovery", this.onPeerDiscovery);
    }
    stop() {
      this.libp2p.removeEventListener("peer:discovery", this.onPeerDiscovery);
    }
    async onPeerDiscovery(event) {
      const peerId2 = event.detail.id;
      log7.info(`Discovered new peer: ${peerId2}`);
      try {
        await this.updatePeerStore(peerId2, event.detail.multiaddrs);
        await this.dialer.dial(peerId2);
      } catch (error) {
        log7.error(`Error dialing peer ${peerId2}`, error);
      }
    }
    async updatePeerStore(peerId2, multiaddrs) {
      try {
        log7.info(`Updating peer store for ${peerId2}`);
        const peer = await this.getPeer(peerId2);
        if (!peer) {
          log7.info(`Peer ${peerId2} not found in store, saving`);
          await this.libp2p.peerStore.save(peerId2, {
            multiaddrs
          });
          return;
        }
        const hasSameAddr = multiaddrs.every((addr) => peer.addresses.some((a) => a.multiaddr.equals(addr)));
        if (hasSameAddr) {
          log7.info(`Peer ${peerId2} has same addresses in peer store, skipping`);
          return;
        }
        log7.info(`Merging peer ${peerId2} addresses in peer store`);
        await this.libp2p.peerStore.merge(peerId2, {
          multiaddrs
        });
      } catch (error) {
        log7.error(`Error updating peer store for ${peerId2}`, error);
      }
    }
    async getPeer(peerId2) {
      try {
        return await this.libp2p.peerStore.get(peerId2);
      } catch (error) {
        log7.error(`Error getting peer info for ${peerId2}`, error);
        return void 0;
      }
    }
  };

  // ../node_modules/@waku/core/dist/lib/connection_manager/keep_alive_manager.js
  var RelayPingContentTopic = "/relay-ping/1/ping/null";
  var log8 = new Logger("keep-alive");
  var KeepAliveManager = class {
    relay;
    networkConfig;
    libp2p;
    options;
    pingKeepAliveTimers = /* @__PURE__ */ new Map();
    relayKeepAliveTimers = /* @__PURE__ */ new Map();
    constructor({ options, relay, networkConfig, libp2p }) {
      this.options = options;
      this.relay = relay;
      this.networkConfig = networkConfig;
      this.libp2p = libp2p;
      this.onPeerConnect = this.onPeerConnect.bind(this);
      this.onPeerDisconnect = this.onPeerDisconnect.bind(this);
    }
    start() {
      this.libp2p.addEventListener("peer:connect", this.onPeerConnect);
      this.libp2p.addEventListener("peer:disconnect", this.onPeerDisconnect);
    }
    stop() {
      this.libp2p.removeEventListener("peer:connect", this.onPeerConnect);
      this.libp2p.removeEventListener("peer:disconnect", this.onPeerDisconnect);
      for (const timer of this.pingKeepAliveTimers.values()) {
        clearInterval(timer);
      }
      for (const timerArray of this.relayKeepAliveTimers.values()) {
        for (const timer of timerArray) {
          clearInterval(timer);
        }
      }
      this.pingKeepAliveTimers.clear();
      this.relayKeepAliveTimers.clear();
    }
    onPeerConnect(evt) {
      const peerId2 = evt.detail;
      this.startPingForPeer(peerId2);
    }
    onPeerDisconnect(evt) {
      const peerId2 = evt.detail;
      this.stopPingForPeer(peerId2);
    }
    startPingForPeer(peerId2) {
      this.stopPingForPeer(peerId2);
      this.startLibp2pPing(peerId2);
      this.startRelayPing(peerId2);
    }
    stopPingForPeer(peerId2) {
      this.stopLibp2pPing(peerId2);
      this.stopRelayPing(peerId2);
    }
    startLibp2pPing(peerId2) {
      if (this.options.pingKeepAlive === 0) {
        log8.warn(`Ping keep alive is disabled pingKeepAlive:${this.options.pingKeepAlive}, skipping start for libp2p ping`);
        return;
      }
      const peerIdStr = peerId2.toString();
      if (this.pingKeepAliveTimers.has(peerIdStr)) {
        log8.warn(`Ping already started for peer: ${peerIdStr}, skipping start for libp2p ping`);
        return;
      }
      const interval = setInterval(() => {
        void this.pingLibp2p(peerId2);
      }, this.options.pingKeepAlive * 1e3);
      this.pingKeepAliveTimers.set(peerIdStr, interval);
    }
    stopLibp2pPing(peerId2) {
      const peerIdStr = peerId2.toString();
      if (!this.pingKeepAliveTimers.has(peerIdStr)) {
        log8.warn(`Ping not started for peer: ${peerIdStr}, skipping stop for ping`);
        return;
      }
      clearInterval(this.pingKeepAliveTimers.get(peerIdStr));
      this.pingKeepAliveTimers.delete(peerIdStr);
    }
    startRelayPing(peerId2) {
      if (!this.relay) {
        return;
      }
      if (this.options.relayKeepAlive === 0) {
        log8.warn(`Relay keep alive is disabled relayKeepAlive:${this.options.relayKeepAlive}, skipping start for relay ping`);
        return;
      }
      if (this.relayKeepAliveTimers.has(peerId2.toString())) {
        log8.warn(`Relay ping already started for peer: ${peerId2.toString()}, skipping start for relay ping`);
        return;
      }
      const intervals = [];
      for (const topic of this.relay.pubsubTopics) {
        const meshPeers = this.relay.getMeshPeers(topic);
        if (!meshPeers.includes(peerId2.toString())) {
          log8.warn(`Peer: ${peerId2.toString()} is not in the mesh for topic: ${topic}, skipping start for relay ping`);
          continue;
        }
        const routingInfo = createRoutingInfo(this.networkConfig, {
          contentTopic: RelayPingContentTopic,
          pubsubTopic: topic
        });
        const encoder3 = createEncoder({
          routingInfo,
          contentTopic: RelayPingContentTopic,
          ephemeral: true
        });
        const interval = setInterval(() => {
          void this.pingRelay(encoder3);
        }, this.options.relayKeepAlive * 1e3);
        intervals.push(interval);
      }
      this.relayKeepAliveTimers.set(peerId2.toString(), intervals);
    }
    stopRelayPing(peerId2) {
      if (!this.relay) {
        return;
      }
      const peerIdStr = peerId2.toString();
      if (!this.relayKeepAliveTimers.has(peerIdStr)) {
        log8.warn(`Relay ping not started for peer: ${peerIdStr}, skipping stop for relay ping`);
        return;
      }
      this.relayKeepAliveTimers.get(peerIdStr)?.map(clearInterval);
      this.relayKeepAliveTimers.delete(peerIdStr);
    }
    async pingRelay(encoder3) {
      try {
        log8.info("Sending Waku Relay ping message");
        await this.relay.send(encoder3, { payload: new Uint8Array([1]) });
      } catch (e) {
        log8.error("Failed to send relay ping", e);
      }
    }
    async pingLibp2p(peerId2) {
      try {
        log8.info(`Pinging libp2p peer (${peerId2.toString()})`);
        const ping2 = await this.libp2p.services.ping.ping(peerId2);
        log8.info(`Ping succeeded (${peerId2.toString()})`, ping2);
        await this.libp2p.peerStore.merge(peerId2, {
          metadata: {
            ping: utf8ToBytes2(ping2.toString())
          }
        });
        log8.info(`Ping updated for peer (${peerId2.toString()})`);
      } catch (e) {
        log8.error(`Ping failed for peer (${peerId2.toString()})`, e);
      }
    }
  };

  // ../node_modules/@waku/core/dist/lib/connection_manager/network_monitor.js
  var NetworkMonitor = class {
    libp2p;
    events;
    isNetworkConnected = false;
    constructor(options) {
      this.libp2p = options.libp2p;
      this.events = options.events;
      this.onConnectedEvent = this.onConnectedEvent.bind(this);
      this.onDisconnectedEvent = this.onDisconnectedEvent.bind(this);
      this.dispatchNetworkEvent = this.dispatchNetworkEvent.bind(this);
    }
    start() {
      this.libp2p.addEventListener("peer:connect", this.onConnectedEvent);
      this.libp2p.addEventListener("peer:disconnect", this.onDisconnectedEvent);
      try {
        globalThis.addEventListener("online", this.dispatchNetworkEvent);
        globalThis.addEventListener("offline", this.dispatchNetworkEvent);
      } catch (err) {
      }
    }
    stop() {
      this.libp2p.removeEventListener("peer:connect", this.onConnectedEvent);
      this.libp2p.removeEventListener("peer:disconnect", this.onDisconnectedEvent);
      try {
        globalThis.removeEventListener("online", this.dispatchNetworkEvent);
        globalThis.removeEventListener("offline", this.dispatchNetworkEvent);
      } catch (err) {
      }
    }
    /**
     * Returns true if the node is connected to the network via libp2p and browser.
     */
    isConnected() {
      if (!this.isBrowserConnected()) {
        return false;
      }
      return this.isP2PConnected();
    }
    /**
     * Returns true if the node is connected to the network via libp2p.
     */
    isP2PConnected() {
      return this.isNetworkConnected;
    }
    /**
     * Returns true if the node is connected to the network via browser.
     */
    isBrowserConnected() {
      try {
        if (globalThis?.navigator && !globalThis?.navigator?.onLine) {
          return false;
        }
      } catch (err) {
      }
      return true;
    }
    onConnectedEvent() {
      if (!this.isNetworkConnected) {
        this.isNetworkConnected = true;
        this.dispatchNetworkEvent();
      }
    }
    onDisconnectedEvent() {
      if (this.isNetworkConnected && this.libp2p.getConnections().length === 0) {
        this.isNetworkConnected = false;
        this.dispatchNetworkEvent();
      }
    }
    dispatchNetworkEvent() {
      this.events.dispatchEvent(new CustomEvent("waku:connection", {
        detail: this.isConnected()
      }));
    }
  };

  // ../node_modules/@waku/core/dist/lib/connection_manager/shard_reader.js
  var log9 = new Logger("shard-reader");
  var ShardReader = class {
    libp2p;
    clusterId;
    constructor(options) {
      this.libp2p = options.libp2p;
      this.clusterId = options.networkConfig.clusterId;
    }
    async isPeerOnCluster(id) {
      const peerRelayShards = await this.getRelayShards(id);
      if (!peerRelayShards) {
        return false;
      }
      return peerRelayShards.clusterId === this.clusterId;
    }
    async hasShardInfo(id) {
      const shardInfo = await this.getRelayShards(id);
      return !!shardInfo;
    }
    async isPeerOnTopic(id, pubsubTopic) {
      try {
        const { clusterId, shard } = pubsubTopicToSingleShardInfo(pubsubTopic);
        if (clusterId !== this.clusterId)
          return false;
        return await this.isPeerOnShard(id, shard);
      } catch (error) {
        log9.error(`Error comparing pubsub topic ${pubsubTopic} with shard info for ${id}`, error);
        return false;
      }
    }
    async isPeerOnShard(id, shard) {
      const peerShardInfo = await this.getRelayShards(id);
      log9.info(`Checking if peer on same shard: this { clusterId: ${this.clusterId}, shardId: ${shard} },${id} { clusterId: ${peerShardInfo?.clusterId}, shards: ${peerShardInfo?.shards} }`);
      if (!peerShardInfo) {
        return false;
      }
      return peerShardInfo.clusterId === this.clusterId && peerShardInfo.shards.includes(shard);
    }
    async getRelayShards(id) {
      try {
        const peer = await this.libp2p.peerStore.get(id);
        const shardInfoBytes = peer.metadata.get("shardInfo");
        if (!shardInfoBytes) {
          return void 0;
        }
        return decodeRelayShard(shardInfoBytes);
      } catch (error) {
        log9.error(`Error getting shard info for ${id}`, error);
        return void 0;
      }
    }
  };

  // ../node_modules/@libp2p/interface/dist/src/connection.js
  var connectionSymbol = Symbol.for("@libp2p/connection");

  // ../node_modules/@libp2p/interface/dist/src/content-routing.js
  var contentRoutingSymbol = Symbol.for("@libp2p/content-routing");

  // ../node_modules/@libp2p/interface/dist/src/peer-discovery.js
  var peerDiscoverySymbol = Symbol.for("@libp2p/peer-discovery");

  // ../node_modules/@libp2p/interface/dist/src/peer-id.js
  var peerIdSymbol = Symbol.for("@libp2p/peer-id");
  function isPeerId(other) {
    return Boolean(other?.[peerIdSymbol]);
  }

  // ../node_modules/@libp2p/interface/dist/src/peer-routing.js
  var peerRoutingSymbol = Symbol.for("@libp2p/peer-routing");

  // ../node_modules/@libp2p/interface/dist/src/peer-store.js
  var KEEP_ALIVE = "keep-alive";

  // ../node_modules/@libp2p/interface/dist/src/transport.js
  var transportSymbol = Symbol.for("@libp2p/transport");
  var FaultTolerance;
  (function(FaultTolerance2) {
    FaultTolerance2[FaultTolerance2["FATAL_ALL"] = 0] = "FATAL_ALL";
    FaultTolerance2[FaultTolerance2["NO_FATAL"] = 1] = "NO_FATAL";
  })(FaultTolerance || (FaultTolerance = {}));

  // ../node_modules/@libp2p/interface/dist/src/errors.js
  var AbortError3 = class extends Error {
    static name = "AbortError";
    constructor(message2 = "The operation was aborted") {
      super(message2);
      this.name = "AbortError";
    }
  };
  var UnexpectedPeerError = class extends Error {
    static name = "UnexpectedPeerError";
    constructor(message2 = "Unexpected Peer") {
      super(message2);
      this.name = "UnexpectedPeerError";
    }
  };
  var InvalidCryptoExchangeError = class extends Error {
    static name = "InvalidCryptoExchangeError";
    constructor(message2 = "Invalid crypto exchange") {
      super(message2);
      this.name = "InvalidCryptoExchangeError";
    }
  };
  var InvalidParametersError = class extends Error {
    static name = "InvalidParametersError";
    constructor(message2 = "Invalid parameters") {
      super(message2);
      this.name = "InvalidParametersError";
    }
  };
  var InvalidPublicKeyError = class extends Error {
    static name = "InvalidPublicKeyError";
    constructor(message2 = "Invalid public key") {
      super(message2);
      this.name = "InvalidPublicKeyError";
    }
  };
  var InvalidPrivateKeyError = class extends Error {
    static name = "InvalidPrivateKeyError";
    constructor(message2 = "Invalid private key") {
      super(message2);
      this.name = "InvalidPrivateKeyError";
    }
  };
  var ConnectionClosingError = class extends Error {
    static name = "ConnectionClosingError";
    constructor(message2 = "The connection is closing") {
      super(message2);
      this.name = "ConnectionClosingError";
    }
  };
  var ConnectionClosedError = class extends Error {
    static name = "ConnectionClosedError";
    constructor(message2 = "The connection is closed") {
      super(message2);
      this.name = "ConnectionClosedError";
    }
  };
  var ConnectionFailedError = class extends Error {
    static name = "ConnectionFailedError";
    constructor(message2 = "Connection failed") {
      super(message2);
      this.name = "ConnectionFailedError";
    }
  };
  var MuxerClosedError = class extends Error {
    static name = "MuxerClosedError";
    constructor(message2 = "The muxer is closed") {
      super(message2);
      this.name = "MuxerClosedError";
    }
  };
  var StreamResetError = class extends Error {
    static name = "StreamResetError";
    constructor(message2 = "The stream has been reset") {
      super(message2);
      this.name = "StreamResetError";
    }
  };
  var StreamStateError = class extends Error {
    static name = "StreamStateError";
    constructor(message2 = "The stream is in an invalid state") {
      super(message2);
      this.name = "StreamStateError";
    }
  };
  var NotFoundError = class extends Error {
    static name = "NotFoundError";
    constructor(message2 = "Not found") {
      super(message2);
      this.name = "NotFoundError";
    }
  };
  var InvalidPeerIdError = class extends Error {
    static name = "InvalidPeerIdError";
    constructor(message2 = "Invalid PeerID") {
      super(message2);
      this.name = "InvalidPeerIdError";
    }
  };
  var InvalidMultiaddrError = class extends Error {
    static name = "InvalidMultiaddrError";
    constructor(message2 = "Invalid multiaddr") {
      super(message2);
      this.name = "InvalidMultiaddrError";
    }
  };
  var InvalidCIDError = class extends Error {
    static name = "InvalidCIDError";
    constructor(message2 = "Invalid CID") {
      super(message2);
      this.name = "InvalidCIDError";
    }
  };
  var InvalidMultihashError = class extends Error {
    static name = "InvalidMultihashError";
    constructor(message2 = "Invalid Multihash") {
      super(message2);
      this.name = "InvalidMultihashError";
    }
  };
  var UnsupportedProtocolError = class extends Error {
    static name = "UnsupportedProtocolError";
    constructor(message2 = "Unsupported protocol error") {
      super(message2);
      this.name = "UnsupportedProtocolError";
    }
  };
  var InvalidMessageError = class extends Error {
    static name = "InvalidMessageError";
    constructor(message2 = "Invalid message") {
      super(message2);
      this.name = "InvalidMessageError";
    }
  };
  var ProtocolError2 = class extends Error {
    static name = "ProtocolError";
    constructor(message2 = "Protocol error") {
      super(message2);
      this.name = "ProtocolError";
    }
  };
  var TimeoutError = class extends Error {
    static name = "TimeoutError";
    constructor(message2 = "Timed out") {
      super(message2);
      this.name = "TimeoutError";
    }
  };
  var NotStartedError = class extends Error {
    static name = "NotStartedError";
    constructor(message2 = "Not started") {
      super(message2);
      this.name = "NotStartedError";
    }
  };
  var DialError = class extends Error {
    static name = "DialError";
    constructor(message2 = "Dial error") {
      super(message2);
      this.name = "DialError";
    }
  };
  var LimitedConnectionError = class extends Error {
    static name = "LimitedConnectionError";
    constructor(message2 = "Limited connection") {
      super(message2);
      this.name = "LimitedConnectionError";
    }
  };
  var TooManyInboundProtocolStreamsError = class extends Error {
    static name = "TooManyInboundProtocolStreamsError";
    constructor(message2 = "Too many inbound protocol streams") {
      super(message2);
      this.name = "TooManyInboundProtocolStreamsError";
    }
  };
  var TooManyOutboundProtocolStreamsError = class extends Error {
    static name = "TooManyOutboundProtocolStreamsError";
    constructor(message2 = "Too many outbound protocol streams") {
      super(message2);
      this.name = "TooManyOutboundProtocolStreamsError";
    }
  };
  var UnsupportedKeyTypeError = class extends Error {
    static name = "UnsupportedKeyTypeError";
    constructor(message2 = "Unsupported key type") {
      super(message2);
      this.name = "UnsupportedKeyTypeError";
    }
  };

  // ../node_modules/main-event/dist/src/events.browser.js
  function setMaxListeners() {
  }

  // ../node_modules/main-event/dist/src/index.js
  var TypedEventEmitter = class extends EventTarget {
    #listeners = /* @__PURE__ */ new Map();
    constructor() {
      super();
      setMaxListeners(Infinity, this);
    }
    listenerCount(type) {
      const listeners = this.#listeners.get(type);
      if (listeners == null) {
        return 0;
      }
      return listeners.length;
    }
    addEventListener(type, listener, options) {
      super.addEventListener(type, listener, options);
      let list = this.#listeners.get(type);
      if (list == null) {
        list = [];
        this.#listeners.set(type, list);
      }
      list.push({
        callback: listener,
        once: (options !== true && options !== false && options?.once) ?? false
      });
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type.toString(), listener ?? null, options);
      let list = this.#listeners.get(type);
      if (list == null) {
        return;
      }
      list = list.filter(({ callback }) => callback !== listener);
      this.#listeners.set(type, list);
    }
    dispatchEvent(event) {
      const result = super.dispatchEvent(event);
      let list = this.#listeners.get(event.type);
      if (list == null) {
        return result;
      }
      list = list.filter(({ once }) => !once);
      this.#listeners.set(event.type, list);
      return result;
    }
    safeDispatchEvent(type, detail = {}) {
      return this.dispatchEvent(new CustomEvent(type, detail));
    }
  };

  // ../node_modules/@libp2p/interface/dist/src/startable.js
  function isStartable(obj) {
    return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
  }
  async function start(...objs) {
    const startables = [];
    for (const obj of objs) {
      if (isStartable(obj)) {
        startables.push(obj);
      }
    }
    await Promise.all(startables.map(async (s2) => {
      if (s2.beforeStart != null) {
        await s2.beforeStart();
      }
    }));
    await Promise.all(startables.map(async (s2) => {
      await s2.start();
    }));
    await Promise.all(startables.map(async (s2) => {
      if (s2.afterStart != null) {
        await s2.afterStart();
      }
    }));
  }
  async function stop(...objs) {
    const startables = [];
    for (const obj of objs) {
      if (isStartable(obj)) {
        startables.push(obj);
      }
    }
    await Promise.all(startables.map(async (s2) => {
      if (s2.beforeStop != null) {
        await s2.beforeStop();
      }
    }));
    await Promise.all(startables.map(async (s2) => {
      await s2.stop();
    }));
    await Promise.all(startables.map(async (s2) => {
      if (s2.afterStop != null) {
        await s2.afterStop();
      }
    }));
  }

  // ../node_modules/@libp2p/interface/dist/src/index.js
  var serviceCapabilities = Symbol.for("@libp2p/service-capabilities");
  var serviceDependencies = Symbol.for("@libp2p/service-dependencies");

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports3 = {};
  __export(base58_exports3, {
    base58btc: () => base58btc3,
    base58flickr: () => base58flickr3
  });

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bytes.js
  var empty3 = new Uint8Array(0);
  function equals6(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce3(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function fromString5(str) {
    return new TextEncoder().encode(str);
  }
  function toString4(b) {
    return new TextDecoder().decode(b);
  }

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/vendor/base-x.js
  function base4(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src3 = base4;
  var _brrp__multiformats_scope_baseX3 = src3;
  var base_x_default3 = _brrp__multiformats_scope_baseX3;

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base.js
  var Encoder4 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder4 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or3(this, decoder);
    }
  };
  var ComposedDecoder3 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or3(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or3(left, right) {
    return new ComposedDecoder3({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec3 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder4(name19, prefix, baseEncode);
      this.decoder = new Decoder4(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from5({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec3(name19, prefix, encode79, decode99);
  }
  function baseX3({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default3(alphabet18, name19);
    return from5({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce3(decode99(text))
    });
  }
  function decode13(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode11(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx3(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc46483({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx3(alphabet18);
    return from5({
      prefix,
      name: name19,
      encode(input) {
        return encode11(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode13(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base58.js
  var base58btc3 = baseX3({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr3 = baseX3({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports3 = {};
  __export(base32_exports3, {
    base32: () => base323,
    base32hex: () => base32hex3,
    base32hexpad: () => base32hexpad3,
    base32hexpadupper: () => base32hexpadupper3,
    base32hexupper: () => base32hexupper3,
    base32pad: () => base32pad3,
    base32padupper: () => base32padupper3,
    base32upper: () => base32upper3,
    base32z: () => base32z3
  });
  var base323 = rfc46483({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper3 = rfc46483({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad3 = rfc46483({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper3 = rfc46483({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex3 = rfc46483({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper3 = rfc46483({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad3 = rfc46483({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper3 = rfc46483({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z3 = rfc46483({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports3 = {};
  __export(base36_exports3, {
    base36: () => base363,
    base36upper: () => base36upper3
  });
  var base363 = baseX3({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper3 = baseX3({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_13 = encode12;
  var MSB4 = 128;
  var REST4 = 127;
  var MSBALL3 = ~REST4;
  var INT3 = Math.pow(2, 31);
  function encode12(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT3) {
      out[offset++] = num & 255 | MSB4;
      num /= 128;
    }
    while (num & MSBALL3) {
      out[offset++] = num & 255 | MSB4;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode12.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode14 = read4;
  var MSB$13 = 128;
  var REST$13 = 127;
  function read4(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read4.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$13) << shift : (b & REST$13) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$13);
    read4.bytes = counter - offset;
    return res;
  }
  var N14 = Math.pow(2, 7);
  var N24 = Math.pow(2, 14);
  var N34 = Math.pow(2, 21);
  var N44 = Math.pow(2, 28);
  var N54 = Math.pow(2, 35);
  var N64 = Math.pow(2, 42);
  var N74 = Math.pow(2, 49);
  var N83 = Math.pow(2, 56);
  var N93 = Math.pow(2, 63);
  var length4 = function(value) {
    return value < N14 ? 1 : value < N24 ? 2 : value < N34 ? 3 : value < N44 ? 4 : value < N54 ? 5 : value < N64 ? 6 : value < N74 ? 7 : value < N83 ? 8 : value < N93 ? 9 : 10;
  };
  var varint3 = {
    encode: encode_13,
    decode: decode14,
    encodingLength: length4
  };
  var _brrp_varint3 = varint3;
  var varint_default3 = _brrp_varint3;

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/varint.js
  function decode15(data, offset = 0) {
    const code18 = varint_default3.decode(data, offset);
    return [code18, varint_default3.decode.bytes];
  }
  function encodeTo3(int, target, offset = 0) {
    varint_default3.encode(int, target, offset);
    return target;
  }
  function encodingLength4(int) {
    return varint_default3.encodingLength(int);
  }

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/hashes/digest.js
  function create3(code18, digest18) {
    const size = digest18.byteLength;
    const sizeOffset = encodingLength4(code18);
    const digestOffset = sizeOffset + encodingLength4(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo3(code18, bytes2, 0);
    encodeTo3(size, bytes2, sizeOffset);
    bytes2.set(digest18, digestOffset);
    return new Digest3(code18, size, digest18, bytes2);
  }
  function decode16(multihash) {
    const bytes2 = coerce3(multihash);
    const [code18, sizeOffset] = decode15(bytes2);
    const [size, digestOffset] = decode15(bytes2.subarray(sizeOffset));
    const digest18 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest18.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest3(code18, size, digest18, bytes2);
  }
  function equals7(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals6(a.bytes, data.bytes);
    }
  }
  var Digest3 = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code18, size, digest18, bytes2) {
      this.code = code18;
      this.size = size;
      this.digest = digest18;
      this.bytes = bytes2;
    }
  };

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/cid.js
  function format3(link, base37) {
    const { bytes: bytes2, version: version5 } = link;
    switch (version5) {
      case 0:
        return toStringV03(bytes2, baseCache3(link), base37 ?? base58btc3.encoder);
      default:
        return toStringV13(bytes2, baseCache3(link), base37 ?? base323.encoder);
    }
  }
  var cache3 = /* @__PURE__ */ new WeakMap();
  function baseCache3(cid) {
    const baseCache19 = cache3.get(cid);
    if (baseCache19 == null) {
      const baseCache20 = /* @__PURE__ */ new Map();
      cache3.set(cid, baseCache20);
      return baseCache20;
    }
    return baseCache19;
  }
  var CID3 = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version5, code18, multihash, bytes2) {
      this.code = code18;
      this.version = version5;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code18, multihash } = this;
          if (code18 !== DAG_PB_CODE3) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE3) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code18, digest: digest18 } = this.multihash;
          const multihash = create3(code18, digest18);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals7(self2.multihash, unknown.multihash);
    }
    toString(base37) {
      return format3(this, base37);
    }
    toJSON() {
      return { "/": format3(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version5, code: code18, multihash, bytes: bytes2 } = value;
        return new _CID(version5, code18, multihash, bytes2 ?? encodeCID3(version5, code18, multihash.bytes));
      } else if (value[cidSymbol3] === true) {
        const { version: version5, multihash, code: code18 } = value;
        const digest18 = decode16(multihash);
        return _CID.create(version5, code18, digest18);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version5, code18, digest18) {
      if (typeof code18 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest18.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version5) {
        case 0: {
          if (code18 !== DAG_PB_CODE3) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE3}) block encoding`);
          } else {
            return new _CID(version5, code18, digest18, digest18.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID3(version5, code18, digest18.bytes);
          return new _CID(version5, code18, digest18, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest18) {
      return _CID.create(0, DAG_PB_CODE3, digest18);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code18, digest18) {
      return _CID.create(1, code18, digest18);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes2) {
      const [cid, remainder] = _CID.decodeFirst(bytes2);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes2) {
      const specs = _CID.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce3(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest18 = new Digest3(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest18) : _CID.createV1(specs.codec, digest18);
      return [cid, bytes2.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length21] = decode15(initialBytes.subarray(offset));
        offset += length21;
        return i;
      };
      let version5 = next();
      let codec = DAG_PB_CODE3;
      if (version5 === 18) {
        version5 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version5 !== 0 && version5 !== 1) {
        throw new RangeError(`Invalid CID version ${version5}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version5, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base37) {
      const [prefix, bytes2] = parseCIDtoBytes3(source, base37);
      const cid = _CID.decode(bytes2);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache3(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes3(source, base37) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base37 ?? base58btc3;
        return [
          base58btc3.prefix,
          decoder.decode(`${base58btc3.prefix}${source}`)
        ];
      }
      case base58btc3.prefix: {
        const decoder = base37 ?? base58btc3;
        return [base58btc3.prefix, decoder.decode(source)];
      }
      case base323.prefix: {
        const decoder = base37 ?? base323;
        return [base323.prefix, decoder.decode(source)];
      }
      case base363.prefix: {
        const decoder = base37 ?? base363;
        return [base363.prefix, decoder.decode(source)];
      }
      default: {
        if (base37 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base37.decode(source)];
      }
    }
  }
  function toStringV03(bytes2, cache20, base37) {
    const { prefix } = base37;
    if (prefix !== base58btc3.prefix) {
      throw Error(`Cannot string encode V0 in ${base37.name} encoding`);
    }
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2).slice(1);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV13(bytes2, cache20, base37) {
    const { prefix } = base37;
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE3 = 112;
  var SHA_256_CODE3 = 18;
  function encodeCID3(version5, code18, multihash) {
    const codeOffset = encodingLength4(version5);
    const hashOffset = codeOffset + encodingLength4(code18);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo3(version5, bytes2, 0);
    encodeTo3(code18, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  }
  var cidSymbol3 = Symbol.for("@ipld/js-cid/CID");

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports5 = {};
  __export(identity_exports5, {
    identity: () => identity5
  });
  var code3 = 0;
  var name3 = "identity";
  var encode13 = coerce3;
  function digest3(input) {
    return create3(code3, encode13(input));
  }
  var identity5 = { code: code3, name: name3, encode: encode13, digest: digest3 };

  // ../node_modules/@libp2p/crypto/node_modules/uint8arrays/dist/src/equals.js
  function equals8(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports3 = {};
  __export(base10_exports3, {
    base10: () => base103
  });
  var base103 = baseX3({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports3 = {};
  __export(base16_exports3, {
    base16: () => base163,
    base16upper: () => base16upper3
  });
  var base163 = rfc46483({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper3 = rfc46483({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports3 = {};
  __export(base2_exports3, {
    base2: () => base23
  });
  var base23 = rfc46483({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports3 = {};
  __export(base256emoji_exports3, {
    base256emoji: () => base256emoji3
  });
  var alphabet3 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars3 = alphabet3.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes3 = alphabet3.reduce((p, c, i) => {
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
  }, []);
  function encode14(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars3[c];
      return p;
    }, "");
  }
  function decode17(str) {
    const byts = [];
    for (const char of str) {
      const codePoint = char.codePointAt(0);
      if (codePoint == null) {
        throw new Error(`Invalid character: ${char}`);
      }
      const byt = alphabetCharsToBytes3[codePoint];
      if (byt == null) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji3 = from5({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode14,
    decode: decode17
  });

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports3 = {};
  __export(base64_exports3, {
    base64: () => base643,
    base64pad: () => base64pad3,
    base64url: () => base64url3,
    base64urlpad: () => base64urlpad3
  });
  var base643 = rfc46483({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad3 = rfc46483({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url3 = rfc46483({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad3 = rfc46483({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports3 = {};
  __export(base8_exports3, {
    base8: () => base83
  });
  var base83 = rfc46483({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports6 = {};
  __export(identity_exports6, {
    identity: () => identity6
  });
  var identity6 = from5({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString4(buf),
    decode: (str) => fromString5(str)
  });

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/codecs/json.js
  var textEncoder3 = new TextEncoder();
  var textDecoder3 = new TextDecoder();

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports3 = {};
  __export(sha2_browser_exports3, {
    sha256: () => sha2564,
    sha512: () => sha5123
  });

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/hashes/hasher.js
  function from6({ name: name19, code: code18, encode: encode79 }) {
    return new Hasher3(name19, code18, encode79);
  }
  var Hasher3 = class {
    name;
    code;
    encode;
    constructor(name19, code18, encode79) {
      this.name = name19;
      this.code = code18;
      this.encode = encode79;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create3(this.code, result) : result.then((digest18) => create3(this.code, digest18));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  function sha3(name19) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name19, data));
  }
  var sha2564 = from6({
    name: "sha2-256",
    code: 18,
    encode: sha3("SHA-256")
  });
  var sha5123 = from6({
    name: "sha2-512",
    code: 19,
    encode: sha3("SHA-512")
  });

  // ../node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/basics.js
  var bases3 = { ...identity_exports6, ...base2_exports3, ...base8_exports3, ...base10_exports3, ...base16_exports3, ...base32_exports3, ...base36_exports3, ...base58_exports3, ...base64_exports3, ...base256emoji_exports3 };
  var hashes3 = { ...sha2_browser_exports3, ...identity_exports5 };

  // ../node_modules/@libp2p/crypto/node_modules/uint8arrays/dist/src/alloc.js
  function allocUnsafe6(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/@libp2p/crypto/node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec4(name19, prefix, encode79, decode99) {
    return {
      name: name19,
      prefix,
      encoder: {
        name: name19,
        prefix,
        encode: encode79
      },
      decoder: {
        decode: decode99
      }
    };
  }
  var string3 = createCodec4("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder3 = new TextEncoder();
    return encoder3.encode(str.substring(1));
  });
  var ascii3 = createCodec4("ascii", "a", (buf) => {
    let string19 = "a";
    for (let i = 0; i < buf.length; i++) {
      string19 += String.fromCharCode(buf[i]);
    }
    return string19;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe6(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  var BASES3 = {
    utf8: string3,
    "utf-8": string3,
    hex: bases3.base16,
    latin1: ascii3,
    ascii: ascii3,
    binary: ascii3,
    ...bases3
  };
  var bases_default3 = BASES3;

  // ../node_modules/@libp2p/crypto/node_modules/uint8arrays/dist/src/from-string.js
  function fromString6(string19, encoding = "utf8") {
    const base37 = bases_default3[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.decoder.decode(`${base37.prefix}${string19}`);
  }

  // ../node_modules/@libp2p/crypto/node_modules/uint8arrays/dist/src/to-string.js
  function toString5(array, encoding = "utf8") {
    const base37 = bases_default3[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.encoder.encode(array).substring(1);
  }

  // ../node_modules/@libp2p/crypto/dist/src/keys/rsa/der.js
  var TAG_MASK = parseInt("11111", 2);
  var LONG_LENGTH_MASK = parseInt("10000000", 2);
  var LONG_LENGTH_BYTES_MASK = parseInt("01111111", 2);
  var decoders = {
    0: readSequence,
    1: readSequence,
    2: readInteger,
    3: readBitString,
    4: readOctetString,
    5: readNull,
    6: readObjectIdentifier,
    16: readSequence,
    22: readSequence,
    48: readSequence
  };
  function decodeDer(buf, context = { offset: 0 }) {
    const tag = buf[context.offset] & TAG_MASK;
    context.offset++;
    if (decoders[tag] != null) {
      return decoders[tag](buf, context);
    }
    throw new Error("No decoder for tag " + tag);
  }
  function readLength(buf, context) {
    let length21 = 0;
    if ((buf[context.offset] & LONG_LENGTH_MASK) === LONG_LENGTH_MASK) {
      const count = buf[context.offset] & LONG_LENGTH_BYTES_MASK;
      let str = "0x";
      context.offset++;
      for (let i = 0; i < count; i++, context.offset++) {
        str += buf[context.offset].toString(16).padStart(2, "0");
      }
      length21 = parseInt(str, 16);
    } else {
      length21 = buf[context.offset];
      context.offset++;
    }
    return length21;
  }
  function readSequence(buf, context) {
    readLength(buf, context);
    const entries = [];
    while (true) {
      if (context.offset >= buf.byteLength) {
        break;
      }
      const result = decodeDer(buf, context);
      if (result === null) {
        break;
      }
      entries.push(result);
    }
    return entries;
  }
  function readInteger(buf, context) {
    const length21 = readLength(buf, context);
    const start2 = context.offset;
    const end = context.offset + length21;
    const vals = [];
    for (let i = start2; i < end; i++) {
      if (i === start2 && buf[i] === 0) {
        continue;
      }
      vals.push(buf[i]);
    }
    context.offset += length21;
    return Uint8Array.from(vals);
  }
  function readObjectIdentifier(buf, context) {
    const count = readLength(buf, context);
    const finalOffset = context.offset + count;
    const byte = buf[context.offset];
    context.offset++;
    let val1 = 0;
    let val2 = 0;
    if (byte < 40) {
      val1 = 0;
      val2 = byte;
    } else if (byte < 80) {
      val1 = 1;
      val2 = byte - 40;
    } else {
      val1 = 2;
      val2 = byte - 80;
    }
    let oid = `${val1}.${val2}`;
    let num = [];
    while (context.offset < finalOffset) {
      const byte2 = buf[context.offset];
      context.offset++;
      num.push(byte2 & 127);
      if (byte2 < 128) {
        num.reverse();
        let val = 0;
        for (let i = 0; i < num.length; i++) {
          val += num[i] << i * 7;
        }
        oid += `.${val}`;
        num = [];
      }
    }
    return oid;
  }
  function readNull(buf, context) {
    context.offset++;
    return null;
  }
  function readBitString(buf, context) {
    const length21 = readLength(buf, context);
    const unusedBits = buf[context.offset];
    context.offset++;
    const bytes2 = buf.subarray(context.offset, context.offset + length21 - 1);
    context.offset += length21;
    if (unusedBits !== 0) {
      throw new Error("Unused bits in bit string is unimplemented");
    }
    return bytes2;
  }
  function readOctetString(buf, context) {
    const length21 = readLength(buf, context);
    const bytes2 = buf.subarray(context.offset, context.offset + length21);
    context.offset += length21;
    return bytes2;
  }
  function encodeNumber(value) {
    let number3 = value.toString(16);
    if (number3.length % 2 === 1) {
      number3 = "0" + number3;
    }
    const array = new Uint8ArrayList();
    for (let i = 0; i < number3.length; i += 2) {
      array.append(Uint8Array.from([parseInt(`${number3[i]}${number3[i + 1]}`, 16)]));
    }
    return array;
  }
  function encodeLength(bytes2) {
    if (bytes2.byteLength < 128) {
      return Uint8Array.from([bytes2.byteLength]);
    }
    const length21 = encodeNumber(bytes2.byteLength);
    return new Uint8ArrayList(Uint8Array.from([
      length21.byteLength | LONG_LENGTH_MASK
    ]), length21);
  }
  function encodeInteger(value) {
    const contents = new Uint8ArrayList();
    const mask = 128;
    const positive2 = (value.subarray()[0] & mask) === mask;
    if (positive2) {
      contents.append(Uint8Array.from([0]));
    }
    contents.append(value);
    return new Uint8ArrayList(Uint8Array.from([2]), encodeLength(contents), contents);
  }
  function encodeBitString(value) {
    const unusedBits = Uint8Array.from([0]);
    const contents = new Uint8ArrayList(unusedBits, value);
    return new Uint8ArrayList(Uint8Array.from([3]), encodeLength(contents), contents);
  }
  function encodeOctetString(value) {
    return new Uint8ArrayList(Uint8Array.from([4]), encodeLength(value), value);
  }
  function encodeSequence(values, tag = 48) {
    const output2 = new Uint8ArrayList();
    for (const buf of values) {
      output2.append(buf);
    }
    return new Uint8ArrayList(Uint8Array.from([tag]), encodeLength(output2), output2);
  }

  // ../node_modules/@libp2p/crypto/dist/src/keys/ecdsa/index.js
  async function generateECDSAKey(curve = "P-256") {
    const keyPair = await crypto.subtle.generateKey({
      name: "ECDSA",
      namedCurve: curve
    }, true, ["sign", "verify"]);
    return {
      publicKey: await crypto.subtle.exportKey("jwk", keyPair.publicKey),
      privateKey: await crypto.subtle.exportKey("jwk", keyPair.privateKey)
    };
  }
  async function hashAndSign(key, msg, options) {
    const privateKey = await crypto.subtle.importKey("jwk", key, {
      name: "ECDSA",
      namedCurve: key.crv ?? "P-256"
    }, false, ["sign"]);
    options?.signal?.throwIfAborted();
    const signature = await crypto.subtle.sign({
      name: "ECDSA",
      hash: {
        name: "SHA-256"
      }
    }, privateKey, msg.subarray());
    options?.signal?.throwIfAborted();
    return new Uint8Array(signature, 0, signature.byteLength);
  }
  async function hashAndVerify(key, sig, msg, options) {
    const publicKey = await crypto.subtle.importKey("jwk", key, {
      name: "ECDSA",
      namedCurve: key.crv ?? "P-256"
    }, false, ["verify"]);
    options?.signal?.throwIfAborted();
    const result = await crypto.subtle.verify({
      name: "ECDSA",
      hash: {
        name: "SHA-256"
      }
    }, publicKey, sig, msg.subarray());
    options?.signal?.throwIfAborted();
    return result;
  }

  // ../node_modules/@libp2p/crypto/dist/src/keys/ecdsa/utils.js
  var OID_256 = Uint8Array.from([6, 8, 42, 134, 72, 206, 61, 3, 1, 7]);
  var OID_384 = Uint8Array.from([6, 5, 43, 129, 4, 0, 34]);
  var OID_521 = Uint8Array.from([6, 5, 43, 129, 4, 0, 35]);
  var P_256_KEY_JWK = {
    ext: true,
    kty: "EC",
    crv: "P-256"
  };
  var P_384_KEY_JWK = {
    ext: true,
    kty: "EC",
    crv: "P-384"
  };
  var P_521_KEY_JWK = {
    ext: true,
    kty: "EC",
    crv: "P-521"
  };
  var P_256_KEY_LENGTH = 32;
  var P_384_KEY_LENGTH = 48;
  var P_521_KEY_LENGTH = 66;
  function unmarshalECDSAPublicKey(bytes2) {
    const message2 = decodeDer(bytes2);
    return pkiMessageToECDSAPublicKey(message2);
  }
  function pkiMessageToECDSAPublicKey(message2) {
    const coordinates = message2[1][1][0];
    const offset = 1;
    let x;
    let y2;
    if (coordinates.byteLength === P_256_KEY_LENGTH * 2 + 1) {
      x = toString5(coordinates.subarray(offset, offset + P_256_KEY_LENGTH), "base64url");
      y2 = toString5(coordinates.subarray(offset + P_256_KEY_LENGTH), "base64url");
      return new ECDSAPublicKey({
        ...P_256_KEY_JWK,
        key_ops: ["verify"],
        x,
        y: y2
      });
    }
    if (coordinates.byteLength === P_384_KEY_LENGTH * 2 + 1) {
      x = toString5(coordinates.subarray(offset, offset + P_384_KEY_LENGTH), "base64url");
      y2 = toString5(coordinates.subarray(offset + P_384_KEY_LENGTH), "base64url");
      return new ECDSAPublicKey({
        ...P_384_KEY_JWK,
        key_ops: ["verify"],
        x,
        y: y2
      });
    }
    if (coordinates.byteLength === P_521_KEY_LENGTH * 2 + 1) {
      x = toString5(coordinates.subarray(offset, offset + P_521_KEY_LENGTH), "base64url");
      y2 = toString5(coordinates.subarray(offset + P_521_KEY_LENGTH), "base64url");
      return new ECDSAPublicKey({
        ...P_521_KEY_JWK,
        key_ops: ["verify"],
        x,
        y: y2
      });
    }
    throw new InvalidParametersError(`coordinates were wrong length, got ${coordinates.byteLength}, expected 65, 97 or 133`);
  }
  function privateKeyToPKIMessage(privateKey) {
    return encodeSequence([
      encodeInteger(Uint8Array.from([1])),
      // header
      encodeOctetString(fromString6(privateKey.d ?? "", "base64url")),
      // body
      encodeSequence([
        getOID(privateKey.crv)
      ], 160),
      encodeSequence([
        encodeBitString(new Uint8ArrayList(Uint8Array.from([4]), fromString6(privateKey.x ?? "", "base64url"), fromString6(privateKey.y ?? "", "base64url")))
      ], 161)
    ]).subarray();
  }
  function publicKeyToPKIMessage(publicKey) {
    return encodeSequence([
      encodeInteger(Uint8Array.from([1])),
      // header
      encodeSequence([
        getOID(publicKey.crv)
      ], 160),
      encodeSequence([
        encodeBitString(new Uint8ArrayList(Uint8Array.from([4]), fromString6(publicKey.x ?? "", "base64url"), fromString6(publicKey.y ?? "", "base64url")))
      ], 161)
    ]).subarray();
  }
  function getOID(curve) {
    if (curve === "P-256") {
      return OID_256;
    }
    if (curve === "P-384") {
      return OID_384;
    }
    if (curve === "P-521") {
      return OID_521;
    }
    throw new InvalidParametersError(`Invalid curve ${curve}`);
  }
  async function generateECDSAKeyPair(curve = "P-256") {
    const key = await generateECDSAKey(curve);
    return new ECDSAPrivateKey(key.privateKey);
  }

  // ../node_modules/@libp2p/crypto/dist/src/keys/ecdsa/ecdsa.js
  var ECDSAPublicKey = class {
    type = "ECDSA";
    jwk;
    _raw;
    constructor(jwk) {
      this.jwk = jwk;
    }
    get raw() {
      if (this._raw == null) {
        this._raw = publicKeyToPKIMessage(this.jwk);
      }
      return this._raw;
    }
    toMultihash() {
      return identity5.digest(publicKeyToProtobuf(this));
    }
    toCID() {
      return CID3.createV1(114, this.toMultihash());
    }
    toString() {
      return base58btc3.encode(this.toMultihash().bytes).substring(1);
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals8(this.raw, key.raw);
    }
    async verify(data, sig, options) {
      return hashAndVerify(this.jwk, sig, data, options);
    }
  };
  var ECDSAPrivateKey = class {
    type = "ECDSA";
    jwk;
    publicKey;
    _raw;
    constructor(jwk) {
      this.jwk = jwk;
      this.publicKey = new ECDSAPublicKey({
        crv: jwk.crv,
        ext: jwk.ext,
        key_ops: ["verify"],
        kty: "EC",
        x: jwk.x,
        y: jwk.y
      });
    }
    get raw() {
      if (this._raw == null) {
        this._raw = privateKeyToPKIMessage(this.jwk);
      }
      return this._raw;
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals8(this.raw, key.raw);
    }
    async sign(message2, options) {
      return hashAndSign(this.jwk, message2, options);
    }
  };

  // ../node_modules/@libp2p/crypto/node_modules/@noble/hashes/esm/crypto.js
  var crypto3 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

  // ../node_modules/@libp2p/crypto/node_modules/@noble/hashes/esm/utils.js
  function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error("positive integer expected, got " + n);
  }
  function abytes(b, ...lengths) {
    if (!isBytes(b))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
  }
  function ahash(h2) {
    if (typeof h2 !== "function" || typeof h2.create !== "function")
      throw new Error("Hash should be wrapped by utils.createHasher");
    anumber(h2.outputLen);
    anumber(h2.blockLen);
  }
  function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least " + min);
    }
  }
  function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
      arrays[i].fill(0);
    }
  }
  function createView2(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function rotr2(word, shift) {
    return word << 32 - shift | word >>> shift;
  }
  var hasHexBuiltin = /* @__PURE__ */ (() => (
    // @ts-ignore
    typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
  ))();
  var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex2(bytes2) {
    abytes(bytes2);
    if (hasHexBuiltin)
      return bytes2.toHex();
    let hex = "";
    for (let i = 0; i < bytes2.length; i++) {
      hex += hexes[bytes2[i]];
    }
    return hex;
  }
  var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
      return ch - asciis._0;
    if (ch >= asciis.A && ch <= asciis.F)
      return ch - (asciis.A - 10);
    if (ch >= asciis.a && ch <= asciis.f)
      return ch - (asciis.a - 10);
    return;
  }
  function hexToBytes2(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    if (hasHexBuiltin)
      return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase16(hex.charCodeAt(hi));
      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  }
  function utf8ToBytes3(str) {
    if (typeof str !== "string")
      throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes2(data) {
    if (typeof data === "string")
      data = utf8ToBytes3(data);
    abytes(data);
    return data;
  }
  function concatBytes2(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      abytes(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  }
  var Hash2 = class {
  };
  function createHasher(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function randomBytes2(bytesLength = 32) {
    if (crypto3 && typeof crypto3.getRandomValues === "function") {
      return crypto3.getRandomValues(new Uint8Array(bytesLength));
    }
    if (crypto3 && typeof crypto3.randomBytes === "function") {
      return Uint8Array.from(crypto3.randomBytes(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }

  // ../node_modules/@libp2p/crypto/node_modules/@noble/hashes/esm/_md.js
  function setBigUint642(view, byteOffset, value, isLE3) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE3);
    const _32n4 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n4 & _u32_max);
    const wl = Number(value & _u32_max);
    const h2 = isLE3 ? 4 : 0;
    const l = isLE3 ? 0 : 4;
    view.setUint32(byteOffset + h2, wh, isLE3);
    view.setUint32(byteOffset + l, wl, isLE3);
  }
  function Chi2(a, b, c) {
    return a & b ^ ~a & c;
  }
  function Maj2(a, b, c) {
    return a & b ^ a & c ^ b & c;
  }
  var HashMD = class extends Hash2 {
    constructor(blockLen, outputLen, padOffset, isLE3) {
      super();
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE3;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView2(this.buffer);
    }
    update(data) {
      aexists(this);
      data = toBytes2(data);
      abytes(data);
      const { view, buffer, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take2 = Math.min(blockLen - this.pos, len - pos);
        if (take2 === blockLen) {
          const dataView = createView2(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take2), this.pos);
        this.pos += take2;
        pos += take2;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE3 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      clean(this.buffer.subarray(pos));
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE3);
      this.process(view, 0);
      const oview = createView2(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE3);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length: length21, finished, destroyed, pos } = this;
      to.destroyed = destroyed;
      to.finished = finished;
      to.length = length21;
      to.pos = pos;
      if (length21 % blockLen)
        to.buffer.set(buffer);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  };
  var SHA256_IV = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA512_IV = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]);

  // ../node_modules/@libp2p/crypto/node_modules/@noble/hashes/esm/_u64.js
  var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n = /* @__PURE__ */ BigInt(32);
  function fromBig(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
      const { h: h2, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h2, l];
    }
    return [Ah, Al];
  }
  var shrSH = (h2, _l, s2) => h2 >>> s2;
  var shrSL = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
  var rotrSH = (h2, l, s2) => h2 >>> s2 | l << 32 - s2;
  var rotrSL = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
  var rotrBH = (h2, l, s2) => h2 << 64 - s2 | l >>> s2 - 32;
  var rotrBL = (h2, l, s2) => h2 >>> s2 - 32 | l << 64 - s2;
  function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

  // ../node_modules/@libp2p/crypto/node_modules/@noble/hashes/esm/sha2.js
  var SHA256_K2 = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var SHA256_W2 = /* @__PURE__ */ new Uint32Array(64);
  var SHA2562 = class extends HashMD {
    constructor(outputLen = 32) {
      super(64, outputLen, 8, false);
      this.A = SHA256_IV[0] | 0;
      this.B = SHA256_IV[1] | 0;
      this.C = SHA256_IV[2] | 0;
      this.D = SHA256_IV[3] | 0;
      this.E = SHA256_IV[4] | 0;
      this.F = SHA256_IV[5] | 0;
      this.G = SHA256_IV[6] | 0;
      this.H = SHA256_IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        SHA256_W2[i] = view.getUint32(offset, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W2[i - 15];
        const W2 = SHA256_W2[i - 2];
        const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
        const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
        SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = rotr2(E, 6) ^ rotr2(E, 11) ^ rotr2(E, 25);
        const T1 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i] + SHA256_W2[i] | 0;
        const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
        const T2 = sigma0 + Maj2(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      clean(SHA256_W2);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      clean(this.buffer);
    }
  };
  var K512 = /* @__PURE__ */ (() => split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n) => BigInt(n))))();
  var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
  var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
  var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
  var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
  var SHA512 = class extends HashMD {
    constructor(outputLen = 64) {
      super(128, outputLen, 16, false);
      this.Ah = SHA512_IV[0] | 0;
      this.Al = SHA512_IV[1] | 0;
      this.Bh = SHA512_IV[2] | 0;
      this.Bl = SHA512_IV[3] | 0;
      this.Ch = SHA512_IV[4] | 0;
      this.Cl = SHA512_IV[5] | 0;
      this.Dh = SHA512_IV[6] | 0;
      this.Dl = SHA512_IV[7] | 0;
      this.Eh = SHA512_IV[8] | 0;
      this.El = SHA512_IV[9] | 0;
      this.Fh = SHA512_IV[10] | 0;
      this.Fl = SHA512_IV[11] | 0;
      this.Gh = SHA512_IV[12] | 0;
      this.Gl = SHA512_IV[13] | 0;
      this.Hh = SHA512_IV[14] | 0;
      this.Hl = SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4) {
        SHA512_W_H[i] = view.getUint32(offset);
        SHA512_W_L[i] = view.getUint32(offset += 4);
      }
      for (let i = 16; i < 80; i++) {
        const W15h = SHA512_W_H[i - 15] | 0;
        const W15l = SHA512_W_L[i - 15] | 0;
        const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
        const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H[i - 2] | 0;
        const W2l = SHA512_W_L[i - 2] | 0;
        const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
        const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
        const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
        const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
        SHA512_W_H[i] = SUMh | 0;
        SHA512_W_L[i] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i = 0; i < 80; i++) {
        const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
        const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
        const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
        const T1l = T1ll | 0;
        const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
        const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = add3L(T1l, sigma0l, MAJl);
        Ah = add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      clean(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
      clean(this.buffer);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  var sha2565 = /* @__PURE__ */ createHasher(() => new SHA2562());
  var sha5124 = /* @__PURE__ */ createHasher(() => new SHA512());

  // ../node_modules/@libp2p/crypto/node_modules/@noble/curves/esm/utils.js
  var _0n = /* @__PURE__ */ BigInt(0);
  var _1n = /* @__PURE__ */ BigInt(1);
  function _abool2(value, title = "") {
    if (typeof value !== "boolean") {
      const prefix = title && `"${title}"`;
      throw new Error(prefix + "expected boolean, got type=" + typeof value);
    }
    return value;
  }
  function _abytes2(value, length21, title = "") {
    const bytes2 = isBytes(value);
    const len = value?.length;
    const needsLen = length21 !== void 0;
    if (!bytes2 || needsLen && len !== length21) {
      const prefix = title && `"${title}"`;
      const ofLen = needsLen ? ` of length ${length21}` : "";
      const got = bytes2 ? `length=${len}` : `type=${typeof value}`;
      throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
    }
    return value;
  }
  function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? "0" + hex : hex;
  }
  function hexToNumber(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return hex === "" ? _0n : BigInt("0x" + hex);
  }
  function bytesToNumberBE(bytes2) {
    return hexToNumber(bytesToHex2(bytes2));
  }
  function bytesToNumberLE(bytes2) {
    abytes(bytes2);
    return hexToNumber(bytesToHex2(Uint8Array.from(bytes2).reverse()));
  }
  function numberToBytesBE(n, len) {
    return hexToBytes2(n.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
  }
  function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes2(hex);
      } catch (e) {
        throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
      }
    } else if (isBytes(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(title + " must be hex string or Uint8Array");
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(title + " of length " + expectedLength + " expected, got " + len);
    return res;
  }
  function equalBytes(a, b) {
    if (a.length !== b.length)
      return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
      diff |= a[i] ^ b[i];
    return diff === 0;
  }
  function copyBytes(bytes2) {
    return Uint8Array.from(bytes2);
  }
  var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
  function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
  }
  function aInRange(title, n, min, max) {
    if (!inRange(n, min, max))
      throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
  }
  function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
      ;
    return len;
  }
  var bitMask = (n) => (_1n << BigInt(n)) - _1n;
  function createHmacDrbg(hashLen2, qByteLen, hmacFn) {
    if (typeof hashLen2 !== "number" || hashLen2 < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    const u8n = (len) => new Uint8Array(len);
    const u8of = (byte) => Uint8Array.of(byte);
    let v = u8n(hashLen2);
    let k = u8n(hashLen2);
    let i = 0;
    const reset = () => {
      v.fill(1);
      k.fill(0);
      i = 0;
    };
    const h2 = (...b) => hmacFn(k, v, ...b);
    const reseed = (seed = u8n(0)) => {
      k = h2(u8of(0), seed);
      v = h2();
      if (seed.length === 0)
        return;
      k = h2(u8of(1), seed);
      v = h2();
    };
    const gen = () => {
      if (i++ >= 1e3)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v = h2();
        const sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return concatBytes2(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  function _validateObject(object, fields, optFields = {}) {
    if (!object || typeof object !== "object")
      throw new Error("expected valid options object");
    function checkField(fieldName, expectedType, isOpt) {
      const val = object[fieldName];
      if (isOpt && val === void 0)
        return;
      const current = typeof val;
      if (current !== expectedType || val === null)
        throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
  }
  var notImplemented = () => {
    throw new Error("not implemented");
  };
  function memoized(fn) {
    const map2 = /* @__PURE__ */ new WeakMap();
    return (arg, ...args) => {
      const val = map2.get(arg);
      if (val !== void 0)
        return val;
      const computed = fn(arg, ...args);
      map2.set(arg, computed);
      return computed;
    };
  }

  // ../node_modules/@libp2p/crypto/node_modules/@noble/curves/esm/abstract/modular.js
  var _0n2 = BigInt(0);
  var _1n2 = BigInt(1);
  var _2n = /* @__PURE__ */ BigInt(2);
  var _3n = /* @__PURE__ */ BigInt(3);
  var _4n = /* @__PURE__ */ BigInt(4);
  var _5n = /* @__PURE__ */ BigInt(5);
  var _7n = /* @__PURE__ */ BigInt(7);
  var _8n = /* @__PURE__ */ BigInt(8);
  var _9n = /* @__PURE__ */ BigInt(9);
  var _16n = /* @__PURE__ */ BigInt(16);
  function mod2(a, b) {
    const result = a % b;
    return result >= _0n2 ? result : b + result;
  }
  function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n2) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert(number3, modulo) {
    if (number3 === _0n2)
      throw new Error("invert: expected non-zero number");
    if (modulo <= _0n2)
      throw new Error("invert: expected positive modulus, got " + modulo);
    let a = mod2(number3, modulo);
    let b = modulo;
    let x = _0n2, y2 = _1n2, u = _1n2, v = _0n2;
    while (a !== _0n2) {
      const q = b / a;
      const r = b % a;
      const m2 = x - u * q;
      const n = y2 - v * q;
      b = a, a = r, x = u, y2 = v, u = m2, v = n;
    }
    const gcd = b;
    if (gcd !== _1n2)
      throw new Error("invert: does not exist");
    return mod2(x, modulo);
  }
  function assertIsSquare(Fp4, root, n) {
    if (!Fp4.eql(Fp4.sqr(root), n))
      throw new Error("Cannot find square root");
  }
  function sqrt3mod4(Fp4, n) {
    const p1div4 = (Fp4.ORDER + _1n2) / _4n;
    const root = Fp4.pow(n, p1div4);
    assertIsSquare(Fp4, root, n);
    return root;
  }
  function sqrt5mod8(Fp4, n) {
    const p5div8 = (Fp4.ORDER - _5n) / _8n;
    const n2 = Fp4.mul(n, _2n);
    const v = Fp4.pow(n2, p5div8);
    const nv = Fp4.mul(n, v);
    const i = Fp4.mul(Fp4.mul(nv, _2n), v);
    const root = Fp4.mul(nv, Fp4.sub(i, Fp4.ONE));
    assertIsSquare(Fp4, root, n);
    return root;
  }
  function sqrt9mod16(P) {
    const Fp_ = Field(P);
    const tn = tonelliShanks(P);
    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
    const c2 = tn(Fp_, c1);
    const c3 = tn(Fp_, Fp_.neg(c1));
    const c4 = (P + _7n) / _16n;
    return (Fp4, n) => {
      let tv1 = Fp4.pow(n, c4);
      let tv2 = Fp4.mul(tv1, c1);
      const tv3 = Fp4.mul(tv1, c2);
      const tv4 = Fp4.mul(tv1, c3);
      const e1 = Fp4.eql(Fp4.sqr(tv2), n);
      const e2 = Fp4.eql(Fp4.sqr(tv3), n);
      tv1 = Fp4.cmov(tv1, tv2, e1);
      tv2 = Fp4.cmov(tv4, tv3, e2);
      const e3 = Fp4.eql(Fp4.sqr(tv2), n);
      const root = Fp4.cmov(tv1, tv2, e3);
      assertIsSquare(Fp4, root, n);
      return root;
    };
  }
  function tonelliShanks(P) {
    if (P < _3n)
      throw new Error("sqrt is not defined for small field");
    let Q = P - _1n2;
    let S = 0;
    while (Q % _2n === _0n2) {
      Q /= _2n;
      S++;
    }
    let Z = _2n;
    const _Fp = Field(P);
    while (FpLegendre(_Fp, Z) === 1) {
      if (Z++ > 1e3)
        throw new Error("Cannot find square root: probably non-prime P");
    }
    if (S === 1)
      return sqrt3mod4;
    let cc = _Fp.pow(Z, Q);
    const Q1div2 = (Q + _1n2) / _2n;
    return function tonelliSlow(Fp4, n) {
      if (Fp4.is0(n))
        return n;
      if (FpLegendre(Fp4, n) !== 1)
        throw new Error("Cannot find square root");
      let M = S;
      let c = Fp4.mul(Fp4.ONE, cc);
      let t = Fp4.pow(n, Q);
      let R = Fp4.pow(n, Q1div2);
      while (!Fp4.eql(t, Fp4.ONE)) {
        if (Fp4.is0(t))
          return Fp4.ZERO;
        let i = 1;
        let t_tmp = Fp4.sqr(t);
        while (!Fp4.eql(t_tmp, Fp4.ONE)) {
          i++;
          t_tmp = Fp4.sqr(t_tmp);
          if (i === M)
            throw new Error("Cannot find square root");
        }
        const exponent = _1n2 << BigInt(M - i - 1);
        const b = Fp4.pow(c, exponent);
        M = i;
        c = Fp4.sqr(b);
        t = Fp4.mul(t, c);
        R = Fp4.mul(R, b);
      }
      return R;
    };
  }
  function FpSqrt(P) {
    if (P % _4n === _3n)
      return sqrt3mod4;
    if (P % _8n === _5n)
      return sqrt5mod8;
    if (P % _16n === _9n)
      return sqrt9mod16(P);
    return tonelliShanks(P);
  }
  var isNegativeLE = (num, modulo) => (mod2(num, modulo) & _1n2) === _1n2;
  var FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "number",
      BITS: "number"
    };
    const opts = FIELD_FIELDS.reduce((map2, val) => {
      map2[val] = "function";
      return map2;
    }, initial);
    _validateObject(field, opts);
    return field;
  }
  function FpPow(Fp4, num, power) {
    if (power < _0n2)
      throw new Error("invalid exponent, negatives unsupported");
    if (power === _0n2)
      return Fp4.ONE;
    if (power === _1n2)
      return num;
    let p = Fp4.ONE;
    let d2 = num;
    while (power > _0n2) {
      if (power & _1n2)
        p = Fp4.mul(p, d2);
      d2 = Fp4.sqr(d2);
      power >>= _1n2;
    }
    return p;
  }
  function FpInvertBatch(Fp4, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp4.ZERO : void 0);
    const multipliedAcc = nums.reduce((acc, num, i) => {
      if (Fp4.is0(num))
        return acc;
      inverted[i] = acc;
      return Fp4.mul(acc, num);
    }, Fp4.ONE);
    const invertedAcc = Fp4.inv(multipliedAcc);
    nums.reduceRight((acc, num, i) => {
      if (Fp4.is0(num))
        return acc;
      inverted[i] = Fp4.mul(acc, inverted[i]);
      return Fp4.mul(acc, num);
    }, invertedAcc);
    return inverted;
  }
  function FpLegendre(Fp4, n) {
    const p1mod2 = (Fp4.ORDER - _1n2) / _2n;
    const powered = Fp4.pow(n, p1mod2);
    const yes = Fp4.eql(powered, Fp4.ONE);
    const zero2 = Fp4.eql(powered, Fp4.ZERO);
    const no = Fp4.eql(powered, Fp4.neg(Fp4.ONE));
    if (!yes && !zero2 && !no)
      throw new Error("invalid Legendre symbol result");
    return yes ? 1 : zero2 ? 0 : -1;
  }
  function nLength(n, nBitLength) {
    if (nBitLength !== void 0)
      anumber(nBitLength);
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field(ORDER, bitLenOrOpts, isLE3 = false, opts = {}) {
    if (ORDER <= _0n2)
      throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
    let _nbitLength = void 0;
    let _sqrt = void 0;
    let modFromBytes = false;
    let allowedLengths = void 0;
    if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
      if (opts.sqrt || isLE3)
        throw new Error("cannot specify opts in two arguments");
      const _opts = bitLenOrOpts;
      if (_opts.BITS)
        _nbitLength = _opts.BITS;
      if (_opts.sqrt)
        _sqrt = _opts.sqrt;
      if (typeof _opts.isLE === "boolean")
        isLE3 = _opts.isLE;
      if (typeof _opts.modFromBytes === "boolean")
        modFromBytes = _opts.modFromBytes;
      allowedLengths = _opts.allowedLengths;
    } else {
      if (typeof bitLenOrOpts === "number")
        _nbitLength = bitLenOrOpts;
      if (opts.sqrt)
        _sqrt = opts.sqrt;
    }
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
    if (BYTES > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let sqrtP;
    const f = Object.freeze({
      ORDER,
      isLE: isLE3,
      BITS,
      BYTES,
      MASK: bitMask(BITS),
      ZERO: _0n2,
      ONE: _1n2,
      allowedLengths,
      create: (num) => mod2(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error("invalid field element: expected bigint, got " + typeof num);
        return _0n2 <= num && num < ORDER;
      },
      is0: (num) => num === _0n2,
      // is valid and invertible
      isValidNot0: (num) => !f.is0(num) && f.isValid(num),
      isOdd: (num) => (num & _1n2) === _1n2,
      neg: (num) => mod2(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod2(num * num, ORDER),
      add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
      pow: (num, power) => FpPow(f, num, power),
      div: (lhs, rhs) => mod2(lhs * invert(rhs, ORDER), ORDER),
      // Same as above, but doesn't normalize
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert(num, ORDER),
      sqrt: _sqrt || ((n) => {
        if (!sqrtP)
          sqrtP = FpSqrt(ORDER);
        return sqrtP(f, n);
      }),
      toBytes: (num) => isLE3 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
      fromBytes: (bytes2, skipValidation = true) => {
        if (allowedLengths) {
          if (!allowedLengths.includes(bytes2.length) || bytes2.length > BYTES) {
            throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes2.length);
          }
          const padded = new Uint8Array(BYTES);
          padded.set(bytes2, isLE3 ? 0 : padded.length - bytes2.length);
          bytes2 = padded;
        }
        if (bytes2.length !== BYTES)
          throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes2.length);
        let scalar = isLE3 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
        if (modFromBytes)
          scalar = mod2(scalar, ORDER);
        if (!skipValidation) {
          if (!f.isValid(scalar))
            throw new Error("invalid field element: outside of range 0..ORDER");
        }
        return scalar;
      },
      // TODO: we don't need it here, move out to separate fn
      invertBatch: (lst) => FpInvertBatch(f, lst),
      // We can't move this out because Fp6, Fp12 implement it
      // and it's unclear what to return in there.
      cmov: (a, b, c) => c ? b : a
    });
    return Object.freeze(f);
  }
  function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  function getMinHashLength(fieldOrder) {
    const length21 = getFieldBytesLength(fieldOrder);
    return length21 + Math.ceil(length21 / 2);
  }
  function mapHashToField(key, fieldOrder, isLE3 = false) {
    const len = key.length;
    const fieldLen2 = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    if (len < 16 || len < minLen || len > 1024)
      throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
    const num = isLE3 ? bytesToNumberLE(key) : bytesToNumberBE(key);
    const reduced = mod2(num, fieldOrder - _1n2) + _1n2;
    return isLE3 ? numberToBytesLE(reduced, fieldLen2) : numberToBytesBE(reduced, fieldLen2);
  }

  // ../node_modules/@libp2p/crypto/node_modules/@noble/curves/esm/abstract/curve.js
  var _0n3 = BigInt(0);
  var _1n3 = BigInt(1);
  function negateCt(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
  }
  function normalizeZ(c, points) {
    const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));
    return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
  }
  function validateW(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
      throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
  }
  function calcWOpts(W, scalarBits) {
    validateW(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1;
    const windowSize = 2 ** (W - 1);
    const maxNumber = 2 ** W;
    const mask = bitMask(W);
    const shiftBy = BigInt(W);
    return { windows, windowSize, mask, maxNumber, shiftBy };
  }
  function calcOffsets(n, window2, wOpts) {
    const { windowSize, mask, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n & mask);
    let nextN = n >> shiftBy;
    if (wbits > windowSize) {
      wbits -= maxNumber;
      nextN += _1n3;
    }
    const offsetStart = window2 * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1;
    const isZero = wbits === 0;
    const isNeg = wbits < 0;
    const isNegF = window2 % 2 !== 0;
    const offsetF = offsetStart;
    return { nextN, offset, isZero, isNeg, isNegF, offsetF };
  }
  function validateMSMPoints(points, c) {
    if (!Array.isArray(points))
      throw new Error("array expected");
    points.forEach((p, i) => {
      if (!(p instanceof c))
        throw new Error("invalid point at index " + i);
    });
  }
  function validateMSMScalars(scalars, field) {
    if (!Array.isArray(scalars))
      throw new Error("array of scalars expected");
    scalars.forEach((s2, i) => {
      if (!field.isValid(s2))
        throw new Error("invalid scalar at index " + i);
    });
  }
  var pointPrecomputes = /* @__PURE__ */ new WeakMap();
  var pointWindowSizes = /* @__PURE__ */ new WeakMap();
  function getW(P) {
    return pointWindowSizes.get(P) || 1;
  }
  function assert0(n) {
    if (n !== _0n3)
      throw new Error("invalid wNAF");
  }
  var wNAF = class {
    // Parametrized with a given Point class (not individual point)
    constructor(Point2, bits) {
      this.BASE = Point2.BASE;
      this.ZERO = Point2.ZERO;
      this.Fn = Point2.Fn;
      this.bits = bits;
    }
    // non-const time multiplication ladder
    _unsafeLadder(elm, n, p = this.ZERO) {
      let d2 = elm;
      while (n > _0n3) {
        if (n & _1n3)
          p = p.add(d2);
        d2 = d2.double();
        n >>= _1n3;
      }
      return p;
    }
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param point Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(point, W) {
      const { windows, windowSize } = calcWOpts(W, this.bits);
      const points = [];
      let p = point;
      let base37 = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base37 = p;
        points.push(base37);
        for (let i = 1; i < windowSize; i++) {
          base37 = base37.add(p);
          points.push(base37);
        }
        p = base37.double();
      }
      return points;
    }
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * More compact implementation:
     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      if (!this.Fn.isValid(n))
        throw new Error("invalid scalar");
      let p = this.ZERO;
      let f = this.BASE;
      const wo = calcWOpts(W, this.bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
        n = nextN;
        if (isZero) {
          f = f.add(negateCt(isNegF, precomputes[offsetF]));
        } else {
          p = p.add(negateCt(isNeg, precomputes[offset]));
        }
      }
      assert0(n);
      return { p, f };
    }
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
      const wo = calcWOpts(W, this.bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        if (n === _0n3)
          break;
        const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
        n = nextN;
        if (isZero) {
          continue;
        } else {
          const item = precomputes[offset];
          acc = acc.add(isNeg ? item.negate() : item);
        }
      }
      assert0(n);
      return acc;
    }
    getPrecomputes(W, point, transform) {
      let comp = pointPrecomputes.get(point);
      if (!comp) {
        comp = this.precomputeWindow(point, W);
        if (W !== 1) {
          if (typeof transform === "function")
            comp = transform(comp);
          pointPrecomputes.set(point, comp);
        }
      }
      return comp;
    }
    cached(point, scalar, transform) {
      const W = getW(point);
      return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
    }
    unsafe(point, scalar, transform, prev) {
      const W = getW(point);
      if (W === 1)
        return this._unsafeLadder(point, scalar, prev);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
    }
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    createCache(P, W) {
      validateW(W, this.bits);
      pointWindowSizes.set(P, W);
      pointPrecomputes.delete(P);
    }
    hasCache(elm) {
      return getW(elm) !== 1;
    }
  };
  function mulEndoUnsafe(Point2, point, k1, k2) {
    let acc = point;
    let p1 = Point2.ZERO;
    let p2 = Point2.ZERO;
    while (k1 > _0n3 || k2 > _0n3) {
      if (k1 & _1n3)
        p1 = p1.add(acc);
      if (k2 & _1n3)
        p2 = p2.add(acc);
      acc = acc.double();
      k1 >>= _1n3;
      k2 >>= _1n3;
    }
    return { p1, p2 };
  }
  function pippenger(c, fieldN, points, scalars) {
    validateMSMPoints(points, c);
    validateMSMScalars(scalars, fieldN);
    const plength = points.length;
    const slength = scalars.length;
    if (plength !== slength)
      throw new Error("arrays of points and scalars must have equal length");
    const zero2 = c.ZERO;
    const wbits = bitLen(BigInt(plength));
    let windowSize = 1;
    if (wbits > 12)
      windowSize = wbits - 3;
    else if (wbits > 4)
      windowSize = wbits - 2;
    else if (wbits > 0)
      windowSize = 2;
    const MASK = bitMask(windowSize);
    const buckets = new Array(Number(MASK) + 1).fill(zero2);
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero2;
    for (let i = lastBits; i >= 0; i -= windowSize) {
      buckets.fill(zero2);
      for (let j = 0; j < slength; j++) {
        const scalar = scalars[j];
        const wbits2 = Number(scalar >> BigInt(i) & MASK);
        buckets[wbits2] = buckets[wbits2].add(points[j]);
      }
      let resI = zero2;
      for (let j = buckets.length - 1, sumI = zero2; j > 0; j--) {
        sumI = sumI.add(buckets[j]);
        resI = resI.add(sumI);
      }
      sum = sum.add(resI);
      if (i !== 0)
        for (let j = 0; j < windowSize; j++)
          sum = sum.double();
    }
    return sum;
  }
  function createField(order, field, isLE3) {
    if (field) {
      if (field.ORDER !== order)
        throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
      validateField(field);
      return field;
    } else {
      return Field(order, { isLE: isLE3 });
    }
  }
  function _createCurveFields(type, CURVE2, curveOpts = {}, FpFnLE) {
    if (FpFnLE === void 0)
      FpFnLE = type === "edwards";
    if (!CURVE2 || typeof CURVE2 !== "object")
      throw new Error(`expected valid ${type} CURVE object`);
    for (const p of ["p", "n", "h"]) {
      const val = CURVE2[p];
      if (!(typeof val === "bigint" && val > _0n3))
        throw new Error(`CURVE.${p} must be positive bigint`);
    }
    const Fp4 = createField(CURVE2.p, curveOpts.Fp, FpFnLE);
    const Fn3 = createField(CURVE2.n, curveOpts.Fn, FpFnLE);
    const _b = type === "weierstrass" ? "b" : "d";
    const params = ["Gx", "Gy", "a", _b];
    for (const p of params) {
      if (!Fp4.isValid(CURVE2[p]))
        throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
    }
    CURVE2 = Object.freeze(Object.assign({}, CURVE2));
    return { CURVE: CURVE2, Fp: Fp4, Fn: Fn3 };
  }

  // ../node_modules/@libp2p/crypto/node_modules/@noble/curves/esm/abstract/edwards.js
  var _0n4 = BigInt(0);
  var _1n4 = BigInt(1);
  var _2n2 = BigInt(2);
  var _8n2 = BigInt(8);
  function isEdValidXY(Fp4, CURVE2, x, y2) {
    const x2 = Fp4.sqr(x);
    const y22 = Fp4.sqr(y2);
    const left = Fp4.add(Fp4.mul(CURVE2.a, x2), y22);
    const right = Fp4.add(Fp4.ONE, Fp4.mul(CURVE2.d, Fp4.mul(x2, y22)));
    return Fp4.eql(left, right);
  }
  function edwards(params, extraOpts = {}) {
    const validated = _createCurveFields("edwards", params, extraOpts, extraOpts.FpFnLE);
    const { Fp: Fp4, Fn: Fn3 } = validated;
    let CURVE2 = validated.CURVE;
    const { h: cofactor, n: CURVE_ORDER } = CURVE2;
    _validateObject(extraOpts, {}, { uvRatio: "function" });
    const MASK = _2n2 << BigInt(Fn3.BYTES * 8) - _1n4;
    const modP = (n) => Fp4.create(n);
    const uvRatio4 = extraOpts.uvRatio || ((u, v) => {
      try {
        return { isValid: true, value: Fp4.sqrt(Fp4.div(u, v)) };
      } catch (e) {
        return { isValid: false, value: _0n4 };
      }
    });
    if (!isEdValidXY(Fp4, CURVE2, CURVE2.Gx, CURVE2.Gy))
      throw new Error("bad curve params: generator point");
    function acoord(title, n, banZero = false) {
      const min = banZero ? _1n4 : _0n4;
      aInRange("coordinate " + title, n, min, MASK);
      return n;
    }
    function aextpoint(other) {
      if (!(other instanceof Point2))
        throw new Error("ExtendedPoint expected");
    }
    const toAffineMemo = memoized((p, iz) => {
      const { X, Y, Z } = p;
      const is0 = p.is0();
      if (iz == null)
        iz = is0 ? _8n2 : Fp4.inv(Z);
      const x = modP(X * iz);
      const y2 = modP(Y * iz);
      const zz = Fp4.mul(Z, iz);
      if (is0)
        return { x: _0n4, y: _1n4 };
      if (zz !== _1n4)
        throw new Error("invZ was invalid");
      return { x, y: y2 };
    });
    const assertValidMemo = memoized((p) => {
      const { a, d: d2 } = CURVE2;
      if (p.is0())
        throw new Error("bad point: ZERO");
      const { X, Y, Z, T } = p;
      const X2 = modP(X * X);
      const Y2 = modP(Y * Y);
      const Z2 = modP(Z * Z);
      const Z4 = modP(Z2 * Z2);
      const aX2 = modP(X2 * a);
      const left = modP(Z2 * modP(aX2 + Y2));
      const right = modP(Z4 + modP(d2 * modP(X2 * Y2)));
      if (left !== right)
        throw new Error("bad point: equation left != right (1)");
      const XY = modP(X * Y);
      const ZT = modP(Z * T);
      if (XY !== ZT)
        throw new Error("bad point: equation left != right (2)");
      return true;
    });
    class Point2 {
      constructor(X, Y, Z, T) {
        this.X = acoord("x", X);
        this.Y = acoord("y", Y);
        this.Z = acoord("z", Z, true);
        this.T = acoord("t", T);
        Object.freeze(this);
      }
      static CURVE() {
        return CURVE2;
      }
      static fromAffine(p) {
        if (p instanceof Point2)
          throw new Error("extended point not allowed");
        const { x, y: y2 } = p || {};
        acoord("x", x);
        acoord("y", y2);
        return new Point2(x, y2, _1n4, modP(x * y2));
      }
      // Uses algo from RFC8032 5.1.3.
      static fromBytes(bytes2, zip215 = false) {
        const len = Fp4.BYTES;
        const { a, d: d2 } = CURVE2;
        bytes2 = copyBytes(_abytes2(bytes2, len, "point"));
        _abool2(zip215, "zip215");
        const normed = copyBytes(bytes2);
        const lastByte = bytes2[len - 1];
        normed[len - 1] = lastByte & ~128;
        const y2 = bytesToNumberLE(normed);
        const max = zip215 ? MASK : Fp4.ORDER;
        aInRange("pointHex.y", y2, _0n4, max);
        const y22 = modP(y2 * y2);
        const u = modP(y22 - _1n4);
        const v = modP(d2 * y22 - a);
        let { isValid, value: x } = uvRatio4(u, v);
        if (!isValid)
          throw new Error("Point.fromHex: invalid y coordinate");
        const isXOdd = (x & _1n4) === _1n4;
        const isLastByteOdd = (lastByte & 128) !== 0;
        if (!zip215 && x === _0n4 && isLastByteOdd)
          throw new Error("Point.fromHex: x=0 and x_0=1");
        if (isLastByteOdd !== isXOdd)
          x = modP(-x);
        return Point2.fromAffine({ x, y: y2 });
      }
      static fromHex(bytes2, zip215 = false) {
        return Point2.fromBytes(ensureBytes("point", bytes2), zip215);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      precompute(windowSize = 8, isLazy = true) {
        wnaf.createCache(this, windowSize);
        if (!isLazy)
          this.multiply(_2n2);
        return this;
      }
      // Useful in fromAffine() - not for fromBytes(), which always created valid points.
      assertValidity() {
        assertValidMemo(this);
      }
      // Compare one point to another.
      equals(other) {
        aextpoint(other);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const { X: X2, Y: Y2, Z: Z2 } = other;
        const X1Z2 = modP(X1 * Z2);
        const X2Z1 = modP(X2 * Z1);
        const Y1Z2 = modP(Y1 * Z2);
        const Y2Z1 = modP(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      is0() {
        return this.equals(Point2.ZERO);
      }
      negate() {
        return new Point2(modP(-this.X), this.Y, this.Z, modP(-this.T));
      }
      // Fast algo for doubling Extended Point.
      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
      // Cost: 4M + 4S + 1*a + 6add + 1*2.
      double() {
        const { a } = CURVE2;
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const A = modP(X1 * X1);
        const B = modP(Y1 * Y1);
        const C = modP(_2n2 * modP(Z1 * Z1));
        const D = modP(a * A);
        const x1y1 = X1 + Y1;
        const E = modP(modP(x1y1 * x1y1) - A - B);
        const G = D + B;
        const F = G - C;
        const H = D - B;
        const X3 = modP(E * F);
        const Y3 = modP(G * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G);
        return new Point2(X3, Y3, Z3, T3);
      }
      // Fast algo for adding 2 Extended Points.
      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
      // Cost: 9M + 1*a + 1*d + 7add.
      add(other) {
        aextpoint(other);
        const { a, d: d2 } = CURVE2;
        const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
        const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
        const A = modP(X1 * X2);
        const B = modP(Y1 * Y2);
        const C = modP(T1 * d2 * T2);
        const D = modP(Z1 * Z2);
        const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
        const F = D - C;
        const G = D + C;
        const H = modP(B - a * A);
        const X3 = modP(E * F);
        const Y3 = modP(G * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G);
        return new Point2(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      // Constant-time multiplication.
      multiply(scalar) {
        const n = scalar;
        aInRange("scalar", n, _1n4, CURVE_ORDER);
        const { p, f } = wnaf.cached(this, n, (p2) => normalizeZ(Point2, p2));
        return normalizeZ(Point2, [p, f])[0];
      }
      // Non-constant-time multiplication. Uses double-and-add algorithm.
      // It's faster, but should only be used when you don't care about
      // an exposed private key e.g. sig verification.
      // Does NOT allow scalars higher than CURVE.n.
      // Accepts optional accumulator to merge with multiply (important for sparse scalars)
      multiplyUnsafe(scalar, acc = Point2.ZERO) {
        const n = scalar;
        aInRange("scalar", n, _0n4, CURVE_ORDER);
        if (n === _0n4)
          return Point2.ZERO;
        if (this.is0() || n === _1n4)
          return this;
        return wnaf.unsafe(this, n, (p) => normalizeZ(Point2, p), acc);
      }
      // Checks if point is of small order.
      // If you add something to small order point, you will have "dirty"
      // point with torsion component.
      // Multiplies point by cofactor and checks if the result is 0.
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      // Multiplies point by curve order and checks if the result is 0.
      // Returns `false` is the point is dirty.
      isTorsionFree() {
        return wnaf.unsafe(this, CURVE_ORDER).is0();
      }
      // Converts Extended point to default (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      toAffine(invertedZ) {
        return toAffineMemo(this, invertedZ);
      }
      clearCofactor() {
        if (cofactor === _1n4)
          return this;
        return this.multiplyUnsafe(cofactor);
      }
      toBytes() {
        const { x, y: y2 } = this.toAffine();
        const bytes2 = numberToBytesLE(y2, Fp4.BYTES);
        bytes2[bytes2.length - 1] |= x & _1n4 ? 128 : 0;
        return bytes2;
      }
      /** @deprecated use `toBytes` */
      toRawBytes() {
        return this.toBytes();
      }
      toHex() {
        return bytesToHex2(this.toBytes());
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
      // TODO: remove
      get ex() {
        return this.X;
      }
      get ey() {
        return this.Y;
      }
      get ez() {
        return this.Z;
      }
      get et() {
        return this.T;
      }
      static normalizeZ(points) {
        return normalizeZ(Point2, points);
      }
      static msm(points, scalars) {
        return pippenger(Point2, Fn3, points, scalars);
      }
      _setWindowSize(windowSize) {
        this.precompute(windowSize);
      }
    }
    Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy, _1n4, modP(CURVE2.Gx * CURVE2.Gy));
    Point2.ZERO = new Point2(_0n4, _1n4, _1n4, _0n4);
    Point2.Fp = Fp4;
    Point2.Fn = Fn3;
    const wnaf = new wNAF(Point2, Fn3.BYTES * 8);
    return Point2;
  }
  var PrimeEdwardsPoint = class {
    constructor(ep) {
      this.ep = ep;
    }
    // Static methods that must be implemented by subclasses
    static fromBytes(_bytes) {
      notImplemented();
    }
    static fromHex(_hex) {
      notImplemented();
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    // Common implementations
    clearCofactor() {
      return this;
    }
    assertValidity() {
      this.ep.assertValidity();
    }
    toAffine(invertedZ) {
      return this.ep.toAffine(invertedZ);
    }
    /** @deprecated use `toBytes` */
    toRawBytes() {
      return this.toBytes();
    }
    toHex() {
      return bytesToHex2(this.toBytes());
    }
    toString() {
      return this.toHex();
    }
    isTorsionFree() {
      return true;
    }
    isSmallOrder() {
      return false;
    }
    add(other) {
      this.assertSame(other);
      return this.init(this.ep.add(other.ep));
    }
    subtract(other) {
      this.assertSame(other);
      return this.init(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
      return this.init(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
      return this.init(this.ep.multiplyUnsafe(scalar));
    }
    double() {
      return this.init(this.ep.double());
    }
    negate() {
      return this.init(this.ep.negate());
    }
    precompute(windowSize, isLazy) {
      return this.init(this.ep.precompute(windowSize, isLazy));
    }
  };
  function eddsa(Point2, cHash, eddsaOpts = {}) {
    if (typeof cHash !== "function")
      throw new Error('"hash" function param is required');
    _validateObject(eddsaOpts, {}, {
      adjustScalarBytes: "function",
      randomBytes: "function",
      domain: "function",
      prehash: "function",
      mapToCurve: "function"
    });
    const { prehash } = eddsaOpts;
    const { BASE: G, Fp: Fp4, Fn: Fn3 } = Point2;
    const CURVE_ORDER = Fn3.ORDER;
    const randomBytes_ = eddsaOpts.randomBytes || randomBytes2;
    const adjustScalarBytes4 = eddsaOpts.adjustScalarBytes || ((bytes2) => bytes2);
    const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
      _abool2(phflag, "phflag");
      if (ctx.length || phflag)
        throw new Error("Contexts/pre-hash are not supported");
      return data;
    });
    function modN(a) {
      return Fn3.create(a);
    }
    function modN_LE(hash2) {
      return modN(bytesToNumberLE(hash2));
    }
    function getPrivateScalar(key) {
      const len = lengths.secret;
      key = ensureBytes("private key", key, len);
      const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
      const head = adjustScalarBytes4(hashed.slice(0, len));
      const prefix = hashed.slice(len, 2 * len);
      const scalar = modN_LE(head);
      return { head, prefix, scalar };
    }
    function getExtendedPublicKey(secretKey) {
      const { head, prefix, scalar } = getPrivateScalar(secretKey);
      const point = G.multiply(scalar);
      const pointBytes = point.toBytes();
      return { head, prefix, scalar, point, pointBytes };
    }
    function getPublicKey(secretKey) {
      return getExtendedPublicKey(secretKey).pointBytes;
    }
    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
      const msg = concatBytes2(...msgs);
      return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
    }
    function sign3(msg, secretKey, options = {}) {
      msg = ensureBytes("message", msg);
      if (prehash)
        msg = prehash(msg);
      const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
      const r = hashDomainToScalar(options.context, prefix, msg);
      const R = G.multiply(r).toBytes();
      const k = hashDomainToScalar(options.context, R, pointBytes, msg);
      const s2 = modN(r + k * scalar);
      aInRange("signature.s", s2, _0n4, CURVE_ORDER);
      const L = Fp4.BYTES;
      const res = concatBytes2(R, numberToBytesLE(s2, L));
      return ensureBytes("result", res, L * 2);
    }
    const verifyOpts = { zip215: true };
    function verify2(sig, msg, publicKey, options = verifyOpts) {
      const { context, zip215 } = options;
      const len = lengths.signature;
      sig = ensureBytes("signature", sig, len);
      msg = ensureBytes("message", msg);
      publicKey = ensureBytes("publicKey", publicKey, lengths.public);
      if (zip215 !== void 0)
        _abool2(zip215, "zip215");
      if (prehash)
        msg = prehash(msg);
      const mid = len / 2;
      const r = sig.subarray(0, mid);
      const s2 = bytesToNumberLE(sig.subarray(mid, len));
      let A, R, SB;
      try {
        A = Point2.fromBytes(publicKey, zip215);
        R = Point2.fromBytes(r, zip215);
        SB = G.multiplyUnsafe(s2);
      } catch (error) {
        return false;
      }
      if (!zip215 && A.isSmallOrder())
        return false;
      const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
      const RkA = R.add(A.multiplyUnsafe(k));
      return RkA.subtract(SB).clearCofactor().is0();
    }
    G.precompute(8);
    const _size = Fp4.BYTES;
    const lengths = {
      secret: _size,
      public: _size,
      signature: 2 * _size,
      seed: _size
    };
    function randomSecretKey(seed = randomBytes_(lengths.seed)) {
      return _abytes2(seed, lengths.seed, "seed");
    }
    function keygen(seed) {
      const secretKey = utils2.randomSecretKey(seed);
      return { secretKey, publicKey: getPublicKey(secretKey) };
    }
    function isValidSecretKey(key) {
      try {
        return !!Fn3.fromBytes(key, false);
      } catch (error) {
        return false;
      }
    }
    function isValidPublicKey(key, zip215) {
      try {
        return !!Point2.fromBytes(key, zip215);
      } catch (error) {
        return false;
      }
    }
    const utils2 = {
      getExtendedPublicKey,
      randomSecretKey,
      isValidSecretKey,
      isValidPublicKey,
      /**
       * Converts ed public key to x public key. Uses formula:
       * - ed25519:
       *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
       *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
       * - ed448:
       *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
       *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
       *
       * There is NO `fromMontgomery`:
       * - There are 2 valid ed25519 points for every x25519, with flipped coordinate
       * - Sometimes there are 0 valid ed25519 points, because x25519 *additionally*
       *   accepts inputs on the quadratic twist, which can't be moved to ed25519
       */
      toMontgomery(publicKey) {
        const { y: y2 } = Point2.fromBytes(publicKey);
        const size = lengths.public;
        const is25519 = size === 32;
        if (!is25519 && size !== 57)
          throw new Error("only defined for 25519 and 448");
        const u = is25519 ? Fp4.div(_1n4 + y2, _1n4 - y2) : Fp4.div(y2 - _1n4, y2 + _1n4);
        return Fp4.toBytes(u);
      },
      toMontgomeryPriv(secretKey) {
        const size = lengths.secret;
        _abytes2(secretKey, size);
        const hashed = cHash(secretKey.subarray(0, size));
        return adjustScalarBytes4(hashed).subarray(0, size);
      },
      /** @deprecated */
      randomPrivateKey: randomSecretKey,
      /** @deprecated */
      precompute(windowSize = 8, point = Point2.BASE) {
        return point.precompute(windowSize, false);
      }
    };
    return Object.freeze({
      keygen,
      getPublicKey,
      sign: sign3,
      verify: verify2,
      utils: utils2,
      Point: Point2,
      lengths
    });
  }
  function _eddsa_legacy_opts_to_new(c) {
    const CURVE2 = {
      a: c.a,
      d: c.d,
      p: c.Fp.ORDER,
      n: c.n,
      h: c.h,
      Gx: c.Gx,
      Gy: c.Gy
    };
    const Fp4 = c.Fp;
    const Fn3 = Field(CURVE2.n, c.nBitLength, true);
    const curveOpts = { Fp: Fp4, Fn: Fn3, uvRatio: c.uvRatio };
    const eddsaOpts = {
      randomBytes: c.randomBytes,
      adjustScalarBytes: c.adjustScalarBytes,
      domain: c.domain,
      prehash: c.prehash,
      mapToCurve: c.mapToCurve
    };
    return { CURVE: CURVE2, curveOpts, hash: c.hash, eddsaOpts };
  }
  function _eddsa_new_output_to_legacy(c, eddsa3) {
    const legacy = Object.assign({}, eddsa3, { ExtendedPoint: eddsa3.Point, CURVE: c });
    return legacy;
  }
  function twistedEdwards(c) {
    const { CURVE: CURVE2, curveOpts, hash: hash2, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
    const Point2 = edwards(CURVE2, curveOpts);
    const EDDSA = eddsa(Point2, hash2, eddsaOpts);
    return _eddsa_new_output_to_legacy(c, EDDSA);
  }

  // ../node_modules/@libp2p/crypto/node_modules/@noble/curves/esm/ed25519.js
  var _0n5 = BigInt(0);
  var _1n5 = BigInt(1);
  var _2n3 = BigInt(2);
  var _3n2 = BigInt(3);
  var _5n2 = BigInt(5);
  var _8n3 = BigInt(8);
  var ed25519_CURVE_p = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
  var ed25519_CURVE = {
    p: ed25519_CURVE_p,
    n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
    h: _8n3,
    a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
    d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
    Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
    Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
  };
  function ed25519_pow_2_252_3(x) {
    const _10n2 = BigInt(10), _20n2 = BigInt(20), _40n2 = BigInt(40), _80n2 = BigInt(80);
    const P = ed25519_CURVE_p;
    const x2 = x * x % P;
    const b2 = x2 * x % P;
    const b4 = pow2(b2, _2n3, P) * b2 % P;
    const b5 = pow2(b4, _1n5, P) * x % P;
    const b10 = pow2(b5, _5n2, P) * b5 % P;
    const b20 = pow2(b10, _10n2, P) * b10 % P;
    const b40 = pow2(b20, _20n2, P) * b20 % P;
    const b80 = pow2(b40, _40n2, P) * b40 % P;
    const b160 = pow2(b80, _80n2, P) * b80 % P;
    const b240 = pow2(b160, _80n2, P) * b80 % P;
    const b250 = pow2(b240, _10n2, P) * b10 % P;
    const pow_p_5_8 = pow2(b250, _2n3, P) * x % P;
    return { pow_p_5_8, b2 };
  }
  function adjustScalarBytes(bytes2) {
    bytes2[0] &= 248;
    bytes2[31] &= 127;
    bytes2[31] |= 64;
    return bytes2;
  }
  var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
  function uvRatio(u, v) {
    const P = ed25519_CURVE_p;
    const v3 = mod2(v * v * v, P);
    const v7 = mod2(v3 * v3 * v, P);
    const pow3 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
    let x = mod2(u * v3 * pow3, P);
    const vx2 = mod2(v * x * x, P);
    const root1 = x;
    const root2 = mod2(x * ED25519_SQRT_M1, P);
    const useRoot1 = vx2 === u;
    const useRoot2 = vx2 === mod2(-u, P);
    const noRoot = vx2 === mod2(-u * ED25519_SQRT_M1, P);
    if (useRoot1)
      x = root1;
    if (useRoot2 || noRoot)
      x = root2;
    if (isNegativeLE(x, P))
      x = mod2(-x, P);
    return { isValid: useRoot1 || useRoot2, value: x };
  }
  var Fp = /* @__PURE__ */ (() => Field(ed25519_CURVE.p, { isLE: true }))();
  var Fn = /* @__PURE__ */ (() => Field(ed25519_CURVE.n, { isLE: true }))();
  var ed25519Defaults = /* @__PURE__ */ (() => ({
    ...ed25519_CURVE,
    Fp,
    hash: sha5124,
    adjustScalarBytes,
    // dom2
    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
    // Constant-time, u/√v
    uvRatio
  }))();
  var ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
  var SQRT_M1 = ED25519_SQRT_M1;
  var SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
  var INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
  var ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
  var D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
  var invertSqrt = (number3) => uvRatio(_1n5, number3);
  var MAX_255B = /* @__PURE__ */ BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  var bytes255ToNumberLE = (bytes2) => ed25519.Point.Fp.create(bytesToNumberLE(bytes2) & MAX_255B);
  function calcElligatorRistrettoMap(r0) {
    const { d: d2 } = ed25519_CURVE;
    const P = Fp.ORDER;
    const mod6 = (n) => Fp.create(n);
    const r = mod6(SQRT_M1 * r0 * r0);
    const Ns = mod6((r + _1n5) * ONE_MINUS_D_SQ);
    let c = BigInt(-1);
    const D = mod6((c - d2 * r) * mod6(r + d2));
    let { isValid: Ns_D_is_sq, value: s2 } = uvRatio(Ns, D);
    let s_ = mod6(s2 * r0);
    if (!isNegativeLE(s_, P))
      s_ = mod6(-s_);
    if (!Ns_D_is_sq)
      s2 = s_;
    if (!Ns_D_is_sq)
      c = r;
    const Nt = mod6(c * (r - _1n5) * D_MINUS_ONE_SQ - D);
    const s22 = s2 * s2;
    const W0 = mod6((s2 + s2) * D);
    const W1 = mod6(Nt * SQRT_AD_MINUS_ONE);
    const W2 = mod6(_1n5 - s22);
    const W3 = mod6(_1n5 + s22);
    return new ed25519.Point(mod6(W0 * W3), mod6(W2 * W1), mod6(W1 * W3), mod6(W0 * W2));
  }
  function ristretto255_map(bytes2) {
    abytes(bytes2, 64);
    const r1 = bytes255ToNumberLE(bytes2.subarray(0, 32));
    const R1 = calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(bytes2.subarray(32, 64));
    const R2 = calcElligatorRistrettoMap(r2);
    return new _RistrettoPoint(R1.add(R2));
  }
  var _RistrettoPoint = class __RistrettoPoint extends PrimeEdwardsPoint {
    constructor(ep) {
      super(ep);
    }
    static fromAffine(ap) {
      return new __RistrettoPoint(ed25519.Point.fromAffine(ap));
    }
    assertSame(other) {
      if (!(other instanceof __RistrettoPoint))
        throw new Error("RistrettoPoint expected");
    }
    init(ep) {
      return new __RistrettoPoint(ep);
    }
    /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
    static hashToCurve(hex) {
      return ristretto255_map(ensureBytes("ristrettoHash", hex, 64));
    }
    static fromBytes(bytes2) {
      abytes(bytes2, 32);
      const { a, d: d2 } = ed25519_CURVE;
      const P = ed25519_CURVE_p;
      const mod6 = (n) => Fp.create(n);
      const s2 = bytes255ToNumberLE(bytes2);
      if (!equalBytes(numberToBytesLE(s2, 32), bytes2) || isNegativeLE(s2, P))
        throw new Error("invalid ristretto255 encoding 1");
      const s22 = mod6(s2 * s2);
      const u1 = mod6(_1n5 + a * s22);
      const u2 = mod6(_1n5 - a * s22);
      const u1_2 = mod6(u1 * u1);
      const u2_2 = mod6(u2 * u2);
      const v = mod6(a * d2 * u1_2 - u2_2);
      const { isValid, value: I } = invertSqrt(mod6(v * u2_2));
      const Dx = mod6(I * u2);
      const Dy = mod6(I * Dx * v);
      let x = mod6((s2 + s2) * Dx);
      if (isNegativeLE(x, P))
        x = mod6(-x);
      const y2 = mod6(u1 * Dy);
      const t = mod6(x * y2);
      if (!isValid || isNegativeLE(t, P) || y2 === _0n5)
        throw new Error("invalid ristretto255 encoding 2");
      return new __RistrettoPoint(new ed25519.Point(x, y2, _1n5, t));
    }
    /**
     * Converts ristretto-encoded string to ristretto point.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
     */
    static fromHex(hex) {
      return __RistrettoPoint.fromBytes(ensureBytes("ristrettoHex", hex, 32));
    }
    static msm(points, scalars) {
      return pippenger(__RistrettoPoint, ed25519.Point.Fn, points, scalars);
    }
    /**
     * Encodes ristretto point to Uint8Array.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
     */
    toBytes() {
      let { X, Y, Z, T } = this.ep;
      const P = ed25519_CURVE_p;
      const mod6 = (n) => Fp.create(n);
      const u1 = mod6(mod6(Z + Y) * mod6(Z - Y));
      const u2 = mod6(X * Y);
      const u2sq = mod6(u2 * u2);
      const { value: invsqrt } = invertSqrt(mod6(u1 * u2sq));
      const D1 = mod6(invsqrt * u1);
      const D2 = mod6(invsqrt * u2);
      const zInv = mod6(D1 * D2 * T);
      let D;
      if (isNegativeLE(T * zInv, P)) {
        let _x = mod6(Y * SQRT_M1);
        let _y = mod6(X * SQRT_M1);
        X = _x;
        Y = _y;
        D = mod6(D1 * INVSQRT_A_MINUS_D);
      } else {
        D = D2;
      }
      if (isNegativeLE(X * zInv, P))
        Y = mod6(-Y);
      let s2 = mod6((Z - Y) * D);
      if (isNegativeLE(s2, P))
        s2 = mod6(-s2);
      return numberToBytesLE(s2, 32);
    }
    /**
     * Compares two Ristretto points.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
     */
    equals(other) {
      this.assertSame(other);
      const { X: X1, Y: Y1 } = this.ep;
      const { X: X2, Y: Y2 } = other.ep;
      const mod6 = (n) => Fp.create(n);
      const one = mod6(X1 * Y2) === mod6(Y1 * X2);
      const two = mod6(Y1 * Y2) === mod6(X1 * X2);
      return one || two;
    }
    is0() {
      return this.equals(__RistrettoPoint.ZERO);
    }
  };
  _RistrettoPoint.BASE = /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.BASE))();
  _RistrettoPoint.ZERO = /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.ZERO))();
  _RistrettoPoint.Fp = /* @__PURE__ */ (() => Fp)();
  _RistrettoPoint.Fn = /* @__PURE__ */ (() => Fn)();

  // ../node_modules/@libp2p/crypto/dist/src/errors.js
  var SigningError = class extends Error {
    constructor(message2 = "An error occurred while signing a message") {
      super(message2);
      this.name = "SigningError";
    }
  };
  var VerificationError = class extends Error {
    constructor(message2 = "An error occurred while verifying a message") {
      super(message2);
      this.name = "VerificationError";
    }
  };
  var WebCryptoMissingError = class extends Error {
    constructor(message2 = "Missing Web Crypto API") {
      super(message2);
      this.name = "WebCryptoMissingError";
    }
  };

  // ../node_modules/@libp2p/crypto/dist/src/webcrypto/webcrypto.browser.js
  var webcrypto_browser_default = {
    get(win = globalThis) {
      const nativeCrypto = win.crypto;
      if (nativeCrypto?.subtle == null) {
        throw new WebCryptoMissingError("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");
      }
      return nativeCrypto;
    }
  };

  // ../node_modules/@libp2p/crypto/dist/src/webcrypto/index.js
  var webcrypto_default = webcrypto_browser_default;

  // ../node_modules/@libp2p/crypto/dist/src/keys/ed25519/index.browser.js
  var PUBLIC_KEY_BYTE_LENGTH = 32;
  var PRIVATE_KEY_BYTE_LENGTH = 64;
  var KEYS_BYTE_LENGTH = 32;
  var ed25519Supported;
  var webCryptoEd25519SupportedPromise = (async () => {
    try {
      await webcrypto_default.get().subtle.generateKey({ name: "Ed25519" }, true, ["sign", "verify"]);
      return true;
    } catch {
      return false;
    }
  })();
  function generateKey() {
    const privateKeyRaw = ed25519.utils.randomPrivateKey();
    const publicKey = ed25519.getPublicKey(privateKeyRaw);
    const privateKey = concatKeys(privateKeyRaw, publicKey);
    return {
      privateKey,
      publicKey
    };
  }
  async function hashAndSignWebCrypto(privateKey, msg) {
    let privateKeyRaw;
    if (privateKey.length === PRIVATE_KEY_BYTE_LENGTH) {
      privateKeyRaw = privateKey.subarray(0, 32);
    } else {
      privateKeyRaw = privateKey;
    }
    const jwk = {
      crv: "Ed25519",
      kty: "OKP",
      x: toString5(privateKey.subarray(32), "base64url"),
      d: toString5(privateKeyRaw, "base64url"),
      ext: true,
      key_ops: ["sign"]
    };
    const key = await webcrypto_default.get().subtle.importKey("jwk", jwk, { name: "Ed25519" }, true, ["sign"]);
    const sig = await webcrypto_default.get().subtle.sign({ name: "Ed25519" }, key, msg instanceof Uint8Array ? msg : msg.subarray());
    return new Uint8Array(sig, 0, sig.byteLength);
  }
  function hashAndSignNoble(privateKey, msg) {
    const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);
    return ed25519.sign(msg instanceof Uint8Array ? msg : msg.subarray(), privateKeyRaw);
  }
  async function hashAndSign2(privateKey, msg) {
    if (ed25519Supported == null) {
      ed25519Supported = await webCryptoEd25519SupportedPromise;
    }
    if (ed25519Supported) {
      return hashAndSignWebCrypto(privateKey, msg);
    }
    return hashAndSignNoble(privateKey, msg);
  }
  async function hashAndVerifyWebCrypto(publicKey, sig, msg) {
    if (publicKey.buffer instanceof ArrayBuffer) {
      const key = await webcrypto_default.get().subtle.importKey("raw", publicKey.buffer, { name: "Ed25519" }, false, ["verify"]);
      const isValid = await webcrypto_default.get().subtle.verify({ name: "Ed25519" }, key, sig, msg instanceof Uint8Array ? msg : msg.subarray());
      return isValid;
    }
    throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys");
  }
  function hashAndVerifyNoble(publicKey, sig, msg) {
    return ed25519.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey);
  }
  async function hashAndVerify2(publicKey, sig, msg) {
    if (ed25519Supported == null) {
      ed25519Supported = await webCryptoEd25519SupportedPromise;
    }
    if (ed25519Supported) {
      return hashAndVerifyWebCrypto(publicKey, sig, msg);
    }
    return hashAndVerifyNoble(publicKey, sig, msg);
  }
  function concatKeys(privateKeyRaw, publicKey) {
    const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);
    for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {
      privateKey[i] = privateKeyRaw[i];
      privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];
    }
    return privateKey;
  }

  // ../node_modules/@libp2p/crypto/dist/src/util.js
  function isPromise(thing) {
    if (thing == null) {
      return false;
    }
    return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
  }

  // ../node_modules/@libp2p/crypto/dist/src/keys/ed25519/ed25519.js
  var Ed25519PublicKey = class {
    type = "Ed25519";
    raw;
    constructor(key) {
      this.raw = ensureEd25519Key(key, PUBLIC_KEY_BYTE_LENGTH);
    }
    toMultihash() {
      return identity5.digest(publicKeyToProtobuf(this));
    }
    toCID() {
      return CID3.createV1(114, this.toMultihash());
    }
    toString() {
      return base58btc3.encode(this.toMultihash().bytes).substring(1);
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals8(this.raw, key.raw);
    }
    verify(data, sig, options) {
      options?.signal?.throwIfAborted();
      const result = hashAndVerify2(this.raw, sig, data);
      if (isPromise(result)) {
        return result.then((res) => {
          options?.signal?.throwIfAborted();
          return res;
        });
      }
      return result;
    }
  };
  var Ed25519PrivateKey = class {
    type = "Ed25519";
    raw;
    publicKey;
    // key       - 64 byte Uint8Array containing private key
    // publicKey - 32 byte Uint8Array containing public key
    constructor(key, publicKey) {
      this.raw = ensureEd25519Key(key, PRIVATE_KEY_BYTE_LENGTH);
      this.publicKey = new Ed25519PublicKey(publicKey);
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals8(this.raw, key.raw);
    }
    sign(message2, options) {
      options?.signal?.throwIfAborted();
      const sig = hashAndSign2(this.raw, message2);
      if (isPromise(sig)) {
        return sig.then((res) => {
          options?.signal?.throwIfAborted();
          return res;
        });
      }
      options?.signal?.throwIfAborted();
      return sig;
    }
  };

  // ../node_modules/@libp2p/crypto/dist/src/keys/ed25519/utils.js
  function unmarshalEd25519PublicKey(bytes2) {
    bytes2 = ensureEd25519Key(bytes2, PUBLIC_KEY_BYTE_LENGTH);
    return new Ed25519PublicKey(bytes2);
  }
  async function generateEd25519KeyPair() {
    const { privateKey, publicKey } = generateKey();
    return new Ed25519PrivateKey(privateKey, publicKey);
  }
  function ensureEd25519Key(key, length21) {
    key = Uint8Array.from(key ?? []);
    if (key.length !== length21) {
      throw new InvalidParametersError(`Key must be a Uint8Array of length ${length21}, got ${key.length}`);
    }
    return key;
  }

  // ../node_modules/@libp2p/crypto/dist/src/keys/keys.js
  var KeyType;
  (function(KeyType3) {
    KeyType3["RSA"] = "RSA";
    KeyType3["Ed25519"] = "Ed25519";
    KeyType3["secp256k1"] = "secp256k1";
    KeyType3["ECDSA"] = "ECDSA";
  })(KeyType || (KeyType = {}));
  var __KeyTypeValues;
  (function(__KeyTypeValues3) {
    __KeyTypeValues3[__KeyTypeValues3["RSA"] = 0] = "RSA";
    __KeyTypeValues3[__KeyTypeValues3["Ed25519"] = 1] = "Ed25519";
    __KeyTypeValues3[__KeyTypeValues3["secp256k1"] = 2] = "secp256k1";
    __KeyTypeValues3[__KeyTypeValues3["ECDSA"] = 3] = "ECDSA";
  })(__KeyTypeValues || (__KeyTypeValues = {}));
  (function(KeyType3) {
    KeyType3.codec = () => {
      return enumeration(__KeyTypeValues);
    };
  })(KeyType || (KeyType = {}));
  var PublicKey;
  (function(PublicKey3) {
    let _codec;
    PublicKey3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.Type != null) {
            w2.uint32(8);
            KeyType.codec().encode(obj.Type, w2);
          }
          if (obj.Data != null) {
            w2.uint32(18);
            w2.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {};
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.Type = KeyType.codec().decode(reader);
                break;
              }
              case 2: {
                obj.Data = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PublicKey3.encode = (obj) => {
      return encodeMessage(obj, PublicKey3.codec());
    };
    PublicKey3.decode = (buf, opts) => {
      return decodeMessage(buf, PublicKey3.codec(), opts);
    };
  })(PublicKey || (PublicKey = {}));
  var PrivateKey;
  (function(PrivateKey3) {
    let _codec;
    PrivateKey3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.Type != null) {
            w2.uint32(8);
            KeyType.codec().encode(obj.Type, w2);
          }
          if (obj.Data != null) {
            w2.uint32(18);
            w2.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {};
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.Type = KeyType.codec().decode(reader);
                break;
              }
              case 2: {
                obj.Data = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PrivateKey3.encode = (obj) => {
      return encodeMessage(obj, PrivateKey3.codec());
    };
    PrivateKey3.decode = (buf, opts) => {
      return decodeMessage(buf, PrivateKey3.codec(), opts);
    };
  })(PrivateKey || (PrivateKey = {}));

  // ../node_modules/@libp2p/crypto/dist/src/random-bytes.js
  function randomBytes3(length21) {
    if (isNaN(length21) || length21 <= 0) {
      throw new InvalidParametersError("random bytes length must be a Number bigger than 0");
    }
    return randomBytes2(length21);
  }

  // ../node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js
  var utils_exports = {};
  __export(utils_exports, {
    MAX_RSA_KEY_SIZE: () => MAX_RSA_KEY_SIZE,
    generateRSAKeyPair: () => generateRSAKeyPair,
    jwkToJWKKeyPair: () => jwkToJWKKeyPair,
    jwkToPkcs1: () => jwkToPkcs1,
    jwkToPkix: () => jwkToPkix,
    jwkToRSAPrivateKey: () => jwkToRSAPrivateKey,
    pkcs1MessageToJwk: () => pkcs1MessageToJwk,
    pkcs1MessageToRSAPrivateKey: () => pkcs1MessageToRSAPrivateKey,
    pkcs1ToJwk: () => pkcs1ToJwk,
    pkcs1ToRSAPrivateKey: () => pkcs1ToRSAPrivateKey,
    pkixMessageToJwk: () => pkixMessageToJwk,
    pkixMessageToRSAPublicKey: () => pkixMessageToRSAPublicKey,
    pkixToJwk: () => pkixToJwk,
    pkixToRSAPublicKey: () => pkixToRSAPublicKey
  });

  // ../node_modules/@libp2p/crypto/node_modules/@noble/hashes/esm/sha256.js
  var sha2566 = sha2565;

  // ../node_modules/@libp2p/crypto/dist/src/keys/rsa/rsa.js
  var RSAPublicKey = class {
    type = "RSA";
    jwk;
    _raw;
    _multihash;
    constructor(jwk, digest18) {
      this.jwk = jwk;
      this._multihash = digest18;
    }
    get raw() {
      if (this._raw == null) {
        this._raw = utils_exports.jwkToPkix(this.jwk);
      }
      return this._raw;
    }
    toMultihash() {
      return this._multihash;
    }
    toCID() {
      return CID3.createV1(114, this._multihash);
    }
    toString() {
      return base58btc3.encode(this.toMultihash().bytes).substring(1);
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals8(this.raw, key.raw);
    }
    verify(data, sig, options) {
      return hashAndVerify3(this.jwk, sig, data, options);
    }
  };
  var RSAPrivateKey = class {
    type = "RSA";
    jwk;
    _raw;
    publicKey;
    constructor(jwk, publicKey) {
      this.jwk = jwk;
      this.publicKey = publicKey;
    }
    get raw() {
      if (this._raw == null) {
        this._raw = utils_exports.jwkToPkcs1(this.jwk);
      }
      return this._raw;
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals8(this.raw, key.raw);
    }
    sign(message2, options) {
      return hashAndSign3(this.jwk, message2, options);
    }
  };

  // ../node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js
  var MAX_RSA_KEY_SIZE = 8192;
  var SHA2_256_CODE = 18;
  var MAX_RSA_JWK_SIZE = 1062;
  var RSA_ALGORITHM_IDENTIFIER = Uint8Array.from([
    48,
    13,
    6,
    9,
    42,
    134,
    72,
    134,
    247,
    13,
    1,
    1,
    1,
    5,
    0
  ]);
  function pkcs1ToJwk(bytes2) {
    const message2 = decodeDer(bytes2);
    return pkcs1MessageToJwk(message2);
  }
  function pkcs1MessageToJwk(message2) {
    return {
      n: toString5(message2[1], "base64url"),
      e: toString5(message2[2], "base64url"),
      d: toString5(message2[3], "base64url"),
      p: toString5(message2[4], "base64url"),
      q: toString5(message2[5], "base64url"),
      dp: toString5(message2[6], "base64url"),
      dq: toString5(message2[7], "base64url"),
      qi: toString5(message2[8], "base64url"),
      kty: "RSA"
    };
  }
  function jwkToPkcs1(jwk) {
    if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
      throw new InvalidParametersError("JWK was missing components");
    }
    return encodeSequence([
      encodeInteger(Uint8Array.from([0])),
      encodeInteger(fromString6(jwk.n, "base64url")),
      encodeInteger(fromString6(jwk.e, "base64url")),
      encodeInteger(fromString6(jwk.d, "base64url")),
      encodeInteger(fromString6(jwk.p, "base64url")),
      encodeInteger(fromString6(jwk.q, "base64url")),
      encodeInteger(fromString6(jwk.dp, "base64url")),
      encodeInteger(fromString6(jwk.dq, "base64url")),
      encodeInteger(fromString6(jwk.qi, "base64url"))
    ]).subarray();
  }
  function pkixToJwk(bytes2) {
    const message2 = decodeDer(bytes2, {
      offset: 0
    });
    return pkixMessageToJwk(message2);
  }
  function pkixMessageToJwk(message2) {
    const keys = decodeDer(message2[1], {
      offset: 0
    });
    return {
      kty: "RSA",
      n: toString5(keys[0], "base64url"),
      e: toString5(keys[1], "base64url")
    };
  }
  function jwkToPkix(jwk) {
    if (jwk.n == null || jwk.e == null) {
      throw new InvalidParametersError("JWK was missing components");
    }
    const subjectPublicKeyInfo = encodeSequence([
      RSA_ALGORITHM_IDENTIFIER,
      encodeBitString(encodeSequence([
        encodeInteger(fromString6(jwk.n, "base64url")),
        encodeInteger(fromString6(jwk.e, "base64url"))
      ]))
    ]);
    return subjectPublicKeyInfo.subarray();
  }
  function pkcs1ToRSAPrivateKey(bytes2) {
    const message2 = decodeDer(bytes2);
    return pkcs1MessageToRSAPrivateKey(message2);
  }
  function pkcs1MessageToRSAPrivateKey(message2) {
    const jwk = pkcs1MessageToJwk(message2);
    return jwkToRSAPrivateKey(jwk);
  }
  function pkixToRSAPublicKey(bytes2, digest18) {
    if (bytes2.byteLength >= MAX_RSA_JWK_SIZE) {
      throw new InvalidPublicKeyError("Key size is too large");
    }
    const message2 = decodeDer(bytes2, {
      offset: 0
    });
    return pkixMessageToRSAPublicKey(message2, bytes2, digest18);
  }
  function pkixMessageToRSAPublicKey(message2, bytes2, digest18) {
    const jwk = pkixMessageToJwk(message2);
    if (digest18 == null) {
      const hash2 = sha2566(PublicKey.encode({
        Type: KeyType.RSA,
        Data: bytes2
      }));
      digest18 = create3(SHA2_256_CODE, hash2);
    }
    return new RSAPublicKey(jwk, digest18);
  }
  function jwkToRSAPrivateKey(jwk) {
    if (rsaKeySize(jwk) > MAX_RSA_KEY_SIZE) {
      throw new InvalidParametersError("Key size is too large");
    }
    const keys = jwkToJWKKeyPair(jwk);
    const hash2 = sha2566(PublicKey.encode({
      Type: KeyType.RSA,
      Data: jwkToPkix(keys.publicKey)
    }));
    const digest18 = create3(SHA2_256_CODE, hash2);
    return new RSAPrivateKey(keys.privateKey, new RSAPublicKey(keys.publicKey, digest18));
  }
  async function generateRSAKeyPair(bits) {
    if (bits > MAX_RSA_KEY_SIZE) {
      throw new InvalidParametersError("Key size is too large");
    }
    const keys = await generateRSAKey(bits);
    const hash2 = sha2566(PublicKey.encode({
      Type: KeyType.RSA,
      Data: jwkToPkix(keys.publicKey)
    }));
    const digest18 = create3(SHA2_256_CODE, hash2);
    return new RSAPrivateKey(keys.privateKey, new RSAPublicKey(keys.publicKey, digest18));
  }
  function jwkToJWKKeyPair(key) {
    if (key == null) {
      throw new InvalidParametersError("Missing key parameter");
    }
    return {
      privateKey: key,
      publicKey: {
        kty: key.kty,
        n: key.n,
        e: key.e
      }
    };
  }

  // ../node_modules/@libp2p/crypto/dist/src/keys/rsa/index.browser.js
  async function generateRSAKey(bits, options) {
    const pair2 = await webcrypto_default.get().subtle.generateKey({
      name: "RSASSA-PKCS1-v1_5",
      modulusLength: bits,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: { name: "SHA-256" }
    }, true, ["sign", "verify"]);
    options?.signal?.throwIfAborted();
    const keys = await exportKey(pair2, options);
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  }
  async function hashAndSign3(key, msg, options) {
    const privateKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["sign"]);
    options?.signal?.throwIfAborted();
    const sig = await webcrypto_default.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, msg instanceof Uint8Array ? msg : msg.subarray());
    options?.signal?.throwIfAborted();
    return new Uint8Array(sig, 0, sig.byteLength);
  }
  async function hashAndVerify3(key, sig, msg, options) {
    const publicKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["verify"]);
    options?.signal?.throwIfAborted();
    const result = await webcrypto_default.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg instanceof Uint8Array ? msg : msg.subarray());
    options?.signal?.throwIfAborted();
    return result;
  }
  async function exportKey(pair2, options) {
    if (pair2.privateKey == null || pair2.publicKey == null) {
      throw new InvalidParametersError("Private and public key are required");
    }
    const result = await Promise.all([
      webcrypto_default.get().subtle.exportKey("jwk", pair2.privateKey),
      webcrypto_default.get().subtle.exportKey("jwk", pair2.publicKey)
    ]);
    options?.signal?.throwIfAborted();
    return result;
  }
  function rsaKeySize(jwk) {
    if (jwk.kty !== "RSA") {
      throw new InvalidParametersError("invalid key type");
    } else if (jwk.n == null) {
      throw new InvalidParametersError("invalid key modulus");
    }
    const bytes2 = fromString6(jwk.n, "base64url");
    return bytes2.length * 8;
  }

  // ../node_modules/@libp2p/crypto/node_modules/@noble/hashes/esm/hmac.js
  var HMAC = class extends Hash2 {
    constructor(hash2, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      ahash(hash2);
      const key = toBytes2(_key);
      this.iHash = hash2.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash2.create();
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54 ^ 92;
      this.oHash.update(pad);
      clean(pad);
    }
    update(buf) {
      aexists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      aexists(this);
      abytes(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac = (hash2, key, message2) => new HMAC(hash2, key).update(message2).digest();
  hmac.create = (hash2, key) => new HMAC(hash2, key);

  // ../node_modules/@libp2p/crypto/node_modules/@noble/curves/esm/abstract/weierstrass.js
  var divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n4) / den;
  function _splitEndoScalar(k, basis, n) {
    const [[a1, b1], [a2, b2]] = basis;
    const c1 = divNearest(b2 * k, n);
    const c2 = divNearest(-b1 * k, n);
    let k1 = k - c1 * a1 - c2 * a2;
    let k2 = -c1 * b1 - c2 * b2;
    const k1neg = k1 < _0n6;
    const k2neg = k2 < _0n6;
    if (k1neg)
      k1 = -k1;
    if (k2neg)
      k2 = -k2;
    const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n6;
    if (k1 < _0n6 || k1 >= MAX_NUM || k2 < _0n6 || k2 >= MAX_NUM) {
      throw new Error("splitScalar (endomorphism): failed, k=" + k);
    }
    return { k1neg, k1, k2neg, k2 };
  }
  function validateSigFormat(format19) {
    if (!["compact", "recovered", "der"].includes(format19))
      throw new Error('Signature format must be "compact", "recovered", or "der"');
    return format19;
  }
  function validateSigOpts(opts, def) {
    const optsn = {};
    for (let optName of Object.keys(def)) {
      optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
    }
    _abool2(optsn.lowS, "lowS");
    _abool2(optsn.prehash, "prehash");
    if (optsn.format !== void 0)
      validateSigFormat(optsn.format);
    return optsn;
  }
  var DERErr = class extends Error {
    constructor(m2 = "") {
      super(m2);
    }
  };
  var DER = {
    // asn.1 DER encoding utils
    Err: DERErr,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
      encode: (tag, data) => {
        const { Err: E } = DER;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length & 1)
          throw new E("tlv.encode: unpadded data");
        const dataLen = data.length / 2;
        const len = numberToHexUnpadded(dataLen);
        if (len.length / 2 & 128)
          throw new E("tlv.encode: long form length too big");
        const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
        const t = numberToHexUnpadded(tag);
        return t + lenLen + len + data;
      },
      // v - value, l - left bytes (unparsed)
      decode(tag, data) {
        const { Err: E } = DER;
        let pos = 0;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length < 2 || data[pos++] !== tag)
          throw new E("tlv.decode: wrong tlv");
        const first = data[pos++];
        const isLong = !!(first & 128);
        let length21 = 0;
        if (!isLong)
          length21 = first;
        else {
          const lenLen = first & 127;
          if (!lenLen)
            throw new E("tlv.decode(long): indefinite length not supported");
          if (lenLen > 4)
            throw new E("tlv.decode(long): byte length is too big");
          const lengthBytes = data.subarray(pos, pos + lenLen);
          if (lengthBytes.length !== lenLen)
            throw new E("tlv.decode: length bytes not complete");
          if (lengthBytes[0] === 0)
            throw new E("tlv.decode(long): zero leftmost byte");
          for (const b of lengthBytes)
            length21 = length21 << 8 | b;
          pos += lenLen;
          if (length21 < 128)
            throw new E("tlv.decode(long): not minimal encoding");
        }
        const v = data.subarray(pos, pos + length21);
        if (v.length !== length21)
          throw new E("tlv.decode: wrong value length");
        return { v, l: data.subarray(pos + length21) };
      }
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
      encode(num) {
        const { Err: E } = DER;
        if (num < _0n6)
          throw new E("integer: negative integers are not allowed");
        let hex = numberToHexUnpadded(num);
        if (Number.parseInt(hex[0], 16) & 8)
          hex = "00" + hex;
        if (hex.length & 1)
          throw new E("unexpected DER parsing assertion: unpadded hex");
        return hex;
      },
      decode(data) {
        const { Err: E } = DER;
        if (data[0] & 128)
          throw new E("invalid signature integer: negative");
        if (data[0] === 0 && !(data[1] & 128))
          throw new E("invalid signature integer: unnecessary leading zero");
        return bytesToNumberBE(data);
      }
    },
    toSig(hex) {
      const { Err: E, _int: int, _tlv: tlv } = DER;
      const data = ensureBytes("signature", hex);
      const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
      if (seqLeftBytes.length)
        throw new E("invalid signature: left bytes after parsing");
      const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
      const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
      if (sLeftBytes.length)
        throw new E("invalid signature: left bytes after parsing");
      return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
      const { _tlv: tlv, _int: int } = DER;
      const rs = tlv.encode(2, int.encode(sig.r));
      const ss = tlv.encode(2, int.encode(sig.s));
      const seq = rs + ss;
      return tlv.encode(48, seq);
    }
  };
  var _0n6 = BigInt(0);
  var _1n6 = BigInt(1);
  var _2n4 = BigInt(2);
  var _3n3 = BigInt(3);
  var _4n2 = BigInt(4);
  function _normFnElement(Fn3, key) {
    const { BYTES: expected } = Fn3;
    let num;
    if (typeof key === "bigint") {
      num = key;
    } else {
      let bytes2 = ensureBytes("private key", key);
      try {
        num = Fn3.fromBytes(bytes2);
      } catch (error) {
        throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
      }
    }
    if (!Fn3.isValidNot0(num))
      throw new Error("invalid private key: out of range [1..N-1]");
    return num;
  }
  function weierstrassN(params, extraOpts = {}) {
    const validated = _createCurveFields("weierstrass", params, extraOpts);
    const { Fp: Fp4, Fn: Fn3 } = validated;
    let CURVE2 = validated.CURVE;
    const { h: cofactor, n: CURVE_ORDER } = CURVE2;
    _validateObject(extraOpts, {}, {
      allowInfinityPoint: "boolean",
      clearCofactor: "function",
      isTorsionFree: "function",
      fromBytes: "function",
      toBytes: "function",
      endo: "object",
      wrapPrivateKey: "boolean"
    });
    const { endo: endo2 } = extraOpts;
    if (endo2) {
      if (!Fp4.is0(CURVE2.a) || typeof endo2.beta !== "bigint" || !Array.isArray(endo2.basises)) {
        throw new Error('invalid endo: expected "beta": bigint and "basises": array');
      }
    }
    const lengths = getWLengths(Fp4, Fn3);
    function assertCompressionIsSupported() {
      if (!Fp4.isOdd)
        throw new Error("compression is not supported: Field does not have .isOdd()");
    }
    function pointToBytes(_c, point, isCompressed) {
      const { x, y: y2 } = point.toAffine();
      const bx = Fp4.toBytes(x);
      _abool2(isCompressed, "isCompressed");
      if (isCompressed) {
        assertCompressionIsSupported();
        const hasEvenY = !Fp4.isOdd(y2);
        return concatBytes2(pprefix(hasEvenY), bx);
      } else {
        return concatBytes2(Uint8Array.of(4), bx, Fp4.toBytes(y2));
      }
    }
    function pointFromBytes(bytes2) {
      _abytes2(bytes2, void 0, "Point");
      const { public: comp, publicUncompressed: uncomp } = lengths;
      const length21 = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (length21 === comp && (head === 2 || head === 3)) {
        const x = Fp4.fromBytes(tail);
        if (!Fp4.isValid(x))
          throw new Error("bad point: is not on curve, wrong x");
        const y2 = weierstrassEquation(x);
        let y3;
        try {
          y3 = Fp4.sqrt(y2);
        } catch (sqrtError) {
          const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("bad point: is not on curve, sqrt error" + err);
        }
        assertCompressionIsSupported();
        const isYOdd = Fp4.isOdd(y3);
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp4.neg(y3);
        return { x, y: y3 };
      } else if (length21 === uncomp && head === 4) {
        const L = Fp4.BYTES;
        const x = Fp4.fromBytes(tail.subarray(0, L));
        const y2 = Fp4.fromBytes(tail.subarray(L, L * 2));
        if (!isValidXY(x, y2))
          throw new Error("bad point: is not on curve");
        return { x, y: y2 };
      } else {
        throw new Error(`bad point: got length ${length21}, expected compressed=${comp} or uncompressed=${uncomp}`);
      }
    }
    const encodePoint = extraOpts.toBytes || pointToBytes;
    const decodePoint = extraOpts.fromBytes || pointFromBytes;
    function weierstrassEquation(x) {
      const x2 = Fp4.sqr(x);
      const x3 = Fp4.mul(x2, x);
      return Fp4.add(Fp4.add(x3, Fp4.mul(x, CURVE2.a)), CURVE2.b);
    }
    function isValidXY(x, y2) {
      const left = Fp4.sqr(y2);
      const right = weierstrassEquation(x);
      return Fp4.eql(left, right);
    }
    if (!isValidXY(CURVE2.Gx, CURVE2.Gy))
      throw new Error("bad curve params: generator point");
    const _4a3 = Fp4.mul(Fp4.pow(CURVE2.a, _3n3), _4n2);
    const _27b2 = Fp4.mul(Fp4.sqr(CURVE2.b), BigInt(27));
    if (Fp4.is0(Fp4.add(_4a3, _27b2)))
      throw new Error("bad curve params: a or b");
    function acoord(title, n, banZero = false) {
      if (!Fp4.isValid(n) || banZero && Fp4.is0(n))
        throw new Error(`bad point coordinate ${title}`);
      return n;
    }
    function aprjpoint(other) {
      if (!(other instanceof Point2))
        throw new Error("ProjectivePoint expected");
    }
    function splitEndoScalarN(k) {
      if (!endo2 || !endo2.basises)
        throw new Error("no endo");
      return _splitEndoScalar(k, endo2.basises, Fn3.ORDER);
    }
    const toAffineMemo = memoized((p, iz) => {
      const { X, Y, Z } = p;
      if (Fp4.eql(Z, Fp4.ONE))
        return { x: X, y: Y };
      const is0 = p.is0();
      if (iz == null)
        iz = is0 ? Fp4.ONE : Fp4.inv(Z);
      const x = Fp4.mul(X, iz);
      const y2 = Fp4.mul(Y, iz);
      const zz = Fp4.mul(Z, iz);
      if (is0)
        return { x: Fp4.ZERO, y: Fp4.ZERO };
      if (!Fp4.eql(zz, Fp4.ONE))
        throw new Error("invZ was invalid");
      return { x, y: y2 };
    });
    const assertValidMemo = memoized((p) => {
      if (p.is0()) {
        if (extraOpts.allowInfinityPoint && !Fp4.is0(p.Y))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y: y2 } = p.toAffine();
      if (!Fp4.isValid(x) || !Fp4.isValid(y2))
        throw new Error("bad point: x or y not field elements");
      if (!isValidXY(x, y2))
        throw new Error("bad point: equation left != right");
      if (!p.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
      return true;
    });
    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
      k2p = new Point2(Fp4.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
      k1p = negateCt(k1neg, k1p);
      k2p = negateCt(k2neg, k2p);
      return k1p.add(k2p);
    }
    class Point2 {
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      constructor(X, Y, Z) {
        this.X = acoord("x", X);
        this.Y = acoord("y", Y, true);
        this.Z = acoord("z", Z);
        Object.freeze(this);
      }
      static CURVE() {
        return CURVE2;
      }
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      static fromAffine(p) {
        const { x, y: y2 } = p || {};
        if (!p || !Fp4.isValid(x) || !Fp4.isValid(y2))
          throw new Error("invalid affine point");
        if (p instanceof Point2)
          throw new Error("projective point not allowed");
        if (Fp4.is0(x) && Fp4.is0(y2))
          return Point2.ZERO;
        return new Point2(x, y2, Fp4.ONE);
      }
      static fromBytes(bytes2) {
        const P = Point2.fromAffine(decodePoint(_abytes2(bytes2, void 0, "point")));
        P.assertValidity();
        return P;
      }
      static fromHex(hex) {
        return Point2.fromBytes(ensureBytes("pointHex", hex));
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       *
       * @param windowSize
       * @param isLazy true will defer table computation until the first multiplication
       * @returns
       */
      precompute(windowSize = 8, isLazy = true) {
        wnaf.createCache(this, windowSize);
        if (!isLazy)
          this.multiply(_3n3);
        return this;
      }
      // TODO: return `this`
      /** A point on curve is valid if it conforms to equation. */
      assertValidity() {
        assertValidMemo(this);
      }
      hasEvenY() {
        const { y: y2 } = this.toAffine();
        if (!Fp4.isOdd)
          throw new Error("Field doesn't support isOdd");
        return !Fp4.isOdd(y2);
      }
      /** Compare one point to another. */
      equals(other) {
        aprjpoint(other);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const { X: X2, Y: Y2, Z: Z2 } = other;
        const U1 = Fp4.eql(Fp4.mul(X1, Z2), Fp4.mul(X2, Z1));
        const U2 = Fp4.eql(Fp4.mul(Y1, Z2), Fp4.mul(Y2, Z1));
        return U1 && U2;
      }
      /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
      negate() {
        return new Point2(this.X, Fp4.neg(this.Y), this.Z);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a, b } = CURVE2;
        const b3 = Fp4.mul(b, _3n3);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        let X3 = Fp4.ZERO, Y3 = Fp4.ZERO, Z3 = Fp4.ZERO;
        let t0 = Fp4.mul(X1, X1);
        let t1 = Fp4.mul(Y1, Y1);
        let t2 = Fp4.mul(Z1, Z1);
        let t3 = Fp4.mul(X1, Y1);
        t3 = Fp4.add(t3, t3);
        Z3 = Fp4.mul(X1, Z1);
        Z3 = Fp4.add(Z3, Z3);
        X3 = Fp4.mul(a, Z3);
        Y3 = Fp4.mul(b3, t2);
        Y3 = Fp4.add(X3, Y3);
        X3 = Fp4.sub(t1, Y3);
        Y3 = Fp4.add(t1, Y3);
        Y3 = Fp4.mul(X3, Y3);
        X3 = Fp4.mul(t3, X3);
        Z3 = Fp4.mul(b3, Z3);
        t2 = Fp4.mul(a, t2);
        t3 = Fp4.sub(t0, t2);
        t3 = Fp4.mul(a, t3);
        t3 = Fp4.add(t3, Z3);
        Z3 = Fp4.add(t0, t0);
        t0 = Fp4.add(Z3, t0);
        t0 = Fp4.add(t0, t2);
        t0 = Fp4.mul(t0, t3);
        Y3 = Fp4.add(Y3, t0);
        t2 = Fp4.mul(Y1, Z1);
        t2 = Fp4.add(t2, t2);
        t0 = Fp4.mul(t2, t3);
        X3 = Fp4.sub(X3, t0);
        Z3 = Fp4.mul(t2, t1);
        Z3 = Fp4.add(Z3, Z3);
        Z3 = Fp4.add(Z3, Z3);
        return new Point2(X3, Y3, Z3);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(other) {
        aprjpoint(other);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const { X: X2, Y: Y2, Z: Z2 } = other;
        let X3 = Fp4.ZERO, Y3 = Fp4.ZERO, Z3 = Fp4.ZERO;
        const a = CURVE2.a;
        const b3 = Fp4.mul(CURVE2.b, _3n3);
        let t0 = Fp4.mul(X1, X2);
        let t1 = Fp4.mul(Y1, Y2);
        let t2 = Fp4.mul(Z1, Z2);
        let t3 = Fp4.add(X1, Y1);
        let t4 = Fp4.add(X2, Y2);
        t3 = Fp4.mul(t3, t4);
        t4 = Fp4.add(t0, t1);
        t3 = Fp4.sub(t3, t4);
        t4 = Fp4.add(X1, Z1);
        let t5 = Fp4.add(X2, Z2);
        t4 = Fp4.mul(t4, t5);
        t5 = Fp4.add(t0, t2);
        t4 = Fp4.sub(t4, t5);
        t5 = Fp4.add(Y1, Z1);
        X3 = Fp4.add(Y2, Z2);
        t5 = Fp4.mul(t5, X3);
        X3 = Fp4.add(t1, t2);
        t5 = Fp4.sub(t5, X3);
        Z3 = Fp4.mul(a, t4);
        X3 = Fp4.mul(b3, t2);
        Z3 = Fp4.add(X3, Z3);
        X3 = Fp4.sub(t1, Z3);
        Z3 = Fp4.add(t1, Z3);
        Y3 = Fp4.mul(X3, Z3);
        t1 = Fp4.add(t0, t0);
        t1 = Fp4.add(t1, t0);
        t2 = Fp4.mul(a, t2);
        t4 = Fp4.mul(b3, t4);
        t1 = Fp4.add(t1, t2);
        t2 = Fp4.sub(t0, t2);
        t2 = Fp4.mul(a, t2);
        t4 = Fp4.add(t4, t2);
        t0 = Fp4.mul(t1, t4);
        Y3 = Fp4.add(Y3, t0);
        t0 = Fp4.mul(t5, t4);
        X3 = Fp4.mul(t3, X3);
        X3 = Fp4.sub(X3, t0);
        t0 = Fp4.mul(t3, t1);
        Z3 = Fp4.mul(t5, Z3);
        Z3 = Fp4.add(Z3, t0);
        return new Point2(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point2.ZERO);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(scalar) {
        const { endo: endo3 } = extraOpts;
        if (!Fn3.isValidNot0(scalar))
          throw new Error("invalid scalar: out of range");
        let point, fake;
        const mul = (n) => wnaf.cached(this, n, (p) => normalizeZ(Point2, p));
        if (endo3) {
          const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
          const { p: k1p, f: k1f } = mul(k1);
          const { p: k2p, f: k2f } = mul(k2);
          fake = k1f.add(k2f);
          point = finishEndo(endo3.beta, k1p, k2p, k1neg, k2neg);
        } else {
          const { p, f } = mul(scalar);
          point = p;
          fake = f;
        }
        return normalizeZ(Point2, [point, fake])[0];
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed secret key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(sc) {
        const { endo: endo3 } = extraOpts;
        const p = this;
        if (!Fn3.isValid(sc))
          throw new Error("invalid scalar: out of range");
        if (sc === _0n6 || p.is0())
          return Point2.ZERO;
        if (sc === _1n6)
          return p;
        if (wnaf.hasCache(this))
          return this.multiply(sc);
        if (endo3) {
          const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
          const { p1, p2 } = mulEndoUnsafe(Point2, p, k1, k2);
          return finishEndo(endo3.beta, p1, p2, k1neg, k2neg);
        } else {
          return wnaf.unsafe(p, sc);
        }
      }
      multiplyAndAddUnsafe(Q, a, b) {
        const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
        return sum.is0() ? void 0 : sum;
      }
      /**
       * Converts Projective point to affine (x, y) coordinates.
       * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
       */
      toAffine(invertedZ) {
        return toAffineMemo(this, invertedZ);
      }
      /**
       * Checks whether Point is free of torsion elements (is in prime subgroup).
       * Always torsion-free for cofactor=1 curves.
       */
      isTorsionFree() {
        const { isTorsionFree } = extraOpts;
        if (cofactor === _1n6)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point2, this);
        return wnaf.unsafe(this, CURVE_ORDER).is0();
      }
      clearCofactor() {
        const { clearCofactor } = extraOpts;
        if (cofactor === _1n6)
          return this;
        if (clearCofactor)
          return clearCofactor(Point2, this);
        return this.multiplyUnsafe(cofactor);
      }
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      toBytes(isCompressed = true) {
        _abool2(isCompressed, "isCompressed");
        this.assertValidity();
        return encodePoint(Point2, this, isCompressed);
      }
      toHex(isCompressed = true) {
        return bytesToHex2(this.toBytes(isCompressed));
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
      // TODO: remove
      get px() {
        return this.X;
      }
      get py() {
        return this.X;
      }
      get pz() {
        return this.Z;
      }
      toRawBytes(isCompressed = true) {
        return this.toBytes(isCompressed);
      }
      _setWindowSize(windowSize) {
        this.precompute(windowSize);
      }
      static normalizeZ(points) {
        return normalizeZ(Point2, points);
      }
      static msm(points, scalars) {
        return pippenger(Point2, Fn3, points, scalars);
      }
      static fromPrivateKey(privateKey) {
        return Point2.BASE.multiply(_normFnElement(Fn3, privateKey));
      }
    }
    Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy, Fp4.ONE);
    Point2.ZERO = new Point2(Fp4.ZERO, Fp4.ONE, Fp4.ZERO);
    Point2.Fp = Fp4;
    Point2.Fn = Fn3;
    const bits = Fn3.BITS;
    const wnaf = new wNAF(Point2, extraOpts.endo ? Math.ceil(bits / 2) : bits);
    return Point2;
  }
  function pprefix(hasEvenY) {
    return Uint8Array.of(hasEvenY ? 2 : 3);
  }
  function getWLengths(Fp4, Fn3) {
    return {
      secret: Fn3.BYTES,
      public: 1 + Fp4.BYTES,
      publicUncompressed: 1 + 2 * Fp4.BYTES,
      publicKeyHasPrefix: true,
      signature: 2 * Fn3.BYTES
    };
  }
  function ecdh(Point2, ecdhOpts = {}) {
    const { Fn: Fn3 } = Point2;
    const randomBytes_ = ecdhOpts.randomBytes || randomBytes2;
    const lengths = Object.assign(getWLengths(Point2.Fp, Fn3), { seed: getMinHashLength(Fn3.ORDER) });
    function isValidSecretKey(secretKey) {
      try {
        return !!_normFnElement(Fn3, secretKey);
      } catch (error) {
        return false;
      }
    }
    function isValidPublicKey(publicKey, isCompressed) {
      const { public: comp, publicUncompressed } = lengths;
      try {
        const l = publicKey.length;
        if (isCompressed === true && l !== comp)
          return false;
        if (isCompressed === false && l !== publicUncompressed)
          return false;
        return !!Point2.fromBytes(publicKey);
      } catch (error) {
        return false;
      }
    }
    function randomSecretKey(seed = randomBytes_(lengths.seed)) {
      return mapHashToField(_abytes2(seed, lengths.seed, "seed"), Fn3.ORDER);
    }
    function getPublicKey(secretKey, isCompressed = true) {
      return Point2.BASE.multiply(_normFnElement(Fn3, secretKey)).toBytes(isCompressed);
    }
    function keygen(seed) {
      const secretKey = randomSecretKey(seed);
      return { secretKey, publicKey: getPublicKey(secretKey) };
    }
    function isProbPub(item) {
      if (typeof item === "bigint")
        return false;
      if (item instanceof Point2)
        return true;
      if (Fn3.allowedLengths || lengths.secret === lengths.public)
        return void 0;
      const l = ensureBytes("key", item).length;
      return l === lengths.public || l === lengths.publicUncompressed;
    }
    function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
      if (isProbPub(secretKeyA) === true)
        throw new Error("first arg must be private key");
      if (isProbPub(publicKeyB) === false)
        throw new Error("second arg must be public key");
      const s2 = _normFnElement(Fn3, secretKeyA);
      const b = Point2.fromHex(publicKeyB);
      return b.multiply(s2).toBytes(isCompressed);
    }
    const utils2 = {
      isValidSecretKey,
      isValidPublicKey,
      randomSecretKey,
      // TODO: remove
      isValidPrivateKey: isValidSecretKey,
      randomPrivateKey: randomSecretKey,
      normPrivateKeyToScalar: (key) => _normFnElement(Fn3, key),
      precompute(windowSize = 8, point = Point2.BASE) {
        return point.precompute(windowSize, false);
      }
    };
    return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point: Point2, utils: utils2, lengths });
  }
  function ecdsa(Point2, hash2, ecdsaOpts = {}) {
    ahash(hash2);
    _validateObject(ecdsaOpts, {}, {
      hmac: "function",
      lowS: "boolean",
      randomBytes: "function",
      bits2int: "function",
      bits2int_modN: "function"
    });
    const randomBytes_ = ecdsaOpts.randomBytes || randomBytes2;
    const hmac_ = ecdsaOpts.hmac || ((key, ...msgs) => hmac(hash2, key, concatBytes2(...msgs)));
    const { Fp: Fp4, Fn: Fn3 } = Point2;
    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn3;
    const { keygen, getPublicKey, getSharedSecret, utils: utils2, lengths } = ecdh(Point2, ecdsaOpts);
    const defaultSigOpts = {
      prehash: false,
      lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
      format: void 0,
      //'compact' as ECDSASigFormat,
      extraEntropy: false
    };
    const defaultSigOpts_format = "compact";
    function isBiggerThanHalfOrder(number3) {
      const HALF = CURVE_ORDER >> _1n6;
      return number3 > HALF;
    }
    function normalizeS(s2) {
      return isBiggerThanHalfOrder(s2) ? Fn3.neg(s2) : s2;
    }
    function validateRS(title, num) {
      if (!Fn3.isValidNot0(num))
        throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
      return num;
    }
    class Signature2 {
      constructor(r, s2, recovery) {
        this.r = validateRS("r", r);
        this.s = validateRS("s", s2);
        if (recovery != null)
          this.recovery = recovery;
        Object.freeze(this);
      }
      static fromBytes(bytes2, format19 = defaultSigOpts_format) {
        validateSigFormat(format19);
        const size = lengths.signature;
        let recid;
        if (format19 === "der") {
          const { r: r2, s: s3 } = DER.toSig(_abytes2(bytes2));
          return new Signature2(r2, s3);
        }
        if (format19 === "recovered") {
          _abytes2(bytes2, size + 1);
          recid = bytes2[0];
          format19 = "compact";
          bytes2 = bytes2.subarray(1);
        }
        _abytes2(bytes2, size);
        const L = size / 2;
        const r = bytes2.subarray(0, L);
        const s2 = bytes2.subarray(L, L * 2);
        return new Signature2(Fn3.fromBytes(r), Fn3.fromBytes(s2), recid);
      }
      static fromHex(hex, format19) {
        return this.fromBytes(hexToBytes2(hex), format19);
      }
      addRecoveryBit(recovery) {
        return new Signature2(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const FIELD_ORDER = Fp4.ORDER;
        const { r, s: s2, recovery: rec } = this;
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const hasCofactor = CURVE_ORDER * _2n4 < FIELD_ORDER;
        if (hasCofactor && rec > 1)
          throw new Error("recovery id is ambiguous for h>1 curve");
        const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
        if (!Fp4.isValid(radj))
          throw new Error("recovery id 2 or 3 invalid");
        const x = Fp4.toBytes(radj);
        const R = Point2.fromBytes(concatBytes2(pprefix((rec & 1) === 0), x));
        const ir = Fn3.inv(radj);
        const h2 = bits2int_modN(ensureBytes("msgHash", msgHash));
        const u1 = Fn3.create(-h2 * ir);
        const u2 = Fn3.create(s2 * ir);
        const Q = Point2.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
        if (Q.is0())
          throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      toBytes(format19 = defaultSigOpts_format) {
        validateSigFormat(format19);
        if (format19 === "der")
          return hexToBytes2(DER.hexFromSig(this));
        const r = Fn3.toBytes(this.r);
        const s2 = Fn3.toBytes(this.s);
        if (format19 === "recovered") {
          if (this.recovery == null)
            throw new Error("recovery bit must be present");
          return concatBytes2(Uint8Array.of(this.recovery), r, s2);
        }
        return concatBytes2(r, s2);
      }
      toHex(format19) {
        return bytesToHex2(this.toBytes(format19));
      }
      // TODO: remove
      assertValidity() {
      }
      static fromCompact(hex) {
        return Signature2.fromBytes(ensureBytes("sig", hex), "compact");
      }
      static fromDER(hex) {
        return Signature2.fromBytes(ensureBytes("sig", hex), "der");
      }
      normalizeS() {
        return this.hasHighS() ? new Signature2(this.r, Fn3.neg(this.s), this.recovery) : this;
      }
      toDERRawBytes() {
        return this.toBytes("der");
      }
      toDERHex() {
        return bytesToHex2(this.toBytes("der"));
      }
      toCompactRawBytes() {
        return this.toBytes("compact");
      }
      toCompactHex() {
        return bytesToHex2(this.toBytes("compact"));
      }
    }
    const bits2int2 = ecdsaOpts.bits2int || function(bytes2) {
      if (bytes2.length > 8192)
        throw new Error("input is too large");
      const num = bytesToNumberBE(bytes2);
      const delta = bytes2.length * 8 - fnBits;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = ecdsaOpts.bits2int_modN || function(bytes2) {
      return Fn3.create(bits2int2(bytes2));
    };
    const ORDER_MASK = bitMask(fnBits);
    function int2octets2(num) {
      aInRange("num < 2^" + fnBits, num, _0n6, ORDER_MASK);
      return Fn3.toBytes(num);
    }
    function prepSig(message2, privateKey, opts) {
      if (["recovered", "canonical"].some((k) => k in opts))
        throw new Error("sign() legacy options not supported");
      const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
      message2 = _abytes2(message2, void 0, "message");
      if (prehash)
        message2 = _abytes2(hash2(message2), void 0, "prehashed message");
      const h1int = bits2int_modN(message2);
      const d2 = _normFnElement(Fn3, privateKey);
      const seedArgs = [int2octets2(d2), int2octets2(h1int)];
      if (extraEntropy != null && extraEntropy !== false) {
        const e = extraEntropy === true ? randomBytes_(lengths.secret) : extraEntropy;
        seedArgs.push(ensureBytes("extraEntropy", e));
      }
      const seed = concatBytes2(...seedArgs);
      const m2 = h1int;
      function k2sig(kBytes) {
        const k = bits2int2(kBytes);
        if (!Fn3.isValidNot0(k))
          return;
        const ik = Fn3.inv(k);
        const q = Point2.BASE.multiply(k).toAffine();
        const r = Fn3.create(q.x);
        if (r === _0n6)
          return;
        const s2 = Fn3.create(ik * Fn3.create(m2 + r * d2));
        if (s2 === _0n6)
          return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n6);
        let normS = s2;
        if (lowS && isBiggerThanHalfOrder(s2)) {
          normS = normalizeS(s2);
          recovery ^= 1;
        }
        return new Signature2(r, normS, recovery);
      }
      return { seed, k2sig };
    }
    function sign3(message2, secretKey, opts = {}) {
      message2 = ensureBytes("message", message2);
      const { seed, k2sig } = prepSig(message2, secretKey, opts);
      const drbg = createHmacDrbg(hash2.outputLen, Fn3.BYTES, hmac_);
      const sig = drbg(seed, k2sig);
      return sig;
    }
    Point2.BASE.precompute(8);
    function verify2(signature, message2, publicKey, opts = {}) {
      const sg = signature;
      message2 = ensureBytes("msgHash", message2);
      publicKey = ensureBytes("publicKey", publicKey);
      const { lowS, prehash, format: format19 } = validateSigOpts(opts, defaultSigOpts);
      let _sig = void 0;
      let P;
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      if (format19 === void 0) {
        const isHex = typeof sg === "string" || isBytes(sg);
        const isObj = !isHex && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
        if (!isHex && !isObj)
          throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        if (isObj) {
          _sig = new Signature2(sg.r, sg.s);
        } else if (isHex) {
          try {
            _sig = Signature2.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof DER.Err))
              throw derError;
          }
          if (!_sig) {
            try {
              _sig = Signature2.fromCompact(sg);
            } catch (error) {
              return false;
            }
          }
        }
      } else {
        if (format19 === "compact" || format19 === "der") {
          if (typeof sg !== "string" && !isBytes(sg))
            throw new Error('"der" / "compact" format expects Uint8Array signature');
          _sig = Signature2.fromBytes(ensureBytes("sig", sg), format19);
        } else {
          throw new Error('format must be "compact", "der" or "js"');
        }
      }
      if (!_sig)
        return false;
      try {
        P = Point2.fromHex(publicKey);
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          message2 = hash2(message2);
        const { r, s: s2 } = _sig;
        const h2 = bits2int_modN(message2);
        const is = Fn3.inv(s2);
        const u1 = Fn3.create(h2 * is);
        const u2 = Fn3.create(r * is);
        const R = Point2.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
        if (R.is0())
          return false;
        const v = Fn3.create(R.x);
        return v === r;
      } catch (e) {
        return false;
      }
    }
    function recoverPublicKey(signature, message2, opts = {}) {
      const prehash = opts.prehash !== void 0 ? opts.prehash : defaultSigOpts.prehash;
      _abool2(prehash, "prehash");
      message2 = _abytes2(message2, void 0, "message");
      if (prehash)
        message2 = _abytes2(hash2(message2), void 0, "prehashed message");
      return Signature2.fromBytes(signature, "recovered").recoverPublicKey(message2).toBytes();
    }
    return Object.freeze({
      keygen,
      getPublicKey,
      getSharedSecret,
      utils: utils2,
      lengths,
      Point: Point2,
      sign: sign3,
      verify: verify2,
      recoverPublicKey,
      Signature: Signature2,
      hash: hash2
    });
  }
  function _weierstrass_legacy_opts_to_new(c) {
    const CURVE2 = {
      a: c.a,
      b: c.b,
      p: c.Fp.ORDER,
      n: c.n,
      h: c.h,
      Gx: c.Gx,
      Gy: c.Gy
    };
    const Fp4 = c.Fp;
    let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2)))) : void 0;
    const Fn3 = Field(CURVE2.n, {
      BITS: c.nBitLength,
      allowedLengths,
      modFromBytes: c.wrapPrivateKey
    });
    const curveOpts = {
      Fp: Fp4,
      Fn: Fn3,
      allowInfinityPoint: c.allowInfinityPoint,
      endo: c.endo,
      isTorsionFree: c.isTorsionFree,
      clearCofactor: c.clearCofactor,
      fromBytes: c.fromBytes,
      toBytes: c.toBytes
    };
    return { CURVE: CURVE2, curveOpts };
  }
  function _ecdsa_legacy_opts_to_new(c) {
    const { CURVE: CURVE2, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const ecdsaOpts = {
      hmac: c.hmac,
      randomBytes: c.randomBytes,
      lowS: c.lowS,
      bits2int: c.bits2int,
      bits2int_modN: c.bits2int_modN
    };
    return { CURVE: CURVE2, curveOpts, hash: c.hash, ecdsaOpts };
  }
  function _ecdsa_new_output_to_legacy(c, _ecdsa) {
    const Point2 = _ecdsa.Point;
    return Object.assign({}, _ecdsa, {
      ProjectivePoint: Point2,
      CURVE: Object.assign({}, c, nLength(Point2.Fn.ORDER, Point2.Fn.BITS))
    });
  }
  function weierstrass(c) {
    const { CURVE: CURVE2, curveOpts, hash: hash2, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
    const Point2 = weierstrassN(CURVE2, curveOpts);
    const signs = ecdsa(Point2, hash2, ecdsaOpts);
    return _ecdsa_new_output_to_legacy(c, signs);
  }

  // ../node_modules/@libp2p/crypto/node_modules/@noble/curves/esm/_shortw_utils.js
  function createCurve(curveDef, defHash) {
    const create19 = (hash2) => weierstrass({ ...curveDef, hash: hash2 });
    return { ...create19(defHash), create: create19 };
  }

  // ../node_modules/@libp2p/crypto/node_modules/@noble/curves/esm/secp256k1.js
  var secp256k1_CURVE = {
    p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
    Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
  };
  var secp256k1_ENDO = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    basises: [
      [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
      [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
    ]
  };
  var _2n5 = /* @__PURE__ */ BigInt(2);
  function sqrtMod(y2) {
    const P = secp256k1_CURVE.p;
    const _3n9 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y2 * y2 * y2 % P;
    const b3 = b2 * b2 * y2 % P;
    const b6 = pow2(b3, _3n9, P) * b3 % P;
    const b9 = pow2(b6, _3n9, P) * b3 % P;
    const b11 = pow2(b9, _2n5, P) * b2 % P;
    const b22 = pow2(b11, _11n, P) * b11 % P;
    const b44 = pow2(b22, _22n, P) * b22 % P;
    const b88 = pow2(b44, _44n, P) * b44 % P;
    const b176 = pow2(b88, _88n, P) * b88 % P;
    const b220 = pow2(b176, _44n, P) * b44 % P;
    const b223 = pow2(b220, _3n9, P) * b3 % P;
    const t1 = pow2(b223, _23n, P) * b22 % P;
    const t2 = pow2(t1, _6n, P) * b2 % P;
    const root = pow2(t2, _2n5, P);
    if (!Fpk1.eql(Fpk1.sqr(root), y2))
      throw new Error("Cannot find square root");
    return root;
  }
  var Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });
  var secp256k1 = createCurve({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha2565);

  // ../node_modules/@libp2p/crypto/dist/src/keys/secp256k1/index.browser.js
  function hashAndSign4(key, msg, options) {
    const p = sha2564.digest(msg instanceof Uint8Array ? msg : msg.subarray());
    if (isPromise(p)) {
      return p.then(({ digest: digest18 }) => {
        options?.signal?.throwIfAborted();
        return secp256k1.sign(digest18, key).toDERRawBytes();
      }).catch((err) => {
        if (err.name === "AbortError") {
          throw err;
        }
        throw new SigningError(String(err));
      });
    }
    try {
      return secp256k1.sign(p.digest, key).toDERRawBytes();
    } catch (err) {
      throw new SigningError(String(err));
    }
  }
  function hashAndVerify4(key, sig, msg, options) {
    const p = sha2564.digest(msg instanceof Uint8Array ? msg : msg.subarray());
    if (isPromise(p)) {
      return p.then(({ digest: digest18 }) => {
        options?.signal?.throwIfAborted();
        return secp256k1.verify(sig, digest18, key);
      }).catch((err) => {
        if (err.name === "AbortError") {
          throw err;
        }
        throw new VerificationError(String(err));
      });
    }
    try {
      options?.signal?.throwIfAborted();
      return secp256k1.verify(sig, p.digest, key);
    } catch (err) {
      throw new VerificationError(String(err));
    }
  }

  // ../node_modules/@libp2p/crypto/dist/src/keys/secp256k1/secp256k1.js
  var Secp256k1PublicKey = class {
    type = "secp256k1";
    raw;
    _key;
    constructor(key) {
      this._key = validateSecp256k1PublicKey(key);
      this.raw = compressSecp256k1PublicKey(this._key);
    }
    toMultihash() {
      return identity5.digest(publicKeyToProtobuf(this));
    }
    toCID() {
      return CID3.createV1(114, this.toMultihash());
    }
    toString() {
      return base58btc3.encode(this.toMultihash().bytes).substring(1);
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals8(this.raw, key.raw);
    }
    verify(data, sig, options) {
      return hashAndVerify4(this._key, sig, data, options);
    }
  };
  var Secp256k1PrivateKey = class {
    type = "secp256k1";
    raw;
    publicKey;
    constructor(key, publicKey) {
      this.raw = validateSecp256k1PrivateKey(key);
      this.publicKey = new Secp256k1PublicKey(publicKey ?? computeSecp256k1PublicKey(key));
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals8(this.raw, key.raw);
    }
    sign(message2, options) {
      return hashAndSign4(this.raw, message2, options);
    }
  };

  // ../node_modules/@libp2p/crypto/dist/src/keys/secp256k1/utils.js
  function unmarshalSecp256k1PublicKey(bytes2) {
    return new Secp256k1PublicKey(bytes2);
  }
  async function generateSecp256k1KeyPair() {
    const privateKeyBytes = generateSecp256k1PrivateKey();
    return new Secp256k1PrivateKey(privateKeyBytes);
  }
  function compressSecp256k1PublicKey(key) {
    const point = secp256k1.ProjectivePoint.fromHex(key).toRawBytes(true);
    return point;
  }
  function validateSecp256k1PrivateKey(key) {
    try {
      secp256k1.getPublicKey(key, true);
      return key;
    } catch (err) {
      throw new InvalidPrivateKeyError(String(err));
    }
  }
  function validateSecp256k1PublicKey(key) {
    try {
      secp256k1.ProjectivePoint.fromHex(key);
      return key;
    } catch (err) {
      throw new InvalidPublicKeyError(String(err));
    }
  }
  function computeSecp256k1PublicKey(privateKey) {
    try {
      return secp256k1.getPublicKey(privateKey, true);
    } catch (err) {
      throw new InvalidPrivateKeyError(String(err));
    }
  }
  function generateSecp256k1PrivateKey() {
    return secp256k1.utils.randomPrivateKey();
  }

  // ../node_modules/@libp2p/crypto/dist/src/keys/index.js
  async function generateKeyPair(type, bits) {
    if (type === "Ed25519") {
      return generateEd25519KeyPair();
    }
    if (type === "secp256k1") {
      return generateSecp256k1KeyPair();
    }
    if (type === "RSA") {
      return generateRSAKeyPair(toBits(bits));
    }
    if (type === "ECDSA") {
      return generateECDSAKeyPair(toCurve(bits));
    }
    throw new UnsupportedKeyTypeError();
  }
  function publicKeyFromProtobuf(buf, digest18) {
    const { Type, Data } = PublicKey.decode(buf);
    const data = Data ?? new Uint8Array();
    switch (Type) {
      case KeyType.RSA:
        return pkixToRSAPublicKey(data, digest18);
      case KeyType.Ed25519:
        return unmarshalEd25519PublicKey(data);
      case KeyType.secp256k1:
        return unmarshalSecp256k1PublicKey(data);
      case KeyType.ECDSA:
        return unmarshalECDSAPublicKey(data);
      default:
        throw new UnsupportedKeyTypeError();
    }
  }
  function publicKeyFromMultihash(digest18) {
    const { Type, Data } = PublicKey.decode(digest18.digest);
    const data = Data ?? new Uint8Array();
    switch (Type) {
      case KeyType.Ed25519:
        return unmarshalEd25519PublicKey(data);
      case KeyType.secp256k1:
        return unmarshalSecp256k1PublicKey(data);
      case KeyType.ECDSA:
        return unmarshalECDSAPublicKey(data);
      default:
        throw new UnsupportedKeyTypeError();
    }
  }
  function publicKeyToProtobuf(key) {
    return PublicKey.encode({
      Type: KeyType[key.type],
      Data: key.raw
    });
  }
  function toBits(bits) {
    if (bits == null) {
      return 2048;
    }
    return parseInt(bits, 10);
  }
  function toCurve(curve) {
    if (curve === "P-256" || curve == null) {
      return "P-256";
    }
    if (curve === "P-384") {
      return "P-384";
    }
    if (curve === "P-521") {
      return "P-521";
    }
    throw new InvalidParametersError("Unsupported curve, should be P-256, P-384 or P-521");
  }

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports4 = {};
  __export(base58_exports4, {
    base58btc: () => base58btc4,
    base58flickr: () => base58flickr4
  });

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bytes.js
  var empty4 = new Uint8Array(0);
  function equals9(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce4(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function fromString7(str) {
    return new TextEncoder().encode(str);
  }
  function toString6(b) {
    return new TextDecoder().decode(b);
  }

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/vendor/base-x.js
  function base5(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src4 = base5;
  var _brrp__multiformats_scope_baseX4 = src4;
  var base_x_default4 = _brrp__multiformats_scope_baseX4;

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base.js
  var Encoder5 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder5 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or4(this, decoder);
    }
  };
  var ComposedDecoder4 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or4(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or4(left, right) {
    return new ComposedDecoder4({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec4 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder5(name19, prefix, baseEncode);
      this.decoder = new Decoder5(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from7({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec4(name19, prefix, encode79, decode99);
  }
  function baseX4({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default4(alphabet18, name19);
    return from7({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce4(decode99(text))
    });
  }
  function decode18(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode15(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx4(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc46484({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx4(alphabet18);
    return from7({
      prefix,
      name: name19,
      encode(input) {
        return encode15(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode18(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base58.js
  var base58btc4 = baseX4({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr4 = baseX4({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports4 = {};
  __export(base32_exports4, {
    base32: () => base324,
    base32hex: () => base32hex4,
    base32hexpad: () => base32hexpad4,
    base32hexpadupper: () => base32hexpadupper4,
    base32hexupper: () => base32hexupper4,
    base32pad: () => base32pad4,
    base32padupper: () => base32padupper4,
    base32upper: () => base32upper4,
    base32z: () => base32z4
  });
  var base324 = rfc46484({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper4 = rfc46484({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad4 = rfc46484({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper4 = rfc46484({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex4 = rfc46484({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper4 = rfc46484({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad4 = rfc46484({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper4 = rfc46484({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z4 = rfc46484({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports4 = {};
  __export(base36_exports4, {
    base36: () => base364,
    base36upper: () => base36upper4
  });
  var base364 = baseX4({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper4 = baseX4({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_14 = encode16;
  var MSB5 = 128;
  var REST5 = 127;
  var MSBALL4 = ~REST5;
  var INT4 = Math.pow(2, 31);
  function encode16(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT4) {
      out[offset++] = num & 255 | MSB5;
      num /= 128;
    }
    while (num & MSBALL4) {
      out[offset++] = num & 255 | MSB5;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode16.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode19 = read5;
  var MSB$14 = 128;
  var REST$14 = 127;
  function read5(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read5.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$14) << shift : (b & REST$14) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$14);
    read5.bytes = counter - offset;
    return res;
  }
  var N15 = Math.pow(2, 7);
  var N25 = Math.pow(2, 14);
  var N35 = Math.pow(2, 21);
  var N45 = Math.pow(2, 28);
  var N55 = Math.pow(2, 35);
  var N65 = Math.pow(2, 42);
  var N75 = Math.pow(2, 49);
  var N84 = Math.pow(2, 56);
  var N94 = Math.pow(2, 63);
  var length5 = function(value) {
    return value < N15 ? 1 : value < N25 ? 2 : value < N35 ? 3 : value < N45 ? 4 : value < N55 ? 5 : value < N65 ? 6 : value < N75 ? 7 : value < N84 ? 8 : value < N94 ? 9 : 10;
  };
  var varint4 = {
    encode: encode_14,
    decode: decode19,
    encodingLength: length5
  };
  var _brrp_varint4 = varint4;
  var varint_default4 = _brrp_varint4;

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/varint.js
  function decode20(data, offset = 0) {
    const code18 = varint_default4.decode(data, offset);
    return [code18, varint_default4.decode.bytes];
  }
  function encodeTo4(int, target, offset = 0) {
    varint_default4.encode(int, target, offset);
    return target;
  }
  function encodingLength5(int) {
    return varint_default4.encodingLength(int);
  }

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/hashes/digest.js
  function create4(code18, digest18) {
    const size = digest18.byteLength;
    const sizeOffset = encodingLength5(code18);
    const digestOffset = sizeOffset + encodingLength5(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo4(code18, bytes2, 0);
    encodeTo4(size, bytes2, sizeOffset);
    bytes2.set(digest18, digestOffset);
    return new Digest4(code18, size, digest18, bytes2);
  }
  function decode21(multihash) {
    const bytes2 = coerce4(multihash);
    const [code18, sizeOffset] = decode20(bytes2);
    const [size, digestOffset] = decode20(bytes2.subarray(sizeOffset));
    const digest18 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest18.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest4(code18, size, digest18, bytes2);
  }
  function equals10(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals9(a.bytes, data.bytes);
    }
  }
  var Digest4 = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code18, size, digest18, bytes2) {
      this.code = code18;
      this.size = size;
      this.digest = digest18;
      this.bytes = bytes2;
    }
  };

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/cid.js
  function format4(link, base37) {
    const { bytes: bytes2, version: version5 } = link;
    switch (version5) {
      case 0:
        return toStringV04(bytes2, baseCache4(link), base37 ?? base58btc4.encoder);
      default:
        return toStringV14(bytes2, baseCache4(link), base37 ?? base324.encoder);
    }
  }
  var cache4 = /* @__PURE__ */ new WeakMap();
  function baseCache4(cid) {
    const baseCache19 = cache4.get(cid);
    if (baseCache19 == null) {
      const baseCache20 = /* @__PURE__ */ new Map();
      cache4.set(cid, baseCache20);
      return baseCache20;
    }
    return baseCache19;
  }
  var CID4 = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version5, code18, multihash, bytes2) {
      this.code = code18;
      this.version = version5;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code18, multihash } = this;
          if (code18 !== DAG_PB_CODE4) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE4) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code18, digest: digest18 } = this.multihash;
          const multihash = create4(code18, digest18);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals10(self2.multihash, unknown.multihash);
    }
    toString(base37) {
      return format4(this, base37);
    }
    toJSON() {
      return { "/": format4(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version5, code: code18, multihash, bytes: bytes2 } = value;
        return new _CID(version5, code18, multihash, bytes2 ?? encodeCID4(version5, code18, multihash.bytes));
      } else if (value[cidSymbol4] === true) {
        const { version: version5, multihash, code: code18 } = value;
        const digest18 = decode21(multihash);
        return _CID.create(version5, code18, digest18);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version5, code18, digest18) {
      if (typeof code18 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest18.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version5) {
        case 0: {
          if (code18 !== DAG_PB_CODE4) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE4}) block encoding`);
          } else {
            return new _CID(version5, code18, digest18, digest18.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID4(version5, code18, digest18.bytes);
          return new _CID(version5, code18, digest18, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest18) {
      return _CID.create(0, DAG_PB_CODE4, digest18);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code18, digest18) {
      return _CID.create(1, code18, digest18);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes2) {
      const [cid, remainder] = _CID.decodeFirst(bytes2);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes2) {
      const specs = _CID.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce4(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest18 = new Digest4(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest18) : _CID.createV1(specs.codec, digest18);
      return [cid, bytes2.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length21] = decode20(initialBytes.subarray(offset));
        offset += length21;
        return i;
      };
      let version5 = next();
      let codec = DAG_PB_CODE4;
      if (version5 === 18) {
        version5 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version5 !== 0 && version5 !== 1) {
        throw new RangeError(`Invalid CID version ${version5}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version5, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base37) {
      const [prefix, bytes2] = parseCIDtoBytes4(source, base37);
      const cid = _CID.decode(bytes2);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache4(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes4(source, base37) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base37 ?? base58btc4;
        return [
          base58btc4.prefix,
          decoder.decode(`${base58btc4.prefix}${source}`)
        ];
      }
      case base58btc4.prefix: {
        const decoder = base37 ?? base58btc4;
        return [base58btc4.prefix, decoder.decode(source)];
      }
      case base324.prefix: {
        const decoder = base37 ?? base324;
        return [base324.prefix, decoder.decode(source)];
      }
      case base364.prefix: {
        const decoder = base37 ?? base364;
        return [base364.prefix, decoder.decode(source)];
      }
      default: {
        if (base37 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base37.decode(source)];
      }
    }
  }
  function toStringV04(bytes2, cache20, base37) {
    const { prefix } = base37;
    if (prefix !== base58btc4.prefix) {
      throw Error(`Cannot string encode V0 in ${base37.name} encoding`);
    }
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2).slice(1);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV14(bytes2, cache20, base37) {
    const { prefix } = base37;
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE4 = 112;
  var SHA_256_CODE4 = 18;
  function encodeCID4(version5, code18, multihash) {
    const codeOffset = encodingLength5(version5);
    const hashOffset = codeOffset + encodingLength5(code18);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo4(version5, bytes2, 0);
    encodeTo4(code18, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  }
  var cidSymbol4 = Symbol.for("@ipld/js-cid/CID");

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports7 = {};
  __export(identity_exports7, {
    identity: () => identity7
  });
  var code4 = 0;
  var name4 = "identity";
  var encode17 = coerce4;
  function digest4(input) {
    return create4(code4, encode17(input));
  }
  var identity7 = { code: code4, name: name4, encode: encode17, digest: digest4 };

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports4 = {};
  __export(sha2_browser_exports4, {
    sha256: () => sha2567,
    sha512: () => sha5125
  });

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/hashes/hasher.js
  function from8({ name: name19, code: code18, encode: encode79 }) {
    return new Hasher4(name19, code18, encode79);
  }
  var Hasher4 = class {
    name;
    code;
    encode;
    constructor(name19, code18, encode79) {
      this.name = name19;
      this.code = code18;
      this.encode = encode79;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create4(this.code, result) : result.then((digest18) => create4(this.code, digest18));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  function sha4(name19) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name19, data));
  }
  var sha2567 = from8({
    name: "sha2-256",
    code: 18,
    encode: sha4("SHA-256")
  });
  var sha5125 = from8({
    name: "sha2-512",
    code: 19,
    encode: sha4("SHA-512")
  });

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports4 = {};
  __export(base10_exports4, {
    base10: () => base104
  });
  var base104 = baseX4({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports4 = {};
  __export(base16_exports4, {
    base16: () => base164,
    base16upper: () => base16upper4
  });
  var base164 = rfc46484({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper4 = rfc46484({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports4 = {};
  __export(base2_exports4, {
    base2: () => base24
  });
  var base24 = rfc46484({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports4 = {};
  __export(base256emoji_exports4, {
    base256emoji: () => base256emoji4
  });
  var alphabet4 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars4 = alphabet4.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes4 = alphabet4.reduce((p, c, i) => {
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
  }, []);
  function encode18(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars4[c];
      return p;
    }, "");
  }
  function decode22(str) {
    const byts = [];
    for (const char of str) {
      const codePoint = char.codePointAt(0);
      if (codePoint == null) {
        throw new Error(`Invalid character: ${char}`);
      }
      const byt = alphabetCharsToBytes4[codePoint];
      if (byt == null) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji4 = from7({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode18,
    decode: decode22
  });

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports4 = {};
  __export(base64_exports4, {
    base64: () => base644,
    base64pad: () => base64pad4,
    base64url: () => base64url4,
    base64urlpad: () => base64urlpad4
  });
  var base644 = rfc46484({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad4 = rfc46484({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url4 = rfc46484({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad4 = rfc46484({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports4 = {};
  __export(base8_exports4, {
    base8: () => base84
  });
  var base84 = rfc46484({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports8 = {};
  __export(identity_exports8, {
    identity: () => identity8
  });
  var identity8 = from7({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString6(buf),
    decode: (str) => fromString7(str)
  });

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/codecs/json.js
  var textEncoder4 = new TextEncoder();
  var textDecoder4 = new TextDecoder();

  // ../node_modules/@libp2p/peer-id/node_modules/multiformats/dist/src/basics.js
  var bases4 = { ...identity_exports8, ...base2_exports4, ...base8_exports4, ...base10_exports4, ...base16_exports4, ...base32_exports4, ...base36_exports4, ...base58_exports4, ...base64_exports4, ...base256emoji_exports4 };
  var hashes4 = { ...sha2_browser_exports4, ...identity_exports7 };

  // ../node_modules/@libp2p/peer-id/node_modules/uint8arrays/dist/src/alloc.js
  function allocUnsafe7(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/@libp2p/peer-id/node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec5(name19, prefix, encode79, decode99) {
    return {
      name: name19,
      prefix,
      encoder: {
        name: name19,
        prefix,
        encode: encode79
      },
      decoder: {
        decode: decode99
      }
    };
  }
  var string4 = createCodec5("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder3 = new TextEncoder();
    return encoder3.encode(str.substring(1));
  });
  var ascii4 = createCodec5("ascii", "a", (buf) => {
    let string19 = "a";
    for (let i = 0; i < buf.length; i++) {
      string19 += String.fromCharCode(buf[i]);
    }
    return string19;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe7(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  var BASES4 = {
    utf8: string4,
    "utf-8": string4,
    hex: bases4.base16,
    latin1: ascii4,
    ascii: ascii4,
    binary: ascii4,
    ...bases4
  };
  var bases_default4 = BASES4;

  // ../node_modules/@libp2p/peer-id/node_modules/uint8arrays/dist/src/to-string.js
  function toString7(array, encoding = "utf8") {
    const base37 = bases_default4[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.encoder.encode(array).substring(1);
  }

  // ../node_modules/@libp2p/peer-id/node_modules/uint8arrays/dist/src/equals.js
  function equals11(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }

  // ../node_modules/@libp2p/peer-id/node_modules/uint8arrays/dist/src/from-string.js
  function fromString8(string19, encoding = "utf8") {
    const base37 = bases_default4[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.decoder.decode(`${base37.prefix}${string19}`);
  }

  // ../node_modules/@libp2p/peer-id/dist/src/peer-id.js
  var inspect = Symbol.for("nodejs.util.inspect.custom");
  var LIBP2P_KEY_CODE = 114;
  var PeerIdImpl = class {
    type;
    multihash;
    publicKey;
    string;
    constructor(init) {
      this.type = init.type;
      this.multihash = init.multihash;
      Object.defineProperty(this, "string", {
        enumerable: false,
        writable: true
      });
    }
    get [Symbol.toStringTag]() {
      return `PeerId(${this.toString()})`;
    }
    [peerIdSymbol] = true;
    toString() {
      if (this.string == null) {
        this.string = base58btc4.encode(this.multihash.bytes).slice(1);
      }
      return this.string;
    }
    toMultihash() {
      return this.multihash;
    }
    // return self-describing String representation
    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
    toCID() {
      return CID4.createV1(LIBP2P_KEY_CODE, this.multihash);
    }
    toJSON() {
      return this.toString();
    }
    /**
     * Checks the equality of `this` peer against a given PeerId
     */
    equals(id) {
      if (id == null) {
        return false;
      }
      if (id instanceof Uint8Array) {
        return equals11(this.multihash.bytes, id);
      } else if (typeof id === "string") {
        return this.toString() === id;
      } else if (id?.toMultihash()?.bytes != null) {
        return equals11(this.multihash.bytes, id.toMultihash().bytes);
      } else {
        throw new Error("not valid Id");
      }
    }
    /**
     * Returns PeerId as a human-readable string
     * https://nodejs.org/api/util.html#utilinspectcustom
     *
     * @example
     * ```TypeScript
     * import { peerIdFromString } from '@libp2p/peer-id'
     *
     * console.info(peerIdFromString('QmFoo'))
     * // 'PeerId(QmFoo)'
     * ```
     */
    [inspect]() {
      return `PeerId(${this.toString()})`;
    }
  };
  var RSAPeerId = class extends PeerIdImpl {
    type = "RSA";
    publicKey;
    constructor(init) {
      super({ ...init, type: "RSA" });
      this.publicKey = init.publicKey;
    }
  };
  var Ed25519PeerId = class extends PeerIdImpl {
    type = "Ed25519";
    publicKey;
    constructor(init) {
      super({ ...init, type: "Ed25519" });
      this.publicKey = init.publicKey;
    }
  };
  var Secp256k1PeerId = class extends PeerIdImpl {
    type = "secp256k1";
    publicKey;
    constructor(init) {
      super({ ...init, type: "secp256k1" });
      this.publicKey = init.publicKey;
    }
  };
  var TRANSPORT_IPFS_GATEWAY_HTTP_CODE = 2336;
  var URLPeerId = class {
    type = "url";
    multihash;
    publicKey;
    url;
    constructor(url) {
      this.url = url.toString();
      this.multihash = identity7.digest(fromString8(this.url));
    }
    [inspect]() {
      return `PeerId(${this.url})`;
    }
    [peerIdSymbol] = true;
    toString() {
      return this.toCID().toString();
    }
    toMultihash() {
      return this.multihash;
    }
    toCID() {
      return CID4.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE, this.toMultihash());
    }
    toJSON() {
      return this.toString();
    }
    equals(other) {
      if (other == null) {
        return false;
      }
      if (other instanceof Uint8Array) {
        other = toString7(other);
      }
      return other.toString() === this.toString();
    }
  };

  // ../node_modules/@libp2p/peer-id/dist/src/index.js
  var LIBP2P_KEY_CODE2 = 114;
  var TRANSPORT_IPFS_GATEWAY_HTTP_CODE2 = 2336;
  function peerIdFromString(str, decoder) {
    let multihash;
    if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
      multihash = decode21(base58btc4.decode(`z${str}`));
    } else if (str.startsWith("k51qzi5uqu5") || str.startsWith("kzwfwjn5ji4") || str.startsWith("k2k4r8") || str.startsWith("bafz")) {
      return peerIdFromCID(CID4.parse(str));
    } else {
      if (decoder == null) {
        throw new InvalidParametersError('Please pass a multibase decoder for strings that do not start with "1" or "Q"');
      }
      multihash = decode21(decoder.decode(str));
    }
    return peerIdFromMultihash(multihash);
  }
  function peerIdFromPublicKey(publicKey) {
    if (publicKey.type === "Ed25519") {
      return new Ed25519PeerId({
        multihash: publicKey.toCID().multihash,
        publicKey
      });
    } else if (publicKey.type === "secp256k1") {
      return new Secp256k1PeerId({
        multihash: publicKey.toCID().multihash,
        publicKey
      });
    } else if (publicKey.type === "RSA") {
      return new RSAPeerId({
        multihash: publicKey.toCID().multihash,
        publicKey
      });
    }
    throw new UnsupportedKeyTypeError();
  }
  function peerIdFromPrivateKey(privateKey) {
    return peerIdFromPublicKey(privateKey.publicKey);
  }
  function peerIdFromMultihash(multihash) {
    if (isSha256Multihash(multihash)) {
      return new RSAPeerId({ multihash });
    } else if (isIdentityMultihash(multihash)) {
      try {
        const publicKey = publicKeyFromMultihash(multihash);
        if (publicKey.type === "Ed25519") {
          return new Ed25519PeerId({ multihash, publicKey });
        } else if (publicKey.type === "secp256k1") {
          return new Secp256k1PeerId({ multihash, publicKey });
        }
      } catch (err) {
        const url = toString7(multihash.digest);
        return new URLPeerId(new URL(url));
      }
    }
    throw new InvalidMultihashError("Supplied PeerID Multihash is invalid");
  }
  function peerIdFromCID(cid) {
    if (cid?.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE2 && cid.code !== TRANSPORT_IPFS_GATEWAY_HTTP_CODE2) {
      throw new InvalidCIDError("Supplied PeerID CID is invalid");
    }
    if (cid.code === TRANSPORT_IPFS_GATEWAY_HTTP_CODE2) {
      const url = toString7(cid.multihash.digest);
      return new URLPeerId(new URL(url));
    }
    return peerIdFromMultihash(cid.multihash);
  }
  function isIdentityMultihash(multihash) {
    return multihash.code === identity7.code;
  }
  function isSha256Multihash(multihash) {
    return multihash.code === sha2567.code;
  }

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports5 = {};
  __export(base10_exports5, {
    base10: () => base105
  });

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bytes.js
  var empty5 = new Uint8Array(0);
  function equals12(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce5(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function fromString9(str) {
    return new TextEncoder().encode(str);
  }
  function toString8(b) {
    return new TextDecoder().decode(b);
  }

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/vendor/base-x.js
  function base6(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src5 = base6;
  var _brrp__multiformats_scope_baseX5 = src5;
  var base_x_default5 = _brrp__multiformats_scope_baseX5;

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base.js
  var Encoder6 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder6 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or5(this, decoder);
    }
  };
  var ComposedDecoder5 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or5(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or5(left, right) {
    return new ComposedDecoder5({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec5 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder6(name19, prefix, baseEncode);
      this.decoder = new Decoder6(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from9({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec5(name19, prefix, encode79, decode99);
  }
  function baseX5({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default5(alphabet18, name19);
    return from9({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce5(decode99(text))
    });
  }
  function decode23(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode19(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx5(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc46485({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx5(alphabet18);
    return from9({
      prefix,
      name: name19,
      encode(input) {
        return encode19(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode23(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base10.js
  var base105 = baseX5({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports5 = {};
  __export(base16_exports5, {
    base16: () => base165,
    base16upper: () => base16upper5
  });
  var base165 = rfc46485({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper5 = rfc46485({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports5 = {};
  __export(base2_exports5, {
    base2: () => base25
  });
  var base25 = rfc46485({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports5 = {};
  __export(base256emoji_exports5, {
    base256emoji: () => base256emoji5
  });
  var alphabet5 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars5 = alphabet5.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes5 = alphabet5.reduce((p, c, i) => {
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
  }, []);
  function encode20(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars5[c];
      return p;
    }, "");
  }
  function decode24(str) {
    const byts = [];
    for (const char of str) {
      const codePoint = char.codePointAt(0);
      if (codePoint == null) {
        throw new Error(`Invalid character: ${char}`);
      }
      const byt = alphabetCharsToBytes5[codePoint];
      if (byt == null) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji5 = from9({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode20,
    decode: decode24
  });

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports5 = {};
  __export(base32_exports5, {
    base32: () => base325,
    base32hex: () => base32hex5,
    base32hexpad: () => base32hexpad5,
    base32hexpadupper: () => base32hexpadupper5,
    base32hexupper: () => base32hexupper5,
    base32pad: () => base32pad5,
    base32padupper: () => base32padupper5,
    base32upper: () => base32upper5,
    base32z: () => base32z5
  });
  var base325 = rfc46485({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper5 = rfc46485({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad5 = rfc46485({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper5 = rfc46485({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex5 = rfc46485({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper5 = rfc46485({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad5 = rfc46485({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper5 = rfc46485({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z5 = rfc46485({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports5 = {};
  __export(base36_exports5, {
    base36: () => base365,
    base36upper: () => base36upper5
  });
  var base365 = baseX5({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper5 = baseX5({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports5 = {};
  __export(base58_exports5, {
    base58btc: () => base58btc5,
    base58flickr: () => base58flickr5
  });
  var base58btc5 = baseX5({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr5 = baseX5({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports5 = {};
  __export(base64_exports5, {
    base64: () => base645,
    base64pad: () => base64pad5,
    base64url: () => base64url5,
    base64urlpad: () => base64urlpad5
  });
  var base645 = rfc46485({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad5 = rfc46485({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url5 = rfc46485({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad5 = rfc46485({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports5 = {};
  __export(base8_exports5, {
    base8: () => base85
  });
  var base85 = rfc46485({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports9 = {};
  __export(identity_exports9, {
    identity: () => identity9
  });
  var identity9 = from9({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString8(buf),
    decode: (str) => fromString9(str)
  });

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/codecs/json.js
  var textEncoder5 = new TextEncoder();
  var textDecoder5 = new TextDecoder();

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports10 = {};
  __export(identity_exports10, {
    identity: () => identity10
  });

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_15 = encode21;
  var MSB6 = 128;
  var REST6 = 127;
  var MSBALL5 = ~REST6;
  var INT5 = Math.pow(2, 31);
  function encode21(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT5) {
      out[offset++] = num & 255 | MSB6;
      num /= 128;
    }
    while (num & MSBALL5) {
      out[offset++] = num & 255 | MSB6;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode21.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode25 = read6;
  var MSB$15 = 128;
  var REST$15 = 127;
  function read6(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read6.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$15) << shift : (b & REST$15) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$15);
    read6.bytes = counter - offset;
    return res;
  }
  var N16 = Math.pow(2, 7);
  var N26 = Math.pow(2, 14);
  var N36 = Math.pow(2, 21);
  var N46 = Math.pow(2, 28);
  var N56 = Math.pow(2, 35);
  var N66 = Math.pow(2, 42);
  var N76 = Math.pow(2, 49);
  var N85 = Math.pow(2, 56);
  var N95 = Math.pow(2, 63);
  var length6 = function(value) {
    return value < N16 ? 1 : value < N26 ? 2 : value < N36 ? 3 : value < N46 ? 4 : value < N56 ? 5 : value < N66 ? 6 : value < N76 ? 7 : value < N85 ? 8 : value < N95 ? 9 : 10;
  };
  var varint5 = {
    encode: encode_15,
    decode: decode25,
    encodingLength: length6
  };
  var _brrp_varint5 = varint5;
  var varint_default5 = _brrp_varint5;

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/varint.js
  function decode26(data, offset = 0) {
    const code18 = varint_default5.decode(data, offset);
    return [code18, varint_default5.decode.bytes];
  }
  function encodeTo5(int, target, offset = 0) {
    varint_default5.encode(int, target, offset);
    return target;
  }
  function encodingLength6(int) {
    return varint_default5.encodingLength(int);
  }

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/digest.js
  function create5(code18, digest18) {
    const size = digest18.byteLength;
    const sizeOffset = encodingLength6(code18);
    const digestOffset = sizeOffset + encodingLength6(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo5(code18, bytes2, 0);
    encodeTo5(size, bytes2, sizeOffset);
    bytes2.set(digest18, digestOffset);
    return new Digest5(code18, size, digest18, bytes2);
  }
  function decode27(multihash) {
    const bytes2 = coerce5(multihash);
    const [code18, sizeOffset] = decode26(bytes2);
    const [size, digestOffset] = decode26(bytes2.subarray(sizeOffset));
    const digest18 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest18.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest5(code18, size, digest18, bytes2);
  }
  function equals13(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals12(a.bytes, data.bytes);
    }
  }
  var Digest5 = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code18, size, digest18, bytes2) {
      this.code = code18;
      this.size = size;
      this.digest = digest18;
      this.bytes = bytes2;
    }
  };

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/identity.js
  var code5 = 0;
  var name5 = "identity";
  var encode22 = coerce5;
  function digest5(input) {
    return create5(code5, encode22(input));
  }
  var identity10 = { code: code5, name: name5, encode: encode22, digest: digest5 };

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports5 = {};
  __export(sha2_browser_exports5, {
    sha256: () => sha2568,
    sha512: () => sha5126
  });

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/hasher.js
  function from10({ name: name19, code: code18, encode: encode79 }) {
    return new Hasher5(name19, code18, encode79);
  }
  var Hasher5 = class {
    name;
    code;
    encode;
    constructor(name19, code18, encode79) {
      this.name = name19;
      this.code = code18;
      this.encode = encode79;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create5(this.code, result) : result.then((digest18) => create5(this.code, digest18));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  function sha5(name19) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name19, data));
  }
  var sha2568 = from10({
    name: "sha2-256",
    code: 18,
    encode: sha5("SHA-256")
  });
  var sha5126 = from10({
    name: "sha2-512",
    code: 19,
    encode: sha5("SHA-512")
  });

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/cid.js
  function format5(link, base37) {
    const { bytes: bytes2, version: version5 } = link;
    switch (version5) {
      case 0:
        return toStringV05(bytes2, baseCache5(link), base37 ?? base58btc5.encoder);
      default:
        return toStringV15(bytes2, baseCache5(link), base37 ?? base325.encoder);
    }
  }
  var cache5 = /* @__PURE__ */ new WeakMap();
  function baseCache5(cid) {
    const baseCache19 = cache5.get(cid);
    if (baseCache19 == null) {
      const baseCache20 = /* @__PURE__ */ new Map();
      cache5.set(cid, baseCache20);
      return baseCache20;
    }
    return baseCache19;
  }
  var CID5 = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version5, code18, multihash, bytes2) {
      this.code = code18;
      this.version = version5;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code18, multihash } = this;
          if (code18 !== DAG_PB_CODE5) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE5) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code18, digest: digest18 } = this.multihash;
          const multihash = create5(code18, digest18);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals13(self2.multihash, unknown.multihash);
    }
    toString(base37) {
      return format5(this, base37);
    }
    toJSON() {
      return { "/": format5(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version5, code: code18, multihash, bytes: bytes2 } = value;
        return new _CID(version5, code18, multihash, bytes2 ?? encodeCID5(version5, code18, multihash.bytes));
      } else if (value[cidSymbol5] === true) {
        const { version: version5, multihash, code: code18 } = value;
        const digest18 = decode27(multihash);
        return _CID.create(version5, code18, digest18);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version5, code18, digest18) {
      if (typeof code18 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest18.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version5) {
        case 0: {
          if (code18 !== DAG_PB_CODE5) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE5}) block encoding`);
          } else {
            return new _CID(version5, code18, digest18, digest18.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID5(version5, code18, digest18.bytes);
          return new _CID(version5, code18, digest18, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest18) {
      return _CID.create(0, DAG_PB_CODE5, digest18);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code18, digest18) {
      return _CID.create(1, code18, digest18);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes2) {
      const [cid, remainder] = _CID.decodeFirst(bytes2);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes2) {
      const specs = _CID.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce5(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest18 = new Digest5(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest18) : _CID.createV1(specs.codec, digest18);
      return [cid, bytes2.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length21] = decode26(initialBytes.subarray(offset));
        offset += length21;
        return i;
      };
      let version5 = next();
      let codec = DAG_PB_CODE5;
      if (version5 === 18) {
        version5 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version5 !== 0 && version5 !== 1) {
        throw new RangeError(`Invalid CID version ${version5}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version5, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base37) {
      const [prefix, bytes2] = parseCIDtoBytes5(source, base37);
      const cid = _CID.decode(bytes2);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache5(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes5(source, base37) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base37 ?? base58btc5;
        return [
          base58btc5.prefix,
          decoder.decode(`${base58btc5.prefix}${source}`)
        ];
      }
      case base58btc5.prefix: {
        const decoder = base37 ?? base58btc5;
        return [base58btc5.prefix, decoder.decode(source)];
      }
      case base325.prefix: {
        const decoder = base37 ?? base325;
        return [base325.prefix, decoder.decode(source)];
      }
      case base365.prefix: {
        const decoder = base37 ?? base365;
        return [base365.prefix, decoder.decode(source)];
      }
      default: {
        if (base37 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base37.decode(source)];
      }
    }
  }
  function toStringV05(bytes2, cache20, base37) {
    const { prefix } = base37;
    if (prefix !== base58btc5.prefix) {
      throw Error(`Cannot string encode V0 in ${base37.name} encoding`);
    }
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2).slice(1);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV15(bytes2, cache20, base37) {
    const { prefix } = base37;
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE5 = 112;
  var SHA_256_CODE5 = 18;
  function encodeCID5(version5, code18, multihash) {
    const codeOffset = encodingLength6(version5);
    const hashOffset = codeOffset + encodingLength6(code18);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo5(version5, bytes2, 0);
    encodeTo5(code18, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  }
  var cidSymbol5 = Symbol.for("@ipld/js-cid/CID");

  // ../node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/basics.js
  var bases5 = { ...identity_exports9, ...base2_exports5, ...base8_exports5, ...base10_exports5, ...base16_exports5, ...base32_exports5, ...base36_exports5, ...base58_exports5, ...base64_exports5, ...base256emoji_exports5 };
  var hashes5 = { ...sha2_browser_exports5, ...identity_exports10 };

  // ../node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/alloc.js
  function allocUnsafe8(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec6(name19, prefix, encode79, decode99) {
    return {
      name: name19,
      prefix,
      encoder: {
        name: name19,
        prefix,
        encode: encode79
      },
      decoder: {
        decode: decode99
      }
    };
  }
  var string5 = createCodec6("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder3 = new TextEncoder();
    return encoder3.encode(str.substring(1));
  });
  var ascii5 = createCodec6("ascii", "a", (buf) => {
    let string19 = "a";
    for (let i = 0; i < buf.length; i++) {
      string19 += String.fromCharCode(buf[i]);
    }
    return string19;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe8(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  var BASES5 = {
    utf8: string5,
    "utf-8": string5,
    hex: bases5.base16,
    latin1: ascii5,
    ascii: ascii5,
    binary: ascii5,
    ...bases5
  };
  var bases_default5 = BASES5;

  // ../node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/to-string.js
  function toString9(array, encoding = "utf8") {
    const base37 = bases_default5[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.encoder.encode(array).substring(1);
  }

  // ../node_modules/@multiformats/multiaddr/dist/src/errors.js
  var InvalidMultiaddrError2 = class extends Error {
    static name = "InvalidMultiaddrError";
    name = "InvalidMultiaddrError";
  };
  var ValidationError = class extends Error {
    static name = "ValidationError";
    name = "ValidationError";
  };
  var InvalidParametersError2 = class extends Error {
    static name = "InvalidParametersError";
    name = "InvalidParametersError";
  };
  var UnknownProtocolError = class extends Error {
    static name = "UnknownProtocolError";
    name = "UnknownProtocolError";
  };

  // ../node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/equals.js
  function equals14(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }

  // ../node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/from-string.js
  function fromString10(string19, encoding = "utf8") {
    const base37 = bases_default5[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.decoder.decode(`${base37.prefix}${string19}`);
  }

  // ../node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/as-uint8array.js
  function asUint8Array4(buf) {
    return buf;
  }

  // ../node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/concat.js
  function concat4(arrays, length21) {
    if (length21 == null) {
      length21 = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output2 = allocUnsafe8(length21);
    let offset = 0;
    for (const arr of arrays) {
      output2.set(arr, offset);
      offset += arr.length;
    }
    return asUint8Array4(output2);
  }

  // ../node_modules/@chainsafe/is-ip/lib/parser.js
  var Parser = class {
    index = 0;
    input = "";
    new(input) {
      this.index = 0;
      this.input = input;
      return this;
    }
    /** Run a parser, and restore the pre-parse state if it fails. */
    readAtomically(fn) {
      const index = this.index;
      const result = fn();
      if (result === void 0) {
        this.index = index;
      }
      return result;
    }
    /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */
    parseWith(fn) {
      const result = fn();
      if (this.index !== this.input.length) {
        return void 0;
      }
      return result;
    }
    /** Peek the next character from the input */
    peekChar() {
      if (this.index >= this.input.length) {
        return void 0;
      }
      return this.input[this.index];
    }
    /** Read the next character from the input */
    readChar() {
      if (this.index >= this.input.length) {
        return void 0;
      }
      return this.input[this.index++];
    }
    /** Read the next character from the input if it matches the target. */
    readGivenChar(target) {
      return this.readAtomically(() => {
        const char = this.readChar();
        if (char !== target) {
          return void 0;
        }
        return char;
      });
    }
    /**
     * Helper for reading separators in an indexed loop. Reads the separator
     * character iff index > 0, then runs the parser. When used in a loop,
     * the separator character will only be read on index > 0 (see
     * readIPv4Addr for an example)
     */
    readSeparator(sep, index, inner) {
      return this.readAtomically(() => {
        if (index > 0) {
          if (this.readGivenChar(sep) === void 0) {
            return void 0;
          }
        }
        return inner();
      });
    }
    /**
     * Read a number off the front of the input in the given radix, stopping
     * at the first non-digit character or eof. Fails if the number has more
     * digits than max_digits or if there is no number.
     */
    readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {
      return this.readAtomically(() => {
        let result = 0;
        let digitCount = 0;
        const leadingChar = this.peekChar();
        if (leadingChar === void 0) {
          return void 0;
        }
        const hasLeadingZero = leadingChar === "0";
        const maxValue2 = 2 ** (8 * maxBytes) - 1;
        while (true) {
          const digit = this.readAtomically(() => {
            const char = this.readChar();
            if (char === void 0) {
              return void 0;
            }
            const num = Number.parseInt(char, radix);
            if (Number.isNaN(num)) {
              return void 0;
            }
            return num;
          });
          if (digit === void 0) {
            break;
          }
          result *= radix;
          result += digit;
          if (result > maxValue2) {
            return void 0;
          }
          digitCount += 1;
          if (maxDigits !== void 0) {
            if (digitCount > maxDigits) {
              return void 0;
            }
          }
        }
        if (digitCount === 0) {
          return void 0;
        } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
          return void 0;
        } else {
          return result;
        }
      });
    }
    /** Read an IPv4 address. */
    readIPv4Addr() {
      return this.readAtomically(() => {
        const out = new Uint8Array(4);
        for (let i = 0; i < out.length; i++) {
          const ix = this.readSeparator(".", i, () => this.readNumber(10, 3, false, 1));
          if (ix === void 0) {
            return void 0;
          }
          out[i] = ix;
        }
        return out;
      });
    }
    /** Read an IPv6 Address. */
    readIPv6Addr() {
      const readGroups = (groups) => {
        for (let i = 0; i < groups.length / 2; i++) {
          const ix = i * 2;
          if (i < groups.length - 3) {
            const ipv4 = this.readSeparator(":", i, () => this.readIPv4Addr());
            if (ipv4 !== void 0) {
              groups[ix] = ipv4[0];
              groups[ix + 1] = ipv4[1];
              groups[ix + 2] = ipv4[2];
              groups[ix + 3] = ipv4[3];
              return [ix + 4, true];
            }
          }
          const group = this.readSeparator(":", i, () => this.readNumber(16, 4, true, 2));
          if (group === void 0) {
            return [ix, false];
          }
          groups[ix] = group >> 8;
          groups[ix + 1] = group & 255;
        }
        return [groups.length, false];
      };
      return this.readAtomically(() => {
        const head = new Uint8Array(16);
        const [headSize, headIp4] = readGroups(head);
        if (headSize === 16) {
          return head;
        }
        if (headIp4) {
          return void 0;
        }
        if (this.readGivenChar(":") === void 0) {
          return void 0;
        }
        if (this.readGivenChar(":") === void 0) {
          return void 0;
        }
        const tail = new Uint8Array(14);
        const limit = 16 - (headSize + 2);
        const [tailSize] = readGroups(tail.subarray(0, limit));
        head.set(tail.subarray(0, tailSize), 16 - tailSize);
        return head;
      });
    }
    /** Read an IP Address, either IPv4 or IPv6. */
    readIPAddr() {
      return this.readIPv4Addr() ?? this.readIPv6Addr();
    }
  };

  // ../node_modules/@chainsafe/is-ip/lib/parse.js
  var MAX_IPV6_LENGTH = 45;
  var MAX_IPV4_LENGTH = 15;
  var parser = new Parser();
  function parseIPv4(input) {
    if (input.length > MAX_IPV4_LENGTH) {
      return void 0;
    }
    return parser.new(input).parseWith(() => parser.readIPv4Addr());
  }
  function parseIPv6(input) {
    if (input.includes("%")) {
      input = input.split("%")[0];
    }
    if (input.length > MAX_IPV6_LENGTH) {
      return void 0;
    }
    return parser.new(input).parseWith(() => parser.readIPv6Addr());
  }
  function parseIP(input, mapIPv4ToIPv6 = false) {
    if (input.includes("%")) {
      input = input.split("%")[0];
    }
    if (input.length > MAX_IPV6_LENGTH) {
      return void 0;
    }
    const addr = parser.new(input).parseWith(() => parser.readIPAddr());
    if (!addr) {
      return void 0;
    }
    if (mapIPv4ToIPv6 && addr.length === 4) {
      return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, addr[0], addr[1], addr[2], addr[3]]);
    }
    return addr;
  }

  // ../node_modules/@chainsafe/is-ip/lib/is-ip.js
  function isIPv4(input) {
    return Boolean(parseIPv4(input));
  }
  function isIPv6(input) {
    return Boolean(parseIPv6(input));
  }

  // ../node_modules/@multiformats/multiaddr/dist/src/constants.js
  var CODE_IP4 = 4;
  var CODE_TCP = 6;
  var CODE_UDP = 273;
  var CODE_DCCP = 33;
  var CODE_IP6 = 41;
  var CODE_IP6ZONE = 42;
  var CODE_IPCIDR = 43;
  var CODE_DNS = 53;
  var CODE_DNS4 = 54;
  var CODE_DNS6 = 55;
  var CODE_DNSADDR = 56;
  var CODE_SCTP = 132;
  var CODE_UDT = 301;
  var CODE_UTP = 302;
  var CODE_UNIX = 400;
  var CODE_P2P = 421;
  var CODE_ONION = 444;
  var CODE_ONION3 = 445;
  var CODE_GARLIC64 = 446;
  var CODE_GARLIC32 = 447;
  var CODE_TLS = 448;
  var CODE_SNI = 449;
  var CODE_NOISE = 454;
  var CODE_QUIC = 460;
  var CODE_QUIC_V1 = 461;
  var CODE_WEBTRANSPORT = 465;
  var CODE_CERTHASH = 466;
  var CODE_HTTP = 480;
  var CODE_HTTP_PATH = 481;
  var CODE_HTTPS = 443;
  var CODE_WS = 477;
  var CODE_WSS = 478;
  var CODE_P2P_WEBSOCKET_STAR = 479;
  var CODE_P2P_STARDUST = 277;
  var CODE_P2P_WEBRTC_STAR = 275;
  var CODE_P2P_WEBRTC_DIRECT = 276;
  var CODE_WEBRTC_DIRECT = 280;
  var CODE_WEBRTC = 281;
  var CODE_P2P_CIRCUIT = 290;
  var CODE_MEMORY = 777;

  // ../node_modules/@multiformats/multiaddr/dist/src/utils.js
  function bytesToString(base37) {
    return (buf) => {
      return toString9(buf, base37);
    };
  }
  function stringToBytes(base37) {
    return (buf) => {
      return fromString10(buf, base37);
    };
  }
  function bytes2port(buf) {
    const view = new DataView(buf.buffer);
    return view.getUint16(buf.byteOffset).toString();
  }
  function port2bytes(port) {
    const buf = new ArrayBuffer(2);
    const view = new DataView(buf);
    view.setUint16(0, typeof port === "string" ? parseInt(port) : port);
    return new Uint8Array(buf);
  }
  function onion2bytes(str) {
    const addr = str.split(":");
    if (addr.length !== 2) {
      throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 16) {
      throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
    }
    const buf = fromString10(addr[0], "base32");
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
      throw new Error("Port number is not in range(1, 65536)");
    }
    const portBuf = port2bytes(port);
    return concat4([buf, portBuf], buf.length + portBuf.length);
  }
  function onion32bytes(str) {
    const addr = str.split(":");
    if (addr.length !== 2) {
      throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 56) {
      throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
    }
    const buf = base325.decode(`b${addr[0]}`);
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
      throw new Error("Port number is not in range(1, 65536)");
    }
    const portBuf = port2bytes(port);
    return concat4([buf, portBuf], buf.length + portBuf.length);
  }
  function bytes2onion(buf) {
    const addrBytes = buf.subarray(0, buf.length - 2);
    const portBytes = buf.subarray(buf.length - 2);
    const addr = toString9(addrBytes, "base32");
    const port = bytes2port(portBytes);
    return `${addr}:${port}`;
  }
  var ip4ToBytes = function(ip) {
    ip = ip.toString().trim();
    const bytes2 = new Uint8Array(4);
    ip.split(/\./g).forEach((byte, index) => {
      const value = parseInt(byte, 10);
      if (isNaN(value) || value < 0 || value > 255) {
        throw new InvalidMultiaddrError2("Invalid byte value in IP address");
      }
      bytes2[index] = value;
    });
    return bytes2;
  };
  var ip6ToBytes = function(ip) {
    let offset = 0;
    ip = ip.toString().trim();
    const sections = ip.split(":", 8);
    let i;
    for (i = 0; i < sections.length; i++) {
      const isv4 = isIPv4(sections[i]);
      let v4Buffer;
      if (isv4) {
        v4Buffer = ip4ToBytes(sections[i]);
        sections[i] = toString9(v4Buffer.subarray(0, 2), "base16");
      }
      if (v4Buffer != null && ++i < 8) {
        sections.splice(i, 0, toString9(v4Buffer.subarray(2, 4), "base16"));
      }
    }
    if (sections[0] === "") {
      while (sections.length < 8) {
        sections.unshift("0");
      }
    } else if (sections[sections.length - 1] === "") {
      while (sections.length < 8) {
        sections.push("0");
      }
    } else if (sections.length < 8) {
      for (i = 0; i < sections.length && sections[i] !== ""; i++) {
      }
      const argv = [i, 1];
      for (i = 9 - sections.length; i > 0; i--) {
        argv.push("0");
      }
      sections.splice.apply(sections, argv);
    }
    const bytes2 = new Uint8Array(offset + 16);
    for (i = 0; i < sections.length; i++) {
      if (sections[i] === "") {
        sections[i] = "0";
      }
      const word = parseInt(sections[i], 16);
      if (isNaN(word) || word < 0 || word > 65535) {
        throw new InvalidMultiaddrError2("Invalid byte value in IP address");
      }
      bytes2[offset++] = word >> 8 & 255;
      bytes2[offset++] = word & 255;
    }
    return bytes2;
  };
  var ip4ToString = function(buf) {
    if (buf.byteLength !== 4) {
      throw new InvalidMultiaddrError2("IPv4 address was incorrect length");
    }
    const result = [];
    for (let i = 0; i < buf.byteLength; i++) {
      result.push(buf[i]);
    }
    return result.join(".");
  };
  var ip6ToString = function(buf) {
    if (buf.byteLength !== 16) {
      throw new InvalidMultiaddrError2("IPv6 address was incorrect length");
    }
    const result = [];
    for (let i = 0; i < buf.byteLength; i += 2) {
      const byte1 = buf[i];
      const byte2 = buf[i + 1];
      const tuple = `${byte1.toString(16).padStart(2, "0")}${byte2.toString(16).padStart(2, "0")}`;
      result.push(tuple);
    }
    const ip = result.join(":");
    try {
      const url = new URL(`http://[${ip}]`);
      return url.hostname.substring(1, url.hostname.length - 1);
    } catch {
      throw new InvalidMultiaddrError2(`Invalid IPv6 address "${ip}"`);
    }
  };
  function ip6StringToValue(str) {
    try {
      const url = new URL(`http://[${str}]`);
      return url.hostname.substring(1, url.hostname.length - 1);
    } catch {
      throw new InvalidMultiaddrError2(`Invalid IPv6 address "${str}"`);
    }
  }
  var decoders2 = Object.values(bases5).map((c) => c.decoder);
  var anybaseDecoder = (function() {
    let acc = decoders2[0].or(decoders2[1]);
    decoders2.slice(2).forEach((d2) => acc = acc.or(d2));
    return acc;
  })();
  function mb2bytes(mbstr) {
    return anybaseDecoder.decode(mbstr);
  }
  function bytes2mb(base37) {
    return (buf) => {
      return base37.encoder.encode(buf);
    };
  }

  // ../node_modules/@multiformats/multiaddr/dist/src/validation.js
  function integer(value) {
    const int = parseInt(value);
    if (int.toString() !== value) {
      throw new ValidationError("Value must be an integer");
    }
  }
  function positive(value) {
    if (value < 0) {
      throw new ValidationError("Value must be a positive integer, or zero");
    }
  }
  function maxValue(max) {
    return (value) => {
      if (value > max) {
        throw new ValidationError(`Value must be smaller than or equal to ${max}`);
      }
    };
  }
  function validate(...funcs) {
    return (value) => {
      for (const fn of funcs) {
        fn(value);
      }
    };
  }
  var validatePort = validate(integer, positive, maxValue(65535));

  // ../node_modules/@multiformats/multiaddr/dist/src/registry.js
  var V = -1;
  var Registry = class {
    protocolsByCode = /* @__PURE__ */ new Map();
    protocolsByName = /* @__PURE__ */ new Map();
    getProtocol(key) {
      let codec;
      if (typeof key === "string") {
        codec = this.protocolsByName.get(key);
      } else {
        codec = this.protocolsByCode.get(key);
      }
      if (codec == null) {
        throw new UnknownProtocolError(`Protocol ${key} was unknown`);
      }
      return codec;
    }
    addProtocol(codec) {
      this.protocolsByCode.set(codec.code, codec);
      this.protocolsByName.set(codec.name, codec);
      codec.aliases?.forEach((alias) => {
        this.protocolsByName.set(alias, codec);
      });
    }
    removeProtocol(code18) {
      const codec = this.protocolsByCode.get(code18);
      if (codec == null) {
        return;
      }
      this.protocolsByCode.delete(codec.code);
      this.protocolsByName.delete(codec.name);
      codec.aliases?.forEach((alias) => {
        this.protocolsByName.delete(alias);
      });
    }
  };
  var registry = new Registry();
  var codecs = [{
    code: CODE_IP4,
    name: "ip4",
    size: 32,
    valueToBytes: ip4ToBytes,
    bytesToValue: ip4ToString,
    validate: (value) => {
      if (!isIPv4(value)) {
        throw new ValidationError(`Invalid IPv4 address "${value}"`);
      }
    }
  }, {
    code: CODE_TCP,
    name: "tcp",
    size: 16,
    valueToBytes: port2bytes,
    bytesToValue: bytes2port,
    validate: validatePort
  }, {
    code: CODE_UDP,
    name: "udp",
    size: 16,
    valueToBytes: port2bytes,
    bytesToValue: bytes2port,
    validate: validatePort
  }, {
    code: CODE_DCCP,
    name: "dccp",
    size: 16,
    valueToBytes: port2bytes,
    bytesToValue: bytes2port,
    validate: validatePort
  }, {
    code: CODE_IP6,
    name: "ip6",
    size: 128,
    valueToBytes: ip6ToBytes,
    bytesToValue: ip6ToString,
    stringToValue: ip6StringToValue,
    validate: (value) => {
      if (!isIPv6(value)) {
        throw new ValidationError(`Invalid IPv6 address "${value}"`);
      }
    }
  }, {
    code: CODE_IP6ZONE,
    name: "ip6zone",
    size: V
  }, {
    code: CODE_IPCIDR,
    name: "ipcidr",
    size: 8,
    bytesToValue: bytesToString("base10"),
    valueToBytes: stringToBytes("base10")
  }, {
    code: CODE_DNS,
    name: "dns",
    size: V,
    resolvable: true
  }, {
    code: CODE_DNS4,
    name: "dns4",
    size: V,
    resolvable: true
  }, {
    code: CODE_DNS6,
    name: "dns6",
    size: V,
    resolvable: true
  }, {
    code: CODE_DNSADDR,
    name: "dnsaddr",
    size: V,
    resolvable: true
  }, {
    code: CODE_SCTP,
    name: "sctp",
    size: 16,
    valueToBytes: port2bytes,
    bytesToValue: bytes2port,
    validate: validatePort
  }, {
    code: CODE_UDT,
    name: "udt"
  }, {
    code: CODE_UTP,
    name: "utp"
  }, {
    code: CODE_UNIX,
    name: "unix",
    size: V,
    path: true,
    stringToValue: (str) => decodeURIComponent(str),
    valueToString: (val) => encodeURIComponent(val)
  }, {
    code: CODE_P2P,
    name: "p2p",
    aliases: ["ipfs"],
    size: V,
    bytesToValue: bytesToString("base58btc"),
    valueToBytes: (val) => {
      if (val.startsWith("Q") || val.startsWith("1")) {
        return stringToBytes("base58btc")(val);
      }
      return CID5.parse(val).multihash.bytes;
    }
  }, {
    code: CODE_ONION,
    name: "onion",
    size: 96,
    bytesToValue: bytes2onion,
    valueToBytes: onion2bytes
  }, {
    code: CODE_ONION3,
    name: "onion3",
    size: 296,
    bytesToValue: bytes2onion,
    valueToBytes: onion32bytes
  }, {
    code: CODE_GARLIC64,
    name: "garlic64",
    size: V
  }, {
    code: CODE_GARLIC32,
    name: "garlic32",
    size: V
  }, {
    code: CODE_TLS,
    name: "tls"
  }, {
    code: CODE_SNI,
    name: "sni",
    size: V
  }, {
    code: CODE_NOISE,
    name: "noise"
  }, {
    code: CODE_QUIC,
    name: "quic"
  }, {
    code: CODE_QUIC_V1,
    name: "quic-v1"
  }, {
    code: CODE_WEBTRANSPORT,
    name: "webtransport"
  }, {
    code: CODE_CERTHASH,
    name: "certhash",
    size: V,
    bytesToValue: bytes2mb(base64url5),
    valueToBytes: mb2bytes
  }, {
    code: CODE_HTTP,
    name: "http"
  }, {
    code: CODE_HTTP_PATH,
    name: "http-path",
    size: V,
    stringToValue: (str) => `/${decodeURIComponent(str)}`,
    valueToString: (val) => encodeURIComponent(val.substring(1))
  }, {
    code: CODE_HTTPS,
    name: "https"
  }, {
    code: CODE_WS,
    name: "ws"
  }, {
    code: CODE_WSS,
    name: "wss"
  }, {
    code: CODE_P2P_WEBSOCKET_STAR,
    name: "p2p-websocket-star"
  }, {
    code: CODE_P2P_STARDUST,
    name: "p2p-stardust"
  }, {
    code: CODE_P2P_WEBRTC_STAR,
    name: "p2p-webrtc-star"
  }, {
    code: CODE_P2P_WEBRTC_DIRECT,
    name: "p2p-webrtc-direct"
  }, {
    code: CODE_WEBRTC_DIRECT,
    name: "webrtc-direct"
  }, {
    code: CODE_WEBRTC,
    name: "webrtc"
  }, {
    code: CODE_P2P_CIRCUIT,
    name: "p2p-circuit"
  }, {
    code: CODE_MEMORY,
    name: "memory",
    size: V
  }];
  codecs.forEach((codec) => {
    registry.addProtocol(codec);
  });

  // ../node_modules/@multiformats/multiaddr/dist/src/components.js
  function bytesToComponents(bytes2) {
    const components = [];
    let i = 0;
    while (i < bytes2.length) {
      const code18 = decode(bytes2, i);
      const codec = registry.getProtocol(code18);
      const codeLength = encodingLength(code18);
      const size = sizeForAddr(codec, bytes2, i + codeLength);
      let sizeLength = 0;
      if (size > 0 && codec.size === V) {
        sizeLength = encodingLength(size);
      }
      const componentLength = codeLength + sizeLength + size;
      const component = {
        code: code18,
        name: codec.name,
        bytes: bytes2.subarray(i, i + componentLength)
      };
      if (size > 0) {
        const valueOffset = i + codeLength + sizeLength;
        const valueBytes = bytes2.subarray(valueOffset, valueOffset + size);
        component.value = codec.bytesToValue?.(valueBytes) ?? toString9(valueBytes);
      }
      components.push(component);
      i += componentLength;
    }
    return components;
  }
  function componentsToBytes(components) {
    let length21 = 0;
    const bytes2 = [];
    for (const component of components) {
      if (component.bytes == null) {
        const codec = registry.getProtocol(component.code);
        const codecLength = encodingLength(component.code);
        let valueBytes;
        let valueLength = 0;
        let valueLengthLength = 0;
        if (component.value != null) {
          valueBytes = codec.valueToBytes?.(component.value) ?? fromString10(component.value);
          valueLength = valueBytes.byteLength;
          if (codec.size === V) {
            valueLengthLength = encodingLength(valueLength);
          }
        }
        const bytes3 = new Uint8Array(codecLength + valueLengthLength + valueLength);
        let offset = 0;
        encodeUint8Array(component.code, bytes3, offset);
        offset += codecLength;
        if (valueBytes != null) {
          if (codec.size === V) {
            encodeUint8Array(valueLength, bytes3, offset);
            offset += valueLengthLength;
          }
          bytes3.set(valueBytes, offset);
        }
        component.bytes = bytes3;
      }
      bytes2.push(component.bytes);
      length21 += component.bytes.byteLength;
    }
    return concat4(bytes2, length21);
  }
  function stringToComponents(string19) {
    if (string19.charAt(0) !== "/") {
      throw new InvalidMultiaddrError2('String multiaddr must start with "/"');
    }
    const components = [];
    let collecting = "protocol";
    let value = "";
    let protocol = "";
    for (let i = 1; i < string19.length; i++) {
      const char = string19.charAt(i);
      if (char !== "/") {
        if (collecting === "protocol") {
          protocol += string19.charAt(i);
        } else {
          value += string19.charAt(i);
        }
      }
      const ended = i === string19.length - 1;
      if (char === "/" || ended) {
        const codec = registry.getProtocol(protocol);
        if (collecting === "protocol") {
          if (codec.size == null || codec.size === 0) {
            components.push({
              code: codec.code,
              name: codec.name
            });
            value = "";
            protocol = "";
            collecting = "protocol";
            continue;
          } else if (ended) {
            throw new InvalidMultiaddrError2(`Component ${protocol} was missing value`);
          }
          collecting = "value";
        } else if (collecting === "value") {
          const component = {
            code: codec.code,
            name: codec.name
          };
          if (codec.size != null && codec.size !== 0) {
            if (value === "") {
              throw new InvalidMultiaddrError2(`Component ${protocol} was missing value`);
            }
            component.value = codec.stringToValue?.(value) ?? value;
          }
          components.push(component);
          value = "";
          protocol = "";
          collecting = "protocol";
        }
      }
    }
    if (protocol !== "" && value !== "") {
      throw new InvalidMultiaddrError2("Incomplete multiaddr");
    }
    return components;
  }
  function componentsToString(components) {
    return `/${components.flatMap((component) => {
      if (component.value == null) {
        return component.name;
      }
      const codec = registry.getProtocol(component.code);
      if (codec == null) {
        throw new InvalidMultiaddrError2(`Unknown protocol code ${component.code}`);
      }
      return [
        component.name,
        codec.valueToString?.(component.value) ?? component.value
      ];
    }).join("/")}`;
  }
  function sizeForAddr(codec, bytes2, offset) {
    if (codec.size == null || codec.size === 0) {
      return 0;
    }
    if (codec.size > 0) {
      return codec.size / 8;
    }
    return decode(bytes2, offset);
  }

  // ../node_modules/@multiformats/multiaddr/dist/src/multiaddr.js
  var inspect2 = Symbol.for("nodejs.util.inspect.custom");
  var symbol2 = Symbol.for("@multiformats/multiaddr");
  var DNS_CODES = [
    CODE_DNS,
    CODE_DNS4,
    CODE_DNS6,
    CODE_DNSADDR
  ];
  var NoAvailableResolverError = class extends Error {
    constructor(message2 = "No available resolver") {
      super(message2);
      this.name = "NoAvailableResolverError";
    }
  };
  function toComponents(addr) {
    if (addr == null) {
      addr = "/";
    }
    if (isMultiaddr(addr)) {
      return addr.getComponents();
    }
    if (addr instanceof Uint8Array) {
      return bytesToComponents(addr);
    }
    if (typeof addr === "string") {
      addr = addr.replace(/\/(\/)+/, "/").replace(/(\/)+$/, "");
      if (addr === "") {
        addr = "/";
      }
      return stringToComponents(addr);
    }
    if (Array.isArray(addr)) {
      return addr;
    }
    throw new InvalidMultiaddrError2("Must be a string, Uint8Array, Component[], or another Multiaddr");
  }
  var Multiaddr = class _Multiaddr {
    [symbol2] = true;
    #components;
    // cache string representation
    #string;
    // cache byte representation
    #bytes;
    constructor(addr = "/", options = {}) {
      this.#components = toComponents(addr);
      if (options.validate !== false) {
        validate2(this);
      }
    }
    get bytes() {
      if (this.#bytes == null) {
        this.#bytes = componentsToBytes(this.#components);
      }
      return this.#bytes;
    }
    toString() {
      if (this.#string == null) {
        this.#string = componentsToString(this.#components);
      }
      return this.#string;
    }
    toJSON() {
      return this.toString();
    }
    toOptions() {
      let family;
      let transport;
      let host;
      let port;
      let zone = "";
      for (const { code: code18, name: name19, value } of this.#components) {
        if (code18 === CODE_IP6ZONE) {
          zone = `%${value ?? ""}`;
        }
        if (DNS_CODES.includes(code18)) {
          transport = "tcp";
          port = 443;
          host = `${value ?? ""}${zone}`;
          family = code18 === CODE_DNS6 ? 6 : 4;
        }
        if (code18 === CODE_TCP || code18 === CODE_UDP) {
          transport = name19 === "tcp" ? "tcp" : "udp";
          port = parseInt(value ?? "");
        }
        if (code18 === CODE_IP4 || code18 === CODE_IP6) {
          transport = "tcp";
          host = `${value ?? ""}${zone}`;
          family = code18 === CODE_IP6 ? 6 : 4;
        }
      }
      if (family == null || transport == null || host == null || port == null) {
        throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
      }
      const opts = {
        family,
        host,
        transport,
        port
      };
      return opts;
    }
    getComponents() {
      return [
        ...this.#components
      ];
    }
    protos() {
      return this.#components.map(({ code: code18, value }) => {
        const codec = registry.getProtocol(code18);
        return {
          code: code18,
          size: codec.size ?? 0,
          name: codec.name,
          resolvable: Boolean(codec.resolvable),
          path: Boolean(codec.path)
        };
      });
    }
    protoCodes() {
      return this.#components.map(({ code: code18 }) => code18);
    }
    protoNames() {
      return this.#components.map(({ name: name19 }) => name19);
    }
    tuples() {
      return this.#components.map(({ code: code18, value }) => {
        if (value == null) {
          return [code18];
        }
        const codec = registry.getProtocol(code18);
        const output2 = [code18];
        if (value != null) {
          output2.push(codec.valueToBytes?.(value) ?? fromString10(value));
        }
        return output2;
      });
    }
    stringTuples() {
      return this.#components.map(({ code: code18, value }) => {
        if (value == null) {
          return [code18];
        }
        return [code18, value];
      });
    }
    encapsulate(addr) {
      const ma = new _Multiaddr(addr);
      return new _Multiaddr([
        ...this.#components,
        ...ma.getComponents()
      ], {
        validate: false
      });
    }
    decapsulate(addr) {
      const addrString = addr.toString();
      const s2 = this.toString();
      const i = s2.lastIndexOf(addrString);
      if (i < 0) {
        throw new InvalidParametersError2(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
      }
      return new _Multiaddr(s2.slice(0, i), {
        validate: false
      });
    }
    decapsulateCode(code18) {
      let index;
      for (let i = this.#components.length - 1; i > -1; i--) {
        if (this.#components[i].code === code18) {
          index = i;
          break;
        }
      }
      return new _Multiaddr(this.#components.slice(0, index), {
        validate: false
      });
    }
    getPeerId() {
      try {
        let tuples = [];
        this.#components.forEach(({ code: code18, value }) => {
          if (code18 === CODE_P2P) {
            tuples.push([code18, value]);
          }
          if (code18 === CODE_P2P_CIRCUIT) {
            tuples = [];
          }
        });
        const tuple = tuples.pop();
        if (tuple?.[1] != null) {
          const peerIdStr = tuple[1];
          if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
            return toString9(base58btc5.decode(`z${peerIdStr}`), "base58btc");
          }
          return toString9(CID5.parse(peerIdStr).multihash.bytes, "base58btc");
        }
        return null;
      } catch (e) {
        return null;
      }
    }
    getPath() {
      for (const component of this.#components) {
        const codec = registry.getProtocol(component.code);
        if (!codec.path) {
          continue;
        }
        return component.value ?? null;
      }
      return null;
    }
    equals(addr) {
      return equals14(this.bytes, addr.bytes);
    }
    async resolve(options) {
      const resolvableProto = this.protos().find((p) => p.resolvable);
      if (resolvableProto == null) {
        return [this];
      }
      const resolver = resolvers.get(resolvableProto.name);
      if (resolver == null) {
        throw new NoAvailableResolverError(`no available resolver for ${resolvableProto.name}`);
      }
      const result = await resolver(this, options);
      return result.map((str) => multiaddr(str));
    }
    nodeAddress() {
      const options = this.toOptions();
      if (options.transport !== "tcp" && options.transport !== "udp") {
        throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
      }
      return {
        family: options.family,
        address: options.host,
        port: options.port
      };
    }
    isThinWaistAddress() {
      if (this.#components.length !== 2) {
        return false;
      }
      if (this.#components[0].code !== CODE_IP4 && this.#components[0].code !== CODE_IP6) {
        return false;
      }
      if (this.#components[1].code !== CODE_TCP && this.#components[1].code !== CODE_UDP) {
        return false;
      }
      return true;
    }
    /**
     * Returns Multiaddr as a human-readable string
     * https://nodejs.org/api/util.html#utilinspectcustom
     *
     * @example
     * ```js
     * import { multiaddr } from '@multiformats/multiaddr'
     *
     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
     * ```
     */
    [inspect2]() {
      return `Multiaddr(${this.toString()})`;
    }
  };
  function validate2(addr) {
    addr.getComponents().forEach((component) => {
      const codec = registry.getProtocol(component.code);
      if (component.value == null) {
        return;
      }
      codec.validate?.(component.value);
    });
  }

  // ../node_modules/@chainsafe/netmask/dist/src/util.js
  function allFF(a, from39, to) {
    let i = 0;
    for (const e of a) {
      if (i < from39)
        continue;
      if (i > to)
        break;
      if (e !== 255)
        return false;
      i++;
    }
    return true;
  }
  function deepEqual(a, b, from39, to) {
    let i = 0;
    for (const e of a) {
      if (i < from39)
        continue;
      if (i > to)
        break;
      if (e !== b[i])
        return false;
      i++;
    }
    return true;
  }
  function ipToString(ip) {
    switch (ip.length) {
      case IPv4Len: {
        return ip.join(".");
      }
      case IPv6Len: {
        const result = [];
        for (let i = 0; i < ip.length; i++) {
          if (i % 2 === 0) {
            result.push(ip[i].toString(16).padStart(2, "0") + ip[i + 1].toString(16).padStart(2, "0"));
          }
        }
        return result.join(":");
      }
      default: {
        throw new Error("Invalid ip length");
      }
    }
  }
  function simpleMaskLength(mask) {
    let ones = 0;
    for (let [index, byte] of mask.entries()) {
      if (byte === 255) {
        ones += 8;
        continue;
      }
      while ((byte & 128) != 0) {
        ones++;
        byte = byte << 1;
      }
      if ((byte & 128) != 0) {
        return -1;
      }
      for (let i = index + 1; i < mask.length; i++) {
        if (mask[i] != 0) {
          return -1;
        }
      }
      break;
    }
    return ones;
  }
  function maskToHex(mask) {
    let hex = "0x";
    for (const byte of mask) {
      hex += (byte >> 4).toString(16) + (byte & 15).toString(16);
    }
    return hex;
  }

  // ../node_modules/@chainsafe/netmask/dist/src/ip.js
  var IPv4Len = 4;
  var IPv6Len = 16;
  var maxIPv6Octet = parseInt("0xFFFF", 16);
  var ipv4Prefix = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    255,
    255
  ]);
  function maskIp(ip, mask) {
    if (mask.length === IPv6Len && ip.length === IPv4Len && allFF(mask, 0, 11)) {
      mask = mask.slice(12);
    }
    if (mask.length === IPv4Len && ip.length === IPv6Len && deepEqual(ip, ipv4Prefix, 0, 11)) {
      ip = ip.slice(12);
    }
    const n = ip.length;
    if (n != mask.length) {
      throw new Error("Failed to mask ip");
    }
    const out = new Uint8Array(n);
    for (let i = 0; i < n; i++) {
      out[i] = ip[i] & mask[i];
    }
    return out;
  }
  function containsIp(net, ip) {
    if (typeof ip === "string") {
      ip = parseIP(ip);
    }
    if (ip == null)
      throw new Error("Invalid ip");
    if (ip.length !== net.network.length) {
      return false;
    }
    for (let i = 0; i < ip.length; i++) {
      if ((net.network[i] & net.mask[i]) !== (ip[i] & net.mask[i])) {
        return false;
      }
    }
    return true;
  }

  // ../node_modules/@chainsafe/netmask/dist/src/cidr.js
  function parseCidr(s2) {
    const [address, maskString] = s2.split("/");
    if (!address || !maskString)
      throw new Error("Failed to parse given CIDR: " + s2);
    let ipLength = IPv4Len;
    let ip = parseIPv4(address);
    if (ip == null) {
      ipLength = IPv6Len;
      ip = parseIPv6(address);
      if (ip == null)
        throw new Error("Failed to parse given CIDR: " + s2);
    }
    const m2 = parseInt(maskString, 10);
    if (Number.isNaN(m2) || String(m2).length !== maskString.length || m2 < 0 || m2 > ipLength * 8) {
      throw new Error("Failed to parse given CIDR: " + s2);
    }
    const mask = cidrMask(m2, 8 * ipLength);
    return {
      network: maskIp(ip, mask),
      mask
    };
  }
  function cidrMask(ones, bits) {
    if (bits !== 8 * IPv4Len && bits !== 8 * IPv6Len)
      throw new Error("Invalid CIDR mask");
    if (ones < 0 || ones > bits)
      throw new Error("Invalid CIDR mask");
    const l = bits / 8;
    const m2 = new Uint8Array(l);
    for (let i = 0; i < l; i++) {
      if (ones >= 8) {
        m2[i] = 255;
        ones -= 8;
        continue;
      }
      m2[i] = 255 - (255 >> ones);
      ones = 0;
    }
    return m2;
  }

  // ../node_modules/@chainsafe/netmask/dist/src/ipnet.js
  var IpNet = class {
    /**
     *
     * @param ipOrCidr either network ip or full cidr address
     * @param mask in case ipOrCidr is network this can be either mask in decimal format or as ip address
     */
    constructor(ipOrCidr, mask) {
      if (mask == null) {
        ({ network: this.network, mask: this.mask } = parseCidr(ipOrCidr));
      } else {
        const ipResult = parseIP(ipOrCidr);
        if (ipResult == null) {
          throw new Error("Failed to parse network");
        }
        mask = String(mask);
        const m2 = parseInt(mask, 10);
        if (Number.isNaN(m2) || String(m2).length !== mask.length || m2 < 0 || m2 > ipResult.length * 8) {
          const maskResult = parseIP(mask);
          if (maskResult == null) {
            throw new Error("Failed to parse mask");
          }
          this.mask = maskResult;
        } else {
          this.mask = cidrMask(m2, 8 * ipResult.length);
        }
        this.network = maskIp(ipResult, this.mask);
      }
    }
    /**
     * Checks if netmask contains ip address
     * @param ip
     * @returns
     */
    contains(ip) {
      return containsIp({ network: this.network, mask: this.mask }, ip);
    }
    /**Serializes back to string format */
    toString() {
      const l = simpleMaskLength(this.mask);
      const mask = l !== -1 ? String(l) : maskToHex(this.mask);
      return ipToString(this.network) + "/" + mask;
    }
  };

  // ../node_modules/@chainsafe/netmask/dist/src/index.js
  function cidrContains(cidr, ip) {
    const ipnet = new IpNet(cidr);
    return ipnet.contains(ip);
  }

  // ../node_modules/@multiformats/multiaddr/dist/src/convert.js
  function convertToIpNet(multiaddr2) {
    let mask;
    let addr;
    multiaddr2.getComponents().forEach((component) => {
      if (component.name === "ip4" || component.name === "ip6") {
        addr = component.value;
      }
      if (component.name === "ipcidr") {
        mask = component.value;
      }
    });
    if (mask == null || addr == null) {
      throw new Error("Invalid multiaddr");
    }
    return new IpNet(addr, mask);
  }
  function convertToString(proto, buf) {
    const protocol = registry.getProtocol(proto);
    return protocol.bytesToValue?.(buf) ?? toString9(buf, "base16");
  }
  function convertToBytes(proto, str) {
    const protocol = registry.getProtocol(proto);
    return protocol.valueToBytes?.(str) ?? fromString10(str, "base16");
  }

  // ../node_modules/@multiformats/multiaddr/dist/src/index.js
  var resolvers = /* @__PURE__ */ new Map();
  function isMultiaddr(value) {
    return Boolean(value?.[symbol2]);
  }
  function multiaddr(addr) {
    return new Multiaddr(addr);
  }
  function protocols(proto) {
    const codec = registry.getProtocol(proto);
    return {
      code: codec.code,
      size: codec.size ?? 0,
      name: codec.name,
      resolvable: Boolean(codec.resolvable),
      path: Boolean(codec.path)
    };
  }

  // ../node_modules/@waku/core/dist/lib/connection_manager/utils.js
  var getPeerPing = (peer) => {
    if (!peer) {
      return -1;
    }
    try {
      const bytes2 = peer.metadata.get("ping");
      if (!bytes2) {
        return -1;
      }
      return Number(bytesToUtf8(bytes2));
    } catch (e) {
      return -1;
    }
  };
  var mapToPeerIdOrMultiaddr = (input) => {
    return isPeerId(input) ? input : multiaddr(input);
  };
  var mapToPeerId = (input) => {
    return isPeerId(input) ? input : peerIdFromString(multiaddr(input).getPeerId());
  };

  // ../node_modules/@waku/core/dist/lib/connection_manager/connection_manager.js
  var log10 = new Logger("connection-manager");
  var DEFAULT_MAX_BOOTSTRAP_PEERS_ALLOWED = 3;
  var DEFAULT_PING_KEEP_ALIVE_SEC = 5 * 60;
  var DEFAULT_RELAY_KEEP_ALIVE_SEC = 5 * 60;
  var DEFAULT_ENABLE_AUTO_RECOVERY = true;
  var DEFAULT_MAX_CONNECTIONS = 10;
  var DEFAULT_MAX_DIALING_PEERS = 3;
  var DEFAULT_FAILED_DIAL_COOLDOWN_SEC = 60;
  var DEFAULT_DIAL_COOLDOWN_SEC = 10;
  var ConnectionManager = class {
    keepAliveManager;
    discoveryDialer;
    dialer;
    shardReader;
    networkMonitor;
    connectionLimiter;
    options;
    libp2p;
    constructor(options) {
      this.libp2p = options.libp2p;
      this.options = {
        maxBootstrapPeers: DEFAULT_MAX_BOOTSTRAP_PEERS_ALLOWED,
        maxConnections: DEFAULT_MAX_CONNECTIONS,
        pingKeepAlive: DEFAULT_PING_KEEP_ALIVE_SEC,
        relayKeepAlive: DEFAULT_RELAY_KEEP_ALIVE_SEC,
        enableAutoRecovery: DEFAULT_ENABLE_AUTO_RECOVERY,
        maxDialingPeers: DEFAULT_MAX_DIALING_PEERS,
        failedDialCooldown: DEFAULT_FAILED_DIAL_COOLDOWN_SEC,
        dialCooldown: DEFAULT_DIAL_COOLDOWN_SEC,
        ...options.config
      };
      this.keepAliveManager = new KeepAliveManager({
        relay: options.relay,
        libp2p: options.libp2p,
        networkConfig: options.networkConfig,
        options: {
          pingKeepAlive: this.options.pingKeepAlive,
          relayKeepAlive: this.options.relayKeepAlive
        }
      });
      this.shardReader = new ShardReader({
        libp2p: options.libp2p,
        networkConfig: options.networkConfig
      });
      this.dialer = new Dialer({
        libp2p: options.libp2p,
        shardReader: this.shardReader,
        options: this.options
      });
      this.discoveryDialer = new DiscoveryDialer({
        libp2p: options.libp2p,
        dialer: this.dialer
      });
      this.networkMonitor = new NetworkMonitor({
        libp2p: options.libp2p,
        events: options.events
      });
      this.connectionLimiter = new ConnectionLimiter({
        libp2p: options.libp2p,
        events: options.events,
        networkMonitor: this.networkMonitor,
        dialer: this.dialer,
        options: this.options
      });
    }
    start() {
      this.dialer.start();
      this.networkMonitor.start();
      this.discoveryDialer.start();
      this.keepAliveManager.start();
      this.connectionLimiter.start();
    }
    stop() {
      this.dialer.stop();
      this.networkMonitor.stop();
      this.discoveryDialer.stop();
      this.keepAliveManager.stop();
      this.connectionLimiter.stop();
    }
    isConnected() {
      return this.networkMonitor.isConnected();
    }
    async dial(peer, protocolCodecs) {
      const ma = mapToPeerIdOrMultiaddr(peer);
      log10.info(`Dialing peer ${ma.toString()} with protocols ${protocolCodecs}`);
      const stream = await this.libp2p.dialProtocol(ma, protocolCodecs);
      log10.info(`Dialed peer ${ma.toString()} with protocols ${protocolCodecs}`);
      return stream;
    }
    async hangUp(peer) {
      const peerId2 = mapToPeerId(peer);
      try {
        log10.info(`Dropping connection with peer ${peerId2.toString()}`);
        await this.libp2p.hangUp(peerId2);
        log10.info(`Dropped connection with peer ${peerId2.toString()}`);
        return true;
      } catch (error) {
        log10.error(`Error dropping connection with peer ${peerId2.toString()} - ${error}`);
        return false;
      }
    }
    async getConnectedPeers(codec) {
      const peerIDs = this.libp2p.getPeers();
      log10.info(`Getting connected peers for codec ${codec}`);
      if (peerIDs.length === 0) {
        log10.info(`No connected peers`);
        return [];
      }
      const peers = await Promise.all(peerIDs.map(async (id) => {
        try {
          return await this.libp2p.peerStore.get(id);
        } catch (e) {
          return null;
        }
      }));
      const result = peers.filter((p) => !!p).filter((p) => codec ? p.protocols.includes(codec) : true).sort((left, right) => getPeerPing(left) - getPeerPing(right));
      log10.info(`Found ${result.length} connected peers for codec ${codec}`);
      return result;
    }
    async hasShardInfo(peerId2) {
      return this.shardReader.hasShardInfo(peerId2);
    }
    async isPeerOnTopic(peerId2, pubsubTopic) {
      return this.shardReader.isPeerOnTopic(peerId2, pubsubTopic);
    }
    async isPeerOnShard(peerId2, shardId) {
      return this.shardReader.isPeerOnShard(peerId2, shardId);
    }
  };

  // ../node_modules/@waku/core/dist/lib/metadata/metadata.js
  var log11 = new Logger("metadata");
  var MetadataCodec = "/vac/waku/metadata/1.0.0";
  var Metadata = class {
    clusterId;
    streamManager;
    libp2pComponents;
    handshakesConfirmed = /* @__PURE__ */ new Map();
    multicodec = MetadataCodec;
    constructor(clusterId, libp2p) {
      this.clusterId = clusterId;
      this.streamManager = new StreamManager(MetadataCodec, libp2p);
      this.libp2pComponents = libp2p;
      void libp2p.registrar.handle(MetadataCodec, (streamData) => {
        void this.onRequest(streamData);
      });
    }
    /**
     * Make a metadata query to a peer
     */
    async query(peerId2) {
      const request2 = metadata_exports.WakuMetadataRequest.encode({
        clusterId: this.clusterId,
        shards: []
        // Only services node need to provide shards
      });
      const peer = await this.libp2pComponents.peerStore.get(peerId2);
      if (!peer) {
        return {
          shardInfo: null,
          error: ProtocolError.NO_PEER_AVAILABLE
        };
      }
      const stream = await this.streamManager.getStream(peerId2);
      if (!stream) {
        log11.error(`Failed to get a stream for remote peer:${peerId2.toString()}`);
        return {
          shardInfo: null,
          error: ProtocolError.NO_STREAM_AVAILABLE
        };
      }
      const encodedResponse = await pipe([request2], encode10, stream, decode12, async (source) => await src_default(source));
      const { error, shardInfo } = this.decodeMetadataResponse(encodedResponse);
      if (error) {
        return {
          shardInfo: null,
          error
        };
      }
      await this.savePeerShardInfo(peerId2, shardInfo);
      return {
        shardInfo,
        error: null
      };
    }
    async confirmOrAttemptHandshake(peerId2) {
      const shardInfo = this.handshakesConfirmed.get(peerId2.toString());
      if (shardInfo) {
        return {
          shardInfo,
          error: null
        };
      }
      return await this.query(peerId2);
    }
    /**
     * Handle an incoming metadata request
     */
    async onRequest(streamData) {
      try {
        const { stream, connection } = streamData;
        const encodedShardInfo = metadata_exports.WakuMetadataResponse.encode({
          clusterId: this.clusterId,
          shards: []
          // Only service nodes need to provide shards
        });
        const encodedResponse = await pipe([encodedShardInfo], encode10, stream, decode12, async (source) => await src_default(source));
        const { error, shardInfo } = this.decodeMetadataResponse(encodedResponse);
        if (error) {
          return;
        }
        await this.savePeerShardInfo(connection.remotePeer, shardInfo);
      } catch (error) {
        log11.error("Error handling metadata request", error);
      }
    }
    decodeMetadataResponse(encodedResponse) {
      const bytes2 = new Uint8ArrayList();
      encodedResponse.forEach((chunk) => {
        bytes2.append(chunk);
      });
      const response = metadata_exports.WakuMetadataResponse.decode(bytes2);
      if (!response) {
        log11.error("Error decoding metadata response");
        return {
          shardInfo: null,
          error: ProtocolError.DECODE_FAILED
        };
      }
      return {
        shardInfo: response,
        error: null
      };
    }
    async savePeerShardInfo(peerId2, shardInfo) {
      await this.libp2pComponents.peerStore.merge(peerId2, {
        metadata: {
          shardInfo: encodeRelayShard(shardInfo)
        }
      });
      this.handshakesConfirmed.set(peerId2.toString(), shardInfo);
    }
  };
  function wakuMetadata(clusterId) {
    return (components) => new Metadata(clusterId, components);
  }

  // ../node_modules/@waku/core/dist/lib/message_hash/message_hash.js
  function messageHash(pubsubTopic, message2) {
    const pubsubTopicBytes = utf8ToBytes2(pubsubTopic);
    const contentTopicBytes = utf8ToBytes2(message2.contentTopic);
    const timestampBytes = tryConvertTimestampToBytes(message2.timestamp);
    const bytes2 = concat([
      pubsubTopicBytes,
      message2.payload,
      contentTopicBytes,
      message2.meta,
      timestampBytes
    ].filter(isDefined));
    return sha2562(bytes2);
  }
  function tryConvertTimestampToBytes(timestamp) {
    if (!timestamp) {
      return;
    }
    let bigIntTimestamp;
    if (typeof timestamp === "bigint") {
      bigIntTimestamp = timestamp;
    } else {
      bigIntTimestamp = BigInt(timestamp.valueOf()) * 1000000n;
    }
    return numberToBytes(bigIntTimestamp);
  }
  function messageHashStr(pubsubTopic, message2) {
    const hash2 = messageHash(pubsubTopic, message2);
    const hashStr = bytesToHex(hash2);
    return hashStr;
  }

  // ../node_modules/@waku/sdk/dist/peer_manager/peer_manager.js
  var log12 = new Logger("peer-manager");
  var DEFAULT_NUM_PEERS_TO_USE = 2;
  var PeerManagerEventNames;
  (function(PeerManagerEventNames2) {
    PeerManagerEventNames2["Connect"] = "filter:connect";
    PeerManagerEventNames2["Disconnect"] = "filter:disconnect";
  })(PeerManagerEventNames || (PeerManagerEventNames = {}));
  var PeerManager = class {
    events = new TypedEventEmitter();
    numPeersToUse;
    libp2p;
    connectionManager;
    lockedPeers = /* @__PURE__ */ new Set();
    unlockedPeers = /* @__PURE__ */ new Map();
    constructor(params) {
      this.onConnected = this.onConnected.bind(this);
      this.onDisconnected = this.onDisconnected.bind(this);
      this.numPeersToUse = params?.config?.numPeersToUse || DEFAULT_NUM_PEERS_TO_USE;
      this.libp2p = params.libp2p;
      this.connectionManager = params.connectionManager;
    }
    start() {
      this.libp2p.addEventListener("peer:identify", this.onConnected);
      this.libp2p.addEventListener("peer:disconnect", this.onDisconnected);
    }
    stop() {
      this.libp2p.removeEventListener("peer:identify", this.onConnected);
      this.libp2p.removeEventListener("peer:disconnect", this.onDisconnected);
    }
    async getPeers(params) {
      log12.info(`Getting peers for protocol: ${params.protocol}, pubsubTopic: ${params.pubsubTopic}`);
      const connectedPeers2 = await this.connectionManager.getConnectedPeers();
      log12.info(`Found ${connectedPeers2.length} connected peers`);
      let results = [];
      for (const peer of connectedPeers2) {
        const hasProtocol = this.hasPeerProtocol(peer, params.protocol);
        const hasSamePubsub = await this.connectionManager.isPeerOnTopic(peer.id, params.pubsubTopic);
        const isPeerAvailableForUse = this.isPeerAvailableForUse(peer.id);
        if (hasProtocol && hasSamePubsub && isPeerAvailableForUse) {
          results.push(peer);
          log12.info(`Peer ${peer.id} qualifies for protocol ${params.protocol}`);
        }
      }
      const lockedPeers = results.filter((p) => this.isPeerLocked(p.id));
      log12.info(`Found ${lockedPeers.length} locked peers out of ${results.length} qualifying peers`);
      if (lockedPeers.length >= this.numPeersToUse) {
        const selectedPeers = lockedPeers.slice(0, this.numPeersToUse).map((p) => p.id);
        log12.info(`Using ${selectedPeers.length} locked peers: ${selectedPeers.map((p) => p.toString())}`);
        return selectedPeers;
      }
      const notLockedPeers = results.filter((p) => !this.isPeerLocked(p.id));
      log12.info(`Found ${notLockedPeers.length} unlocked peers, need ${this.numPeersToUse - lockedPeers.length} more`);
      results = [...lockedPeers, ...notLockedPeers].slice(0, this.numPeersToUse).map((p) => {
        this.lockPeer(p.id);
        return p;
      });
      const finalPeers = results.map((p) => p.id);
      log12.info(`Selected ${finalPeers.length} peers: ${finalPeers.map((p) => p.toString())}`);
      return finalPeers;
    }
    async renewPeer(id, params) {
      log12.info(`Renewing peer ${id} for protocol: ${params.protocol}, pubsubTopic: ${params.pubsubTopic}`);
      const connectedPeers2 = await this.connectionManager.getConnectedPeers();
      const renewedPeer = connectedPeers2.find((p) => p.id.equals(id));
      if (!renewedPeer) {
        log12.warn(`Cannot renew peer:${id}, no connection to the peer.`);
        return;
      }
      log12.info(`Found peer ${id} in connected peers, unlocking and getting new peers`);
      this.unlockPeer(renewedPeer.id);
      await this.getPeers(params);
    }
    async isPeerOnPubsub(id, pubsubTopic) {
      const hasShardInfo = await this.connectionManager.hasShardInfo(id);
      if (!hasShardInfo) {
        return true;
      }
      return this.connectionManager.isPeerOnTopic(id, pubsubTopic);
    }
    async onConnected(event) {
      const result = event.detail;
      const isFilterPeer = result.protocols.includes(this.matchProtocolToCodec(Protocols.Filter));
      if (isFilterPeer) {
        this.dispatchFilterPeerConnect(result.peerId);
      }
    }
    async onDisconnected(event) {
      const peerId2 = event.detail;
      try {
        const peer = await this.libp2p.peerStore.get(peerId2);
        const isFilterPeer = this.hasPeerProtocol(peer, Protocols.Filter);
        if (isFilterPeer) {
          this.dispatchFilterPeerDisconnect(peer.id);
        }
      } catch (error) {
        log12.error(`Failed to dispatch Filter disconnect event:${error}`);
      }
    }
    hasPeerProtocol(peer, protocol) {
      return peer.protocols.includes(this.matchProtocolToCodec(protocol));
    }
    lockPeer(id) {
      log12.info(`Locking peer ${id}`);
      this.lockedPeers.add(id.toString());
      this.libp2p.getConnections().filter((c) => c.remotePeer.equals(id)).forEach((c) => c.tags.push(CONNECTION_LOCKED_TAG));
      this.unlockedPeers.delete(id.toString());
    }
    isPeerLocked(id) {
      return this.lockedPeers.has(id.toString());
    }
    unlockPeer(id) {
      log12.info(`Unlocking peer ${id}`);
      this.lockedPeers.delete(id.toString());
      this.libp2p.getConnections().filter((c) => c.remotePeer.equals(id)).forEach((c) => {
        c.tags = c.tags.filter((t) => t !== CONNECTION_LOCKED_TAG);
      });
      this.unlockedPeers.set(id.toString(), Date.now());
    }
    isPeerAvailableForUse(id) {
      const value = this.unlockedPeers.get(id.toString());
      if (!value) {
        return true;
      }
      const wasUnlocked = new Date(value).getTime();
      return Date.now() - wasUnlocked >= 1e4 ? true : false;
    }
    dispatchFilterPeerConnect(id) {
      this.events.dispatchEvent(new CustomEvent(PeerManagerEventNames.Connect, { detail: id }));
    }
    dispatchFilterPeerDisconnect(id) {
      this.events.dispatchEvent(new CustomEvent(PeerManagerEventNames.Disconnect, { detail: id }));
    }
    matchProtocolToCodec(protocol) {
      const protocolToCodec = {
        [Protocols.Filter]: FilterCodecs.SUBSCRIBE,
        [Protocols.LightPush]: LightPushCodec,
        [Protocols.Store]: StoreCodec,
        [Protocols.Relay]: ""
      };
      return protocolToCodec[protocol];
    }
  };

  // ../node_modules/@waku/sdk/dist/filter/utils.js
  var TTLSet = class {
    ttlMs;
    cleanupIntervalId = null;
    entryTimestamps = /* @__PURE__ */ new Map();
    /**
     * Creates a new CustomSet with TTL functionality.
     * @param ttlMs - The time-to-live in milliseconds for each entry.
     * @param cleanupIntervalMs - Optional interval between cleanup operations (default: 5000ms).
     */
    constructor(ttlMs, cleanupIntervalMs = 5e3) {
      this.ttlMs = ttlMs;
      this.startCleanupInterval(cleanupIntervalMs);
    }
    dispose() {
      if (this.cleanupIntervalId !== null) {
        clearInterval(this.cleanupIntervalId);
        this.cleanupIntervalId = null;
      }
      this.entryTimestamps.clear();
    }
    add(entry) {
      this.entryTimestamps.set(entry, Date.now());
      return this;
    }
    has(entry) {
      return this.entryTimestamps.has(entry);
    }
    startCleanupInterval(intervalMs) {
      this.cleanupIntervalId = setInterval(() => {
        this.removeExpiredEntries();
      }, intervalMs);
    }
    removeExpiredEntries() {
      const now = Date.now();
      for (const [entry, timestamp] of this.entryTimestamps.entries()) {
        if (now - timestamp > this.ttlMs) {
          this.entryTimestamps.delete(entry);
        }
      }
    }
  };

  // ../node_modules/@waku/sdk/dist/filter/subscription.js
  var log13 = new Logger("sdk:filter-subscription");
  var Subscription = class {
    pubsubTopic;
    protocol;
    peerManager;
    config;
    isStarted = false;
    inProgress = false;
    // Map and Set cannot reliably use PeerId type as a key
    peers = /* @__PURE__ */ new Map();
    peerFailures = /* @__PURE__ */ new Map();
    receivedMessages = new TTLSet(6e4);
    callbacks = /* @__PURE__ */ new Map();
    messageEmitter = new TypedEventEmitter();
    toSubscribeContentTopics = /* @__PURE__ */ new Set();
    toUnsubscribeContentTopics = /* @__PURE__ */ new Set();
    subscribeIntervalId = null;
    keepAliveIntervalId = null;
    get contentTopics() {
      const allTopics = Array.from(this.callbacks.keys()).map((k) => k.contentTopic);
      const uniqueTopics = new Set(allTopics).values();
      return Array.from(uniqueTopics);
    }
    constructor(params) {
      this.config = params.config;
      this.pubsubTopic = params.pubsubTopic;
      this.protocol = params.protocol;
      this.peerManager = params.peerManager;
      this.onPeerConnected = this.onPeerConnected.bind(this);
      this.onPeerDisconnected = this.onPeerDisconnected.bind(this);
    }
    start() {
      log13.info(`Starting subscription for pubsubTopic: ${this.pubsubTopic}`);
      if (this.isStarted || this.inProgress) {
        log13.info("Subscription already started or in progress, skipping start");
        return;
      }
      this.inProgress = true;
      void this.attemptSubscribe({
        useNewContentTopics: false
      });
      this.setupSubscriptionInterval();
      this.setupKeepAliveInterval();
      this.setupEventListeners();
      this.isStarted = true;
      this.inProgress = false;
      log13.info(`Subscription started for pubsubTopic: ${this.pubsubTopic}`);
    }
    stop() {
      log13.info(`Stopping subscription for pubsubTopic: ${this.pubsubTopic}`);
      if (!this.isStarted || this.inProgress) {
        log13.info("Subscription not started or stop in progress, skipping stop");
        return;
      }
      this.inProgress = true;
      this.disposeEventListeners();
      this.disposeIntervals();
      void this.disposePeers();
      this.disposeHandlers();
      this.receivedMessages.dispose();
      this.inProgress = false;
      this.isStarted = false;
      log13.info(`Subscription stopped for pubsubTopic: ${this.pubsubTopic}`);
    }
    isEmpty() {
      return this.callbacks.size === 0;
    }
    async add(decoder, callback) {
      const decoders4 = Array.isArray(decoder) ? decoder : [decoder];
      for (const decoder2 of decoders4) {
        this.addSingle(decoder2, callback);
      }
      return this.toSubscribeContentTopics.size > 0 ? await this.attemptSubscribe({ useNewContentTopics: true }) : true;
    }
    async remove(decoder) {
      const decoders4 = Array.isArray(decoder) ? decoder : [decoder];
      for (const decoder2 of decoders4) {
        this.removeSingle(decoder2);
      }
      return this.toUnsubscribeContentTopics.size > 0 ? await this.attemptUnsubscribe({ useNewContentTopics: true }) : true;
    }
    invoke(message2, _peerId) {
      if (this.isMessageReceived(message2)) {
        log13.info(`Skipping invoking callbacks for already received message: pubsubTopic:${this.pubsubTopic}, peerId:${_peerId.toString()}, contentTopic:${message2.contentTopic}`);
        return;
      }
      log13.info(`Invoking message for contentTopic: ${message2.contentTopic}`);
      this.messageEmitter.dispatchEvent(new CustomEvent(message2.contentTopic, {
        detail: message2
      }));
    }
    addSingle(decoder, callback) {
      log13.info(`Adding subscription for contentTopic: ${decoder.contentTopic}`);
      const isNewContentTopic = !this.contentTopics.includes(decoder.contentTopic);
      if (isNewContentTopic) {
        this.toSubscribeContentTopics.add(decoder.contentTopic);
      }
      if (this.callbacks.has(decoder)) {
        log13.warn(`Replacing callback associated associated with decoder with pubsubTopic:${decoder.pubsubTopic} and contentTopic:${decoder.contentTopic}`);
        const callback2 = this.callbacks.get(decoder);
        this.callbacks.delete(decoder);
        this.messageEmitter.removeEventListener(decoder.contentTopic, callback2);
      }
      const eventHandler = (event) => {
        void (async () => {
          try {
            const message2 = await decoder.fromProtoObj(decoder.pubsubTopic, event.detail);
            void callback(message2);
          } catch (err) {
            log13.error("Error decoding message", err);
          }
        })();
      };
      this.callbacks.set(decoder, eventHandler);
      this.messageEmitter.addEventListener(decoder.contentTopic, eventHandler);
      log13.info(`Subscription added for contentTopic: ${decoder.contentTopic}, isNewContentTopic: ${isNewContentTopic}`);
    }
    removeSingle(decoder) {
      log13.info(`Removing subscription for contentTopic: ${decoder.contentTopic}`);
      const callback = this.callbacks.get(decoder);
      if (!callback) {
        log13.warn(`No callback associated with decoder with pubsubTopic:${decoder.pubsubTopic} and contentTopic:${decoder.contentTopic}`);
      }
      this.callbacks.delete(decoder);
      this.messageEmitter.removeEventListener(decoder.contentTopic, callback);
      const isCompletelyRemoved = !this.contentTopics.includes(decoder.contentTopic);
      if (isCompletelyRemoved) {
        this.toUnsubscribeContentTopics.add(decoder.contentTopic);
      }
      log13.info(`Subscription removed for contentTopic: ${decoder.contentTopic}, isCompletelyRemoved: ${isCompletelyRemoved}`);
    }
    isMessageReceived(message2) {
      try {
        const messageHash2 = messageHashStr(this.pubsubTopic, message2);
        if (this.receivedMessages.has(messageHash2)) {
          return true;
        }
        this.receivedMessages.add(messageHash2);
      } catch (e) {
      }
      return false;
    }
    setupSubscriptionInterval() {
      const subscriptionRefreshIntervalMs = 1e3;
      log13.info(`Setting up subscription interval with period ${subscriptionRefreshIntervalMs}ms`);
      this.subscribeIntervalId = setInterval(() => {
        const run = async () => {
          if (this.toSubscribeContentTopics.size > 0) {
            log13.info(`Subscription interval: ${this.toSubscribeContentTopics.size} topics to subscribe`);
            void await this.attemptSubscribe({ useNewContentTopics: true });
          }
          if (this.toUnsubscribeContentTopics.size > 0) {
            log13.info(`Subscription interval: ${this.toUnsubscribeContentTopics.size} topics to unsubscribe`);
            void await this.attemptUnsubscribe({ useNewContentTopics: true });
          }
        };
        void run();
      }, subscriptionRefreshIntervalMs);
    }
    setupKeepAliveInterval() {
      log13.info(`Setting up keep-alive interval with period ${this.config.keepAliveIntervalMs}ms`);
      this.keepAliveIntervalId = setInterval(() => {
        const run = async () => {
          log13.info(`Keep-alive interval running for ${this.peers.size} peers`);
          let peersToReplace = await Promise.all(Array.from(this.peers.values()).map(async (peer) => {
            const response = await this.protocol.ping(peer);
            if (response.success) {
              log13.info(`Ping successful for peer: ${peer.toString()}`);
              this.peerFailures.set(peer.toString(), 0);
              return;
            }
            let failures = this.peerFailures.get(peer.toString()) || 0;
            failures += 1;
            this.peerFailures.set(peer.toString(), failures);
            log13.warn(`Ping failed for peer: ${peer.toString()}, failures: ${failures}/${this.config.pingsBeforePeerRenewed}`);
            if (failures < this.config.pingsBeforePeerRenewed) {
              return;
            }
            log13.info(`Peer ${peer.toString()} exceeded max failures (${this.config.pingsBeforePeerRenewed}), will be replaced`);
            return peer;
          }));
          peersToReplace = peersToReplace.filter((p) => !!p);
          await Promise.all(peersToReplace.map((p) => {
            this.peers.delete(p?.toString());
            this.peerFailures.delete(p?.toString());
            return this.requestUnsubscribe(p, this.contentTopics);
          }));
          if (peersToReplace.length > 0) {
            log13.info(`Replacing ${peersToReplace.length} failed peers`);
            void await this.attemptSubscribe({
              useNewContentTopics: false,
              useOnlyNewPeers: true
            });
          }
        };
        void run();
      }, this.config.keepAliveIntervalMs);
    }
    setupEventListeners() {
      this.peerManager.events.addEventListener(PeerManagerEventNames.Connect, this.onPeerConnected);
      this.peerManager.events.addEventListener(PeerManagerEventNames.Disconnect, this.onPeerDisconnected);
    }
    disposeIntervals() {
      if (this.subscribeIntervalId) {
        clearInterval(this.subscribeIntervalId);
      }
      if (this.keepAliveIntervalId) {
        clearInterval(this.keepAliveIntervalId);
      }
    }
    disposeHandlers() {
      for (const [decoder, handler] of this.callbacks.entries()) {
        this.messageEmitter.removeEventListener(decoder.contentTopic, handler);
      }
      this.callbacks.clear();
    }
    async disposePeers() {
      await this.attemptUnsubscribe({ useNewContentTopics: false });
      this.peers.clear();
      this.peerFailures = /* @__PURE__ */ new Map();
    }
    disposeEventListeners() {
      this.peerManager.events.removeEventListener(PeerManagerEventNames.Connect, this.onPeerConnected);
      this.peerManager.events.removeEventListener(PeerManagerEventNames.Disconnect, this.onPeerDisconnected);
    }
    async onPeerConnected(event) {
      const id = event.detail?.toString();
      log13.info(`Peer connected: ${id}`);
      const usablePeer = await this.peerManager.isPeerOnPubsub(event.detail, this.pubsubTopic);
      if (!usablePeer) {
        log13.info(`Peer ${id} doesn't support pubsubTopic:${this.pubsubTopic}`);
        return;
      }
      if (this.peers.has(id)) {
        log13.info(`Peer ${id} already subscribed, skipping`);
        return;
      }
      await this.attemptSubscribe({
        useNewContentTopics: false,
        useOnlyNewPeers: true
      });
    }
    async onPeerDisconnected(event) {
      const id = event.detail?.toString();
      log13.info(`Peer disconnected: ${id}`);
      const usablePeer = await this.peerManager.isPeerOnPubsub(event.detail, this.pubsubTopic);
      if (!usablePeer) {
        log13.info(`Peer ${id} doesn't support pubsubTopic:${this.pubsubTopic}`);
        return;
      }
      if (!this.peers.has(id)) {
        log13.info(`Disconnected peer ${id} not in use, ignoring`);
        return;
      }
      log13.info(`Active peer ${id} disconnected, removing from peers list`);
      this.peers.delete(id);
      void this.attemptSubscribe({
        useNewContentTopics: false,
        useOnlyNewPeers: true
      });
    }
    async attemptSubscribe(params) {
      const { useNewContentTopics, useOnlyNewPeers = false } = params;
      const contentTopics = useNewContentTopics ? Array.from(this.toSubscribeContentTopics) : this.contentTopics;
      log13.info(`Attempting to subscribe: useNewContentTopics=${useNewContentTopics}, useOnlyNewPeers=${useOnlyNewPeers}, contentTopics=${contentTopics.length}`);
      if (!contentTopics.length) {
        log13.warn("Requested content topics is an empty array, skipping");
        return false;
      }
      const prevPeers = new Set(this.peers.keys());
      const peersToAdd = await this.peerManager.getPeers({
        protocol: Protocols.Filter,
        pubsubTopic: this.pubsubTopic
      });
      for (const peer of peersToAdd) {
        if (this.peers.size >= this.config.numPeersToUse) {
          break;
        }
        this.peers.set(peer.toString(), peer);
      }
      const peersToUse = useOnlyNewPeers ? Array.from(this.peers.values()).filter((p) => !prevPeers.has(p.toString())) : Array.from(this.peers.values());
      log13.info(`Subscribing with ${peersToUse.length} peers for ${contentTopics.length} content topics`);
      if (useOnlyNewPeers && peersToUse.length === 0) {
        log13.warn(`Requested to use only new peers, but no peers found, skipping`);
        return false;
      }
      const results = await Promise.all(peersToUse.map((p) => this.requestSubscribe(p, contentTopics)));
      const successCount = results.filter((r) => r).length;
      log13.info(`Subscribe attempts completed: ${successCount}/${results.length} successful`);
      if (useNewContentTopics) {
        this.toSubscribeContentTopics = /* @__PURE__ */ new Set();
      }
      return results.some((v) => v);
    }
    async requestSubscribe(peerId2, contentTopics) {
      log13.info(`requestSubscribe: pubsubTopic:${this.pubsubTopic}	contentTopics:${contentTopics.join(",")}`);
      if (!contentTopics.length || !this.pubsubTopic) {
        log13.warn(`requestSubscribe: no contentTopics or pubsubTopic provided, not sending subscribe request`);
        return false;
      }
      const response = await this.protocol.subscribe(this.pubsubTopic, peerId2, contentTopics);
      if (response.failure) {
        log13.warn(`requestSubscribe: Failed to subscribe ${this.pubsubTopic} to ${peerId2.toString()} with error:${response.failure.error} for contentTopics:${contentTopics}`);
        return false;
      }
      log13.info(`requestSubscribe: Subscribed ${this.pubsubTopic} to ${peerId2.toString()} for contentTopics:${contentTopics}`);
      return true;
    }
    async attemptUnsubscribe(params) {
      const { useNewContentTopics } = params;
      const contentTopics = useNewContentTopics ? Array.from(this.toUnsubscribeContentTopics) : this.contentTopics;
      log13.info(`Attempting to unsubscribe: useNewContentTopics=${useNewContentTopics}, contentTopics=${contentTopics.length}`);
      if (!contentTopics.length) {
        log13.warn("Requested content topics is an empty array, skipping");
        return false;
      }
      const peersToUse = Array.from(this.peers.values());
      const result = await Promise.all(peersToUse.map((p) => this.requestUnsubscribe(p, useNewContentTopics ? contentTopics : void 0)));
      const successCount = result.filter((r) => r).length;
      log13.info(`Unsubscribe attempts completed: ${successCount}/${result.length} successful`);
      if (useNewContentTopics) {
        this.toUnsubscribeContentTopics = /* @__PURE__ */ new Set();
      }
      return result.some((v) => v);
    }
    async requestUnsubscribe(peerId2, contentTopics) {
      const response = contentTopics ? await this.protocol.unsubscribe(this.pubsubTopic, peerId2, contentTopics) : await this.protocol.unsubscribeAll(this.pubsubTopic, peerId2);
      if (response.failure) {
        log13.warn(`requestUnsubscribe: Failed to unsubscribe for pubsubTopic:${this.pubsubTopic} from peerId:${peerId2.toString()} with error:${response.failure?.error} for contentTopics:${contentTopics}`);
        return false;
      }
      log13.info(`requestUnsubscribe: Unsubscribed pubsubTopic:${this.pubsubTopic} from peerId:${peerId2.toString()} for contentTopics:${contentTopics}`);
      return true;
    }
  };

  // ../node_modules/@waku/sdk/dist/filter/filter.js
  var log14 = new Logger("sdk:filter");
  var Filter = class {
    protocol;
    peerManager;
    config;
    subscriptions = /* @__PURE__ */ new Map();
    constructor(params) {
      this.config = {
        numPeersToUse: 2,
        pingsBeforePeerRenewed: 3,
        keepAliveIntervalMs: 6e4,
        ...params.options
      };
      this.peerManager = params.peerManager;
      this.protocol = new FilterCore(this.onIncomingMessage.bind(this), params.libp2p);
    }
    get multicodec() {
      return this.protocol.multicodec;
    }
    unsubscribeAll() {
      for (const subscription of this.subscriptions.values()) {
        subscription.stop();
      }
      this.subscriptions.clear();
    }
    async subscribe(decoder, callback) {
      const decoders4 = Array.isArray(decoder) ? decoder : [decoder];
      if (decoders4.length === 0) {
        throw Error("Cannot subscribe with 0 decoders.");
      }
      const pubsubTopics = decoders4.map((v) => v.pubsubTopic);
      const singlePubsubTopic = pubsubTopics[0];
      const contentTopics = decoders4.map((v) => v.contentTopic);
      log14.info(`Subscribing to contentTopics: ${contentTopics}, pubsubTopic: ${singlePubsubTopic}`);
      this.throwIfTopicNotSame(pubsubTopics);
      let subscription = this.subscriptions.get(singlePubsubTopic);
      if (!subscription) {
        subscription = new Subscription({
          pubsubTopic: singlePubsubTopic,
          protocol: this.protocol,
          config: this.config,
          peerManager: this.peerManager
        });
        subscription.start();
      }
      const result = await subscription.add(decoders4, callback);
      this.subscriptions.set(singlePubsubTopic, subscription);
      log14.info(`Subscription ${result ? "successful" : "failed"} for content topic: ${contentTopics}`);
      return result;
    }
    async unsubscribe(decoder) {
      const decoders4 = Array.isArray(decoder) ? decoder : [decoder];
      if (decoders4.length === 0) {
        throw Error("Cannot unsubscribe with 0 decoders.");
      }
      const pubsubTopics = decoders4.map((v) => v.pubsubTopic);
      const singlePubsubTopic = pubsubTopics[0];
      const contentTopics = decoders4.map((v) => v.contentTopic);
      log14.info(`Unsubscribing from contentTopics: ${contentTopics}, pubsubTopic: ${singlePubsubTopic}`);
      this.throwIfTopicNotSame(pubsubTopics);
      const subscription = this.subscriptions.get(singlePubsubTopic);
      if (!subscription) {
        log14.warn("No subscriptions associated with the decoder.");
        return false;
      }
      const result = await subscription.remove(decoders4);
      if (subscription.isEmpty()) {
        log14.warn("Subscription has no decoders anymore, terminating it.");
        subscription.stop();
        this.subscriptions.delete(singlePubsubTopic);
      }
      log14.info(`Unsubscribing ${result ? "successful" : "failed"} for content topic: ${contentTopics}`);
      return result;
    }
    async onIncomingMessage(pubsubTopic, message2, peerId2) {
      log14.info(`Received message for pubsubTopic:${pubsubTopic}, contentTopic:${message2.contentTopic}, peerId:${peerId2.toString()}`);
      const subscription = this.subscriptions.get(pubsubTopic);
      if (!subscription) {
        log14.error(`No subscription locally registered for topic ${pubsubTopic}`);
        return;
      }
      subscription.invoke(message2, peerId2);
    }
    // Limiting to one pubsubTopic for simplicity reasons, we can enable subscription for more than one PubsubTopic at once later when requested
    throwIfTopicNotSame(pubsubTopics) {
      const first = pubsubTopics[0];
      const isSameTopic = pubsubTopics.every((t) => t === first);
      if (!isSameTopic) {
        throw Error(`Cannot subscribe to more than one pubsub topic at the same time, got pubsubTopics:${pubsubTopics}`);
      }
    }
  };

  // ../node_modules/@waku/sdk/dist/health_indicator/health_indicator.js
  var log15 = new Logger("health-indicator");
  var HealthIndicator = class {
    libp2p;
    events;
    value = HealthStatus.Unhealthy;
    constructor(params) {
      this.libp2p = params.libp2p;
      this.events = params.events;
      this.onPeerIdentify = this.onPeerIdentify.bind(this);
      this.onPeerDisconnected = this.onPeerDisconnected.bind(this);
    }
    start() {
      log15.info("start: adding listeners to libp2p");
      this.libp2p.addEventListener("peer:identify", this.onPeerIdentify);
      this.libp2p.addEventListener("peer:disconnect", this.onPeerDisconnected);
    }
    stop() {
      log15.info("stop: removing listeners to libp2p");
      this.libp2p.removeEventListener("peer:identify", this.onPeerIdentify);
      this.libp2p.removeEventListener("peer:disconnect", this.onPeerDisconnected);
    }
    toValue() {
      return this.value;
    }
    async onPeerDisconnected(_event) {
      log15.info(`onPeerDisconnected: received libp2p event`);
      const connections = this.libp2p.getConnections();
      if (connections.length > 0) {
        log15.info("onPeerDisconnected: has connections, ignoring");
      }
      log15.info(`onPeerDisconnected: node identified as ${HealthStatus.Unhealthy}`);
      this.updateAndDispatchHealthEvent(HealthStatus.Unhealthy);
    }
    async onPeerIdentify(_event) {
      log15.info(`onPeerIdentify: received libp2p event`);
      const connections = this.libp2p.getConnections();
      const peers = await Promise.all(connections.map(async (c) => {
        try {
          return await this.libp2p.peerStore.get(c.remotePeer);
        } catch (e) {
          return null;
        }
      }));
      const filterPeers = peers.filter((p) => p?.protocols.includes(FilterCodecs.SUBSCRIBE)).length;
      const lightPushPeers = peers.filter((p) => p?.protocols.includes(LightPushCodec)).length;
      let newValue;
      if (filterPeers === 0 || lightPushPeers === 0) {
        newValue = HealthStatus.Unhealthy;
      } else if (filterPeers >= 2 && lightPushPeers >= 2) {
        newValue = HealthStatus.SufficientlyHealthy;
      } else if (filterPeers === 1 && lightPushPeers === 1) {
        newValue = HealthStatus.MinimallyHealthy;
      } else {
        log15.error(`onPeerIdentify: unexpected state, cannot identify health status of the node: Filter:${filterPeers}; LightPush:${lightPushPeers}`);
        newValue = this.value;
      }
      log15.info(`onPeerIdentify: node identified as ${newValue}`);
      this.updateAndDispatchHealthEvent(newValue);
    }
    updateAndDispatchHealthEvent(newValue) {
      if (this.value !== newValue) {
        this.value = newValue;
        this.events.dispatchEvent(new CustomEvent("waku:health", {
          detail: this.value
        }));
      }
    }
  };

  // ../node_modules/@waku/sdk/dist/light_push/utils.js
  var shouldPeerBeChanged = (failure) => {
    const toBeChanged = failure === ProtocolError.REMOTE_PEER_REJECTED || failure === ProtocolError.NO_RESPONSE || failure === ProtocolError.RLN_PROOF_GENERATION || failure === ProtocolError.NO_PEER_AVAILABLE;
    if (toBeChanged) {
      return true;
    }
    return false;
  };
  var timeout = (timeout2) => {
    return new Promise((_, reject) => setTimeout(() => reject(new Error("Task timeout")), timeout2));
  };

  // ../node_modules/@waku/sdk/dist/light_push/retry_manager.js
  var MAX_CONCURRENT_TASKS = 5;
  var TASK_TIMEOUT_MS = 1e4;
  var log16 = new Logger("sdk:retry-manager");
  var RetryManager = class {
    intervalID = null;
    retryIntervalMs;
    inProgress = 0;
    queue = [];
    peerManager;
    constructor(config) {
      this.peerManager = config.peerManager;
      this.retryIntervalMs = config.retryIntervalMs || 1e3;
    }
    start() {
      this.intervalID = setInterval(() => {
        this.processQueue();
      }, this.retryIntervalMs);
    }
    stop() {
      if (this.intervalID) {
        clearInterval(this.intervalID);
        this.intervalID = null;
      }
    }
    push(callback, maxAttempts, routingInfo) {
      this.queue.push({
        maxAttempts,
        callback,
        routingInfo
      });
    }
    processQueue() {
      if (this.queue.length === 0) {
        return;
      }
      while (this.queue.length && this.inProgress < MAX_CONCURRENT_TASKS) {
        const task = this.queue.shift();
        if (task) {
          this.scheduleTask(task);
        }
      }
    }
    scheduleTask(task) {
      const delayedTask = async () => {
        return this.taskExecutor(task);
      };
      setTimeout(delayedTask, 100);
    }
    async taskExecutor(task) {
      if (task.maxAttempts <= 0) {
        log16.warn("scheduleTask: max attempts has reached, removing from queue");
        return;
      }
      const peerId2 = (await this.peerManager.getPeers({
        protocol: Protocols.LightPush,
        pubsubTopic: task.routingInfo.pubsubTopic
      }))[0];
      if (!peerId2) {
        log16.warn("scheduleTask: no peers, putting back to queue");
        this.queue.push({
          ...task,
          maxAttempts: task.maxAttempts - 1
        });
        return;
      }
      try {
        this.inProgress += 1;
        const response = await Promise.race([
          timeout(TASK_TIMEOUT_MS),
          task.callback(peerId2)
        ]);
        if (response?.failure) {
          throw Error(response.failure.error);
        }
        log16.info("scheduleTask: executed successfully");
        if (task.maxAttempts === 0) {
          log16.warn("scheduleTask: discarded a task due to limit of max attempts");
          return;
        }
        this.queue.push({
          ...task,
          maxAttempts: task.maxAttempts - 1
        });
      } catch (_err) {
        const error = _err;
        log16.error("scheduleTask: task execution failed with error:", error);
        if (shouldPeerBeChanged(error.message)) {
          await this.peerManager.renewPeer(peerId2, {
            protocol: Protocols.LightPush,
            pubsubTopic: task.routingInfo.pubsubTopic
          });
        }
        if (task.maxAttempts === 0) {
          log16.warn("scheduleTask: discarded a task due to limit of max attempts");
          return;
        }
        this.queue.push({
          ...task,
          maxAttempts: task.maxAttempts - 1
        });
      } finally {
        this.inProgress -= 1;
      }
    }
  };

  // ../node_modules/@waku/sdk/dist/light_push/light_push.js
  var log17 = new Logger("sdk:light-push");
  var DEFAULT_MAX_ATTEMPTS = 3;
  var DEFAULT_SEND_OPTIONS = {
    autoRetry: true,
    retryIntervalMs: 1e3,
    maxAttempts: DEFAULT_MAX_ATTEMPTS,
    numPeersToUse: 1
  };
  var LightPush = class {
    config;
    retryManager;
    peerManager;
    protocol;
    constructor(params) {
      this.config = {
        ...DEFAULT_SEND_OPTIONS,
        ...params.options || {}
      };
      this.peerManager = params.peerManager;
      this.protocol = new LightPushCore(params.libp2p);
      this.retryManager = new RetryManager({
        peerManager: params.peerManager,
        retryIntervalMs: this.config.retryIntervalMs
      });
    }
    get multicodec() {
      return this.protocol.multicodec;
    }
    start() {
      this.retryManager.start();
    }
    stop() {
      this.retryManager.stop();
    }
    async send(encoder3, message2, options = {}) {
      options = {
        ...this.config,
        ...options
      };
      const { pubsubTopic } = encoder3;
      log17.info("send: attempting to send a message to pubsubTopic:", pubsubTopic);
      const peerIds = await this.peerManager.getPeers({
        protocol: Protocols.LightPush,
        pubsubTopic: encoder3.pubsubTopic
      });
      const coreResults = peerIds?.length > 0 ? await Promise.all(peerIds.map((peerId2) => this.protocol.send(encoder3, message2, peerId2).catch((_e) => ({
        success: null,
        failure: {
          error: ProtocolError.GENERIC_FAIL
        }
      })))) : [];
      const results = coreResults.length ? {
        successes: coreResults.filter((v) => v.success).map((v) => v.success),
        failures: coreResults.filter((v) => v.failure).map((v) => v.failure)
      } : {
        successes: [],
        failures: [
          {
            error: ProtocolError.NO_PEER_AVAILABLE
          }
        ]
      };
      if (options.autoRetry && results.successes.length === 0) {
        const sendCallback = (peerId2) => this.protocol.send(encoder3, message2, peerId2);
        this.retryManager.push(sendCallback.bind(this), options.maxAttempts || DEFAULT_MAX_ATTEMPTS, encoder3.routingInfo);
      }
      return results;
    }
  };

  // ../node_modules/@waku/sdk/dist/store/store.js
  var log18 = new Logger("store-sdk");
  var Store = class {
    options;
    libp2p;
    peerManager;
    protocol;
    constructor(params) {
      this.options = params.options || {};
      this.peerManager = params.peerManager;
      this.libp2p = params.libp2p;
      this.protocol = new StoreCore(params.libp2p);
    }
    get multicodec() {
      return this.protocol.multicodec;
    }
    /**
     * Queries the Waku Store for historical messages using the provided decoders and options.
     * Returns an asynchronous generator that yields promises of decoded messages.
     *
     * @param decoders - An array of message decoders.
     * @param options - Optional query parameters.
     * @returns An asynchronous generator of promises of decoded messages.
     * @throws If no peers are available to query or if an error occurs during the query.
     */
    async *queryGenerator(decoders4, options) {
      const { decodersAsMap, queryOptions } = this.buildQueryParams(decoders4, options);
      for (const queryOption of queryOptions) {
        const peer = await this.getPeerToUse(queryOption.pubsubTopic);
        if (!peer) {
          log18.error("No peers available to query");
          throw new Error("No peers available to query");
        }
        log18.info(`Querying store with options: ${JSON.stringify(queryOption)}`);
        const responseGenerator = this.protocol.queryPerPage(queryOption, decodersAsMap, peer);
        for await (const messages2 of responseGenerator) {
          yield messages2;
        }
      }
    }
    /**
     * Queries the Waku Store for historical messages and processes them with the provided callback in order.
     *
     * @param decoders - An array of message decoders.
     * @param callback - A callback function to process each decoded message.
     * @param options - Optional query parameters.
     * @returns A promise that resolves when the query and message processing are completed.
     */
    async queryWithOrderedCallback(decoders4, callback, options) {
      log18.info("Querying store with ordered callback");
      for await (const promises of this.queryGenerator(decoders4, options)) {
        if (await this.processMessages(promises, callback))
          break;
      }
    }
    /**
     * Queries the Waku Store for historical messages and processes them with the provided callback using promises.
     *
     * @param decoders - An array of message decoders.
     * @param callback - A callback function to process each promise of a decoded message.
     * @param options - Optional query parameters.
     * @returns A promise that resolves when the query and message processing are completed.
     */
    async queryWithPromiseCallback(decoders4, callback, options) {
      log18.info("Querying store with promise callback");
      let abort = false;
      for await (const page of this.queryGenerator(decoders4, options)) {
        const _promises = page.map(async (msgPromise) => {
          if (abort)
            return;
          abort = Boolean(await callback(msgPromise));
        });
        await Promise.all(_promises);
        if (abort)
          break;
      }
    }
    /**
     * Processes messages based on the provided callback and options.
     *
     * @param messages - An array of promises of decoded messages.
     * @param callback - A callback function to process each decoded message.
     * @returns A promise that resolves to a boolean indicating whether the processing should abort.
     * @private
     */
    async processMessages(messages2, callback) {
      let abort = false;
      const messagesOrUndef = await Promise.all(messages2);
      const processedMessages = messagesOrUndef.filter(isDefined);
      await Promise.all(processedMessages.map(async (msg) => {
        if (msg && !abort) {
          abort = Boolean(await callback(msg));
        }
      }));
      return abort;
    }
    /**
     * Creates a cursor based on the provided decoded message.
     *
     * @param message - The decoded message.
     * @returns A StoreCursor representing the message.
     */
    createCursor(message2) {
      return messageHash(message2.pubsubTopic, message2);
    }
    /**
     * Validates the provided decoders and pubsub topic.
     *
     * @param decoders - An array of message decoders.
     * @returns An object containing the pubsub topic, content topics, and a map of decoders.
     * @throws If no decoders are provided, if multiple pubsub topics are provided, or if no decoders are found for the pubsub topic.
     * @private
     */
    validateDecodersAndPubsubTopic(decoders4) {
      if (decoders4.length === 0) {
        log18.error("No decoders provided");
        throw new Error("No decoders provided");
      }
      const uniquePubsubTopicsInQuery = Array.from(new Set(decoders4.map((decoder) => decoder.pubsubTopic)));
      if (uniquePubsubTopicsInQuery.length > 1) {
        log18.error("API does not support querying multiple pubsub topics at once");
        throw new Error("API does not support querying multiple pubsub topics at once");
      }
      const pubsubTopicForQuery = uniquePubsubTopicsInQuery[0];
      const decodersAsMap = /* @__PURE__ */ new Map();
      decoders4.forEach((dec) => {
        if (decodersAsMap.has(dec.contentTopic)) {
          log18.error("API does not support different decoder per content topic");
          throw new Error("API does not support different decoder per content topic");
        }
        decodersAsMap.set(dec.contentTopic, dec);
      });
      const contentTopics = decoders4.filter((decoder) => decoder.pubsubTopic === pubsubTopicForQuery).map((dec) => dec.contentTopic);
      if (contentTopics.length === 0) {
        log18.error(`No decoders found for topic ${pubsubTopicForQuery}`);
        throw new Error("No decoders found for topic " + pubsubTopicForQuery);
      }
      return {
        pubsubTopic: pubsubTopicForQuery,
        contentTopics,
        decodersAsMap
      };
    }
    async getPeerToUse(pubsubTopic) {
      const peers = await this.peerManager.getPeers({
        protocol: Protocols.Store,
        pubsubTopic
      });
      return this.options.peers ? await this.getPeerFromConfigurationOrFirst(peers, this.options.peers) : peers[0];
    }
    async getPeerFromConfigurationOrFirst(peerIds, configPeers) {
      const storeConfigPeers = configPeers.map(multiaddr);
      const missing = [];
      for (const peer of storeConfigPeers) {
        const matchedPeer = peerIds.find((id) => id.toString() === peer.getPeerId()?.toString());
        if (matchedPeer) {
          return matchedPeer;
        }
        missing.push(peer);
      }
      while (missing.length) {
        const toDial = missing.pop();
        if (!toDial) {
          return;
        }
        try {
          const conn = await this.libp2p.dial(toDial);
          if (conn) {
            return peerIdFromString(toDial.getPeerId());
          }
        } catch (e) {
          log18.warn(`Failed to dial peer from options.peers list for Store protocol. Peer:${toDial.getPeerId()}, error:${e}`);
        }
      }
      log18.warn(`Passed node to use for Store not found: ${configPeers.toString()}. Attempting to use first available peers.`);
      return peerIds[0];
    }
    buildQueryParams(decoders4, options) {
      const isHashQuery = options?.messageHashes && options.messageHashes.length > 0;
      let pubsubTopic;
      let contentTopics;
      let decodersAsMap;
      if (isHashQuery) {
        pubsubTopic = options.pubsubTopic || decoders4[0]?.pubsubTopic || "";
        contentTopics = [];
        decodersAsMap = /* @__PURE__ */ new Map();
        decoders4.forEach((dec) => {
          decodersAsMap.set(dec.contentTopic, dec);
        });
      } else {
        const validated = this.validateDecodersAndPubsubTopic(decoders4);
        pubsubTopic = validated.pubsubTopic;
        contentTopics = validated.contentTopics;
        decodersAsMap = validated.decodersAsMap;
      }
      const subTimeRanges = [];
      if (options?.timeStart && options?.timeEnd) {
        let start2 = options.timeStart;
        const end = options.timeEnd;
        while (end.getTime() - start2.getTime() > this.protocol.maxTimeLimit) {
          const subEnd = new Date(start2.getTime() + this.protocol.maxTimeLimit);
          subTimeRanges.push([start2, subEnd]);
          start2 = subEnd;
        }
        if (subTimeRanges.length === 0) {
          log18.info("Using single time range");
          subTimeRanges.push([start2, end]);
        }
      }
      if (subTimeRanges.length === 0) {
        log18.info("No sub time ranges");
        return {
          decodersAsMap,
          queryOptions: [
            {
              pubsubTopic,
              contentTopics,
              includeData: true,
              paginationForward: true,
              ...options
            }
          ]
        };
      }
      log18.info(`Building ${subTimeRanges.length} sub time ranges`);
      return {
        decodersAsMap,
        queryOptions: subTimeRanges.map(([start2, end]) => ({
          pubsubTopic,
          contentTopics,
          includeData: true,
          paginationForward: true,
          ...options,
          timeStart: start2,
          timeEnd: end
        }))
      };
    }
  };

  // ../node_modules/@waku/sdk/dist/waku/wait_for_remote_peer.js
  var log19 = new Logger("wait-for-remote-peer");
  async function waitForRemotePeer(waku, protocols2, timeoutMs) {
    protocols2 = protocols2?.length ? protocols2 : getEnabledProtocols(waku);
    const connections = waku.libp2p.getConnections();
    if (!waku.isStarted()) {
      throw Error("Waku node is not started");
    }
    for (const protocol of protocols2) {
      switch (protocol) {
        case Protocols.Relay:
          if (!waku.relay)
            throw Error("Cannot wait for Relay peer: protocol not mounted");
          break;
        case Protocols.LightPush:
          if (!waku.lightPush)
            throw Error("Cannot wait for LightPush peer: protocol not mounted");
          break;
        case Protocols.Store:
          if (!waku.store)
            throw Error("Cannot wait for Store peer: protocol not mounted");
          break;
        case Protocols.Filter:
          if (!waku.filter)
            throw Error("Cannot wait for Filter peer: protocol not mounted");
          break;
      }
    }
    const promises = [waitForProtocols(waku, protocols2)];
    if (connections.length > 0 && !protocols2.includes(Protocols.Relay)) {
      promises.push(waitForMetadata(waku, protocols2));
    }
    if (timeoutMs) {
      await rejectOnTimeout(Promise.any(promises), timeoutMs, "Timed out waiting for a remote peer.");
    } else {
      await Promise.any(promises);
    }
  }
  async function waitForProtocols(waku, protocols2) {
    const promises = [];
    if (waku.relay && protocols2.includes(Protocols.Relay)) {
      promises.push(waku.relay.waitForPeers());
    }
    if (waku.store && protocols2.includes(Protocols.Store)) {
      promises.push(waitForConnectedPeer(StoreCodec, waku.libp2p));
    }
    if (waku.lightPush && protocols2.includes(Protocols.LightPush)) {
      promises.push(waitForConnectedPeer(LightPushCodec, waku.libp2p));
    }
    if (waku.filter && protocols2.includes(Protocols.Filter)) {
      promises.push(waitForConnectedPeer(FilterCodecs.SUBSCRIBE, waku.libp2p));
    }
    return Promise.all(promises);
  }
  async function waitForConnectedPeer(codec, libp2p) {
    log19.info(`Waiting for ${codec} peer.`);
    await new Promise((resolve) => {
      const cb = (async (evt) => {
        if (evt.detail?.protocols?.includes(codec)) {
          const metadataService = libp2p.services.metadata;
          if (!metadataService) {
            libp2p.removeEventListener("peer:identify", cb);
            resolve();
            return;
          }
          try {
            await metadataService.confirmOrAttemptHandshake(evt.detail.peerId);
            libp2p.removeEventListener("peer:identify", cb);
            resolve();
          } catch (e) {
            if (e.code === "ERR_CONNECTION_BEING_CLOSED") {
              log19.error("Connection closed. Some peers can be on different shard.");
            }
            log19.error(`Error waiting for metadata: ${e}`);
          }
        }
      });
      libp2p.addEventListener("peer:identify", cb);
    });
  }
  async function waitForMetadata(waku, protocols2) {
    const connectedPeers2 = waku.libp2p.getPeers();
    const metadataService = waku.libp2p.services.metadata;
    const enabledCodes = mapProtocolsToCodecs(protocols2);
    if (!connectedPeers2.length || !metadataService) {
      log19.info(`Skipping waitForMetadata due to missing connections:${connectedPeers2.length} or metadataService:${!!metadataService}`);
      return;
    }
    for (const peerId2 of connectedPeers2) {
      try {
        const peer = await waku.libp2p.peerStore.get(peerId2);
        const hasSomeCodes = peer.protocols.some((c) => enabledCodes.has(c));
        if (hasSomeCodes) {
          const response = await metadataService.confirmOrAttemptHandshake(peerId2);
          if (!response.error) {
            peer.protocols.forEach((c) => {
              if (enabledCodes.has(c)) {
                enabledCodes.set(c, true);
              }
            });
            const confirmedAllCodecs = Array.from(enabledCodes.values()).every((v) => v);
            if (confirmedAllCodecs) {
              return;
            }
          }
        }
      } catch (e) {
        if (e.code === "ERR_CONNECTION_BEING_CLOSED") {
          log19.error("Connection closed. Some peers can be on different shard.");
        }
        log19.error(`Error while iterating through peers: ${e}`);
        continue;
      }
    }
  }
  var awaitTimeout = (ms2, rejectReason) => new Promise((_resolve, reject) => setTimeout(() => reject(Error(rejectReason)), ms2));
  async function rejectOnTimeout(promise, timeoutMs, rejectReason) {
    await Promise.race([promise, awaitTimeout(timeoutMs, rejectReason)]);
  }
  function getEnabledProtocols(waku) {
    const protocols2 = [];
    if (waku.relay) {
      protocols2.push(Protocols.Relay);
    }
    if (waku.filter) {
      protocols2.push(Protocols.Filter);
    }
    if (waku.store) {
      protocols2.push(Protocols.Store);
    }
    if (waku.lightPush) {
      protocols2.push(Protocols.LightPush);
    }
    return protocols2;
  }
  function mapProtocolsToCodecs(protocols2) {
    const codecs2 = /* @__PURE__ */ new Map();
    const protocolToCodec = {
      [Protocols.Filter]: FilterCodecs.SUBSCRIBE,
      [Protocols.LightPush]: LightPushCodec,
      [Protocols.Store]: StoreCodec
    };
    for (const protocol of protocols2) {
      if (protocolToCodec[protocol]) {
        codecs2.set(protocolToCodec[protocol], false);
      }
    }
    return codecs2;
  }

  // ../node_modules/@waku/sdk/dist/waku/waku.js
  var log20 = new Logger("waku");
  var WakuNode = class {
    libp2p;
    relay;
    store;
    filter;
    lightPush;
    events = new TypedEventEmitter();
    networkConfig;
    // needed to create a lock for async operations
    _nodeStateLock = false;
    _nodeStarted = false;
    connectionManager;
    peerManager;
    healthIndicator;
    constructor(options, libp2p, protocolsEnabled, relay) {
      this.relay = relay;
      this.libp2p = libp2p;
      this.networkConfig = options.networkConfig || DefaultNetworkConfig;
      protocolsEnabled = {
        filter: false,
        lightpush: false,
        store: false,
        ...protocolsEnabled
      };
      const peerId2 = this.libp2p.peerId.toString();
      this.connectionManager = new ConnectionManager({
        libp2p,
        relay: this.relay,
        events: this.events,
        networkConfig: this.networkConfig,
        config: options?.connectionManager
      });
      this.peerManager = new PeerManager({
        libp2p,
        config: {
          numPeersToUse: options.numPeersToUse
        },
        connectionManager: this.connectionManager
      });
      this.healthIndicator = new HealthIndicator({ libp2p, events: this.events });
      if (protocolsEnabled.store) {
        this.store = new Store({
          libp2p,
          peerManager: this.peerManager,
          options: options?.store
        });
      }
      if (protocolsEnabled.lightpush) {
        this.lightPush = new LightPush({
          libp2p,
          peerManager: this.peerManager,
          options: options?.lightPush
        });
      }
      if (protocolsEnabled.filter) {
        this.filter = new Filter({
          libp2p,
          peerManager: this.peerManager,
          options: options.filter
        });
      }
      log20.info("Waku node created", peerId2, `relay: ${!!this.relay}, store: ${!!this.store}, light push: ${!!this.lightPush}, filter: ${!!this.filter}`);
    }
    get peerId() {
      return this.libp2p.peerId;
    }
    get protocols() {
      return this.libp2p.getProtocols();
    }
    get health() {
      return this.healthIndicator.toValue();
    }
    async dial(peer, protocols2) {
      const _protocols = protocols2 ?? [];
      if (typeof protocols2 === "undefined") {
        this.relay && _protocols.push(Protocols.Relay);
        this.store && _protocols.push(Protocols.Store);
        this.filter && _protocols.push(Protocols.Filter);
        this.lightPush && _protocols.push(Protocols.LightPush);
      }
      const codecs2 = [];
      if (_protocols.includes(Protocols.Relay)) {
        if (this.relay) {
          this.relay.gossipSub.multicodecs.forEach((codec) => codecs2.push(codec));
        } else {
          log20.error("Relay codec not included in dial codec: protocol not mounted locally");
        }
      }
      if (_protocols.includes(Protocols.Store)) {
        if (this.store) {
          codecs2.push(this.store.multicodec);
        } else {
          log20.error("Store codec not included in dial codec: protocol not mounted locally");
        }
      }
      if (_protocols.includes(Protocols.LightPush)) {
        if (this.lightPush) {
          codecs2.push(this.lightPush.multicodec);
        } else {
          log20.error("Light Push codec not included in dial codec: protocol not mounted locally");
        }
      }
      if (_protocols.includes(Protocols.Filter)) {
        if (this.filter) {
          codecs2.push(this.filter.multicodec);
        } else {
          log20.error("Filter codec not included in dial codec: protocol not mounted locally");
        }
      }
      log20.info(`Dialing to ${peer?.toString()} with protocols ${_protocols}`);
      return await this.connectionManager.dial(peer, codecs2);
    }
    async hangUp(peer) {
      log20.info(`Hanging up peer:${peer?.toString()}.`);
      return this.connectionManager.hangUp(peer);
    }
    async start() {
      if (this._nodeStateLock || this.isStarted())
        return;
      this._nodeStateLock = true;
      await this.libp2p.start();
      this.connectionManager.start();
      this.peerManager.start();
      this.healthIndicator.start();
      this.lightPush?.start();
      this._nodeStateLock = false;
      this._nodeStarted = true;
    }
    async stop() {
      if (this._nodeStateLock || !this.isStarted())
        return;
      this._nodeStateLock = true;
      this.lightPush?.stop();
      this.healthIndicator.stop();
      this.peerManager.stop();
      this.connectionManager.stop();
      await this.libp2p.stop();
      this._nodeStateLock = false;
      this._nodeStarted = false;
    }
    async getConnectedPeers() {
      return this.connectionManager.getConnectedPeers();
    }
    async waitForPeers(protocols2, timeoutMs) {
      return waitForRemotePeer(this, protocols2, timeoutMs);
    }
    isStarted() {
      return this._nodeStarted && this.libp2p.status === "started";
    }
    isConnected() {
      return this.connectionManager.isConnected();
    }
    createDecoder(params) {
      const routingInfo = this.createRoutingInfo(params.contentTopic, params.shardId);
      return createDecoder(params.contentTopic, routingInfo);
    }
    createEncoder(params) {
      const routingInfo = this.createRoutingInfo(params.contentTopic, params.shardId);
      return createEncoder({
        contentTopic: params.contentTopic,
        ephemeral: params.ephemeral,
        routingInfo
      });
    }
    createRoutingInfo(contentTopic, shardId) {
      return createRoutingInfo(this.networkConfig, { contentTopic, shardId });
    }
  };

  // ../node_modules/it-length-prefixed/node_modules/uint8arrays/dist/src/alloc.js
  function allocUnsafe9(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/it-length-prefixed/dist/src/constants.js
  var MAX_LENGTH_LENGTH2 = 8;
  var MAX_DATA_LENGTH2 = 1024 * 1024 * 4;

  // ../node_modules/it-length-prefixed/dist/src/errors.js
  var InvalidMessageLengthError2 = class extends Error {
    name = "InvalidMessageLengthError";
    code = "ERR_INVALID_MSG_LENGTH";
  };
  var InvalidDataLengthError2 = class extends Error {
    name = "InvalidDataLengthError";
    code = "ERR_MSG_DATA_TOO_LONG";
  };
  var InvalidDataLengthLengthError2 = class extends Error {
    name = "InvalidDataLengthLengthError";
    code = "ERR_MSG_LENGTH_TOO_LONG";
  };
  var UnexpectedEOFError2 = class extends Error {
    name = "UnexpectedEOFError";
    code = "ERR_UNEXPECTED_EOF";
  };

  // ../node_modules/it-length-prefixed/dist/src/utils.js
  function isAsyncIterable5(thing) {
    return thing[Symbol.asyncIterator] != null;
  }

  // ../node_modules/it-length-prefixed/dist/src/encode.js
  function validateMaxDataLength(chunk, maxDataLength) {
    if (chunk.byteLength > maxDataLength) {
      throw new InvalidDataLengthError2("Message length too long");
    }
  }
  var defaultEncoder2 = (length21) => {
    const lengthLength = encodingLength(length21);
    const lengthBuf = allocUnsafe9(lengthLength);
    encode(length21, lengthBuf);
    defaultEncoder2.bytes = lengthLength;
    return lengthBuf;
  };
  defaultEncoder2.bytes = 0;
  function encode23(source, options) {
    options = options ?? {};
    const encodeLength3 = options.lengthEncoder ?? defaultEncoder2;
    const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH2;
    function* maybeYield(chunk) {
      validateMaxDataLength(chunk, maxDataLength);
      const length21 = encodeLength3(chunk.byteLength);
      if (length21 instanceof Uint8Array) {
        yield length21;
      } else {
        yield* length21;
      }
      if (chunk instanceof Uint8Array) {
        yield chunk;
      } else {
        yield* chunk;
      }
    }
    if (isAsyncIterable5(source)) {
      return (async function* () {
        for await (const chunk of source) {
          yield* maybeYield(chunk);
        }
      })();
    }
    return (function* () {
      for (const chunk of source) {
        yield* maybeYield(chunk);
      }
    })();
  }
  encode23.single = (chunk, options) => {
    options = options ?? {};
    const encodeLength3 = options.lengthEncoder ?? defaultEncoder2;
    const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH2;
    validateMaxDataLength(chunk, maxDataLength);
    return new Uint8ArrayList(encodeLength3(chunk.byteLength), chunk);
  };

  // ../node_modules/it-length-prefixed/dist/src/decode.js
  var ReadMode2;
  (function(ReadMode3) {
    ReadMode3[ReadMode3["LENGTH"] = 0] = "LENGTH";
    ReadMode3[ReadMode3["DATA"] = 1] = "DATA";
  })(ReadMode2 || (ReadMode2 = {}));
  var defaultDecoder2 = (buf) => {
    const length21 = decode(buf);
    defaultDecoder2.bytes = encodingLength(length21);
    return length21;
  };
  defaultDecoder2.bytes = 0;
  function decode28(source, options) {
    const buffer = new Uint8ArrayList();
    let mode = ReadMode2.LENGTH;
    let dataLength = -1;
    const lengthDecoder = options?.lengthDecoder ?? defaultDecoder2;
    const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH2;
    const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH2;
    function* maybeYield() {
      while (buffer.byteLength > 0) {
        if (mode === ReadMode2.LENGTH) {
          try {
            dataLength = lengthDecoder(buffer);
            if (dataLength < 0) {
              throw new InvalidMessageLengthError2("Invalid message length");
            }
            if (dataLength > maxDataLength) {
              throw new InvalidDataLengthError2("Message length too long");
            }
            const dataLengthLength = lengthDecoder.bytes;
            buffer.consume(dataLengthLength);
            if (options?.onLength != null) {
              options.onLength(dataLength);
            }
            mode = ReadMode2.DATA;
          } catch (err) {
            if (err instanceof RangeError) {
              if (buffer.byteLength > maxLengthLength) {
                throw new InvalidDataLengthLengthError2("Message length length too long");
              }
              break;
            }
            throw err;
          }
        }
        if (mode === ReadMode2.DATA) {
          if (buffer.byteLength < dataLength) {
            break;
          }
          const data = buffer.sublist(0, dataLength);
          buffer.consume(dataLength);
          if (options?.onData != null) {
            options.onData(data);
          }
          yield data;
          mode = ReadMode2.LENGTH;
        }
      }
    }
    if (isAsyncIterable5(source)) {
      return (async function* () {
        for await (const buf of source) {
          buffer.append(buf);
          yield* maybeYield();
        }
        if (buffer.byteLength > 0) {
          throw new UnexpectedEOFError2("Unexpected end of input");
        }
      })();
    }
    return (function* () {
      for (const buf of source) {
        buffer.append(buf);
        yield* maybeYield();
      }
      if (buffer.byteLength > 0) {
        throw new UnexpectedEOFError2("Unexpected end of input");
      }
    })();
  }
  decode28.fromReader = (reader, options) => {
    let byteLength = 1;
    const varByteSource = (async function* () {
      while (true) {
        try {
          const { done, value } = await reader.next(byteLength);
          if (done === true) {
            return;
          }
          if (value != null) {
            yield value;
          }
        } catch (err) {
          if (err.code === "ERR_UNDER_READ") {
            return { done: true, value: null };
          }
          throw err;
        } finally {
          byteLength = 1;
        }
      }
    })();
    const onLength = (l) => {
      byteLength = l;
    };
    return decode28(varByteSource, {
      ...options ?? {},
      onLength
    });
  };

  // ../node_modules/it-byte-stream/dist/src/errors.js
  var UnexpectedEOFError3 = class extends Error {
    name = "UnexpectedEOFError";
    code = "ERR_UNEXPECTED_EOF";
  };

  // ../node_modules/it-byte-stream/dist/src/index.js
  function byteStream(duplex, opts) {
    const write3 = queuelessPushable();
    duplex.sink(write3).catch(async (err) => {
      await write3.end(err);
    });
    duplex.sink = async (source2) => {
      for await (const buf of source2) {
        await write3.push(buf);
      }
      await write3.end();
    };
    let source = duplex.source;
    if (duplex.source[Symbol.iterator] != null) {
      source = duplex.source[Symbol.iterator]();
    } else if (duplex.source[Symbol.asyncIterator] != null) {
      source = duplex.source[Symbol.asyncIterator]();
    }
    const readBuffer = new Uint8ArrayList();
    const W = {
      read: async (options) => {
        options?.signal?.throwIfAborted();
        if (options?.bytes == null) {
          const { done, value } = await raceSignal(source.next(), options?.signal);
          if (done === true) {
            return null;
          }
          return value;
        }
        while (readBuffer.byteLength < options.bytes) {
          const { value, done } = await raceSignal(source.next(), options?.signal);
          if (done === true) {
            throw new UnexpectedEOFError3("unexpected end of input");
          }
          readBuffer.append(value);
        }
        const buf = readBuffer.sublist(0, options.bytes);
        readBuffer.consume(options.bytes);
        return buf;
      },
      write: async (data, options) => {
        options?.signal?.throwIfAborted();
        if (data instanceof Uint8Array) {
          await write3.push(data, options);
        } else {
          await write3.push(data.subarray(), options);
        }
      },
      unwrap: () => {
        if (readBuffer.byteLength > 0) {
          const originalStream = duplex.source;
          duplex.source = (async function* () {
            if (opts?.yieldBytes === false) {
              yield readBuffer;
            } else {
              yield* readBuffer;
            }
            yield* originalStream;
          })();
        }
        return duplex;
      }
    };
    return W;
  }

  // ../node_modules/it-length-prefixed-stream/dist/src/errors.js
  var InvalidMessageLengthError3 = class extends Error {
    name = "InvalidMessageLengthError";
    code = "ERR_INVALID_MSG_LENGTH";
  };
  var InvalidDataLengthError3 = class extends Error {
    name = "InvalidDataLengthError";
    code = "ERR_MSG_DATA_TOO_LONG";
  };
  var InvalidDataLengthLengthError3 = class extends Error {
    name = "InvalidDataLengthLengthError";
    code = "ERR_MSG_LENGTH_TOO_LONG";
  };

  // ../node_modules/it-length-prefixed-stream/dist/src/index.js
  function lpStream(duplex, opts = {}) {
    const bytes2 = byteStream(duplex, opts);
    if (opts.maxDataLength != null && opts.maxLengthLength == null) {
      opts.maxLengthLength = encodingLength(opts.maxDataLength);
    }
    const decodeLength = opts?.lengthDecoder ?? decode;
    const encodeLength3 = opts?.lengthEncoder ?? encode;
    const W = {
      read: async (options) => {
        let dataLength = -1;
        const lengthBuffer = new Uint8ArrayList();
        while (true) {
          lengthBuffer.append(await bytes2.read({
            ...options,
            bytes: 1
          }));
          try {
            dataLength = decodeLength(lengthBuffer);
          } catch (err) {
            if (err instanceof RangeError) {
              continue;
            }
            throw err;
          }
          if (dataLength < 0) {
            throw new InvalidMessageLengthError3("Invalid message length");
          }
          if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {
            throw new InvalidDataLengthLengthError3("message length length too long");
          }
          if (dataLength > -1) {
            break;
          }
        }
        if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {
          throw new InvalidDataLengthError3("message length too long");
        }
        return bytes2.read({
          ...options,
          bytes: dataLength
        });
      },
      write: async (data, options) => {
        await bytes2.write(new Uint8ArrayList(encodeLength3(data.byteLength), data), options);
      },
      writeV: async (data, options) => {
        const list = new Uint8ArrayList(...data.flatMap((buf) => [encodeLength3(buf.byteLength), buf]));
        await bytes2.write(list, options);
      },
      unwrap: () => {
        return bytes2.unwrap();
      }
    };
    return W;
  }

  // ../node_modules/it-pair/dist/src/index.js
  function pair() {
    const deferred = pDefer();
    let piped = false;
    return {
      sink: async (source) => {
        if (piped) {
          throw new Error("already piped");
        }
        piped = true;
        deferred.resolve(source);
      },
      source: (async function* () {
        const source = await deferred.promise;
        yield* source;
      })()
    };
  }

  // ../node_modules/it-pair/dist/src/duplex.js
  function duplexPair() {
    const a = pair();
    const b = pair();
    return [
      {
        source: a.source,
        sink: b.sink
      },
      {
        source: b.source,
        sink: a.sink
      }
    ];
  }

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/uint8arrays/dist/src/alloc.js
  function alloc4(size = 0) {
    return new Uint8Array(size);
  }
  function allocUnsafe10(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/@chainsafe/libp2p-noise/dist/src/constants.js
  var NOISE_MSG_MAX_LENGTH_BYTES = 65535;
  var NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;
  var DUMP_SESSION_KEYS = Boolean(globalThis.process?.env?.DUMP_SESSION_KEYS);

  // ../node_modules/@noble/ciphers/esm/utils.js
  function isBytes2(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function abool(b) {
    if (typeof b !== "boolean")
      throw new Error(`boolean expected, not ${b}`);
  }
  function anumber2(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error("positive integer expected, got " + n);
  }
  function abytes2(b, ...lengths) {
    if (!isBytes2(b))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
  }
  function aexists2(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput2(out, instance) {
    abytes2(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least " + min);
    }
  }
  function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  }
  function clean2(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
      arrays[i].fill(0);
    }
  }
  function createView3(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  var isLE2 = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
  function utf8ToBytes4(str) {
    if (typeof str !== "string")
      throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes3(data) {
    if (typeof data === "string")
      data = utf8ToBytes4(data);
    else if (isBytes2(data))
      data = copyBytes2(data);
    else
      throw new Error("Uint8Array expected, got " + typeof data);
    return data;
  }
  function checkOpts(defaults, opts) {
    if (opts == null || typeof opts !== "object")
      throw new Error("options must be defined");
    const merged = Object.assign(defaults, opts);
    return merged;
  }
  function equalBytes2(a, b) {
    if (a.length !== b.length)
      return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
      diff |= a[i] ^ b[i];
    return diff === 0;
  }
  var wrapCipher = /* @__NO_SIDE_EFFECTS__ */ (params, constructor) => {
    function wrappedCipher(key, ...args) {
      abytes2(key);
      if (!isLE2)
        throw new Error("Non little-endian hardware is not yet supported");
      if (params.nonceLength !== void 0) {
        const nonce = args[0];
        if (!nonce)
          throw new Error("nonce / iv required");
        if (params.varSizeNonce)
          abytes2(nonce);
        else
          abytes2(nonce, params.nonceLength);
      }
      const tagl = params.tagLength;
      if (tagl && args[1] !== void 0) {
        abytes2(args[1]);
      }
      const cipher = constructor(key, ...args);
      const checkOutput = (fnLength, output2) => {
        if (output2 !== void 0) {
          if (fnLength !== 2)
            throw new Error("cipher output not supported");
          abytes2(output2);
        }
      };
      let called = false;
      const wrCipher = {
        encrypt(data, output2) {
          if (called)
            throw new Error("cannot encrypt() twice with same key + nonce");
          called = true;
          abytes2(data);
          checkOutput(cipher.encrypt.length, output2);
          return cipher.encrypt(data, output2);
        },
        decrypt(data, output2) {
          abytes2(data);
          if (tagl && data.length < tagl)
            throw new Error("invalid ciphertext length: smaller than tagLength=" + tagl);
          checkOutput(cipher.decrypt.length, output2);
          return cipher.decrypt(data, output2);
        }
      };
      return wrCipher;
    }
    Object.assign(wrappedCipher, params);
    return wrappedCipher;
  };
  function getOutput(expectedLength, out, onlyAligned = true) {
    if (out === void 0)
      return new Uint8Array(expectedLength);
    if (out.length !== expectedLength)
      throw new Error("invalid output length, expected " + expectedLength + ", got: " + out.length);
    if (onlyAligned && !isAligned32(out))
      throw new Error("invalid output, must be aligned");
    return out;
  }
  function setBigUint643(view, byteOffset, value, isLE3) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE3);
    const _32n4 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n4 & _u32_max);
    const wl = Number(value & _u32_max);
    const h2 = isLE3 ? 4 : 0;
    const l = isLE3 ? 0 : 4;
    view.setUint32(byteOffset + h2, wh, isLE3);
    view.setUint32(byteOffset + l, wl, isLE3);
  }
  function u64Lengths(dataLength, aadLength, isLE3) {
    abool(isLE3);
    const num = new Uint8Array(16);
    const view = createView3(num);
    setBigUint643(view, 0, BigInt(aadLength), isLE3);
    setBigUint643(view, 8, BigInt(dataLength), isLE3);
    return num;
  }
  function isAligned32(bytes2) {
    return bytes2.byteOffset % 4 === 0;
  }
  function copyBytes2(bytes2) {
    return Uint8Array.from(bytes2);
  }

  // ../node_modules/@noble/ciphers/esm/_arx.js
  var _utf8ToBytes = (str) => Uint8Array.from(str.split("").map((c) => c.charCodeAt(0)));
  var sigma16 = _utf8ToBytes("expand 16-byte k");
  var sigma32 = _utf8ToBytes("expand 32-byte k");
  var sigma16_32 = u32(sigma16);
  var sigma32_32 = u32(sigma32);
  function rotl(a, b) {
    return a << b | a >>> 32 - b;
  }
  function isAligned322(b) {
    return b.byteOffset % 4 === 0;
  }
  var BLOCK_LEN = 64;
  var BLOCK_LEN32 = 16;
  var MAX_COUNTER = 2 ** 32 - 1;
  var U32_EMPTY = new Uint32Array();
  function runCipher(core, sigma, key, nonce, data, output2, counter, rounds) {
    const len = data.length;
    const block = new Uint8Array(BLOCK_LEN);
    const b32 = u32(block);
    const isAligned = isAligned322(data) && isAligned322(output2);
    const d32 = isAligned ? u32(data) : U32_EMPTY;
    const o32 = isAligned ? u32(output2) : U32_EMPTY;
    for (let pos = 0; pos < len; counter++) {
      core(sigma, key, nonce, b32, counter, rounds);
      if (counter >= MAX_COUNTER)
        throw new Error("arx: counter overflow");
      const take2 = Math.min(BLOCK_LEN, len - pos);
      if (isAligned && take2 === BLOCK_LEN) {
        const pos32 = pos / 4;
        if (pos % 4 !== 0)
          throw new Error("arx: invalid block position");
        for (let j = 0, posj; j < BLOCK_LEN32; j++) {
          posj = pos32 + j;
          o32[posj] = d32[posj] ^ b32[j];
        }
        pos += BLOCK_LEN;
        continue;
      }
      for (let j = 0, posj; j < take2; j++) {
        posj = pos + j;
        output2[posj] = data[posj] ^ block[j];
      }
      pos += take2;
    }
  }
  function createCipher(core, opts) {
    const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
    if (typeof core !== "function")
      throw new Error("core must be a function");
    anumber2(counterLength);
    anumber2(rounds);
    abool(counterRight);
    abool(allowShortKeys);
    return (key, nonce, data, output2, counter = 0) => {
      abytes2(key);
      abytes2(nonce);
      abytes2(data);
      const len = data.length;
      if (output2 === void 0)
        output2 = new Uint8Array(len);
      abytes2(output2);
      anumber2(counter);
      if (counter < 0 || counter >= MAX_COUNTER)
        throw new Error("arx: counter overflow");
      if (output2.length < len)
        throw new Error(`arx: output (${output2.length}) is shorter than data (${len})`);
      const toClean = [];
      let l = key.length;
      let k;
      let sigma;
      if (l === 32) {
        toClean.push(k = copyBytes2(key));
        sigma = sigma32_32;
      } else if (l === 16 && allowShortKeys) {
        k = new Uint8Array(32);
        k.set(key);
        k.set(key, 16);
        sigma = sigma16_32;
        toClean.push(k);
      } else {
        throw new Error(`arx: invalid 32-byte key, got length=${l}`);
      }
      if (!isAligned322(nonce))
        toClean.push(nonce = copyBytes2(nonce));
      const k32 = u32(k);
      if (extendNonceFn) {
        if (nonce.length !== 24)
          throw new Error(`arx: extended nonce must be 24 bytes`);
        extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);
        nonce = nonce.subarray(16);
      }
      const nonceNcLen = 16 - counterLength;
      if (nonceNcLen !== nonce.length)
        throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
      if (nonceNcLen !== 12) {
        const nc = new Uint8Array(12);
        nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
        nonce = nc;
        toClean.push(nonce);
      }
      const n32 = u32(nonce);
      runCipher(core, sigma, k32, n32, data, output2, counter, rounds);
      clean2(...toClean);
      return output2;
    };
  }

  // ../node_modules/@noble/ciphers/esm/_poly1305.js
  var u8to16 = (a, i) => a[i++] & 255 | (a[i++] & 255) << 8;
  var Poly1305 = class {
    constructor(key) {
      this.blockLen = 16;
      this.outputLen = 16;
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.pos = 0;
      this.finished = false;
      key = toBytes3(key);
      abytes2(key, 32);
      const t0 = u8to16(key, 0);
      const t1 = u8to16(key, 2);
      const t2 = u8to16(key, 4);
      const t3 = u8to16(key, 6);
      const t4 = u8to16(key, 8);
      const t5 = u8to16(key, 10);
      const t6 = u8to16(key, 12);
      const t7 = u8to16(key, 14);
      this.r[0] = t0 & 8191;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      for (let i = 0; i < 8; i++)
        this.pad[i] = u8to16(key, 16 + 2 * i);
    }
    process(data, offset, isLast = false) {
      const hibit = isLast ? 0 : 1 << 11;
      const { h: h2, r } = this;
      const r0 = r[0];
      const r1 = r[1];
      const r2 = r[2];
      const r3 = r[3];
      const r4 = r[4];
      const r5 = r[5];
      const r6 = r[6];
      const r7 = r[7];
      const r8 = r[8];
      const r9 = r[9];
      const t0 = u8to16(data, offset + 0);
      const t1 = u8to16(data, offset + 2);
      const t2 = u8to16(data, offset + 4);
      const t3 = u8to16(data, offset + 6);
      const t4 = u8to16(data, offset + 8);
      const t5 = u8to16(data, offset + 10);
      const t6 = u8to16(data, offset + 12);
      const t7 = u8to16(data, offset + 14);
      let h0 = h2[0] + (t0 & 8191);
      let h1 = h2[1] + ((t0 >>> 13 | t1 << 3) & 8191);
      let h22 = h2[2] + ((t1 >>> 10 | t2 << 6) & 8191);
      let h3 = h2[3] + ((t2 >>> 7 | t3 << 9) & 8191);
      let h4 = h2[4] + ((t3 >>> 4 | t4 << 12) & 8191);
      let h5 = h2[5] + (t4 >>> 1 & 8191);
      let h6 = h2[6] + ((t4 >>> 14 | t5 << 2) & 8191);
      let h7 = h2[7] + ((t5 >>> 11 | t6 << 5) & 8191);
      let h8 = h2[8] + ((t6 >>> 8 | t7 << 8) & 8191);
      let h9 = h2[9] + (t7 >>> 5 | hibit);
      let c = 0;
      let d0 = c + h0 * r0 + h1 * (5 * r9) + h22 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
      c = d0 >>> 13;
      d0 &= 8191;
      d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
      c += d0 >>> 13;
      d0 &= 8191;
      let d1 = c + h0 * r1 + h1 * r0 + h22 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
      c = d1 >>> 13;
      d1 &= 8191;
      d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
      c += d1 >>> 13;
      d1 &= 8191;
      let d2 = c + h0 * r2 + h1 * r1 + h22 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
      c = d2 >>> 13;
      d2 &= 8191;
      d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
      c += d2 >>> 13;
      d2 &= 8191;
      let d3 = c + h0 * r3 + h1 * r2 + h22 * r1 + h3 * r0 + h4 * (5 * r9);
      c = d3 >>> 13;
      d3 &= 8191;
      d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
      c += d3 >>> 13;
      d3 &= 8191;
      let d4 = c + h0 * r4 + h1 * r3 + h22 * r2 + h3 * r1 + h4 * r0;
      c = d4 >>> 13;
      d4 &= 8191;
      d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
      c += d4 >>> 13;
      d4 &= 8191;
      let d5 = c + h0 * r5 + h1 * r4 + h22 * r3 + h3 * r2 + h4 * r1;
      c = d5 >>> 13;
      d5 &= 8191;
      d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
      c += d5 >>> 13;
      d5 &= 8191;
      let d6 = c + h0 * r6 + h1 * r5 + h22 * r4 + h3 * r3 + h4 * r2;
      c = d6 >>> 13;
      d6 &= 8191;
      d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
      c += d6 >>> 13;
      d6 &= 8191;
      let d7 = c + h0 * r7 + h1 * r6 + h22 * r5 + h3 * r4 + h4 * r3;
      c = d7 >>> 13;
      d7 &= 8191;
      d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
      c += d7 >>> 13;
      d7 &= 8191;
      let d8 = c + h0 * r8 + h1 * r7 + h22 * r6 + h3 * r5 + h4 * r4;
      c = d8 >>> 13;
      d8 &= 8191;
      d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
      c += d8 >>> 13;
      d8 &= 8191;
      let d9 = c + h0 * r9 + h1 * r8 + h22 * r7 + h3 * r6 + h4 * r5;
      c = d9 >>> 13;
      d9 &= 8191;
      d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
      c += d9 >>> 13;
      d9 &= 8191;
      c = (c << 2) + c | 0;
      c = c + d0 | 0;
      d0 = c & 8191;
      c = c >>> 13;
      d1 += c;
      h2[0] = d0;
      h2[1] = d1;
      h2[2] = d2;
      h2[3] = d3;
      h2[4] = d4;
      h2[5] = d5;
      h2[6] = d6;
      h2[7] = d7;
      h2[8] = d8;
      h2[9] = d9;
    }
    finalize() {
      const { h: h2, pad } = this;
      const g = new Uint16Array(10);
      let c = h2[1] >>> 13;
      h2[1] &= 8191;
      for (let i = 2; i < 10; i++) {
        h2[i] += c;
        c = h2[i] >>> 13;
        h2[i] &= 8191;
      }
      h2[0] += c * 5;
      c = h2[0] >>> 13;
      h2[0] &= 8191;
      h2[1] += c;
      c = h2[1] >>> 13;
      h2[1] &= 8191;
      h2[2] += c;
      g[0] = h2[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 8191;
      for (let i = 1; i < 10; i++) {
        g[i] = h2[i] + c;
        c = g[i] >>> 13;
        g[i] &= 8191;
      }
      g[9] -= 1 << 13;
      let mask = (c ^ 1) - 1;
      for (let i = 0; i < 10; i++)
        g[i] &= mask;
      mask = ~mask;
      for (let i = 0; i < 10; i++)
        h2[i] = h2[i] & mask | g[i];
      h2[0] = (h2[0] | h2[1] << 13) & 65535;
      h2[1] = (h2[1] >>> 3 | h2[2] << 10) & 65535;
      h2[2] = (h2[2] >>> 6 | h2[3] << 7) & 65535;
      h2[3] = (h2[3] >>> 9 | h2[4] << 4) & 65535;
      h2[4] = (h2[4] >>> 12 | h2[5] << 1 | h2[6] << 14) & 65535;
      h2[5] = (h2[6] >>> 2 | h2[7] << 11) & 65535;
      h2[6] = (h2[7] >>> 5 | h2[8] << 8) & 65535;
      h2[7] = (h2[8] >>> 8 | h2[9] << 5) & 65535;
      let f = h2[0] + pad[0];
      h2[0] = f & 65535;
      for (let i = 1; i < 8; i++) {
        f = (h2[i] + pad[i] | 0) + (f >>> 16) | 0;
        h2[i] = f & 65535;
      }
      clean2(g);
    }
    update(data) {
      aexists2(this);
      data = toBytes3(data);
      abytes2(data);
      const { buffer, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take2 = Math.min(blockLen - this.pos, len - pos);
        if (take2 === blockLen) {
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(data, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take2), this.pos);
        this.pos += take2;
        pos += take2;
        if (this.pos === blockLen) {
          this.process(buffer, 0, false);
          this.pos = 0;
        }
      }
      return this;
    }
    destroy() {
      clean2(this.h, this.r, this.buffer, this.pad);
    }
    digestInto(out) {
      aexists2(this);
      aoutput2(out, this);
      this.finished = true;
      const { buffer, h: h2 } = this;
      let { pos } = this;
      if (pos) {
        buffer[pos++] = 1;
        for (; pos < 16; pos++)
          buffer[pos] = 0;
        this.process(buffer, 0, true);
      }
      this.finalize();
      let opos = 0;
      for (let i = 0; i < 8; i++) {
        out[opos++] = h2[i] >>> 0;
        out[opos++] = h2[i] >>> 8;
      }
      return out;
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
  };
  function wrapConstructorWithKey(hashCons) {
    const hashC = (msg, key) => hashCons(key).update(toBytes3(msg)).digest();
    const tmp = hashCons(new Uint8Array(32));
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (key) => hashCons(key);
    return hashC;
  }
  var poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));

  // ../node_modules/@noble/ciphers/esm/chacha.js
  function chachaCore(s2, k, n, out, cnt, rounds = 20) {
    let y00 = s2[0], y01 = s2[1], y02 = s2[2], y03 = s2[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for (let r = 0; r < rounds; r += 2) {
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 16);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 12);
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 8);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 7);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 16);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 12);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 8);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 7);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 16);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 12);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 8);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 7);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 16);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 12);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 8);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 7);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 16);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 12);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 8);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 7);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 16);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 12);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 8);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 7);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 16);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 12);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 8);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 7);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 16);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 12);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 8);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 7);
    }
    let oi = 0;
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
  }
  function hchacha(s2, k, i, o32) {
    let x00 = s2[0], x01 = s2[1], x02 = s2[2], x03 = s2[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];
    for (let r = 0; r < 20; r += 2) {
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 16);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 12);
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 8);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 7);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 16);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 12);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 8);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 7);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 16);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 12);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 8);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 7);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 16);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 12);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 8);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 7);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 16);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 12);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 8);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 7);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 16);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 12);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 8);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 7);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 16);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 12);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 8);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 7);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 16);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 12);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 8);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 7);
    }
    let oi = 0;
    o32[oi++] = x00;
    o32[oi++] = x01;
    o32[oi++] = x02;
    o32[oi++] = x03;
    o32[oi++] = x12;
    o32[oi++] = x13;
    o32[oi++] = x14;
    o32[oi++] = x15;
  }
  var chacha20 = /* @__PURE__ */ createCipher(chachaCore, {
    counterRight: false,
    counterLength: 4,
    allowShortKeys: false
  });
  var xchacha20 = /* @__PURE__ */ createCipher(chachaCore, {
    counterRight: false,
    counterLength: 8,
    extendNonceFn: hchacha,
    allowShortKeys: false
  });
  var ZEROS16 = /* @__PURE__ */ new Uint8Array(16);
  var updatePadded = (h2, msg) => {
    h2.update(msg);
    const left = msg.length % 16;
    if (left)
      h2.update(ZEROS16.subarray(left));
  };
  var ZEROS32 = /* @__PURE__ */ new Uint8Array(32);
  function computeTag(fn, key, nonce, data, AAD) {
    const authKey = fn(key, nonce, ZEROS32);
    const h2 = poly1305.create(authKey);
    if (AAD)
      updatePadded(h2, AAD);
    updatePadded(h2, data);
    const num = u64Lengths(data.length, AAD ? AAD.length : 0, true);
    h2.update(num);
    const res = h2.digest();
    clean2(authKey, num);
    return res;
  }
  var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
    const tagLength = 16;
    return {
      encrypt(plaintext, output2) {
        const plength = plaintext.length;
        output2 = getOutput(plength + tagLength, output2, false);
        output2.set(plaintext);
        const oPlain = output2.subarray(0, -tagLength);
        xorStream(key, nonce, oPlain, oPlain, 1);
        const tag = computeTag(xorStream, key, nonce, oPlain, AAD);
        output2.set(tag, plength);
        clean2(tag);
        return output2;
      },
      decrypt(ciphertext, output2) {
        output2 = getOutput(ciphertext.length - tagLength, output2, false);
        const data = ciphertext.subarray(0, -tagLength);
        const passedTag = ciphertext.subarray(-tagLength);
        const tag = computeTag(xorStream, key, nonce, data, AAD);
        if (!equalBytes2(passedTag, tag))
          throw new Error("invalid tag");
        output2.set(ciphertext.subarray(0, -tagLength));
        xorStream(key, nonce, output2, output2, 1);
        clean2(tag);
        return output2;
      }
    };
  };
  var chacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));
  var xchacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));

  // ../node_modules/@noble/hashes/esm/_u64.js
  var U32_MASK642 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n2 = /* @__PURE__ */ BigInt(32);
  function fromBig2(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK642), l: Number(n >> _32n2 & U32_MASK642) };
    return { h: Number(n >> _32n2 & U32_MASK642) | 0, l: Number(n & U32_MASK642) | 0 };
  }
  function split2(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
      const { h: h2, l } = fromBig2(lst[i], le);
      [Ah[i], Al[i]] = [h2, l];
    }
    return [Ah, Al];
  }
  var toBig = (h2, l) => BigInt(h2 >>> 0) << _32n2 | BigInt(l >>> 0);
  var shrSH2 = (h2, _l, s2) => h2 >>> s2;
  var shrSL2 = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
  var rotrSH2 = (h2, l, s2) => h2 >>> s2 | l << 32 - s2;
  var rotrSL2 = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
  var rotrBH2 = (h2, l, s2) => h2 << 64 - s2 | l >>> s2 - 32;
  var rotrBL2 = (h2, l, s2) => h2 >>> s2 - 32 | l << 64 - s2;
  var rotr32H = (_h, l) => l;
  var rotr32L = (h2, _l) => h2;
  var rotlSH = (h2, l, s2) => h2 << s2 | l >>> 32 - s2;
  var rotlSL = (h2, l, s2) => l << s2 | h2 >>> 32 - s2;
  var rotlBH = (h2, l, s2) => l << s2 - 32 | h2 >>> 64 - s2;
  var rotlBL = (h2, l, s2) => h2 << s2 - 32 | l >>> 64 - s2;
  function add2(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  var add3L2 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  var add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  var add4L2 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  var add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  var add5L2 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  var add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  var u64 = {
    fromBig: fromBig2,
    split: split2,
    toBig,
    shrSH: shrSH2,
    shrSL: shrSL2,
    rotrSH: rotrSH2,
    rotrSL: rotrSL2,
    rotrBH: rotrBH2,
    rotrBL: rotrBL2,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add: add2,
    add3L: add3L2,
    add3H: add3H2,
    add4L: add4L2,
    add4H: add4H2,
    add5H: add5H2,
    add5L: add5L2
  };
  var u64_default = u64;

  // ../node_modules/@noble/hashes/esm/sha512.js
  var [SHA512_Kh2, SHA512_Kl2] = /* @__PURE__ */ (() => u64_default.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n) => BigInt(n))))();
  var SHA512_W_H2 = /* @__PURE__ */ new Uint32Array(80);
  var SHA512_W_L2 = /* @__PURE__ */ new Uint32Array(80);
  var SHA5122 = class extends SHA2 {
    constructor() {
      super(128, 64, 16, false);
      this.Ah = 1779033703 | 0;
      this.Al = 4089235720 | 0;
      this.Bh = 3144134277 | 0;
      this.Bl = 2227873595 | 0;
      this.Ch = 1013904242 | 0;
      this.Cl = 4271175723 | 0;
      this.Dh = 2773480762 | 0;
      this.Dl = 1595750129 | 0;
      this.Eh = 1359893119 | 0;
      this.El = 2917565137 | 0;
      this.Fh = 2600822924 | 0;
      this.Fl = 725511199 | 0;
      this.Gh = 528734635 | 0;
      this.Gl = 4215389547 | 0;
      this.Hh = 1541459225 | 0;
      this.Hl = 327033209 | 0;
    }
    // prettier-ignore
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4) {
        SHA512_W_H2[i] = view.getUint32(offset);
        SHA512_W_L2[i] = view.getUint32(offset += 4);
      }
      for (let i = 16; i < 80; i++) {
        const W15h = SHA512_W_H2[i - 15] | 0;
        const W15l = SHA512_W_L2[i - 15] | 0;
        const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
        const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H2[i - 2] | 0;
        const W2l = SHA512_W_L2[i - 2] | 0;
        const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
        const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
        const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L2[i - 7], SHA512_W_L2[i - 16]);
        const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H2[i - 7], SHA512_W_H2[i - 16]);
        SHA512_W_H2[i] = SUMh | 0;
        SHA512_W_L2[i] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i = 0; i < 80; i++) {
        const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
        const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl2[i], SHA512_W_L2[i]);
        const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh2[i], SHA512_W_H2[i]);
        const T1l = T1ll | 0;
        const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
        const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = u64_default.add3L(T1l, sigma0l, MAJl);
        Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      SHA512_W_H2.fill(0);
      SHA512_W_L2.fill(0);
    }
    destroy() {
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  var sha5127 = /* @__PURE__ */ wrapConstructor(() => new SHA5122());

  // ../node_modules/@noble/curves/esm/abstract/utils.js
  var _0n7 = BigInt(0);
  var _1n7 = BigInt(1);
  var _2n6 = BigInt(2);
  var u8a2 = (a) => a instanceof Uint8Array;
  var hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex3(bytes2) {
    if (!u8a2(bytes2))
      throw new Error("Uint8Array expected");
    let hex = "";
    for (let i = 0; i < bytes2.length; i++) {
      hex += hexes2[bytes2[i]];
    }
    return hex;
  }
  function hexToNumber2(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return BigInt(hex === "" ? "0" : `0x${hex}`);
  }
  function hexToBytes3(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    const len = hex.length;
    if (len % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + len);
    const array = new Uint8Array(len / 2);
    for (let i = 0; i < array.length; i++) {
      const j = i * 2;
      const hexByte = hex.slice(j, j + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array[i] = byte;
    }
    return array;
  }
  function bytesToNumberBE2(bytes2) {
    return hexToNumber2(bytesToHex3(bytes2));
  }
  function bytesToNumberLE2(bytes2) {
    if (!u8a2(bytes2))
      throw new Error("Uint8Array expected");
    return hexToNumber2(bytesToHex3(Uint8Array.from(bytes2).reverse()));
  }
  function numberToBytesBE2(n, len) {
    return hexToBytes3(n.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE2(n, len) {
    return numberToBytesBE2(n, len).reverse();
  }
  function ensureBytes2(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes3(hex);
      } catch (e) {
        throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
      }
    } else if (u8a2(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
  }
  function concatBytes3(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0;
    arrays.forEach((a) => {
      if (!u8a2(a))
        throw new Error("Uint8Array expected");
      r.set(a, pad);
      pad += a.length;
    });
    return r;
  }
  var bitMask2 = (n) => (_2n6 << BigInt(n - 1)) - _1n7;
  var validatorFns = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
  function validateObject2(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
      const checkVal = validatorFns[type];
      if (typeof checkVal !== "function")
        throw new Error(`Invalid validator "${type}", expected function`);
      const val = object[fieldName];
      if (isOptional && val === void 0)
        return;
      if (!checkVal(val, object)) {
        throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
      }
    };
    for (const [fieldName, type] of Object.entries(validators))
      checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
      checkField(fieldName, type, true);
    return object;
  }

  // ../node_modules/@noble/curves/esm/abstract/modular.js
  var _0n8 = BigInt(0);
  var _1n8 = BigInt(1);
  var _2n7 = BigInt(2);
  var _3n4 = BigInt(3);
  var _4n3 = BigInt(4);
  var _5n3 = BigInt(5);
  var _8n4 = BigInt(8);
  var _9n2 = BigInt(9);
  var _16n2 = BigInt(16);
  function mod3(a, b) {
    const result = a % b;
    return result >= _0n8 ? result : b + result;
  }
  function pow(num, power, modulo) {
    if (modulo <= _0n8 || power < _0n8)
      throw new Error("Expected power/modulo > 0");
    if (modulo === _1n8)
      return _0n8;
    let res = _1n8;
    while (power > _0n8) {
      if (power & _1n8)
        res = res * num % modulo;
      num = num * num % modulo;
      power >>= _1n8;
    }
    return res;
  }
  function pow22(x, power, modulo) {
    let res = x;
    while (power-- > _0n8) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert2(number3, modulo) {
    if (number3 === _0n8 || modulo <= _0n8) {
      throw new Error(`invert: expected positive integers, got n=${number3} mod=${modulo}`);
    }
    let a = mod3(number3, modulo);
    let b = modulo;
    let x = _0n8, y2 = _1n8, u = _1n8, v = _0n8;
    while (a !== _0n8) {
      const q = b / a;
      const r = b % a;
      const m2 = x - u * q;
      const n = y2 - v * q;
      b = a, a = r, x = u, y2 = v, u = m2, v = n;
    }
    const gcd = b;
    if (gcd !== _1n8)
      throw new Error("invert: does not exist");
    return mod3(x, modulo);
  }
  function tonelliShanks2(P) {
    const legendreC = (P - _1n8) / _2n7;
    let Q, S, Z;
    for (Q = P - _1n8, S = 0; Q % _2n7 === _0n8; Q /= _2n7, S++)
      ;
    for (Z = _2n7; Z < P && pow(Z, legendreC, P) !== P - _1n8; Z++)
      ;
    if (S === 1) {
      const p1div4 = (P + _1n8) / _4n3;
      return function tonelliFast(Fp4, n) {
        const root = Fp4.pow(n, p1div4);
        if (!Fp4.eql(Fp4.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    const Q1div2 = (Q + _1n8) / _2n7;
    return function tonelliSlow(Fp4, n) {
      if (Fp4.pow(n, legendreC) === Fp4.neg(Fp4.ONE))
        throw new Error("Cannot find square root");
      let r = S;
      let g = Fp4.pow(Fp4.mul(Fp4.ONE, Z), Q);
      let x = Fp4.pow(n, Q1div2);
      let b = Fp4.pow(n, Q);
      while (!Fp4.eql(b, Fp4.ONE)) {
        if (Fp4.eql(b, Fp4.ZERO))
          return Fp4.ZERO;
        let m2 = 1;
        for (let t2 = Fp4.sqr(b); m2 < r; m2++) {
          if (Fp4.eql(t2, Fp4.ONE))
            break;
          t2 = Fp4.sqr(t2);
        }
        const ge = Fp4.pow(g, _1n8 << BigInt(r - m2 - 1));
        g = Fp4.sqr(ge);
        x = Fp4.mul(x, ge);
        b = Fp4.mul(b, g);
        r = m2;
      }
      return x;
    };
  }
  function FpSqrt2(P) {
    if (P % _4n3 === _3n4) {
      const p1div4 = (P + _1n8) / _4n3;
      return function sqrt3mod43(Fp4, n) {
        const root = Fp4.pow(n, p1div4);
        if (!Fp4.eql(Fp4.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _8n4 === _5n3) {
      const c1 = (P - _5n3) / _8n4;
      return function sqrt5mod83(Fp4, n) {
        const n2 = Fp4.mul(n, _2n7);
        const v = Fp4.pow(n2, c1);
        const nv = Fp4.mul(n, v);
        const i = Fp4.mul(Fp4.mul(nv, _2n7), v);
        const root = Fp4.mul(nv, Fp4.sub(i, Fp4.ONE));
        if (!Fp4.eql(Fp4.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _16n2 === _9n2) {
    }
    return tonelliShanks2(P);
  }
  var isNegativeLE2 = (num, modulo) => (mod3(num, modulo) & _1n8) === _1n8;
  var FIELD_FIELDS2 = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField2(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS2.reduce((map2, val) => {
      map2[val] = "function";
      return map2;
    }, initial);
    return validateObject2(field, opts);
  }
  function FpPow2(f, num, power) {
    if (power < _0n8)
      throw new Error("Expected power > 0");
    if (power === _0n8)
      return f.ONE;
    if (power === _1n8)
      return num;
    let p = f.ONE;
    let d2 = num;
    while (power > _0n8) {
      if (power & _1n8)
        p = f.mul(p, d2);
      d2 = f.sqr(d2);
      power >>= _1n8;
    }
    return p;
  }
  function FpInvertBatch2(f, nums) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
      if (f.is0(num))
        return acc;
      tmp[i] = acc;
      return f.mul(acc, num);
    }, f.ONE);
    const inverted = f.inv(lastMultiplied);
    nums.reduceRight((acc, num, i) => {
      if (f.is0(num))
        return acc;
      tmp[i] = f.mul(acc, tmp[i]);
      return f.mul(acc, num);
    }, inverted);
    return tmp;
  }
  function nLength2(n, nBitLength) {
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field2(ORDER, bitLen3, isLE3 = false, redef = {}) {
    if (ORDER <= _0n8)
      throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength2(ORDER, bitLen3);
    if (BYTES > 2048)
      throw new Error("Field lengths over 2048 bytes are not supported");
    const sqrtP = FpSqrt2(ORDER);
    const f = Object.freeze({
      ORDER,
      BITS,
      BYTES,
      MASK: bitMask2(BITS),
      ZERO: _0n8,
      ONE: _1n8,
      create: (num) => mod3(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
        return _0n8 <= num && num < ORDER;
      },
      is0: (num) => num === _0n8,
      isOdd: (num) => (num & _1n8) === _1n8,
      neg: (num) => mod3(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod3(num * num, ORDER),
      add: (lhs, rhs) => mod3(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod3(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod3(lhs * rhs, ORDER),
      pow: (num, power) => FpPow2(f, num, power),
      div: (lhs, rhs) => mod3(lhs * invert2(rhs, ORDER), ORDER),
      // Same as above, but doesn't normalize
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert2(num, ORDER),
      sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
      invertBatch: (lst) => FpInvertBatch2(f, lst),
      // TODO: do we really need constant cmov?
      // We don't have const-time bigints anyway, so probably will be not very useful
      cmov: (a, b, c) => c ? b : a,
      toBytes: (num) => isLE3 ? numberToBytesLE2(num, BYTES) : numberToBytesBE2(num, BYTES),
      fromBytes: (bytes2) => {
        if (bytes2.length !== BYTES)
          throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
        return isLE3 ? bytesToNumberLE2(bytes2) : bytesToNumberBE2(bytes2);
      }
    });
    return Object.freeze(f);
  }
  function FpSqrtEven2(Fp4, elm) {
    if (!Fp4.isOdd)
      throw new Error(`Field doesn't have isOdd`);
    const root = Fp4.sqrt(elm);
    return Fp4.isOdd(root) ? Fp4.neg(root) : root;
  }

  // ../node_modules/@noble/curves/esm/abstract/curve.js
  var _0n9 = BigInt(0);
  var _1n9 = BigInt(1);
  function wNAF2(c, bits) {
    const constTimeNegate2 = (condition, item) => {
      const neg = item.negate();
      return condition ? neg : item;
    };
    const opts = (W) => {
      const windows = Math.ceil(bits / W) + 1;
      const windowSize = 2 ** (W - 1);
      return { windows, windowSize };
    };
    return {
      constTimeNegate: constTimeNegate2,
      // non-const time multiplication ladder
      unsafeLadder(elm, n) {
        let p = c.ZERO;
        let d2 = elm;
        while (n > _0n9) {
          if (n & _1n9)
            p = p.add(d2);
          d2 = d2.double();
          n >>= _1n9;
        }
        return p;
      },
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
       * - 𝑊 is the window size
       * - 𝑛 is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(elm, W) {
        const { windows, windowSize } = opts(W);
        const points = [];
        let p = elm;
        let base37 = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base37 = p;
          points.push(base37);
          for (let i = 1; i < windowSize; i++) {
            base37 = base37.add(p);
            points.push(base37);
          }
          p = base37.double();
        }
        return points;
      },
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @returns real and fake (for const-time) points
       */
      wNAF(W, precomputes, n) {
        const { windows, windowSize } = opts(W);
        let p = c.ZERO;
        let f = c.BASE;
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n & mask);
          n >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n9;
          }
          const offset1 = offset;
          const offset2 = offset + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f = f.add(constTimeNegate2(cond1, precomputes[offset1]));
          } else {
            p = p.add(constTimeNegate2(cond2, precomputes[offset2]));
          }
        }
        return { p, f };
      },
      wNAFCached(P, precomputesMap, n, transform) {
        const W = P._WINDOW_SIZE || 1;
        let comp = precomputesMap.get(P);
        if (!comp) {
          comp = this.precomputeWindow(P, W);
          if (W !== 1) {
            precomputesMap.set(P, transform(comp));
          }
        }
        return this.wNAF(W, comp, n);
      }
    };
  }
  function validateBasic(curve) {
    validateField2(curve.Fp);
    validateObject2(curve, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...nLength2(curve.n, curve.nBitLength),
      ...curve,
      ...{ p: curve.Fp.ORDER }
    });
  }

  // ../node_modules/@noble/curves/esm/abstract/edwards.js
  var _0n10 = BigInt(0);
  var _1n10 = BigInt(1);
  var _2n8 = BigInt(2);
  var _8n5 = BigInt(8);
  var VERIFY_DEFAULT = { zip215: true };
  function validateOpts(curve) {
    const opts = validateBasic(curve);
    validateObject2(curve, {
      hash: "function",
      a: "bigint",
      d: "bigint",
      randomBytes: "function"
    }, {
      adjustScalarBytes: "function",
      domain: "function",
      uvRatio: "function",
      mapToCurve: "function"
    });
    return Object.freeze({ ...opts });
  }
  function twistedEdwards2(curveDef) {
    const CURVE2 = validateOpts(curveDef);
    const { Fp: Fp4, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes5, nByteLength, h: cofactor } = CURVE2;
    const MASK = _2n8 << BigInt(nByteLength * 8) - _1n10;
    const modP = Fp4.create;
    const uvRatio4 = CURVE2.uvRatio || ((u, v) => {
      try {
        return { isValid: true, value: Fp4.sqrt(u * Fp4.inv(v)) };
      } catch (e) {
        return { isValid: false, value: _0n10 };
      }
    });
    const adjustScalarBytes4 = CURVE2.adjustScalarBytes || ((bytes2) => bytes2);
    const domain = CURVE2.domain || ((data, ctx, phflag) => {
      if (ctx.length || phflag)
        throw new Error("Contexts/pre-hash are not supported");
      return data;
    });
    const inBig = (n) => typeof n === "bigint" && _0n10 < n;
    const inRange3 = (n, max) => inBig(n) && inBig(max) && n < max;
    const in0MaskRange = (n) => n === _0n10 || inRange3(n, MASK);
    function assertInRange(n, max) {
      if (inRange3(n, max))
        return n;
      throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);
    }
    function assertGE0(n) {
      return n === _0n10 ? n : assertInRange(n, CURVE_ORDER);
    }
    const pointPrecomputes4 = /* @__PURE__ */ new Map();
    function isPoint(other) {
      if (!(other instanceof Point2))
        throw new Error("ExtendedPoint expected");
    }
    class Point2 {
      constructor(ex, ey, ez, et) {
        this.ex = ex;
        this.ey = ey;
        this.ez = ez;
        this.et = et;
        if (!in0MaskRange(ex))
          throw new Error("x required");
        if (!in0MaskRange(ey))
          throw new Error("y required");
        if (!in0MaskRange(ez))
          throw new Error("z required");
        if (!in0MaskRange(et))
          throw new Error("t required");
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static fromAffine(p) {
        if (p instanceof Point2)
          throw new Error("extended point not allowed");
        const { x, y: y2 } = p || {};
        if (!in0MaskRange(x) || !in0MaskRange(y2))
          throw new Error("invalid affine point");
        return new Point2(x, y2, _1n10, modP(x * y2));
      }
      static normalizeZ(points) {
        const toInv = Fp4.invertBatch(points.map((p) => p.ez));
        return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
      }
      // "Private method", don't use it directly
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes4.delete(this);
      }
      // Not required for fromHex(), which always creates valid points.
      // Could be useful for fromAffine().
      assertValidity() {
        const { a, d: d2 } = CURVE2;
        if (this.is0())
          throw new Error("bad point: ZERO");
        const { ex: X, ey: Y, ez: Z, et: T } = this;
        const X2 = modP(X * X);
        const Y2 = modP(Y * Y);
        const Z2 = modP(Z * Z);
        const Z4 = modP(Z2 * Z2);
        const aX2 = modP(X2 * a);
        const left = modP(Z2 * modP(aX2 + Y2));
        const right = modP(Z4 + modP(d2 * modP(X2 * Y2)));
        if (left !== right)
          throw new Error("bad point: equation left != right (1)");
        const XY = modP(X * Y);
        const ZT = modP(Z * T);
        if (XY !== ZT)
          throw new Error("bad point: equation left != right (2)");
      }
      // Compare one point to another.
      equals(other) {
        isPoint(other);
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const { ex: X2, ey: Y2, ez: Z2 } = other;
        const X1Z2 = modP(X1 * Z2);
        const X2Z1 = modP(X2 * Z1);
        const Y1Z2 = modP(Y1 * Z2);
        const Y2Z1 = modP(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      is0() {
        return this.equals(Point2.ZERO);
      }
      negate() {
        return new Point2(modP(-this.ex), this.ey, this.ez, modP(-this.et));
      }
      // Fast algo for doubling Extended Point.
      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
      // Cost: 4M + 4S + 1*a + 6add + 1*2.
      double() {
        const { a } = CURVE2;
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const A = modP(X1 * X1);
        const B = modP(Y1 * Y1);
        const C = modP(_2n8 * modP(Z1 * Z1));
        const D = modP(a * A);
        const x1y1 = X1 + Y1;
        const E = modP(modP(x1y1 * x1y1) - A - B);
        const G2 = D + B;
        const F = G2 - C;
        const H = D - B;
        const X3 = modP(E * F);
        const Y3 = modP(G2 * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G2);
        return new Point2(X3, Y3, Z3, T3);
      }
      // Fast algo for adding 2 Extended Points.
      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
      // Cost: 9M + 1*a + 1*d + 7add.
      add(other) {
        isPoint(other);
        const { a, d: d2 } = CURVE2;
        const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
        if (a === BigInt(-1)) {
          const A2 = modP((Y1 - X1) * (Y2 + X2));
          const B2 = modP((Y1 + X1) * (Y2 - X2));
          const F2 = modP(B2 - A2);
          if (F2 === _0n10)
            return this.double();
          const C2 = modP(Z1 * _2n8 * T2);
          const D2 = modP(T1 * _2n8 * Z2);
          const E2 = D2 + C2;
          const G3 = B2 + A2;
          const H2 = D2 - C2;
          const X32 = modP(E2 * F2);
          const Y32 = modP(G3 * H2);
          const T32 = modP(E2 * H2);
          const Z32 = modP(F2 * G3);
          return new Point2(X32, Y32, Z32, T32);
        }
        const A = modP(X1 * X2);
        const B = modP(Y1 * Y2);
        const C = modP(T1 * d2 * T2);
        const D = modP(Z1 * Z2);
        const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
        const F = D - C;
        const G2 = D + C;
        const H = modP(B - a * A);
        const X3 = modP(E * F);
        const Y3 = modP(G2 * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G2);
        return new Point2(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      wNAF(n) {
        return wnaf.wNAFCached(this, pointPrecomputes4, n, Point2.normalizeZ);
      }
      // Constant-time multiplication.
      multiply(scalar) {
        const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));
        return Point2.normalizeZ([p, f])[0];
      }
      // Non-constant-time multiplication. Uses double-and-add algorithm.
      // It's faster, but should only be used when you don't care about
      // an exposed private key e.g. sig verification.
      // Does NOT allow scalars higher than CURVE.n.
      multiplyUnsafe(scalar) {
        let n = assertGE0(scalar);
        if (n === _0n10)
          return I;
        if (this.equals(I) || n === _1n10)
          return this;
        if (this.equals(G))
          return this.wNAF(n).p;
        return wnaf.unsafeLadder(this, n);
      }
      // Checks if point is of small order.
      // If you add something to small order point, you will have "dirty"
      // point with torsion component.
      // Multiplies point by cofactor and checks if the result is 0.
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      // Multiplies point by curve order and checks if the result is 0.
      // Returns `false` is the point is dirty.
      isTorsionFree() {
        return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
      }
      // Converts Extended point to default (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      toAffine(iz) {
        const { ex: x, ey: y2, ez: z } = this;
        const is0 = this.is0();
        if (iz == null)
          iz = is0 ? _8n5 : Fp4.inv(z);
        const ax = modP(x * iz);
        const ay = modP(y2 * iz);
        const zz = modP(z * iz);
        if (is0)
          return { x: _0n10, y: _1n10 };
        if (zz !== _1n10)
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      }
      clearCofactor() {
        const { h: cofactor2 } = CURVE2;
        if (cofactor2 === _1n10)
          return this;
        return this.multiplyUnsafe(cofactor2);
      }
      // Converts hash string or Uint8Array to Point.
      // Uses algo from RFC8032 5.1.3.
      static fromHex(hex, zip215 = false) {
        const { d: d2, a } = CURVE2;
        const len = Fp4.BYTES;
        hex = ensureBytes2("pointHex", hex, len);
        const normed = hex.slice();
        const lastByte = hex[len - 1];
        normed[len - 1] = lastByte & ~128;
        const y2 = bytesToNumberLE2(normed);
        if (y2 === _0n10) {
        } else {
          if (zip215)
            assertInRange(y2, MASK);
          else
            assertInRange(y2, Fp4.ORDER);
        }
        const y22 = modP(y2 * y2);
        const u = modP(y22 - _1n10);
        const v = modP(d2 * y22 - a);
        let { isValid, value: x } = uvRatio4(u, v);
        if (!isValid)
          throw new Error("Point.fromHex: invalid y coordinate");
        const isXOdd = (x & _1n10) === _1n10;
        const isLastByteOdd = (lastByte & 128) !== 0;
        if (!zip215 && x === _0n10 && isLastByteOdd)
          throw new Error("Point.fromHex: x=0 and x_0=1");
        if (isLastByteOdd !== isXOdd)
          x = modP(-x);
        return Point2.fromAffine({ x, y: y2 });
      }
      static fromPrivateKey(privKey) {
        return getExtendedPublicKey(privKey).point;
      }
      toRawBytes() {
        const { x, y: y2 } = this.toAffine();
        const bytes2 = numberToBytesLE2(y2, Fp4.BYTES);
        bytes2[bytes2.length - 1] |= x & _1n10 ? 128 : 0;
        return bytes2;
      }
      toHex() {
        return bytesToHex3(this.toRawBytes());
      }
    }
    Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy, _1n10, modP(CURVE2.Gx * CURVE2.Gy));
    Point2.ZERO = new Point2(_0n10, _1n10, _1n10, _0n10);
    const { BASE: G, ZERO: I } = Point2;
    const wnaf = wNAF2(Point2, nByteLength * 8);
    function modN(a) {
      return mod3(a, CURVE_ORDER);
    }
    function modN_LE(hash2) {
      return modN(bytesToNumberLE2(hash2));
    }
    function getExtendedPublicKey(key) {
      const len = nByteLength;
      key = ensureBytes2("private key", key, len);
      const hashed = ensureBytes2("hashed private key", cHash(key), 2 * len);
      const head = adjustScalarBytes4(hashed.slice(0, len));
      const prefix = hashed.slice(len, 2 * len);
      const scalar = modN_LE(head);
      const point = G.multiply(scalar);
      const pointBytes = point.toRawBytes();
      return { head, prefix, scalar, point, pointBytes };
    }
    function getPublicKey(privKey) {
      return getExtendedPublicKey(privKey).pointBytes;
    }
    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
      const msg = concatBytes3(...msgs);
      return modN_LE(cHash(domain(msg, ensureBytes2("context", context), !!prehash)));
    }
    function sign3(msg, privKey, options = {}) {
      msg = ensureBytes2("message", msg);
      if (prehash)
        msg = prehash(msg);
      const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
      const r = hashDomainToScalar(options.context, prefix, msg);
      const R = G.multiply(r).toRawBytes();
      const k = hashDomainToScalar(options.context, R, pointBytes, msg);
      const s2 = modN(r + k * scalar);
      assertGE0(s2);
      const res = concatBytes3(R, numberToBytesLE2(s2, Fp4.BYTES));
      return ensureBytes2("result", res, nByteLength * 2);
    }
    const verifyOpts = VERIFY_DEFAULT;
    function verify2(sig, msg, publicKey, options = verifyOpts) {
      const { context, zip215 } = options;
      const len = Fp4.BYTES;
      sig = ensureBytes2("signature", sig, 2 * len);
      msg = ensureBytes2("message", msg);
      if (prehash)
        msg = prehash(msg);
      const s2 = bytesToNumberLE2(sig.slice(len, 2 * len));
      let A, R, SB;
      try {
        A = Point2.fromHex(publicKey, zip215);
        R = Point2.fromHex(sig.slice(0, len), zip215);
        SB = G.multiplyUnsafe(s2);
      } catch (error) {
        return false;
      }
      if (!zip215 && A.isSmallOrder())
        return false;
      const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
      const RkA = R.add(A.multiplyUnsafe(k));
      return RkA.subtract(SB).clearCofactor().equals(Point2.ZERO);
    }
    G._setWindowSize(8);
    const utils2 = {
      getExtendedPublicKey,
      // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
      randomPrivateKey: () => randomBytes5(Fp4.BYTES),
      /**
       * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
       * values. This slows down first getPublicKey() by milliseconds (see Speed section),
       * but allows to speed-up subsequent getPublicKey() calls up to 20x.
       * @param windowSize 2, 4, 8, 16
       */
      precompute(windowSize = 8, point = Point2.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    return {
      CURVE: CURVE2,
      getPublicKey,
      sign: sign3,
      verify: verify2,
      ExtendedPoint: Point2,
      utils: utils2
    };
  }

  // ../node_modules/@noble/curves/esm/abstract/montgomery.js
  var _0n11 = BigInt(0);
  var _1n11 = BigInt(1);
  function validateOpts2(curve) {
    validateObject2(curve, {
      a: "bigint"
    }, {
      montgomeryBits: "isSafeInteger",
      nByteLength: "isSafeInteger",
      adjustScalarBytes: "function",
      domain: "function",
      powPminus2: "function",
      Gu: "bigint"
    });
    return Object.freeze({ ...curve });
  }
  function montgomery(curveDef) {
    const CURVE2 = validateOpts2(curveDef);
    const { P } = CURVE2;
    const modP = (n) => mod3(n, P);
    const montgomeryBits = CURVE2.montgomeryBits;
    const montgomeryBytes = Math.ceil(montgomeryBits / 8);
    const fieldLen2 = CURVE2.nByteLength;
    const adjustScalarBytes4 = CURVE2.adjustScalarBytes || ((bytes2) => bytes2);
    const powPminus2 = CURVE2.powPminus2 || ((x) => pow(x, P - BigInt(2), P));
    function cswap(swap, x_2, x_3) {
      const dummy = modP(swap * (x_2 - x_3));
      x_2 = modP(x_2 - dummy);
      x_3 = modP(x_3 + dummy);
      return [x_2, x_3];
    }
    function assertFieldElement(n) {
      if (typeof n === "bigint" && _0n11 <= n && n < P)
        return n;
      throw new Error("Expected valid scalar 0 < scalar < CURVE.P");
    }
    const a24 = (CURVE2.a - BigInt(2)) / BigInt(4);
    function montgomeryLadder(pointU, scalar) {
      const u = assertFieldElement(pointU);
      const k = assertFieldElement(scalar);
      const x_1 = u;
      let x_2 = _1n11;
      let z_2 = _0n11;
      let x_3 = u;
      let z_3 = _1n11;
      let swap = _0n11;
      let sw;
      for (let t = BigInt(montgomeryBits - 1); t >= _0n11; t--) {
        const k_t = k >> t & _1n11;
        swap ^= k_t;
        sw = cswap(swap, x_2, x_3);
        x_2 = sw[0];
        x_3 = sw[1];
        sw = cswap(swap, z_2, z_3);
        z_2 = sw[0];
        z_3 = sw[1];
        swap = k_t;
        const A = x_2 + z_2;
        const AA = modP(A * A);
        const B = x_2 - z_2;
        const BB = modP(B * B);
        const E = AA - BB;
        const C = x_3 + z_3;
        const D = x_3 - z_3;
        const DA = modP(D * A);
        const CB = modP(C * B);
        const dacb = DA + CB;
        const da_cb = DA - CB;
        x_3 = modP(dacb * dacb);
        z_3 = modP(x_1 * modP(da_cb * da_cb));
        x_2 = modP(AA * BB);
        z_2 = modP(E * (AA + modP(a24 * E)));
      }
      sw = cswap(swap, x_2, x_3);
      x_2 = sw[0];
      x_3 = sw[1];
      sw = cswap(swap, z_2, z_3);
      z_2 = sw[0];
      z_3 = sw[1];
      const z2 = powPminus2(z_2);
      return modP(x_2 * z2);
    }
    function encodeUCoordinate(u) {
      return numberToBytesLE2(modP(u), montgomeryBytes);
    }
    function decodeUCoordinate(uEnc) {
      const u = ensureBytes2("u coordinate", uEnc, montgomeryBytes);
      if (fieldLen2 === montgomeryBytes)
        u[fieldLen2 - 1] &= 127;
      return bytesToNumberLE2(u);
    }
    function decodeScalar(n) {
      const bytes2 = ensureBytes2("scalar", n);
      if (bytes2.length !== montgomeryBytes && bytes2.length !== fieldLen2)
        throw new Error(`Expected ${montgomeryBytes} or ${fieldLen2} bytes, got ${bytes2.length}`);
      return bytesToNumberLE2(adjustScalarBytes4(bytes2));
    }
    function scalarMult(scalar, u) {
      const pointU = decodeUCoordinate(u);
      const _scalar = decodeScalar(scalar);
      const pu = montgomeryLadder(pointU, _scalar);
      if (pu === _0n11)
        throw new Error("Invalid private or public key received");
      return encodeUCoordinate(pu);
    }
    const GuBytes = encodeUCoordinate(CURVE2.Gu);
    function scalarMultBase(scalar) {
      return scalarMult(scalar, GuBytes);
    }
    return {
      scalarMult,
      scalarMultBase,
      getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
      getPublicKey: (privateKey) => scalarMultBase(privateKey),
      utils: { randomPrivateKey: () => CURVE2.randomBytes(CURVE2.nByteLength) },
      GuBytes
    };
  }

  // ../node_modules/@noble/curves/esm/ed25519.js
  var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
  var ED25519_SQRT_M12 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
  var _0n12 = BigInt(0);
  var _1n12 = BigInt(1);
  var _2n9 = BigInt(2);
  var _5n4 = BigInt(5);
  var _10n = BigInt(10);
  var _20n = BigInt(20);
  var _40n = BigInt(40);
  var _80n = BigInt(80);
  function ed25519_pow_2_252_32(x) {
    const P = ED25519_P;
    const x2 = x * x % P;
    const b2 = x2 * x % P;
    const b4 = pow22(b2, _2n9, P) * b2 % P;
    const b5 = pow22(b4, _1n12, P) * x % P;
    const b10 = pow22(b5, _5n4, P) * b5 % P;
    const b20 = pow22(b10, _10n, P) * b10 % P;
    const b40 = pow22(b20, _20n, P) * b20 % P;
    const b80 = pow22(b40, _40n, P) * b40 % P;
    const b160 = pow22(b80, _80n, P) * b80 % P;
    const b240 = pow22(b160, _80n, P) * b80 % P;
    const b250 = pow22(b240, _10n, P) * b10 % P;
    const pow_p_5_8 = pow22(b250, _2n9, P) * x % P;
    return { pow_p_5_8, b2 };
  }
  function adjustScalarBytes2(bytes2) {
    bytes2[0] &= 248;
    bytes2[31] &= 127;
    bytes2[31] |= 64;
    return bytes2;
  }
  function uvRatio2(u, v) {
    const P = ED25519_P;
    const v3 = mod3(v * v * v, P);
    const v7 = mod3(v3 * v3 * v, P);
    const pow3 = ed25519_pow_2_252_32(u * v7).pow_p_5_8;
    let x = mod3(u * v3 * pow3, P);
    const vx2 = mod3(v * x * x, P);
    const root1 = x;
    const root2 = mod3(x * ED25519_SQRT_M12, P);
    const useRoot1 = vx2 === u;
    const useRoot2 = vx2 === mod3(-u, P);
    const noRoot = vx2 === mod3(-u * ED25519_SQRT_M12, P);
    if (useRoot1)
      x = root1;
    if (useRoot2 || noRoot)
      x = root2;
    if (isNegativeLE2(x, P))
      x = mod3(-x, P);
    return { isValid: useRoot1 || useRoot2, value: x };
  }
  var Fp2 = Field2(ED25519_P, void 0, true);
  var ed25519Defaults2 = {
    // Param: a
    a: BigInt(-1),
    // d is equal to -121665/121666 over finite field.
    // Negative number is P - number, and division is invert(number, P)
    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
    // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n
    Fp: Fp2,
    // Subgroup order: how many points curve has
    // 2n**252n + 27742317777372353535851937790883648493n;
    n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
    // Cofactor
    h: BigInt(8),
    // Base point (x, y) aka generator point
    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
    hash: sha5127,
    randomBytes,
    adjustScalarBytes: adjustScalarBytes2,
    // dom2
    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
    // Constant-time, u/√v
    uvRatio: uvRatio2
  };
  function ed25519_domain(data, ctx, phflag) {
    if (ctx.length > 255)
      throw new Error("Context is too big");
    return concatBytes(utf8ToBytes("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
  }
  var ed25519ctx = /* @__PURE__ */ twistedEdwards2({
    ...ed25519Defaults2,
    domain: ed25519_domain
  });
  var ed25519ph = /* @__PURE__ */ twistedEdwards2({
    ...ed25519Defaults2,
    domain: ed25519_domain,
    prehash: sha5127
  });
  var x25519 = /* @__PURE__ */ (() => montgomery({
    P: ED25519_P,
    a: BigInt(486662),
    montgomeryBits: 255,
    nByteLength: 32,
    Gu: BigInt(9),
    powPminus2: (x) => {
      const P = ED25519_P;
      const { pow_p_5_8, b2 } = ed25519_pow_2_252_32(x);
      return mod3(pow22(pow_p_5_8, BigInt(3), P) * b2, P);
    },
    adjustScalarBytes: adjustScalarBytes2,
    randomBytes
  }))();
  var ELL2_C1 = (Fp2.ORDER + BigInt(3)) / BigInt(8);
  var ELL2_C2 = Fp2.pow(_2n9, ELL2_C1);
  var ELL2_C3 = Fp2.sqrt(Fp2.neg(Fp2.ONE));
  var ELL2_C4 = (Fp2.ORDER - BigInt(5)) / BigInt(8);
  var ELL2_J = BigInt(486662);
  var ELL2_C1_EDWARDS = FpSqrtEven2(Fp2, Fp2.neg(BigInt(486664)));
  var SQRT_AD_MINUS_ONE2 = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
  var INVSQRT_A_MINUS_D2 = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
  var ONE_MINUS_D_SQ2 = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
  var D_MINUS_ONE_SQ2 = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
  var MAX_255B2 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

  // ../node_modules/@noble/hashes/esm/hmac.js
  var HMAC2 = class extends Hash {
    constructor(hash2, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      hash(hash2);
      const key = toBytes(_key);
      this.iHash = hash2.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash2.create();
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54 ^ 92;
      this.oHash.update(pad);
      pad.fill(0);
    }
    update(buf) {
      exists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      exists(this);
      bytes(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac2 = (hash2, key, message2) => new HMAC2(hash2, key).update(message2).digest();
  hmac2.create = (hash2, key) => new HMAC2(hash2, key);

  // ../node_modules/@noble/hashes/esm/hkdf.js
  function extract(hash2, ikm, salt) {
    hash(hash2);
    if (salt === void 0)
      salt = new Uint8Array(hash2.outputLen);
    return hmac2(hash2, toBytes(salt), toBytes(ikm));
  }
  var HKDF_COUNTER = /* @__PURE__ */ new Uint8Array([0]);
  var EMPTY_BUFFER = /* @__PURE__ */ new Uint8Array();
  function expand(hash2, prk, info, length21 = 32) {
    hash(hash2);
    number(length21);
    if (length21 > 255 * hash2.outputLen)
      throw new Error("Length should be <= 255*HashLen");
    const blocks = Math.ceil(length21 / hash2.outputLen);
    if (info === void 0)
      info = EMPTY_BUFFER;
    const okm = new Uint8Array(blocks * hash2.outputLen);
    const HMAC4 = hmac2.create(hash2, prk);
    const HMACTmp = HMAC4._cloneInto();
    const T = new Uint8Array(HMAC4.outputLen);
    for (let counter = 0; counter < blocks; counter++) {
      HKDF_COUNTER[0] = counter + 1;
      HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
      okm.set(T, hash2.outputLen * counter);
      HMAC4._cloneInto(HMACTmp);
    }
    HMAC4.destroy();
    HMACTmp.destroy();
    T.fill(0);
    HKDF_COUNTER.fill(0);
    return okm.slice(0, length21);
  }

  // ../node_modules/@chainsafe/libp2p-noise/dist/src/crypto/js.js
  var pureJsCrypto = {
    hashSHA256(data) {
      return sha2562(data.subarray());
    },
    getHKDF(ck, ikm) {
      const prk = extract(sha2562, ikm, ck);
      const okmU8Array = expand(sha2562, prk, void 0, 96);
      const okm = okmU8Array;
      const k1 = okm.subarray(0, 32);
      const k2 = okm.subarray(32, 64);
      const k3 = okm.subarray(64, 96);
      return [k1, k2, k3];
    },
    generateX25519KeyPair() {
      const secretKey = x25519.utils.randomPrivateKey();
      const publicKey = x25519.getPublicKey(secretKey);
      return {
        publicKey,
        privateKey: secretKey
      };
    },
    generateX25519KeyPairFromSeed(seed) {
      const publicKey = x25519.getPublicKey(seed);
      return {
        publicKey,
        privateKey: seed
      };
    },
    generateX25519SharedKey(privateKey, publicKey) {
      return x25519.getSharedSecret(privateKey.subarray(), publicKey.subarray());
    },
    chaCha20Poly1305Encrypt(plaintext, nonce, ad, k) {
      return chacha20poly1305(k, nonce, ad).encrypt(plaintext.subarray());
    },
    chaCha20Poly1305Decrypt(ciphertext, nonce, ad, k, dst) {
      return chacha20poly1305(k, nonce, ad).decrypt(ciphertext.subarray(), dst);
    }
  };

  // ../node_modules/@chainsafe/libp2p-noise/dist/src/crypto/index.browser.js
  var defaultCrypto = pureJsCrypto;

  // ../node_modules/@chainsafe/libp2p-noise/dist/src/crypto.js
  function wrapCrypto(crypto6) {
    return {
      generateKeypair: crypto6.generateX25519KeyPair,
      dh: (keypair, publicKey) => crypto6.generateX25519SharedKey(keypair.privateKey, publicKey).subarray(0, 32),
      encrypt: crypto6.chaCha20Poly1305Encrypt,
      decrypt: crypto6.chaCha20Poly1305Decrypt,
      hash: crypto6.hashSHA256,
      hkdf: crypto6.getHKDF
    };
  }

  // ../node_modules/@chainsafe/libp2p-noise/dist/src/encoder.js
  var uint16BEEncode = (value) => {
    const target = allocUnsafe10(2);
    target[0] = value >> 8;
    target[1] = value;
    return target;
  };
  uint16BEEncode.bytes = 2;
  var uint16BEDecode = (data) => {
    if (data.length < 2)
      throw RangeError("Could not decode int16BE");
    if (data instanceof Uint8Array) {
      let value = 0;
      value += data[0] << 8;
      value += data[1];
      return value;
    }
    return data.getUint16(0);
  };
  uint16BEDecode.bytes = 2;

  // ../node_modules/@chainsafe/libp2p-noise/dist/src/metrics.js
  function registerMetrics(metrics) {
    return {
      xxHandshakeSuccesses: metrics.registerCounter("libp2p_noise_xxhandshake_successes_total", {
        help: "Total count of noise xxHandshakes successes_"
      }),
      xxHandshakeErrors: metrics.registerCounter("libp2p_noise_xxhandshake_error_total", {
        help: "Total count of noise xxHandshakes errors"
      }),
      encryptedPackets: metrics.registerCounter("libp2p_noise_encrypted_packets_total", {
        help: "Total count of noise encrypted packets successfully"
      }),
      decryptedPackets: metrics.registerCounter("libp2p_noise_decrypted_packets_total", {
        help: "Total count of noise decrypted packets"
      }),
      decryptErrors: metrics.registerCounter("libp2p_noise_decrypt_errors_total", {
        help: "Total count of noise decrypt errors"
      })
    };
  }

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports6 = {};
  __export(base10_exports6, {
    base10: () => base106
  });

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bytes.js
  var empty6 = new Uint8Array(0);
  function equals15(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce6(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function fromString11(str) {
    return new TextEncoder().encode(str);
  }
  function toString10(b) {
    return new TextDecoder().decode(b);
  }

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/vendor/base-x.js
  function base7(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src6 = base7;
  var _brrp__multiformats_scope_baseX6 = src6;
  var base_x_default6 = _brrp__multiformats_scope_baseX6;

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base.js
  var Encoder7 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder7 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or6(this, decoder);
    }
  };
  var ComposedDecoder6 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or6(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or6(left, right) {
    return new ComposedDecoder6({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec6 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder7(name19, prefix, baseEncode);
      this.decoder = new Decoder7(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from11({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec6(name19, prefix, encode79, decode99);
  }
  function baseX6({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default6(alphabet18, name19);
    return from11({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce6(decode99(text))
    });
  }
  function decode29(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode24(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx6(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc46486({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx6(alphabet18);
    return from11({
      prefix,
      name: name19,
      encode(input) {
        return encode24(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode29(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base10.js
  var base106 = baseX6({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports6 = {};
  __export(base16_exports6, {
    base16: () => base166,
    base16upper: () => base16upper6
  });
  var base166 = rfc46486({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper6 = rfc46486({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports6 = {};
  __export(base2_exports6, {
    base2: () => base26
  });
  var base26 = rfc46486({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports6 = {};
  __export(base256emoji_exports6, {
    base256emoji: () => base256emoji6
  });
  var alphabet6 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars6 = alphabet6.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes6 = alphabet6.reduce((p, c, i) => {
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
  }, []);
  function encode25(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars6[c];
      return p;
    }, "");
  }
  function decode30(str) {
    const byts = [];
    for (const char of str) {
      const codePoint = char.codePointAt(0);
      if (codePoint == null) {
        throw new Error(`Invalid character: ${char}`);
      }
      const byt = alphabetCharsToBytes6[codePoint];
      if (byt == null) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji6 = from11({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode25,
    decode: decode30
  });

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports6 = {};
  __export(base32_exports6, {
    base32: () => base326,
    base32hex: () => base32hex6,
    base32hexpad: () => base32hexpad6,
    base32hexpadupper: () => base32hexpadupper6,
    base32hexupper: () => base32hexupper6,
    base32pad: () => base32pad6,
    base32padupper: () => base32padupper6,
    base32upper: () => base32upper6,
    base32z: () => base32z6
  });
  var base326 = rfc46486({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper6 = rfc46486({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad6 = rfc46486({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper6 = rfc46486({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex6 = rfc46486({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper6 = rfc46486({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad6 = rfc46486({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper6 = rfc46486({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z6 = rfc46486({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports6 = {};
  __export(base36_exports6, {
    base36: () => base366,
    base36upper: () => base36upper6
  });
  var base366 = baseX6({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper6 = baseX6({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports6 = {};
  __export(base58_exports6, {
    base58btc: () => base58btc6,
    base58flickr: () => base58flickr6
  });
  var base58btc6 = baseX6({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr6 = baseX6({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports6 = {};
  __export(base64_exports6, {
    base64: () => base646,
    base64pad: () => base64pad6,
    base64url: () => base64url6,
    base64urlpad: () => base64urlpad6
  });
  var base646 = rfc46486({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad6 = rfc46486({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url6 = rfc46486({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad6 = rfc46486({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports6 = {};
  __export(base8_exports6, {
    base8: () => base86
  });
  var base86 = rfc46486({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports11 = {};
  __export(identity_exports11, {
    identity: () => identity11
  });
  var identity11 = from11({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString10(buf),
    decode: (str) => fromString11(str)
  });

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/codecs/json.js
  var textEncoder6 = new TextEncoder();
  var textDecoder6 = new TextDecoder();

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports12 = {};
  __export(identity_exports12, {
    identity: () => identity12
  });

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_16 = encode26;
  var MSB7 = 128;
  var REST7 = 127;
  var MSBALL6 = ~REST7;
  var INT6 = Math.pow(2, 31);
  function encode26(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT6) {
      out[offset++] = num & 255 | MSB7;
      num /= 128;
    }
    while (num & MSBALL6) {
      out[offset++] = num & 255 | MSB7;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode26.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode31 = read7;
  var MSB$16 = 128;
  var REST$16 = 127;
  function read7(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read7.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$16) << shift : (b & REST$16) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$16);
    read7.bytes = counter - offset;
    return res;
  }
  var N17 = Math.pow(2, 7);
  var N27 = Math.pow(2, 14);
  var N37 = Math.pow(2, 21);
  var N47 = Math.pow(2, 28);
  var N57 = Math.pow(2, 35);
  var N67 = Math.pow(2, 42);
  var N77 = Math.pow(2, 49);
  var N86 = Math.pow(2, 56);
  var N96 = Math.pow(2, 63);
  var length7 = function(value) {
    return value < N17 ? 1 : value < N27 ? 2 : value < N37 ? 3 : value < N47 ? 4 : value < N57 ? 5 : value < N67 ? 6 : value < N77 ? 7 : value < N86 ? 8 : value < N96 ? 9 : 10;
  };
  var varint6 = {
    encode: encode_16,
    decode: decode31,
    encodingLength: length7
  };
  var _brrp_varint6 = varint6;
  var varint_default6 = _brrp_varint6;

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/varint.js
  function decode32(data, offset = 0) {
    const code18 = varint_default6.decode(data, offset);
    return [code18, varint_default6.decode.bytes];
  }
  function encodeTo6(int, target, offset = 0) {
    varint_default6.encode(int, target, offset);
    return target;
  }
  function encodingLength7(int) {
    return varint_default6.encodingLength(int);
  }

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/hashes/digest.js
  function create6(code18, digest18) {
    const size = digest18.byteLength;
    const sizeOffset = encodingLength7(code18);
    const digestOffset = sizeOffset + encodingLength7(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo6(code18, bytes2, 0);
    encodeTo6(size, bytes2, sizeOffset);
    bytes2.set(digest18, digestOffset);
    return new Digest6(code18, size, digest18, bytes2);
  }
  function decode33(multihash) {
    const bytes2 = coerce6(multihash);
    const [code18, sizeOffset] = decode32(bytes2);
    const [size, digestOffset] = decode32(bytes2.subarray(sizeOffset));
    const digest18 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest18.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest6(code18, size, digest18, bytes2);
  }
  function equals16(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals15(a.bytes, data.bytes);
    }
  }
  var Digest6 = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code18, size, digest18, bytes2) {
      this.code = code18;
      this.size = size;
      this.digest = digest18;
      this.bytes = bytes2;
    }
  };

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/hashes/identity.js
  var code6 = 0;
  var name6 = "identity";
  var encode27 = coerce6;
  function digest6(input) {
    return create6(code6, encode27(input));
  }
  var identity12 = { code: code6, name: name6, encode: encode27, digest: digest6 };

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports6 = {};
  __export(sha2_browser_exports6, {
    sha256: () => sha2569,
    sha512: () => sha5128
  });

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/hashes/hasher.js
  function from12({ name: name19, code: code18, encode: encode79 }) {
    return new Hasher6(name19, code18, encode79);
  }
  var Hasher6 = class {
    name;
    code;
    encode;
    constructor(name19, code18, encode79) {
      this.name = name19;
      this.code = code18;
      this.encode = encode79;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create6(this.code, result) : result.then((digest18) => create6(this.code, digest18));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  function sha6(name19) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name19, data));
  }
  var sha2569 = from12({
    name: "sha2-256",
    code: 18,
    encode: sha6("SHA-256")
  });
  var sha5128 = from12({
    name: "sha2-512",
    code: 19,
    encode: sha6("SHA-512")
  });

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/cid.js
  function format6(link, base37) {
    const { bytes: bytes2, version: version5 } = link;
    switch (version5) {
      case 0:
        return toStringV06(bytes2, baseCache6(link), base37 ?? base58btc6.encoder);
      default:
        return toStringV16(bytes2, baseCache6(link), base37 ?? base326.encoder);
    }
  }
  var cache6 = /* @__PURE__ */ new WeakMap();
  function baseCache6(cid) {
    const baseCache19 = cache6.get(cid);
    if (baseCache19 == null) {
      const baseCache20 = /* @__PURE__ */ new Map();
      cache6.set(cid, baseCache20);
      return baseCache20;
    }
    return baseCache19;
  }
  var CID6 = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version5, code18, multihash, bytes2) {
      this.code = code18;
      this.version = version5;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code18, multihash } = this;
          if (code18 !== DAG_PB_CODE6) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE6) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code18, digest: digest18 } = this.multihash;
          const multihash = create6(code18, digest18);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals16(self2.multihash, unknown.multihash);
    }
    toString(base37) {
      return format6(this, base37);
    }
    toJSON() {
      return { "/": format6(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version5, code: code18, multihash, bytes: bytes2 } = value;
        return new _CID(version5, code18, multihash, bytes2 ?? encodeCID6(version5, code18, multihash.bytes));
      } else if (value[cidSymbol6] === true) {
        const { version: version5, multihash, code: code18 } = value;
        const digest18 = decode33(multihash);
        return _CID.create(version5, code18, digest18);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version5, code18, digest18) {
      if (typeof code18 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest18.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version5) {
        case 0: {
          if (code18 !== DAG_PB_CODE6) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE6}) block encoding`);
          } else {
            return new _CID(version5, code18, digest18, digest18.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID6(version5, code18, digest18.bytes);
          return new _CID(version5, code18, digest18, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest18) {
      return _CID.create(0, DAG_PB_CODE6, digest18);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code18, digest18) {
      return _CID.create(1, code18, digest18);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes2) {
      const [cid, remainder] = _CID.decodeFirst(bytes2);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes2) {
      const specs = _CID.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce6(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest18 = new Digest6(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest18) : _CID.createV1(specs.codec, digest18);
      return [cid, bytes2.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length21] = decode32(initialBytes.subarray(offset));
        offset += length21;
        return i;
      };
      let version5 = next();
      let codec = DAG_PB_CODE6;
      if (version5 === 18) {
        version5 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version5 !== 0 && version5 !== 1) {
        throw new RangeError(`Invalid CID version ${version5}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version5, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base37) {
      const [prefix, bytes2] = parseCIDtoBytes6(source, base37);
      const cid = _CID.decode(bytes2);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache6(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes6(source, base37) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base37 ?? base58btc6;
        return [
          base58btc6.prefix,
          decoder.decode(`${base58btc6.prefix}${source}`)
        ];
      }
      case base58btc6.prefix: {
        const decoder = base37 ?? base58btc6;
        return [base58btc6.prefix, decoder.decode(source)];
      }
      case base326.prefix: {
        const decoder = base37 ?? base326;
        return [base326.prefix, decoder.decode(source)];
      }
      case base366.prefix: {
        const decoder = base37 ?? base366;
        return [base366.prefix, decoder.decode(source)];
      }
      default: {
        if (base37 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base37.decode(source)];
      }
    }
  }
  function toStringV06(bytes2, cache20, base37) {
    const { prefix } = base37;
    if (prefix !== base58btc6.prefix) {
      throw Error(`Cannot string encode V0 in ${base37.name} encoding`);
    }
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2).slice(1);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV16(bytes2, cache20, base37) {
    const { prefix } = base37;
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE6 = 112;
  var SHA_256_CODE6 = 18;
  function encodeCID6(version5, code18, multihash) {
    const codeOffset = encodingLength7(version5);
    const hashOffset = codeOffset + encodingLength7(code18);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo6(version5, bytes2, 0);
    encodeTo6(code18, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  }
  var cidSymbol6 = Symbol.for("@ipld/js-cid/CID");

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/multiformats/dist/src/basics.js
  var bases6 = { ...identity_exports11, ...base2_exports6, ...base8_exports6, ...base10_exports6, ...base16_exports6, ...base32_exports6, ...base36_exports6, ...base58_exports6, ...base64_exports6, ...base256emoji_exports6 };
  var hashes6 = { ...sha2_browser_exports6, ...identity_exports12 };

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec7(name19, prefix, encode79, decode99) {
    return {
      name: name19,
      prefix,
      encoder: {
        name: name19,
        prefix,
        encode: encode79
      },
      decoder: {
        decode: decode99
      }
    };
  }
  var string6 = createCodec7("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder3 = new TextEncoder();
    return encoder3.encode(str.substring(1));
  });
  var ascii6 = createCodec7("ascii", "a", (buf) => {
    let string19 = "a";
    for (let i = 0; i < buf.length; i++) {
      string19 += String.fromCharCode(buf[i]);
    }
    return string19;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe10(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  var BASES6 = {
    utf8: string6,
    "utf-8": string6,
    hex: bases6.base16,
    latin1: ascii6,
    ascii: ascii6,
    binary: ascii6,
    ...bases6
  };
  var bases_default6 = BASES6;

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/uint8arrays/dist/src/to-string.js
  function toString11(array, encoding = "utf8") {
    const base37 = bases_default6[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.encoder.encode(array).substring(1);
  }

  // ../node_modules/@chainsafe/libp2p-noise/dist/src/logger.js
  function logLocalStaticKeys(s2, keyLogger) {
    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
      return;
    }
    if (s2) {
      keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${toString11(s2.publicKey, "hex")}`);
      keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${toString11(s2.privateKey, "hex")}`);
    } else {
      keyLogger("Missing local static keys.");
    }
  }
  function logLocalEphemeralKeys(e, keyLogger) {
    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
      return;
    }
    if (e) {
      keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${toString11(e.publicKey, "hex")}`);
      keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${toString11(e.privateKey, "hex")}`);
    } else {
      keyLogger("Missing local ephemeral keys.");
    }
  }
  function logRemoteStaticKey(rs, keyLogger) {
    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
      return;
    }
    if (rs) {
      keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${toString11(rs.subarray(), "hex")}`);
    } else {
      keyLogger("Missing remote static public key.");
    }
  }
  function logRemoteEphemeralKey(re, keyLogger) {
    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
      return;
    }
    if (re) {
      keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${toString11(re.subarray(), "hex")}`);
    } else {
      keyLogger("Missing remote ephemeral keys.");
    }
  }
  function logCipherState(cs1, cs2, keyLogger) {
    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
      return;
    }
    keyLogger(`CIPHER_STATE_1 ${cs1.n.getUint64()} ${cs1.k && toString11(cs1.k, "hex")}`);
    keyLogger(`CIPHER_STATE_2 ${cs2.n.getUint64()} ${cs2.k && toString11(cs2.k, "hex")}`);
  }

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/uint8arrays/dist/src/util/as-uint8array.js
  function asUint8Array5(buf) {
    return buf;
  }

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/uint8arrays/dist/src/concat.js
  function concat5(arrays, length21) {
    if (length21 == null) {
      length21 = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output2 = allocUnsafe10(length21);
    let offset = 0;
    for (const arr of arrays) {
      output2.set(arr, offset);
      offset += arr.length;
    }
    return asUint8Array5(output2);
  }

  // ../node_modules/@chainsafe/libp2p-noise/node_modules/uint8arrays/dist/src/from-string.js
  function fromString12(string19, encoding = "utf8") {
    const base37 = bases_default6[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.decoder.decode(`${base37.prefix}${string19}`);
  }

  // ../node_modules/@chainsafe/libp2p-noise/dist/src/errors.js
  var InvalidCryptoExchangeError2 = class _InvalidCryptoExchangeError extends Error {
    code;
    constructor(message2 = "Invalid crypto exchange") {
      super(message2);
      this.code = _InvalidCryptoExchangeError.code;
    }
    static code = "ERR_INVALID_CRYPTO_EXCHANGE";
  };

  // ../node_modules/@chainsafe/libp2p-noise/dist/src/nonce.js
  var MIN_NONCE = 0;
  var MAX_NONCE = 4294967295;
  var ERR_MAX_NONCE = "Cipherstate has reached maximum n, a new handshake must be performed";
  var Nonce = class {
    n;
    bytes;
    view;
    constructor(n = MIN_NONCE) {
      this.n = n;
      this.bytes = alloc4(12);
      this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);
      this.view.setUint32(4, n, true);
    }
    increment() {
      this.n++;
      this.view.setUint32(4, this.n, true);
    }
    getBytes() {
      return this.bytes;
    }
    getUint64() {
      return this.n;
    }
    assertValue() {
      if (this.n > MAX_NONCE) {
        throw new Error(ERR_MAX_NONCE);
      }
    }
  };

  // ../node_modules/@chainsafe/libp2p-noise/dist/src/protocol.js
  var ZEROLEN = alloc4(0);
  var CipherState = class {
    k;
    n;
    crypto;
    constructor(crypto6, k = void 0, n = 0) {
      this.crypto = crypto6;
      this.k = k;
      this.n = new Nonce(n);
    }
    hasKey() {
      return Boolean(this.k);
    }
    encryptWithAd(ad, plaintext) {
      if (!this.hasKey()) {
        return plaintext;
      }
      this.n.assertValue();
      const e = this.crypto.encrypt(plaintext, this.n.getBytes(), ad, this.k);
      this.n.increment();
      return e;
    }
    decryptWithAd(ad, ciphertext, dst) {
      if (!this.hasKey()) {
        return ciphertext;
      }
      this.n.assertValue();
      const plaintext = this.crypto.decrypt(ciphertext, this.n.getBytes(), ad, this.k, dst);
      this.n.increment();
      return plaintext;
    }
  };
  var SymmetricState = class {
    cs;
    ck;
    h;
    crypto;
    constructor(crypto6, protocolName) {
      this.crypto = crypto6;
      const protocolNameBytes = fromString12(protocolName, "utf-8");
      this.h = hashProtocolName(crypto6, protocolNameBytes);
      this.ck = this.h;
      this.cs = new CipherState(crypto6);
    }
    mixKey(ikm) {
      const [ck, tempK] = this.crypto.hkdf(this.ck, ikm);
      this.ck = ck;
      this.cs = new CipherState(this.crypto, tempK);
    }
    mixHash(data) {
      this.h = this.crypto.hash(new Uint8ArrayList(this.h, data));
    }
    encryptAndHash(plaintext) {
      const ciphertext = this.cs.encryptWithAd(this.h, plaintext);
      this.mixHash(ciphertext);
      return ciphertext;
    }
    decryptAndHash(ciphertext) {
      const plaintext = this.cs.decryptWithAd(this.h, ciphertext);
      this.mixHash(ciphertext);
      return plaintext;
    }
    split() {
      const [tempK1, tempK2] = this.crypto.hkdf(this.ck, ZEROLEN);
      return [new CipherState(this.crypto, tempK1), new CipherState(this.crypto, tempK2)];
    }
  };
  var AbstractHandshakeState = class {
    ss;
    s;
    e;
    rs;
    re;
    initiator;
    crypto;
    constructor(init) {
      const { crypto: crypto6, protocolName, prologue, initiator, s: s2, e, rs, re } = init;
      this.crypto = crypto6;
      this.ss = new SymmetricState(crypto6, protocolName);
      this.ss.mixHash(prologue);
      this.initiator = initiator;
      this.s = s2;
      this.e = e;
      this.rs = rs;
      this.re = re;
    }
    writeE() {
      if (this.e) {
        throw new Error("ephemeral keypair is already set");
      }
      const e = this.crypto.generateKeypair();
      this.ss.mixHash(e.publicKey);
      this.e = e;
      return e.publicKey;
    }
    writeS() {
      if (!this.s) {
        throw new Error("static keypair is not set");
      }
      return this.ss.encryptAndHash(this.s.publicKey);
    }
    writeEE() {
      if (!this.e) {
        throw new Error("ephemeral keypair is not set");
      }
      if (!this.re) {
        throw new Error("remote ephemeral public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.e, this.re));
    }
    writeES() {
      if (this.initiator) {
        if (!this.e) {
          throw new Error("ephemeral keypair is not set");
        }
        if (!this.rs) {
          throw new Error("remote static public key is not set");
        }
        this.ss.mixKey(this.crypto.dh(this.e, this.rs));
      } else {
        if (!this.s) {
          throw new Error("static keypair is not set");
        }
        if (!this.re) {
          throw new Error("remote ephemeral public key is not set");
        }
        this.ss.mixKey(this.crypto.dh(this.s, this.re));
      }
    }
    writeSE() {
      if (this.initiator) {
        if (!this.s) {
          throw new Error("static keypair is not set");
        }
        if (!this.re) {
          throw new Error("remote ephemeral public key is not set");
        }
        this.ss.mixKey(this.crypto.dh(this.s, this.re));
      } else {
        if (!this.e) {
          throw new Error("ephemeral keypair is not set");
        }
        if (!this.rs) {
          throw new Error("remote static public key is not set");
        }
        this.ss.mixKey(this.crypto.dh(this.e, this.rs));
      }
    }
    readE(message2, offset = 0) {
      if (this.re) {
        throw new Error("remote ephemeral public key is already set");
      }
      if (message2.byteLength < offset + 32) {
        throw new Error("message is not long enough");
      }
      this.re = message2.sublist(offset, offset + 32);
      this.ss.mixHash(this.re);
    }
    readS(message2, offset = 0) {
      if (this.rs) {
        throw new Error("remote static public key is already set");
      }
      const cipherLength = 32 + (this.ss.cs.hasKey() ? 16 : 0);
      if (message2.byteLength < offset + cipherLength) {
        throw new Error("message is not long enough");
      }
      const temp = message2.sublist(offset, offset + cipherLength);
      this.rs = this.ss.decryptAndHash(temp);
      return cipherLength;
    }
    readEE() {
      this.writeEE();
    }
    readES() {
      this.writeES();
    }
    readSE() {
      this.writeSE();
    }
  };
  var XXHandshakeState = class extends AbstractHandshakeState {
    // e
    writeMessageA(payload) {
      return new Uint8ArrayList(this.writeE(), this.ss.encryptAndHash(payload));
    }
    // e, ee, s, es
    writeMessageB(payload) {
      const e = this.writeE();
      this.writeEE();
      const encS = this.writeS();
      this.writeES();
      return new Uint8ArrayList(e, encS, this.ss.encryptAndHash(payload));
    }
    // s, se
    writeMessageC(payload) {
      const encS = this.writeS();
      this.writeSE();
      return new Uint8ArrayList(encS, this.ss.encryptAndHash(payload));
    }
    // e
    readMessageA(message2) {
      try {
        this.readE(message2);
        return this.ss.decryptAndHash(message2.sublist(32));
      } catch (e) {
        throw new InvalidCryptoExchangeError2(`handshake stage 0 validation fail: ${e.message}`);
      }
    }
    // e, ee, s, es
    readMessageB(message2) {
      try {
        this.readE(message2);
        this.readEE();
        const consumed = this.readS(message2, 32);
        this.readES();
        return this.ss.decryptAndHash(message2.sublist(32 + consumed));
      } catch (e) {
        throw new InvalidCryptoExchangeError2(`handshake stage 1 validation fail: ${e.message}`);
      }
    }
    // s, se
    readMessageC(message2) {
      try {
        const consumed = this.readS(message2);
        this.readSE();
        return this.ss.decryptAndHash(message2.sublist(consumed));
      } catch (e) {
        throw new InvalidCryptoExchangeError2(`handshake stage 2 validation fail: ${e.message}`);
      }
    }
  };
  function hashProtocolName(crypto6, protocolName) {
    if (protocolName.length <= 32) {
      const h2 = alloc4(32);
      h2.set(protocolName);
      return h2;
    } else {
      return crypto6.hash(protocolName);
    }
  }

  // ../node_modules/@chainsafe/libp2p-noise/dist/src/proto/payload.js
  var NoiseExtensions;
  (function(NoiseExtensions2) {
    let _codec;
    NoiseExtensions2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.webtransportCerthashes != null) {
            for (const value of obj.webtransportCerthashes) {
              w2.uint32(10);
              w2.bytes(value);
            }
          }
          if (obj.streamMuxers != null) {
            for (const value of obj.streamMuxers) {
              w2.uint32(18);
              w2.string(value);
            }
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            webtransportCerthashes: [],
            streamMuxers: []
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (opts.limits?.webtransportCerthashes != null && obj.webtransportCerthashes.length === opts.limits.webtransportCerthashes) {
                  throw new MaxLengthError('Decode error - map field "webtransportCerthashes" had too many elements');
                }
                obj.webtransportCerthashes.push(reader.bytes());
                break;
              }
              case 2: {
                if (opts.limits?.streamMuxers != null && obj.streamMuxers.length === opts.limits.streamMuxers) {
                  throw new MaxLengthError('Decode error - map field "streamMuxers" had too many elements');
                }
                obj.streamMuxers.push(reader.string());
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    NoiseExtensions2.encode = (obj) => {
      return encodeMessage(obj, NoiseExtensions2.codec());
    };
    NoiseExtensions2.decode = (buf, opts) => {
      return decodeMessage(buf, NoiseExtensions2.codec(), opts);
    };
  })(NoiseExtensions || (NoiseExtensions = {}));
  var NoiseHandshakePayload;
  (function(NoiseHandshakePayload2) {
    let _codec;
    NoiseHandshakePayload2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.identityKey != null && obj.identityKey.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.identityKey);
          }
          if (obj.identitySig != null && obj.identitySig.byteLength > 0) {
            w2.uint32(18);
            w2.bytes(obj.identitySig);
          }
          if (obj.extensions != null) {
            w2.uint32(34);
            NoiseExtensions.codec().encode(obj.extensions, w2);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            identityKey: alloc4(0),
            identitySig: alloc4(0)
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.identityKey = reader.bytes();
                break;
              }
              case 2: {
                obj.identitySig = reader.bytes();
                break;
              }
              case 4: {
                obj.extensions = NoiseExtensions.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.extensions
                });
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    NoiseHandshakePayload2.encode = (obj) => {
      return encodeMessage(obj, NoiseHandshakePayload2.codec());
    };
    NoiseHandshakePayload2.decode = (buf, opts) => {
      return decodeMessage(buf, NoiseHandshakePayload2.codec(), opts);
    };
  })(NoiseHandshakePayload || (NoiseHandshakePayload = {}));

  // ../node_modules/@chainsafe/libp2p-noise/dist/src/utils.js
  async function createHandshakePayload(privateKey, staticPublicKey, extensions) {
    const identitySig = await privateKey.sign(getSignaturePayload(staticPublicKey));
    return NoiseHandshakePayload.encode({
      identityKey: publicKeyToProtobuf(privateKey.publicKey),
      identitySig,
      extensions
    });
  }
  async function decodeHandshakePayload(payloadBytes, remoteStaticKey, remoteIdentityKey) {
    try {
      const payload = NoiseHandshakePayload.decode(payloadBytes);
      const publicKey = publicKeyFromProtobuf(payload.identityKey);
      if (remoteIdentityKey?.equals(publicKey) === false) {
        throw new Error(`Payload identity key ${publicKey} does not match expected remote identity key ${remoteIdentityKey}`);
      }
      if (!remoteStaticKey) {
        throw new Error("Remote static does not exist");
      }
      const signaturePayload = getSignaturePayload(remoteStaticKey);
      if (!await publicKey.verify(signaturePayload, payload.identitySig)) {
        throw new Error("Invalid payload signature");
      }
      return payload;
    } catch (e) {
      throw new UnexpectedPeerError(e.message);
    }
  }
  function getSignaturePayload(publicKey) {
    const prefix = fromString12("noise-libp2p-static-key:");
    if (publicKey instanceof Uint8Array) {
      return concat5([prefix, publicKey], prefix.length + publicKey.length);
    }
    publicKey.prepend(prefix);
    return publicKey;
  }

  // ../node_modules/@chainsafe/libp2p-noise/dist/src/performHandshake.js
  async function performHandshakeInitiator(init, options) {
    const { log: log33, connection, crypto: crypto6, privateKey, prologue, s: s2, remoteIdentityKey, extensions } = init;
    const payload = await createHandshakePayload(privateKey, s2.publicKey, extensions);
    const xx = new XXHandshakeState({
      crypto: crypto6,
      protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
      initiator: true,
      prologue,
      s: s2
    });
    logLocalStaticKeys(xx.s, log33);
    log33.trace("Stage 0 - Initiator starting to send first message.");
    await connection.write(xx.writeMessageA(ZEROLEN), options);
    log33.trace("Stage 0 - Initiator finished sending first message.");
    logLocalEphemeralKeys(xx.e, log33);
    log33.trace("Stage 1 - Initiator waiting to receive first message from responder...");
    const plaintext = xx.readMessageB(await connection.read(options));
    log33.trace("Stage 1 - Initiator received the message.");
    logRemoteEphemeralKey(xx.re, log33);
    logRemoteStaticKey(xx.rs, log33);
    log33.trace("Initiator going to check remote's signature...");
    const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey);
    log33.trace("All good with the signature!");
    log33.trace("Stage 2 - Initiator sending third handshake message.");
    await connection.write(xx.writeMessageC(payload), options);
    log33.trace("Stage 2 - Initiator sent message with signed payload.");
    const [cs1, cs2] = xx.ss.split();
    logCipherState(cs1, cs2, log33);
    return {
      payload: receivedPayload,
      encrypt: (plaintext2) => cs1.encryptWithAd(ZEROLEN, plaintext2),
      decrypt: (ciphertext, dst) => cs2.decryptWithAd(ZEROLEN, ciphertext, dst)
    };
  }
  async function performHandshakeResponder(init, options) {
    const { log: log33, connection, crypto: crypto6, privateKey, prologue, s: s2, remoteIdentityKey, extensions } = init;
    const payload = await createHandshakePayload(privateKey, s2.publicKey, extensions);
    const xx = new XXHandshakeState({
      crypto: crypto6,
      protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
      initiator: false,
      prologue,
      s: s2
    });
    logLocalStaticKeys(xx.s, log33);
    log33.trace("Stage 0 - Responder waiting to receive first message.");
    xx.readMessageA(await connection.read(options));
    log33.trace("Stage 0 - Responder received first message.");
    logRemoteEphemeralKey(xx.re, log33);
    log33.trace("Stage 1 - Responder sending out first message with signed payload and static key.");
    await connection.write(xx.writeMessageB(payload), options);
    log33.trace("Stage 1 - Responder sent the second handshake message with signed payload.");
    logLocalEphemeralKeys(xx.e, log33);
    log33.trace("Stage 2 - Responder waiting for third handshake message...");
    const plaintext = xx.readMessageC(await connection.read(options));
    log33.trace("Stage 2 - Responder received the message, finished handshake.");
    const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey);
    const [cs1, cs2] = xx.ss.split();
    logCipherState(cs1, cs2, log33);
    return {
      payload: receivedPayload,
      encrypt: (plaintext2) => cs2.encryptWithAd(ZEROLEN, plaintext2),
      decrypt: (ciphertext, dst) => cs1.decryptWithAd(ZEROLEN, ciphertext, dst)
    };
  }

  // ../node_modules/@chainsafe/libp2p-noise/dist/src/streaming.js
  var CHACHA_TAG_LENGTH = 16;
  function encryptStream(handshake, metrics) {
    return async function* (source) {
      for await (const chunk of source) {
        for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
          let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
          if (end > chunk.length) {
            end = chunk.length;
          }
          let data;
          if (chunk instanceof Uint8Array) {
            data = handshake.encrypt(chunk.subarray(i, end));
          } else {
            data = handshake.encrypt(chunk.sublist(i, end));
          }
          metrics?.encryptedPackets.increment();
          yield new Uint8ArrayList(uint16BEEncode(data.byteLength), data);
        }
      }
    };
  }
  function decryptStream(handshake, metrics) {
    return async function* (source) {
      for await (const chunk of source) {
        for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {
          let end = i + NOISE_MSG_MAX_LENGTH_BYTES;
          if (end > chunk.length) {
            end = chunk.length;
          }
          if (end - CHACHA_TAG_LENGTH < i) {
            throw new Error("Invalid chunk");
          }
          const encrypted = chunk.sublist(i, end);
          const dst = chunk.subarray(i, end - CHACHA_TAG_LENGTH);
          try {
            const plaintext = handshake.decrypt(encrypted, dst);
            metrics?.decryptedPackets.increment();
            yield plaintext;
          } catch (e) {
            metrics?.decryptErrors.increment();
            throw e;
          }
        }
      }
    };
  }

  // ../node_modules/@chainsafe/libp2p-noise/dist/src/noise.js
  var Noise = class {
    protocol = "/noise";
    crypto;
    prologue;
    staticKey;
    extensions;
    metrics;
    components;
    constructor(components, init = {}) {
      const { staticNoiseKey, extensions, crypto: crypto6, prologueBytes } = init;
      const { metrics } = components;
      this.components = components;
      const _crypto = crypto6 ?? defaultCrypto;
      this.crypto = wrapCrypto(_crypto);
      this.extensions = {
        webtransportCerthashes: [],
        ...extensions
      };
      this.metrics = metrics ? registerMetrics(metrics) : void 0;
      if (staticNoiseKey) {
        this.staticKey = _crypto.generateX25519KeyPairFromSeed(staticNoiseKey);
      } else {
        this.staticKey = _crypto.generateX25519KeyPair();
      }
      this.prologue = prologueBytes ?? alloc4(0);
    }
    [Symbol.toStringTag] = "@chainsafe/libp2p-noise";
    [serviceCapabilities] = [
      "@libp2p/connection-encryption",
      "@chainsafe/libp2p-noise"
    ];
    /**
     * Encrypt outgoing data to the remote party (handshake as initiator)
     *
     * @param connection - streaming iterable duplex that will be encrypted
     * @param options
     * @param options.remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer
     * @param options.signal - Used to abort the operation
     */
    async secureOutbound(connection, options) {
      const wrappedConnection = lpStream(connection, {
        lengthEncoder: uint16BEEncode,
        lengthDecoder: uint16BEDecode,
        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
      });
      const handshake = await this.performHandshakeInitiator(wrappedConnection, this.components.privateKey, options?.remotePeer?.publicKey, options);
      const conn = await this.createSecureConnection(wrappedConnection, handshake);
      connection.source = conn.source;
      connection.sink = conn.sink;
      const publicKey = publicKeyFromProtobuf(handshake.payload.identityKey);
      return {
        conn: connection,
        remoteExtensions: handshake.payload.extensions,
        remotePeer: peerIdFromPublicKey(publicKey),
        streamMuxer: options?.skipStreamMuxerNegotiation === true ? void 0 : this.getStreamMuxer(handshake.payload.extensions?.streamMuxers)
      };
    }
    getStreamMuxer(protocols2) {
      if (protocols2 == null || protocols2.length === 0) {
        return;
      }
      const streamMuxers = this.components.upgrader.getStreamMuxers();
      if (streamMuxers != null) {
        for (const protocol of protocols2) {
          const streamMuxer = streamMuxers.get(protocol);
          if (streamMuxer != null) {
            return streamMuxer;
          }
        }
      }
      if (protocols2.length) {
        throw new InvalidCryptoExchangeError("Early muxer negotiation was requested but the initiator and responder had no common muxers");
      }
    }
    /**
     * Decrypt incoming data (handshake as responder).
     *
     * @param connection - streaming iterable duplex that will be encrypted
     * @param options
     * @param options.remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer
     * @param options.signal - Used to abort the operation
     */
    async secureInbound(connection, options) {
      const wrappedConnection = lpStream(connection, {
        lengthEncoder: uint16BEEncode,
        lengthDecoder: uint16BEDecode,
        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
      });
      const handshake = await this.performHandshakeResponder(wrappedConnection, this.components.privateKey, options?.remotePeer?.publicKey, options);
      const conn = await this.createSecureConnection(wrappedConnection, handshake);
      connection.source = conn.source;
      connection.sink = conn.sink;
      const publicKey = publicKeyFromProtobuf(handshake.payload.identityKey);
      return {
        conn: connection,
        remoteExtensions: handshake.payload.extensions,
        remotePeer: peerIdFromPublicKey(publicKey),
        streamMuxer: options?.skipStreamMuxerNegotiation === true ? void 0 : this.getStreamMuxer(handshake.payload.extensions?.streamMuxers)
      };
    }
    /**
     * Perform XX handshake as initiator.
     */
    async performHandshakeInitiator(connection, privateKey, remoteIdentityKey, options) {
      let result;
      const streamMuxers = options?.skipStreamMuxerNegotiation === true ? [] : [...this.components.upgrader.getStreamMuxers().keys()];
      try {
        result = await performHandshakeInitiator({
          connection,
          privateKey,
          remoteIdentityKey,
          log: this.components.logger.forComponent("libp2p:noise:xxhandshake"),
          crypto: this.crypto,
          prologue: this.prologue,
          s: this.staticKey,
          extensions: {
            streamMuxers,
            webtransportCerthashes: [],
            ...this.extensions
          }
        }, options);
        this.metrics?.xxHandshakeSuccesses.increment();
      } catch (e) {
        this.metrics?.xxHandshakeErrors.increment();
        throw e;
      }
      return result;
    }
    /**
     * Perform XX handshake as responder.
     */
    async performHandshakeResponder(connection, privateKey, remoteIdentityKey, options) {
      let result;
      const streamMuxers = options?.skipStreamMuxerNegotiation === true ? [] : [...this.components.upgrader.getStreamMuxers().keys()];
      try {
        result = await performHandshakeResponder({
          connection,
          privateKey,
          remoteIdentityKey,
          log: this.components.logger.forComponent("libp2p:noise:xxhandshake"),
          crypto: this.crypto,
          prologue: this.prologue,
          s: this.staticKey,
          extensions: {
            streamMuxers,
            webtransportCerthashes: [],
            ...this.extensions
          }
        }, options);
        this.metrics?.xxHandshakeSuccesses.increment();
      } catch (e) {
        this.metrics?.xxHandshakeErrors.increment();
        throw e;
      }
      return result;
    }
    async createSecureConnection(connection, handshake) {
      const [secure, user] = duplexPair();
      const network = connection.unwrap();
      await pipe(
        secure,
        // write to wrapper
        encryptStream(handshake, this.metrics),
        // encrypt data + prefix with message length
        network,
        // send to the remote peer
        (source) => decode28(source, { lengthDecoder: uint16BEDecode }),
        // read message length prefix
        decryptStream(handshake, this.metrics),
        // decrypt the incoming data
        secure
        // pipe to the wrapper
      );
      return user;
    }
  };

  // ../node_modules/@chainsafe/libp2p-noise/dist/src/index.js
  function noise(init = {}) {
    return (components) => new Noise(components, init);
  }

  // ../node_modules/@multiformats/mafmt/dist/src/index.js
  var DNS4 = base9("dns4");
  var DNS6 = base9("dns6");
  var DNSADDR = base9("dnsaddr");
  var DNS = or7(base9("dns"), DNSADDR, DNS4, DNS6);
  var IP = or7(base9("ip4"), base9("ip6"));
  var TCP = or7(and(IP, base9("tcp")), and(DNS, base9("tcp")));
  var UDP = and(IP, base9("udp"));
  var UTP = and(UDP, base9("utp"));
  var QUIC = and(UDP, base9("quic"));
  var QUICV1 = and(UDP, base9("quic-v1"));
  var _WebSockets = or7(and(TCP, base9("ws")), and(DNS, base9("ws")));
  var WebSockets = or7(and(_WebSockets, base9("p2p")), _WebSockets);
  var _WebSocketsSecure = or7(and(TCP, base9("wss")), and(DNS, base9("wss")), and(TCP, base9("tls"), base9("ws")), and(DNS, base9("tls"), base9("ws")));
  var WebSocketsSecure = or7(and(_WebSocketsSecure, base9("p2p")), _WebSocketsSecure);
  var HTTP = or7(and(TCP, base9("http")), and(IP, base9("http")), and(DNS, base9("http")));
  var HTTPS = or7(and(TCP, base9("https")), and(IP, base9("https")), and(DNS, base9("https")));
  var _WebRTCDirect = and(UDP, base9("webrtc-direct"), base9("certhash"));
  var WebRTCDirect = or7(and(_WebRTCDirect, base9("p2p")), _WebRTCDirect);
  var _WebTransport = and(QUICV1, base9("webtransport"), base9("certhash"), base9("certhash"));
  var WebTransport = or7(and(_WebTransport, base9("p2p")), _WebTransport);
  var P2PWebRTCStar = or7(and(WebSockets, base9("p2p-webrtc-star"), base9("p2p")), and(WebSocketsSecure, base9("p2p-webrtc-star"), base9("p2p")), and(WebSockets, base9("p2p-webrtc-star")), and(WebSocketsSecure, base9("p2p-webrtc-star")));
  var WebSocketStar = or7(and(WebSockets, base9("p2p-websocket-star"), base9("p2p")), and(WebSocketsSecure, base9("p2p-websocket-star"), base9("p2p")), and(WebSockets, base9("p2p-websocket-star")), and(WebSocketsSecure, base9("p2p-websocket-star")));
  var P2PWebRTCDirect = or7(and(HTTP, base9("p2p-webrtc-direct"), base9("p2p")), and(HTTPS, base9("p2p-webrtc-direct"), base9("p2p")), and(HTTP, base9("p2p-webrtc-direct")), and(HTTPS, base9("p2p-webrtc-direct")));
  var Reliable = or7(_WebSockets, _WebSocketsSecure, HTTP, HTTPS, P2PWebRTCStar, P2PWebRTCDirect, TCP, UTP, QUIC, DNS, WebRTCDirect, WebTransport);
  var Stardust = or7(and(Reliable, base9("p2p-stardust"), base9("p2p")), and(Reliable, base9("p2p-stardust")));
  var _P2P = or7(and(Reliable, base9("p2p")), P2PWebRTCStar, P2PWebRTCDirect, WebRTCDirect, WebTransport, base9("p2p"));
  var _Circuit = or7(and(_P2P, base9("p2p-circuit"), _P2P), and(_P2P, base9("p2p-circuit")), and(base9("p2p-circuit"), _P2P), and(Reliable, base9("p2p-circuit")), and(base9("p2p-circuit"), Reliable), base9("p2p-circuit"));
  var CircuitRecursive = () => or7(and(_Circuit, CircuitRecursive), _Circuit);
  var Circuit = CircuitRecursive();
  var P2P = or7(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);
  var WebRTC = or7(and(Circuit, base9("webrtc"), base9("p2p")), and(Circuit, base9("webrtc")), and(Reliable, base9("webrtc"), base9("p2p")), and(Reliable, base9("webrtc")), base9("webrtc"));
  function makeMatchesFunction(partialMatch) {
    function matches(a) {
      let ma;
      try {
        ma = multiaddr(a);
      } catch (err) {
        return false;
      }
      const out = partialMatch(ma.protoNames());
      if (out === null) {
        return false;
      }
      if (out === true || out === false) {
        return out;
      }
      return out.length === 0;
    }
    return matches;
  }
  function and(...args) {
    function partialMatch(a) {
      if (a.length < args.length) {
        return null;
      }
      let out = a;
      args.some((arg) => {
        out = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
        if (Array.isArray(out)) {
          a = out;
        }
        if (out === null) {
          return true;
        }
        return false;
      });
      return out;
    }
    return {
      toString: function() {
        return "{ " + args.join(" ") + " }";
      },
      input: args,
      matches: makeMatchesFunction(partialMatch),
      partialMatch
    };
  }
  function or7(...args) {
    function partialMatch(a) {
      let out = null;
      args.some((arg) => {
        const res = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
        if (res != null) {
          out = res;
          return true;
        }
        return false;
      });
      return out;
    }
    const result = {
      toString: function() {
        return "{ " + args.join(" ") + " }";
      },
      input: args,
      matches: makeMatchesFunction(partialMatch),
      partialMatch
    };
    return result;
  }
  function base9(n) {
    const name19 = n;
    function matches(a) {
      let ma;
      try {
        ma = multiaddr(a);
      } catch (err) {
        return false;
      }
      const pnames = ma.protoNames();
      if (pnames.length === 1 && pnames[0] === name19) {
        return true;
      }
      return false;
    }
    function partialMatch(protos) {
      if (protos.length === 0) {
        return null;
      }
      if (protos[0] === name19) {
        return protos.slice(1);
      }
      return null;
    }
    return {
      toString: function() {
        return name19;
      },
      matches,
      partialMatch
    };
  }

  // ../node_modules/@libp2p/bootstrap/dist/src/index.js
  var DEFAULT_BOOTSTRAP_TAG_NAME = "bootstrap";
  var DEFAULT_BOOTSTRAP_TAG_VALUE = 50;
  var DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT = 1e3;
  var Bootstrap = class extends TypedEventEmitter {
    static tag = "bootstrap";
    log;
    timer;
    list;
    timeout;
    components;
    _init;
    constructor(components, options = { list: [] }) {
      if (options.list == null || options.list.length === 0) {
        throw new Error("Bootstrap requires a list of peer addresses");
      }
      super();
      this.components = components;
      this.log = components.logger.forComponent("libp2p:bootstrap");
      this.timeout = options.timeout ?? DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT;
      this.list = [];
      for (const candidate of options.list) {
        if (!P2P.matches(candidate)) {
          this.log.error("Invalid multiaddr");
          continue;
        }
        const ma = multiaddr(candidate);
        const peerIdStr = ma.getPeerId();
        if (peerIdStr == null) {
          this.log.error("Invalid bootstrap multiaddr without peer id");
          continue;
        }
        const peerData = {
          id: peerIdFromString(peerIdStr),
          multiaddrs: [ma]
        };
        this.list.push(peerData);
      }
      this._init = options;
    }
    [peerDiscoverySymbol] = this;
    [Symbol.toStringTag] = "@libp2p/bootstrap";
    [serviceCapabilities] = [
      "@libp2p/peer-discovery"
    ];
    isStarted() {
      return Boolean(this.timer);
    }
    /**
     * Start emitting events
     */
    start() {
      if (this.isStarted()) {
        return;
      }
      this.log("Starting bootstrap node discovery, discovering peers after %s ms", this.timeout);
      this.timer = setTimeout(() => {
        void this._discoverBootstrapPeers().catch((err) => {
          this.log.error(err);
        });
      }, this.timeout);
    }
    /**
     * Emit each address in the list as a PeerInfo
     */
    async _discoverBootstrapPeers() {
      if (this.timer == null) {
        return;
      }
      for (const peerData of this.list) {
        await this.components.peerStore.merge(peerData.id, {
          tags: {
            [this._init.tagName ?? DEFAULT_BOOTSTRAP_TAG_NAME]: {
              value: this._init.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,
              ttl: this._init.tagTTL
            }
          },
          multiaddrs: peerData.multiaddrs
        });
        if (this.timer == null) {
          return;
        }
        this.safeDispatchEvent("peer", { detail: peerData });
        this.components.connectionManager.openConnection(peerData.id).catch((err) => {
          this.log.error("could not dial bootstrap peer %p", peerData.id, err);
        });
      }
    }
    /**
     * Stop emitting events
     */
    stop() {
      if (this.timer != null) {
        clearTimeout(this.timer);
      }
      this.timer = void 0;
    }
  };
  function bootstrap(init) {
    return (components) => new Bootstrap(components, init);
  }

  // ../node_modules/@libp2p/peer-record/node_modules/uint8arrays/dist/src/equals.js
  function equals18(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports7 = {};
  __export(base10_exports7, {
    base10: () => base107
  });

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bytes.js
  var empty7 = new Uint8Array(0);
  function equals19(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce7(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function fromString13(str) {
    return new TextEncoder().encode(str);
  }
  function toString12(b) {
    return new TextDecoder().decode(b);
  }

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/vendor/base-x.js
  function base11(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src7 = base11;
  var _brrp__multiformats_scope_baseX7 = src7;
  var base_x_default7 = _brrp__multiformats_scope_baseX7;

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base.js
  var Encoder8 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder8 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or8(this, decoder);
    }
  };
  var ComposedDecoder7 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or8(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or8(left, right) {
    return new ComposedDecoder7({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec7 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder8(name19, prefix, baseEncode);
      this.decoder = new Decoder8(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from13({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec7(name19, prefix, encode79, decode99);
  }
  function baseX7({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default7(alphabet18, name19);
    return from13({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce7(decode99(text))
    });
  }
  function decode34(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode28(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx7(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc46487({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx7(alphabet18);
    return from13({
      prefix,
      name: name19,
      encode(input) {
        return encode28(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode34(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base10.js
  var base107 = baseX7({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports7 = {};
  __export(base16_exports7, {
    base16: () => base167,
    base16upper: () => base16upper7
  });
  var base167 = rfc46487({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper7 = rfc46487({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports7 = {};
  __export(base2_exports7, {
    base2: () => base27
  });
  var base27 = rfc46487({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports7 = {};
  __export(base256emoji_exports7, {
    base256emoji: () => base256emoji7
  });
  var alphabet7 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars7 = alphabet7.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes7 = alphabet7.reduce((p, c, i) => {
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
  }, []);
  function encode29(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars7[c];
      return p;
    }, "");
  }
  function decode35(str) {
    const byts = [];
    for (const char of str) {
      const codePoint = char.codePointAt(0);
      if (codePoint == null) {
        throw new Error(`Invalid character: ${char}`);
      }
      const byt = alphabetCharsToBytes7[codePoint];
      if (byt == null) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji7 = from13({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode29,
    decode: decode35
  });

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports7 = {};
  __export(base32_exports7, {
    base32: () => base327,
    base32hex: () => base32hex7,
    base32hexpad: () => base32hexpad7,
    base32hexpadupper: () => base32hexpadupper7,
    base32hexupper: () => base32hexupper7,
    base32pad: () => base32pad7,
    base32padupper: () => base32padupper7,
    base32upper: () => base32upper7,
    base32z: () => base32z7
  });
  var base327 = rfc46487({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper7 = rfc46487({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad7 = rfc46487({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper7 = rfc46487({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex7 = rfc46487({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper7 = rfc46487({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad7 = rfc46487({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper7 = rfc46487({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z7 = rfc46487({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports7 = {};
  __export(base36_exports7, {
    base36: () => base367,
    base36upper: () => base36upper7
  });
  var base367 = baseX7({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper7 = baseX7({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports7 = {};
  __export(base58_exports7, {
    base58btc: () => base58btc7,
    base58flickr: () => base58flickr7
  });
  var base58btc7 = baseX7({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr7 = baseX7({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports7 = {};
  __export(base64_exports7, {
    base64: () => base647,
    base64pad: () => base64pad7,
    base64url: () => base64url7,
    base64urlpad: () => base64urlpad7
  });
  var base647 = rfc46487({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad7 = rfc46487({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url7 = rfc46487({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad7 = rfc46487({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports7 = {};
  __export(base8_exports7, {
    base8: () => base87
  });
  var base87 = rfc46487({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports13 = {};
  __export(identity_exports13, {
    identity: () => identity13
  });
  var identity13 = from13({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString12(buf),
    decode: (str) => fromString13(str)
  });

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/codecs/json.js
  var textEncoder7 = new TextEncoder();
  var textDecoder7 = new TextDecoder();

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports14 = {};
  __export(identity_exports14, {
    identity: () => identity14
  });

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_17 = encode30;
  var MSB8 = 128;
  var REST8 = 127;
  var MSBALL7 = ~REST8;
  var INT7 = Math.pow(2, 31);
  function encode30(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT7) {
      out[offset++] = num & 255 | MSB8;
      num /= 128;
    }
    while (num & MSBALL7) {
      out[offset++] = num & 255 | MSB8;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode30.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode36 = read8;
  var MSB$17 = 128;
  var REST$17 = 127;
  function read8(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read8.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$17) << shift : (b & REST$17) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$17);
    read8.bytes = counter - offset;
    return res;
  }
  var N18 = Math.pow(2, 7);
  var N28 = Math.pow(2, 14);
  var N38 = Math.pow(2, 21);
  var N48 = Math.pow(2, 28);
  var N58 = Math.pow(2, 35);
  var N68 = Math.pow(2, 42);
  var N78 = Math.pow(2, 49);
  var N87 = Math.pow(2, 56);
  var N97 = Math.pow(2, 63);
  var length8 = function(value) {
    return value < N18 ? 1 : value < N28 ? 2 : value < N38 ? 3 : value < N48 ? 4 : value < N58 ? 5 : value < N68 ? 6 : value < N78 ? 7 : value < N87 ? 8 : value < N97 ? 9 : 10;
  };
  var varint7 = {
    encode: encode_17,
    decode: decode36,
    encodingLength: length8
  };
  var _brrp_varint7 = varint7;
  var varint_default7 = _brrp_varint7;

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/varint.js
  function decode37(data, offset = 0) {
    const code18 = varint_default7.decode(data, offset);
    return [code18, varint_default7.decode.bytes];
  }
  function encodeTo7(int, target, offset = 0) {
    varint_default7.encode(int, target, offset);
    return target;
  }
  function encodingLength8(int) {
    return varint_default7.encodingLength(int);
  }

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/hashes/digest.js
  function create7(code18, digest18) {
    const size = digest18.byteLength;
    const sizeOffset = encodingLength8(code18);
    const digestOffset = sizeOffset + encodingLength8(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo7(code18, bytes2, 0);
    encodeTo7(size, bytes2, sizeOffset);
    bytes2.set(digest18, digestOffset);
    return new Digest7(code18, size, digest18, bytes2);
  }
  function decode38(multihash) {
    const bytes2 = coerce7(multihash);
    const [code18, sizeOffset] = decode37(bytes2);
    const [size, digestOffset] = decode37(bytes2.subarray(sizeOffset));
    const digest18 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest18.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest7(code18, size, digest18, bytes2);
  }
  function equals20(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals19(a.bytes, data.bytes);
    }
  }
  var Digest7 = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code18, size, digest18, bytes2) {
      this.code = code18;
      this.size = size;
      this.digest = digest18;
      this.bytes = bytes2;
    }
  };

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/hashes/identity.js
  var code7 = 0;
  var name7 = "identity";
  var encode31 = coerce7;
  function digest7(input) {
    return create7(code7, encode31(input));
  }
  var identity14 = { code: code7, name: name7, encode: encode31, digest: digest7 };

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports7 = {};
  __export(sha2_browser_exports7, {
    sha256: () => sha25610,
    sha512: () => sha5129
  });

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/hashes/hasher.js
  function from14({ name: name19, code: code18, encode: encode79 }) {
    return new Hasher7(name19, code18, encode79);
  }
  var Hasher7 = class {
    name;
    code;
    encode;
    constructor(name19, code18, encode79) {
      this.name = name19;
      this.code = code18;
      this.encode = encode79;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create7(this.code, result) : result.then((digest18) => create7(this.code, digest18));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  function sha7(name19) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name19, data));
  }
  var sha25610 = from14({
    name: "sha2-256",
    code: 18,
    encode: sha7("SHA-256")
  });
  var sha5129 = from14({
    name: "sha2-512",
    code: 19,
    encode: sha7("SHA-512")
  });

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/cid.js
  function format7(link, base37) {
    const { bytes: bytes2, version: version5 } = link;
    switch (version5) {
      case 0:
        return toStringV07(bytes2, baseCache7(link), base37 ?? base58btc7.encoder);
      default:
        return toStringV17(bytes2, baseCache7(link), base37 ?? base327.encoder);
    }
  }
  var cache7 = /* @__PURE__ */ new WeakMap();
  function baseCache7(cid) {
    const baseCache19 = cache7.get(cid);
    if (baseCache19 == null) {
      const baseCache20 = /* @__PURE__ */ new Map();
      cache7.set(cid, baseCache20);
      return baseCache20;
    }
    return baseCache19;
  }
  var CID7 = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version5, code18, multihash, bytes2) {
      this.code = code18;
      this.version = version5;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code18, multihash } = this;
          if (code18 !== DAG_PB_CODE7) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE7) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code18, digest: digest18 } = this.multihash;
          const multihash = create7(code18, digest18);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals20(self2.multihash, unknown.multihash);
    }
    toString(base37) {
      return format7(this, base37);
    }
    toJSON() {
      return { "/": format7(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version5, code: code18, multihash, bytes: bytes2 } = value;
        return new _CID(version5, code18, multihash, bytes2 ?? encodeCID7(version5, code18, multihash.bytes));
      } else if (value[cidSymbol7] === true) {
        const { version: version5, multihash, code: code18 } = value;
        const digest18 = decode38(multihash);
        return _CID.create(version5, code18, digest18);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version5, code18, digest18) {
      if (typeof code18 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest18.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version5) {
        case 0: {
          if (code18 !== DAG_PB_CODE7) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE7}) block encoding`);
          } else {
            return new _CID(version5, code18, digest18, digest18.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID7(version5, code18, digest18.bytes);
          return new _CID(version5, code18, digest18, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest18) {
      return _CID.create(0, DAG_PB_CODE7, digest18);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code18, digest18) {
      return _CID.create(1, code18, digest18);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes2) {
      const [cid, remainder] = _CID.decodeFirst(bytes2);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes2) {
      const specs = _CID.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce7(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest18 = new Digest7(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest18) : _CID.createV1(specs.codec, digest18);
      return [cid, bytes2.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length21] = decode37(initialBytes.subarray(offset));
        offset += length21;
        return i;
      };
      let version5 = next();
      let codec = DAG_PB_CODE7;
      if (version5 === 18) {
        version5 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version5 !== 0 && version5 !== 1) {
        throw new RangeError(`Invalid CID version ${version5}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version5, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base37) {
      const [prefix, bytes2] = parseCIDtoBytes7(source, base37);
      const cid = _CID.decode(bytes2);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache7(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes7(source, base37) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base37 ?? base58btc7;
        return [
          base58btc7.prefix,
          decoder.decode(`${base58btc7.prefix}${source}`)
        ];
      }
      case base58btc7.prefix: {
        const decoder = base37 ?? base58btc7;
        return [base58btc7.prefix, decoder.decode(source)];
      }
      case base327.prefix: {
        const decoder = base37 ?? base327;
        return [base327.prefix, decoder.decode(source)];
      }
      case base367.prefix: {
        const decoder = base37 ?? base367;
        return [base367.prefix, decoder.decode(source)];
      }
      default: {
        if (base37 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base37.decode(source)];
      }
    }
  }
  function toStringV07(bytes2, cache20, base37) {
    const { prefix } = base37;
    if (prefix !== base58btc7.prefix) {
      throw Error(`Cannot string encode V0 in ${base37.name} encoding`);
    }
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2).slice(1);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV17(bytes2, cache20, base37) {
    const { prefix } = base37;
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE7 = 112;
  var SHA_256_CODE7 = 18;
  function encodeCID7(version5, code18, multihash) {
    const codeOffset = encodingLength8(version5);
    const hashOffset = codeOffset + encodingLength8(code18);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo7(version5, bytes2, 0);
    encodeTo7(code18, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  }
  var cidSymbol7 = Symbol.for("@ipld/js-cid/CID");

  // ../node_modules/@libp2p/peer-record/node_modules/multiformats/dist/src/basics.js
  var bases7 = { ...identity_exports13, ...base2_exports7, ...base8_exports7, ...base10_exports7, ...base16_exports7, ...base32_exports7, ...base36_exports7, ...base58_exports7, ...base64_exports7, ...base256emoji_exports7 };
  var hashes7 = { ...sha2_browser_exports7, ...identity_exports14 };

  // ../node_modules/@libp2p/peer-record/node_modules/uint8arrays/dist/src/alloc.js
  function alloc5(size = 0) {
    return new Uint8Array(size);
  }
  function allocUnsafe11(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/@libp2p/peer-record/node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec8(name19, prefix, encode79, decode99) {
    return {
      name: name19,
      prefix,
      encoder: {
        name: name19,
        prefix,
        encode: encode79
      },
      decoder: {
        decode: decode99
      }
    };
  }
  var string7 = createCodec8("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder3 = new TextEncoder();
    return encoder3.encode(str.substring(1));
  });
  var ascii7 = createCodec8("ascii", "a", (buf) => {
    let string19 = "a";
    for (let i = 0; i < buf.length; i++) {
      string19 += String.fromCharCode(buf[i]);
    }
    return string19;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe11(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  var BASES7 = {
    utf8: string7,
    "utf-8": string7,
    hex: bases7.base16,
    latin1: ascii7,
    ascii: ascii7,
    binary: ascii7,
    ...bases7
  };
  var bases_default7 = BASES7;

  // ../node_modules/@libp2p/peer-record/node_modules/uint8arrays/dist/src/from-string.js
  function fromString14(string19, encoding = "utf8") {
    const base37 = bases_default7[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.decoder.decode(`${base37.prefix}${string19}`);
  }

  // ../node_modules/@libp2p/peer-record/dist/src/envelope/envelope.js
  var Envelope;
  (function(Envelope2) {
    let _codec;
    Envelope2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.publicKey);
          }
          if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
            w2.uint32(18);
            w2.bytes(obj.payloadType);
          }
          if (obj.payload != null && obj.payload.byteLength > 0) {
            w2.uint32(26);
            w2.bytes(obj.payload);
          }
          if (obj.signature != null && obj.signature.byteLength > 0) {
            w2.uint32(42);
            w2.bytes(obj.signature);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            publicKey: alloc5(0),
            payloadType: alloc5(0),
            payload: alloc5(0),
            signature: alloc5(0)
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.publicKey = reader.bytes();
                break;
              }
              case 2: {
                obj.payloadType = reader.bytes();
                break;
              }
              case 3: {
                obj.payload = reader.bytes();
                break;
              }
              case 5: {
                obj.signature = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Envelope2.encode = (obj) => {
      return encodeMessage(obj, Envelope2.codec());
    };
    Envelope2.decode = (buf, opts) => {
      return decodeMessage(buf, Envelope2.codec(), opts);
    };
  })(Envelope || (Envelope = {}));

  // ../node_modules/@libp2p/peer-record/dist/src/envelope/errors.js
  var InvalidSignatureError = class extends Error {
    constructor(message2 = "Invalid signature") {
      super(message2);
      this.name = "InvalidSignatureError";
    }
  };

  // ../node_modules/@libp2p/peer-record/dist/src/envelope/index.js
  var RecordEnvelope = class _RecordEnvelope {
    /**
     * Unmarshal a serialized Envelope protobuf message
     */
    static createFromProtobuf = (data) => {
      const envelopeData = Envelope.decode(data);
      const publicKey = publicKeyFromProtobuf(envelopeData.publicKey);
      return new _RecordEnvelope({
        publicKey,
        payloadType: envelopeData.payloadType,
        payload: envelopeData.payload,
        signature: envelopeData.signature
      });
    };
    /**
     * Seal marshals the given Record, places the marshaled bytes inside an Envelope
     * and signs it with the given peerId's private key
     */
    static seal = async (record, privateKey, options) => {
      if (privateKey == null) {
        throw new Error("Missing private key");
      }
      const domain = record.domain;
      const payloadType = record.codec;
      const payload = record.marshal();
      const signData = formatSignaturePayload(domain, payloadType, payload);
      const signature = await privateKey.sign(signData.subarray(), options);
      return new _RecordEnvelope({
        publicKey: privateKey.publicKey,
        payloadType,
        payload,
        signature
      });
    };
    /**
     * Open and certify a given marshaled envelope.
     * Data is unmarshaled and the signature validated for the given domain.
     */
    static openAndCertify = async (data, domain, options) => {
      const envelope = _RecordEnvelope.createFromProtobuf(data);
      const valid = await envelope.validate(domain, options);
      if (!valid) {
        throw new InvalidSignatureError("Envelope signature is not valid for the given domain");
      }
      return envelope;
    };
    publicKey;
    payloadType;
    payload;
    signature;
    marshaled;
    /**
     * The Envelope is responsible for keeping an arbitrary signed record
     * by a libp2p peer.
     */
    constructor(init) {
      const { publicKey, payloadType, payload, signature } = init;
      this.publicKey = publicKey;
      this.payloadType = payloadType;
      this.payload = payload;
      this.signature = signature;
    }
    /**
     * Marshal the envelope content
     */
    marshal() {
      if (this.marshaled == null) {
        this.marshaled = Envelope.encode({
          publicKey: publicKeyToProtobuf(this.publicKey),
          payloadType: this.payloadType,
          payload: this.payload.subarray(),
          signature: this.signature
        });
      }
      return this.marshaled;
    }
    /**
     * Verifies if the other Envelope is identical to this one
     */
    equals(other) {
      if (other == null) {
        return false;
      }
      return equals18(this.marshal(), other.marshal());
    }
    /**
     * Validate envelope data signature for the given domain
     */
    async validate(domain, options) {
      const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
      return this.publicKey.verify(signData.subarray(), this.signature, options);
    }
  };
  var formatSignaturePayload = (domain, payloadType, payload) => {
    const domainUint8Array = fromString14(domain);
    const domainLength = encode(domainUint8Array.byteLength);
    const payloadTypeLength = encode(payloadType.length);
    const payloadLength = encode(payload.length);
    return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
  };

  // ../node_modules/@libp2p/utils/dist/src/array-equals.js
  function arrayEquals(a, b) {
    const sort2 = (a2, b2) => a2.toString().localeCompare(b2.toString());
    if (a.length !== b.length) {
      return false;
    }
    b.sort(sort2);
    return a.sort(sort2).every((item, index) => b[index].equals(item));
  }

  // ../node_modules/@libp2p/peer-record/dist/src/peer-record/consts.js
  var ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
  var ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);

  // ../node_modules/@libp2p/peer-record/dist/src/peer-record/peer-record.js
  var PeerRecord;
  (function(PeerRecord3) {
    let AddressInfo;
    (function(AddressInfo2) {
      let _codec2;
      AddressInfo2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w2, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w2.fork();
            }
            if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
              w2.uint32(10);
              w2.bytes(obj.multiaddr);
            }
            if (opts.lengthDelimited !== false) {
              w2.ldelim();
            }
          }, (reader, length21, opts = {}) => {
            const obj = {
              multiaddr: alloc5(0)
            };
            const end = length21 == null ? reader.len : reader.pos + length21;
            while (reader.pos < end) {
              const tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  obj.multiaddr = reader.bytes();
                  break;
                }
                default: {
                  reader.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      AddressInfo2.encode = (obj) => {
        return encodeMessage(obj, AddressInfo2.codec());
      };
      AddressInfo2.decode = (buf, opts) => {
        return decodeMessage(buf, AddressInfo2.codec(), opts);
      };
    })(AddressInfo = PeerRecord3.AddressInfo || (PeerRecord3.AddressInfo = {}));
    let _codec;
    PeerRecord3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.peerId != null && obj.peerId.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.peerId);
          }
          if (obj.seq != null && obj.seq !== 0n) {
            w2.uint32(16);
            w2.uint64(obj.seq);
          }
          if (obj.addresses != null) {
            for (const value of obj.addresses) {
              w2.uint32(26);
              PeerRecord3.AddressInfo.codec().encode(value, w2);
            }
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            peerId: alloc5(0),
            seq: 0n,
            addresses: []
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.peerId = reader.bytes();
                break;
              }
              case 2: {
                obj.seq = reader.uint64();
                break;
              }
              case 3: {
                if (opts.limits?.addresses != null && obj.addresses.length === opts.limits.addresses) {
                  throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
                }
                obj.addresses.push(PeerRecord3.AddressInfo.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.addresses$
                }));
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PeerRecord3.encode = (obj) => {
      return encodeMessage(obj, PeerRecord3.codec());
    };
    PeerRecord3.decode = (buf, opts) => {
      return decodeMessage(buf, PeerRecord3.codec(), opts);
    };
  })(PeerRecord || (PeerRecord = {}));

  // ../node_modules/@libp2p/peer-record/dist/src/peer-record/index.js
  var PeerRecord2 = class _PeerRecord {
    /**
     * Unmarshal Peer Record Protobuf
     */
    static createFromProtobuf = (buf) => {
      const peerRecord = PeerRecord.decode(buf);
      const peerId2 = peerIdFromMultihash(decode38(peerRecord.peerId));
      const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr(a.multiaddr));
      const seqNumber = peerRecord.seq;
      return new _PeerRecord({ peerId: peerId2, multiaddrs, seqNumber });
    };
    static DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;
    static CODEC = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;
    peerId;
    multiaddrs;
    seqNumber;
    domain = _PeerRecord.DOMAIN;
    codec = _PeerRecord.CODEC;
    marshaled;
    constructor(init) {
      const { peerId: peerId2, multiaddrs, seqNumber } = init;
      this.peerId = peerId2;
      this.multiaddrs = multiaddrs ?? [];
      this.seqNumber = seqNumber ?? BigInt(Date.now());
    }
    /**
     * Marshal a record to be used in an envelope
     */
    marshal() {
      if (this.marshaled == null) {
        this.marshaled = PeerRecord.encode({
          peerId: this.peerId.toMultihash().bytes,
          seq: BigInt(this.seqNumber),
          addresses: this.multiaddrs.map((m2) => ({
            multiaddr: m2.bytes
          }))
        });
      }
      return this.marshaled;
    }
    /**
     * Returns true if `this` record equals the `other`
     */
    equals(other) {
      if (!(other instanceof _PeerRecord)) {
        return false;
      }
      if (!this.peerId.equals(other.peerId)) {
        return false;
      }
      if (this.seqNumber !== other.seqNumber) {
        return false;
      }
      if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
        return false;
      }
      return true;
    }
  };

  // ../node_modules/@libp2p/utils/dist/src/debounce.js
  function debounce(func2, wait) {
    let timeout2;
    const output2 = function() {
      const later = function() {
        timeout2 = void 0;
        void func2();
      };
      clearTimeout(timeout2);
      timeout2 = setTimeout(later, wait);
    };
    output2.start = () => {
    };
    output2.stop = () => {
      clearTimeout(timeout2);
    };
    return output2;
  }

  // ../node_modules/it-drain/dist/src/index.js
  function isAsyncIterable6(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function drain(source) {
    if (isAsyncIterable6(source)) {
      return (async () => {
        for await (const _ of source) {
        }
      })();
    } else {
      for (const _ of source) {
      }
    }
  }
  var src_default3 = drain;

  // ../node_modules/it-parallel/dist/src/index.js
  var CustomEvent2 = globalThis.CustomEvent ?? Event;
  async function* parallel(source, options = {}) {
    let concurrency = options.concurrency ?? Infinity;
    if (concurrency < 1) {
      concurrency = Infinity;
    }
    const ordered = options.ordered ?? false;
    const emitter = new EventTarget();
    const ops = [];
    let slotAvailable = pDefer();
    let resultAvailable = pDefer();
    let sourceFinished = false;
    let sourceErr;
    let opErred = false;
    emitter.addEventListener("task-complete", () => {
      resultAvailable.resolve();
    });
    void Promise.resolve().then(async () => {
      try {
        for await (const task of source) {
          if (ops.length === concurrency) {
            slotAvailable = pDefer();
            await slotAvailable.promise;
          }
          if (opErred) {
            break;
          }
          const op = {
            done: false
          };
          ops.push(op);
          task().then((result) => {
            op.done = true;
            op.ok = true;
            op.value = result;
            emitter.dispatchEvent(new CustomEvent2("task-complete"));
          }, (err) => {
            op.done = true;
            op.err = err;
            emitter.dispatchEvent(new CustomEvent2("task-complete"));
          });
        }
        sourceFinished = true;
        emitter.dispatchEvent(new CustomEvent2("task-complete"));
      } catch (err) {
        sourceErr = err;
        emitter.dispatchEvent(new CustomEvent2("task-complete"));
      }
    });
    function valuesAvailable() {
      if (ordered) {
        return ops[0]?.done;
      }
      return Boolean(ops.find((op) => op.done));
    }
    function* yieldOrderedValues() {
      while (ops.length > 0 && ops[0].done) {
        const op = ops[0];
        ops.shift();
        if (op.ok) {
          yield op.value;
        } else {
          opErred = true;
          slotAvailable.resolve();
          throw op.err;
        }
        slotAvailable.resolve();
      }
    }
    function* yieldUnOrderedValues() {
      while (valuesAvailable()) {
        for (let i = 0; i < ops.length; i++) {
          if (ops[i].done) {
            const op = ops[i];
            ops.splice(i, 1);
            i--;
            if (op.ok) {
              yield op.value;
            } else {
              opErred = true;
              slotAvailable.resolve();
              throw op.err;
            }
            slotAvailable.resolve();
          }
        }
      }
    }
    while (true) {
      if (!valuesAvailable()) {
        resultAvailable = pDefer();
        await resultAvailable.promise;
      }
      if (sourceErr != null) {
        throw sourceErr;
      }
      if (ordered) {
        yield* yieldOrderedValues();
      } else {
        yield* yieldUnOrderedValues();
      }
      if (sourceErr != null) {
        throw sourceErr;
      }
      if (sourceFinished && ops.length === 0) {
        break;
      }
    }
  }

  // ../node_modules/it-protobuf-stream/dist/src/index.js
  function pbStream(duplex, opts) {
    const lp = lpStream(duplex, opts);
    const W = {
      read: async (proto, options) => {
        const value = await lp.read(options);
        return proto.decode(value);
      },
      write: async (message2, proto, options) => {
        await lp.write(proto.encode(message2), options);
      },
      writeV: async (messages2, proto, options) => {
        await lp.writeV(messages2.map((message2) => proto.encode(message2)), options);
      },
      pb: (proto) => {
        return {
          read: async (options) => W.read(proto, options),
          write: async (d2, options) => W.write(d2, proto, options),
          writeV: async (d2, options) => W.writeV(d2, proto, options),
          unwrap: () => W
        };
      },
      unwrap: () => {
        return lp.unwrap();
      }
    };
    return W;
  }

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports8 = {};
  __export(base10_exports8, {
    base10: () => base108
  });

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bytes.js
  var empty8 = new Uint8Array(0);
  function equals21(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce8(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function fromString15(str) {
    return new TextEncoder().encode(str);
  }
  function toString13(b) {
    return new TextDecoder().decode(b);
  }

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/vendor/base-x.js
  function base12(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src8 = base12;
  var _brrp__multiformats_scope_baseX8 = src8;
  var base_x_default8 = _brrp__multiformats_scope_baseX8;

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base.js
  var Encoder9 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder9 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or9(this, decoder);
    }
  };
  var ComposedDecoder8 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or9(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or9(left, right) {
    return new ComposedDecoder8({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec8 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder9(name19, prefix, baseEncode);
      this.decoder = new Decoder9(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from15({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec8(name19, prefix, encode79, decode99);
  }
  function baseX8({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default8(alphabet18, name19);
    return from15({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce8(decode99(text))
    });
  }
  function decode39(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode32(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx8(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc46488({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx8(alphabet18);
    return from15({
      prefix,
      name: name19,
      encode(input) {
        return encode32(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode39(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base10.js
  var base108 = baseX8({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports8 = {};
  __export(base16_exports8, {
    base16: () => base168,
    base16upper: () => base16upper8
  });
  var base168 = rfc46488({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper8 = rfc46488({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports8 = {};
  __export(base2_exports8, {
    base2: () => base28
  });
  var base28 = rfc46488({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports8 = {};
  __export(base256emoji_exports8, {
    base256emoji: () => base256emoji8
  });
  var alphabet8 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars8 = alphabet8.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes8 = alphabet8.reduce((p, c, i) => {
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
  }, []);
  function encode33(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars8[c];
      return p;
    }, "");
  }
  function decode40(str) {
    const byts = [];
    for (const char of str) {
      const codePoint = char.codePointAt(0);
      if (codePoint == null) {
        throw new Error(`Invalid character: ${char}`);
      }
      const byt = alphabetCharsToBytes8[codePoint];
      if (byt == null) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji8 = from15({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode33,
    decode: decode40
  });

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports8 = {};
  __export(base32_exports8, {
    base32: () => base328,
    base32hex: () => base32hex8,
    base32hexpad: () => base32hexpad8,
    base32hexpadupper: () => base32hexpadupper8,
    base32hexupper: () => base32hexupper8,
    base32pad: () => base32pad8,
    base32padupper: () => base32padupper8,
    base32upper: () => base32upper8,
    base32z: () => base32z8
  });
  var base328 = rfc46488({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper8 = rfc46488({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad8 = rfc46488({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper8 = rfc46488({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex8 = rfc46488({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper8 = rfc46488({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad8 = rfc46488({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper8 = rfc46488({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z8 = rfc46488({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports8 = {};
  __export(base36_exports8, {
    base36: () => base368,
    base36upper: () => base36upper8
  });
  var base368 = baseX8({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper8 = baseX8({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports8 = {};
  __export(base58_exports8, {
    base58btc: () => base58btc8,
    base58flickr: () => base58flickr8
  });
  var base58btc8 = baseX8({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr8 = baseX8({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports8 = {};
  __export(base64_exports8, {
    base64: () => base648,
    base64pad: () => base64pad8,
    base64url: () => base64url8,
    base64urlpad: () => base64urlpad8
  });
  var base648 = rfc46488({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad8 = rfc46488({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url8 = rfc46488({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad8 = rfc46488({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports8 = {};
  __export(base8_exports8, {
    base8: () => base88
  });
  var base88 = rfc46488({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports15 = {};
  __export(identity_exports15, {
    identity: () => identity15
  });
  var identity15 = from15({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString13(buf),
    decode: (str) => fromString15(str)
  });

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/codecs/json.js
  var textEncoder8 = new TextEncoder();
  var textDecoder8 = new TextDecoder();

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports16 = {};
  __export(identity_exports16, {
    identity: () => identity16
  });

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_18 = encode34;
  var MSB9 = 128;
  var REST9 = 127;
  var MSBALL8 = ~REST9;
  var INT8 = Math.pow(2, 31);
  function encode34(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT8) {
      out[offset++] = num & 255 | MSB9;
      num /= 128;
    }
    while (num & MSBALL8) {
      out[offset++] = num & 255 | MSB9;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode34.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode41 = read9;
  var MSB$18 = 128;
  var REST$18 = 127;
  function read9(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read9.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$18) << shift : (b & REST$18) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$18);
    read9.bytes = counter - offset;
    return res;
  }
  var N19 = Math.pow(2, 7);
  var N29 = Math.pow(2, 14);
  var N39 = Math.pow(2, 21);
  var N49 = Math.pow(2, 28);
  var N59 = Math.pow(2, 35);
  var N69 = Math.pow(2, 42);
  var N79 = Math.pow(2, 49);
  var N88 = Math.pow(2, 56);
  var N98 = Math.pow(2, 63);
  var length9 = function(value) {
    return value < N19 ? 1 : value < N29 ? 2 : value < N39 ? 3 : value < N49 ? 4 : value < N59 ? 5 : value < N69 ? 6 : value < N79 ? 7 : value < N88 ? 8 : value < N98 ? 9 : 10;
  };
  var varint8 = {
    encode: encode_18,
    decode: decode41,
    encodingLength: length9
  };
  var _brrp_varint8 = varint8;
  var varint_default8 = _brrp_varint8;

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/varint.js
  function decode42(data, offset = 0) {
    const code18 = varint_default8.decode(data, offset);
    return [code18, varint_default8.decode.bytes];
  }
  function encodeTo8(int, target, offset = 0) {
    varint_default8.encode(int, target, offset);
    return target;
  }
  function encodingLength9(int) {
    return varint_default8.encodingLength(int);
  }

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/hashes/digest.js
  function create8(code18, digest18) {
    const size = digest18.byteLength;
    const sizeOffset = encodingLength9(code18);
    const digestOffset = sizeOffset + encodingLength9(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo8(code18, bytes2, 0);
    encodeTo8(size, bytes2, sizeOffset);
    bytes2.set(digest18, digestOffset);
    return new Digest8(code18, size, digest18, bytes2);
  }
  function decode43(multihash) {
    const bytes2 = coerce8(multihash);
    const [code18, sizeOffset] = decode42(bytes2);
    const [size, digestOffset] = decode42(bytes2.subarray(sizeOffset));
    const digest18 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest18.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest8(code18, size, digest18, bytes2);
  }
  function equals22(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals21(a.bytes, data.bytes);
    }
  }
  var Digest8 = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code18, size, digest18, bytes2) {
      this.code = code18;
      this.size = size;
      this.digest = digest18;
      this.bytes = bytes2;
    }
  };

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/hashes/identity.js
  var code8 = 0;
  var name8 = "identity";
  var encode35 = coerce8;
  function digest8(input) {
    return create8(code8, encode35(input));
  }
  var identity16 = { code: code8, name: name8, encode: encode35, digest: digest8 };

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports8 = {};
  __export(sha2_browser_exports8, {
    sha256: () => sha25611,
    sha512: () => sha51210
  });

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/hashes/hasher.js
  function from16({ name: name19, code: code18, encode: encode79 }) {
    return new Hasher8(name19, code18, encode79);
  }
  var Hasher8 = class {
    name;
    code;
    encode;
    constructor(name19, code18, encode79) {
      this.name = name19;
      this.code = code18;
      this.encode = encode79;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create8(this.code, result) : result.then((digest18) => create8(this.code, digest18));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  function sha8(name19) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name19, data));
  }
  var sha25611 = from16({
    name: "sha2-256",
    code: 18,
    encode: sha8("SHA-256")
  });
  var sha51210 = from16({
    name: "sha2-512",
    code: 19,
    encode: sha8("SHA-512")
  });

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/cid.js
  function format8(link, base37) {
    const { bytes: bytes2, version: version5 } = link;
    switch (version5) {
      case 0:
        return toStringV08(bytes2, baseCache8(link), base37 ?? base58btc8.encoder);
      default:
        return toStringV18(bytes2, baseCache8(link), base37 ?? base328.encoder);
    }
  }
  var cache8 = /* @__PURE__ */ new WeakMap();
  function baseCache8(cid) {
    const baseCache19 = cache8.get(cid);
    if (baseCache19 == null) {
      const baseCache20 = /* @__PURE__ */ new Map();
      cache8.set(cid, baseCache20);
      return baseCache20;
    }
    return baseCache19;
  }
  var CID8 = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version5, code18, multihash, bytes2) {
      this.code = code18;
      this.version = version5;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code18, multihash } = this;
          if (code18 !== DAG_PB_CODE8) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE8) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code18, digest: digest18 } = this.multihash;
          const multihash = create8(code18, digest18);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals22(self2.multihash, unknown.multihash);
    }
    toString(base37) {
      return format8(this, base37);
    }
    toJSON() {
      return { "/": format8(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version5, code: code18, multihash, bytes: bytes2 } = value;
        return new _CID(version5, code18, multihash, bytes2 ?? encodeCID8(version5, code18, multihash.bytes));
      } else if (value[cidSymbol8] === true) {
        const { version: version5, multihash, code: code18 } = value;
        const digest18 = decode43(multihash);
        return _CID.create(version5, code18, digest18);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version5, code18, digest18) {
      if (typeof code18 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest18.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version5) {
        case 0: {
          if (code18 !== DAG_PB_CODE8) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE8}) block encoding`);
          } else {
            return new _CID(version5, code18, digest18, digest18.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID8(version5, code18, digest18.bytes);
          return new _CID(version5, code18, digest18, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest18) {
      return _CID.create(0, DAG_PB_CODE8, digest18);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code18, digest18) {
      return _CID.create(1, code18, digest18);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes2) {
      const [cid, remainder] = _CID.decodeFirst(bytes2);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes2) {
      const specs = _CID.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce8(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest18 = new Digest8(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest18) : _CID.createV1(specs.codec, digest18);
      return [cid, bytes2.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length21] = decode42(initialBytes.subarray(offset));
        offset += length21;
        return i;
      };
      let version5 = next();
      let codec = DAG_PB_CODE8;
      if (version5 === 18) {
        version5 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version5 !== 0 && version5 !== 1) {
        throw new RangeError(`Invalid CID version ${version5}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version5, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base37) {
      const [prefix, bytes2] = parseCIDtoBytes8(source, base37);
      const cid = _CID.decode(bytes2);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache8(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes8(source, base37) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base37 ?? base58btc8;
        return [
          base58btc8.prefix,
          decoder.decode(`${base58btc8.prefix}${source}`)
        ];
      }
      case base58btc8.prefix: {
        const decoder = base37 ?? base58btc8;
        return [base58btc8.prefix, decoder.decode(source)];
      }
      case base328.prefix: {
        const decoder = base37 ?? base328;
        return [base328.prefix, decoder.decode(source)];
      }
      case base368.prefix: {
        const decoder = base37 ?? base368;
        return [base368.prefix, decoder.decode(source)];
      }
      default: {
        if (base37 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base37.decode(source)];
      }
    }
  }
  function toStringV08(bytes2, cache20, base37) {
    const { prefix } = base37;
    if (prefix !== base58btc8.prefix) {
      throw Error(`Cannot string encode V0 in ${base37.name} encoding`);
    }
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2).slice(1);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV18(bytes2, cache20, base37) {
    const { prefix } = base37;
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE8 = 112;
  var SHA_256_CODE8 = 18;
  function encodeCID8(version5, code18, multihash) {
    const codeOffset = encodingLength9(version5);
    const hashOffset = codeOffset + encodingLength9(code18);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo8(version5, bytes2, 0);
    encodeTo8(code18, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  }
  var cidSymbol8 = Symbol.for("@ipld/js-cid/CID");

  // ../node_modules/@libp2p/identify/node_modules/multiformats/dist/src/basics.js
  var bases8 = { ...identity_exports15, ...base2_exports8, ...base8_exports8, ...base10_exports8, ...base16_exports8, ...base32_exports8, ...base36_exports8, ...base58_exports8, ...base64_exports8, ...base256emoji_exports8 };
  var hashes8 = { ...sha2_browser_exports8, ...identity_exports16 };

  // ../node_modules/@libp2p/identify/node_modules/uint8arrays/dist/src/alloc.js
  function allocUnsafe12(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/@libp2p/identify/node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec9(name19, prefix, encode79, decode99) {
    return {
      name: name19,
      prefix,
      encoder: {
        name: name19,
        prefix,
        encode: encode79
      },
      decoder: {
        decode: decode99
      }
    };
  }
  var string8 = createCodec9("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder3 = new TextEncoder();
    return encoder3.encode(str.substring(1));
  });
  var ascii8 = createCodec9("ascii", "a", (buf) => {
    let string19 = "a";
    for (let i = 0; i < buf.length; i++) {
      string19 += String.fromCharCode(buf[i]);
    }
    return string19;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe12(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  var BASES8 = {
    utf8: string8,
    "utf-8": string8,
    hex: bases8.base16,
    latin1: ascii8,
    ascii: ascii8,
    binary: ascii8,
    ...bases8
  };
  var bases_default8 = BASES8;

  // ../node_modules/@libp2p/identify/node_modules/uint8arrays/dist/src/from-string.js
  function fromString16(string19, encoding = "utf8") {
    const base37 = bases_default8[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.decoder.decode(`${base37.prefix}${string19}`);
  }

  // ../node_modules/@libp2p/identify/dist/src/consts.js
  var IDENTIFY_PROTOCOL_VERSION = "0.1.0";
  var MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
  var MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
  var MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
  var MAX_PUSH_CONCURRENCY = 32;

  // ../node_modules/@libp2p/identify/dist/src/pb/message.js
  var Identify;
  (function(Identify3) {
    let _codec;
    Identify3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.protocolVersion != null) {
            w2.uint32(42);
            w2.string(obj.protocolVersion);
          }
          if (obj.agentVersion != null) {
            w2.uint32(50);
            w2.string(obj.agentVersion);
          }
          if (obj.publicKey != null) {
            w2.uint32(10);
            w2.bytes(obj.publicKey);
          }
          if (obj.listenAddrs != null) {
            for (const value of obj.listenAddrs) {
              w2.uint32(18);
              w2.bytes(value);
            }
          }
          if (obj.observedAddr != null) {
            w2.uint32(34);
            w2.bytes(obj.observedAddr);
          }
          if (obj.protocols != null) {
            for (const value of obj.protocols) {
              w2.uint32(26);
              w2.string(value);
            }
          }
          if (obj.signedPeerRecord != null) {
            w2.uint32(66);
            w2.bytes(obj.signedPeerRecord);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            listenAddrs: [],
            protocols: []
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 5: {
                obj.protocolVersion = reader.string();
                break;
              }
              case 6: {
                obj.agentVersion = reader.string();
                break;
              }
              case 1: {
                obj.publicKey = reader.bytes();
                break;
              }
              case 2: {
                if (opts.limits?.listenAddrs != null && obj.listenAddrs.length === opts.limits.listenAddrs) {
                  throw new MaxLengthError('Decode error - map field "listenAddrs" had too many elements');
                }
                obj.listenAddrs.push(reader.bytes());
                break;
              }
              case 4: {
                obj.observedAddr = reader.bytes();
                break;
              }
              case 3: {
                if (opts.limits?.protocols != null && obj.protocols.length === opts.limits.protocols) {
                  throw new MaxLengthError('Decode error - map field "protocols" had too many elements');
                }
                obj.protocols.push(reader.string());
                break;
              }
              case 8: {
                obj.signedPeerRecord = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Identify3.encode = (obj) => {
      return encodeMessage(obj, Identify3.codec());
    };
    Identify3.decode = (buf, opts) => {
      return decodeMessage(buf, Identify3.codec(), opts);
    };
  })(Identify || (Identify = {}));

  // ../node_modules/@libp2p/identify/dist/src/utils.js
  var defaultValues = {
    protocolPrefix: "ipfs",
    timeout: 5e3,
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    maxObservedAddresses: 10,
    maxMessageSize: MAX_IDENTIFY_MESSAGE_SIZE,
    runOnConnectionOpen: true,
    runOnSelfUpdate: true,
    runOnLimitedConnection: true,
    concurrency: MAX_PUSH_CONCURRENCY
  };
  function getCleanMultiaddr(addr) {
    if (addr != null && addr.length > 0) {
      try {
        return multiaddr(addr);
      } catch {
      }
    }
  }
  function getAgentVersion(nodeInfo, agentVersion) {
    if (agentVersion != null) {
      return agentVersion;
    }
    return nodeInfo.userAgent;
  }
  async function consumeIdentifyMessage(peerStore, events, log33, connection, message2) {
    log33("received identify from %p", connection.remotePeer);
    if (message2 == null) {
      throw new InvalidMessageError("message was null or undefined");
    }
    const peer = {};
    if (message2.listenAddrs.length > 0) {
      peer.addresses = message2.listenAddrs.map((buf) => ({
        isCertified: false,
        multiaddr: multiaddr(buf)
      }));
    }
    if (message2.protocols.length > 0) {
      peer.protocols = message2.protocols;
    }
    if (message2.publicKey != null) {
      const publicKey = publicKeyFromProtobuf(message2.publicKey);
      const peerId2 = peerIdFromPublicKey(publicKey);
      if (!peerId2.equals(connection.remotePeer)) {
        throw new InvalidMessageError("public key did not match remote PeerId");
      }
      peer.publicKey = publicKey;
    }
    let output2;
    if (message2.signedPeerRecord != null) {
      log33.trace("received signedPeerRecord from %p", connection.remotePeer);
      let peerRecordEnvelope2 = message2.signedPeerRecord;
      const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope2, PeerRecord2.DOMAIN);
      let peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
      const envelopePeer = peerIdFromCID(envelope.publicKey.toCID());
      if (!peerRecord.peerId.equals(envelopePeer)) {
        throw new InvalidMessageError("signing key does not match PeerId in the PeerRecord");
      }
      if (!connection.remotePeer.equals(peerRecord.peerId)) {
        throw new InvalidMessageError("signing key does not match remote PeerId");
      }
      let existingPeer;
      try {
        existingPeer = await peerStore.get(peerRecord.peerId);
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
      if (existingPeer != null) {
        peer.metadata = existingPeer.metadata;
        if (existingPeer.peerRecordEnvelope != null) {
          const storedEnvelope = RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope);
          const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
          if (storedRecord.seqNumber >= peerRecord.seqNumber) {
            log33("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
            peerRecord = storedRecord;
            peerRecordEnvelope2 = existingPeer.peerRecordEnvelope;
          }
        }
      }
      peer.peerRecordEnvelope = peerRecordEnvelope2;
      peer.addresses = peerRecord.multiaddrs.map((multiaddr2) => ({
        isCertified: true,
        multiaddr: multiaddr2
      }));
      output2 = {
        seq: peerRecord.seqNumber,
        addresses: peerRecord.multiaddrs
      };
    } else {
      log33("%p did not send a signed peer record", connection.remotePeer);
    }
    log33.trace("patching %p with", connection.remotePeer, peer);
    await peerStore.patch(connection.remotePeer, peer);
    if (message2.agentVersion != null || message2.protocolVersion != null) {
      const metadata = {};
      if (message2.agentVersion != null) {
        metadata.AgentVersion = fromString16(message2.agentVersion);
      }
      if (message2.protocolVersion != null) {
        metadata.ProtocolVersion = fromString16(message2.protocolVersion);
      }
      log33.trace("merging %p metadata", connection.remotePeer, metadata);
      await peerStore.merge(connection.remotePeer, {
        metadata
      });
    }
    const result = {
      peerId: connection.remotePeer,
      protocolVersion: message2.protocolVersion,
      agentVersion: message2.agentVersion,
      publicKey: message2.publicKey,
      listenAddrs: message2.listenAddrs.map((buf) => multiaddr(buf)),
      observedAddr: message2.observedAddr == null ? void 0 : multiaddr(message2.observedAddr),
      protocols: message2.protocols,
      signedPeerRecord: output2,
      connection
    };
    events.safeDispatchEvent("peer:identify", { detail: result });
    return result;
  }
  var AbstractIdentify = class {
    host;
    protocol;
    started;
    timeout;
    peerId;
    privateKey;
    peerStore;
    registrar;
    addressManager;
    maxInboundStreams;
    maxOutboundStreams;
    maxMessageSize;
    maxObservedAddresses;
    events;
    runOnLimitedConnection;
    log;
    constructor(components, init) {
      this.protocol = init.protocol;
      this.started = false;
      this.peerId = components.peerId;
      this.privateKey = components.privateKey;
      this.peerStore = components.peerStore;
      this.registrar = components.registrar;
      this.addressManager = components.addressManager;
      this.events = components.events;
      this.log = init.log;
      this.timeout = init.timeout ?? defaultValues.timeout;
      this.maxInboundStreams = init.maxInboundStreams ?? defaultValues.maxInboundStreams;
      this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues.maxOutboundStreams;
      this.maxMessageSize = init.maxMessageSize ?? defaultValues.maxMessageSize;
      this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses;
      this.runOnLimitedConnection = init.runOnLimitedConnection ?? defaultValues.runOnLimitedConnection;
      this.host = {
        protocolVersion: `${init.protocolPrefix ?? defaultValues.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
        agentVersion: getAgentVersion(components.nodeInfo, init.agentVersion)
      };
    }
    isStarted() {
      return this.started;
    }
    async start() {
      if (this.started) {
        return;
      }
      await this.peerStore.merge(this.peerId, {
        metadata: {
          AgentVersion: fromString16(this.host.agentVersion),
          ProtocolVersion: fromString16(this.host.protocolVersion)
        }
      });
      await this.registrar.handle(this.protocol, (data) => {
        void this.handleProtocol(data).catch((err) => {
          this.log.error(err);
        });
      }, {
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams,
        runOnLimitedConnection: this.runOnLimitedConnection
      });
      this.started = true;
    }
    async stop() {
      await this.registrar.unhandle(this.protocol);
      this.started = false;
    }
  };

  // ../node_modules/@libp2p/utils/dist/src/multiaddr/is-global-unicast.js
  function isGlobalUnicast(ma) {
    try {
      for (const { code: code18, value } of ma.getComponents()) {
        if (value == null) {
          continue;
        }
        if (code18 === CODE_IP6) {
          return cidrContains("2000::/3", value);
        }
      }
    } catch {
    }
    return false;
  }

  // ../node_modules/@libp2p/utils/dist/src/private-ip.js
  var import_netmask3 = __toESM(require_netmask(), 1);
  var PRIVATE_IP_RANGES = [
    "0.0.0.0/8",
    "10.0.0.0/8",
    "100.64.0.0/10",
    "127.0.0.0/8",
    "169.254.0.0/16",
    "172.16.0.0/12",
    "192.0.0.0/24",
    "192.0.0.0/29",
    "192.0.0.8/32",
    "192.0.0.9/32",
    "192.0.0.10/32",
    "192.0.0.170/32",
    "192.0.0.171/32",
    "192.0.2.0/24",
    "192.31.196.0/24",
    "192.52.193.0/24",
    "192.88.99.0/24",
    "192.168.0.0/16",
    "192.175.48.0/24",
    "198.18.0.0/15",
    "198.51.100.0/24",
    "203.0.113.0/24",
    "240.0.0.0/4",
    "255.255.255.255/32"
  ];
  var NETMASK_RANGES = PRIVATE_IP_RANGES.map((ipRange) => new import_netmask3.Netmask(ipRange));
  function ipv4Check(ipAddr) {
    for (const r of NETMASK_RANGES) {
      if (r.contains(ipAddr)) {
        return true;
      }
    }
    return false;
  }
  function isIpv4MappedIpv6(ipAddr) {
    return /^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(ipAddr);
  }
  function ipv4MappedIpv6Check(ipAddr) {
    const parts = ipAddr.split(":");
    if (parts.length < 2) {
      return false;
    }
    const octet34 = parts[parts.length - 1].padStart(4, "0");
    const octet12 = parts[parts.length - 2].padStart(4, "0");
    const ip4 = `${parseInt(octet12.substring(0, 2), 16)}.${parseInt(octet12.substring(2), 16)}.${parseInt(octet34.substring(0, 2), 16)}.${parseInt(octet34.substring(2), 16)}`;
    return ipv4Check(ip4);
  }
  function isIpv4EmbeddedIpv6(ipAddr) {
    return /^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr);
  }
  function ipv4EmbeddedIpv6Check(ipAddr) {
    const parts = ipAddr.split(":");
    const ip4 = parts[parts.length - 1];
    return ipv4Check(ip4);
  }
  function ipv6Check(ipAddr) {
    return /^::$/.test(ipAddr) || /^::1$/.test(ipAddr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ipAddr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ipAddr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ipAddr);
  }
  function isPrivateIp(ip) {
    if (isIPv4(ip)) {
      return ipv4Check(ip);
    }
    if (isIpv4MappedIpv6(ip)) {
      return ipv4MappedIpv6Check(ip);
    }
    if (isIpv4EmbeddedIpv6(ip)) {
      return ipv4EmbeddedIpv6Check(ip);
    }
    if (isIPv6(ip)) {
      return ipv6Check(ip);
    }
  }

  // ../node_modules/@libp2p/utils/dist/src/multiaddr/is-ip-based.js
  function isIpBased(ma) {
    try {
      for (const { code: code18 } of ma.getComponents()) {
        if (code18 === CODE_IP6ZONE) {
          continue;
        }
        return code18 === CODE_IP4 || code18 === CODE_IP6;
      }
    } catch {
    }
    return false;
  }

  // ../node_modules/@libp2p/utils/dist/src/multiaddr/is-private.js
  function isPrivate(ma) {
    try {
      if (!isIpBased(ma)) {
        return false;
      }
      const [[, value]] = ma.stringTuples();
      if (value == null) {
        return false;
      }
      return isPrivateIp(value) ?? false;
    } catch {
    }
    return true;
  }

  // ../node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/dist/src/bytes.js
  var empty9 = new Uint8Array(0);
  function coerce9(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }

  // ../node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/dist/src/vendor/base-x.js
  function base13(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src9 = base13;
  var _brrp__multiformats_scope_baseX9 = src9;
  var base_x_default9 = _brrp__multiformats_scope_baseX9;

  // ../node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/dist/src/bases/base.js
  var Encoder10 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder10 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or10(this, decoder);
    }
  };
  var ComposedDecoder9 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or10(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or10(left, right) {
    return new ComposedDecoder9({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec9 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder10(name19, prefix, baseEncode);
      this.decoder = new Decoder10(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from17({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec9(name19, prefix, encode79, decode99);
  }
  function baseX9({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default9(alphabet18, name19);
    return from17({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce9(decode99(text))
    });
  }
  function decode44(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode36(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx9(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc46489({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx9(alphabet18);
    return from17({
      prefix,
      name: name19,
      encode(input) {
        return encode36(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode44(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/dist/src/bases/base58.js
  var base58btc9 = baseX9({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr9 = baseX9({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/dist/src/bases/base64.js
  var base649 = rfc46489({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad9 = rfc46489({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url9 = rfc46489({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad9 = rfc46489({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // ../node_modules/@multiformats/multiaddr-matcher/dist/src/utils.js
  var toParts = (ma) => {
    return ma.toString().split("/").slice(1);
  };
  var func = (fn) => {
    return {
      match: (vals) => {
        if (vals.length < 1) {
          return false;
        }
        if (fn(vals[0])) {
          return vals.slice(1);
        }
        return false;
      },
      pattern: "fn"
    };
  };
  var literal = (str) => {
    return {
      match: (vals) => func((val) => val === str).match(vals),
      pattern: str
    };
  };
  var string9 = () => {
    return {
      match: (vals) => func((val) => typeof val === "string").match(vals),
      pattern: "{string}"
    };
  };
  var number2 = () => {
    return {
      match: (vals) => func((val) => !isNaN(parseInt(val))).match(vals),
      pattern: "{number}"
    };
  };
  var peerId = () => {
    return {
      match: (vals) => {
        if (vals.length < 2) {
          return false;
        }
        if (vals[0] !== "p2p" && vals[0] !== "ipfs") {
          return false;
        }
        if (vals[1].startsWith("Q") || vals[1].startsWith("1")) {
          try {
            base58btc9.decode(`z${vals[1]}`);
          } catch (err) {
            return false;
          }
        } else {
          return false;
        }
        return vals.slice(2);
      },
      pattern: "/p2p/{peerid}"
    };
  };
  var certhash = () => {
    return {
      match: (vals) => {
        if (vals.length < 2) {
          return false;
        }
        if (vals[0] !== "certhash") {
          return false;
        }
        try {
          base64url9.decode(vals[1]);
        } catch {
          return false;
        }
        return vals.slice(2);
      },
      pattern: "/certhash/{certhash}"
    };
  };
  var optional = (matcher) => {
    return {
      match: (vals) => {
        const result = matcher.match(vals);
        if (result === false) {
          return vals;
        }
        return result;
      },
      pattern: `optional(${matcher.pattern})`
    };
  };
  var or11 = (...matchers) => {
    return {
      match: (vals) => {
        let matches;
        for (const matcher of matchers) {
          const result = matcher.match(vals);
          if (result === false) {
            continue;
          }
          if (matches == null || result.length < matches.length) {
            matches = result;
          }
        }
        if (matches == null) {
          return false;
        }
        return matches;
      },
      pattern: `or(${matchers.map((m2) => m2.pattern).join(", ")})`
    };
  };
  var and2 = (...matchers) => {
    return {
      match: (vals) => {
        for (const matcher of matchers) {
          const result = matcher.match(vals);
          if (result === false) {
            return false;
          }
          vals = result;
        }
        return vals;
      },
      pattern: `and(${matchers.map((m2) => m2.pattern).join(", ")})`
    };
  };
  function fmt(...matchers) {
    function match(ma) {
      let parts = toParts(ma);
      for (const matcher of matchers) {
        const result = matcher.match(parts);
        if (result === false) {
          return false;
        }
        parts = result;
      }
      return parts;
    }
    function matches(ma) {
      const result = match(ma);
      return result !== false;
    }
    function exactMatch(ma) {
      const result = match(ma);
      if (result === false) {
        return false;
      }
      return result.length === 0;
    }
    return {
      matchers,
      matches,
      exactMatch
    };
  }

  // ../node_modules/@multiformats/multiaddr-matcher/dist/src/index.js
  var _PEER_ID = peerId();
  var PEER_ID = fmt(_PEER_ID);
  var _DNS4 = and2(literal("dns4"), string9());
  var _DNS6 = and2(literal("dns6"), string9());
  var _DNSADDR = and2(literal("dnsaddr"), string9());
  var _DNS = and2(literal("dns"), string9());
  var DNS42 = fmt(_DNS4, optional(peerId()));
  var DNS62 = fmt(_DNS6, optional(peerId()));
  var DNSADDR2 = fmt(_DNSADDR, optional(peerId()));
  var DNS2 = fmt(or11(_DNS, _DNSADDR, _DNS4, _DNS6), optional(peerId()));
  var _IP4 = and2(literal("ip4"), func(isIPv4));
  var _IP6 = and2(literal("ip6"), func(isIPv6));
  var _IP = or11(_IP4, _IP6);
  var _IP_OR_DOMAIN = or11(_IP, _DNS, _DNS4, _DNS6, _DNSADDR);
  var IP_OR_DOMAIN = fmt(or11(_IP, and2(or11(_DNS, _DNSADDR, _DNS4, _DNS6), optional(peerId()))));
  var IP4 = fmt(_IP4);
  var IP6 = fmt(_IP6);
  var IP2 = fmt(_IP);
  var _TCP = and2(_IP_OR_DOMAIN, literal("tcp"), number2());
  var _UDP = and2(_IP_OR_DOMAIN, literal("udp"), number2());
  var TCP2 = fmt(and2(_TCP, optional(peerId())));
  var UDP2 = fmt(_UDP);
  var _QUIC = and2(_UDP, literal("quic"), optional(peerId()));
  var _QUICV1 = and2(_UDP, literal("quic-v1"), optional(peerId()));
  var QUIC_V0_OR_V1 = or11(_QUIC, _QUICV1);
  var QUIC2 = fmt(_QUIC);
  var QUICV12 = fmt(_QUICV1);
  var _WEB = or11(_IP_OR_DOMAIN, _TCP, _UDP, _QUIC, _QUICV1);
  var _WebSockets2 = or11(and2(_WEB, literal("ws"), optional(peerId())));
  var WebSockets2 = fmt(_WebSockets2);
  var _WebSocketsSecure2 = or11(and2(_WEB, literal("wss"), optional(peerId())), and2(_WEB, literal("tls"), optional(and2(literal("sni"), string9())), literal("ws"), optional(peerId())));
  var WebSocketsSecure2 = fmt(_WebSocketsSecure2);
  var _WebRTCDirect2 = and2(_UDP, literal("webrtc-direct"), optional(certhash()), optional(certhash()), optional(peerId()));
  var WebRTCDirect2 = fmt(_WebRTCDirect2);
  var _WebTransport2 = and2(_QUICV1, literal("webtransport"), optional(certhash()), optional(certhash()), optional(peerId()));
  var WebTransport2 = fmt(_WebTransport2);
  var _P2P2 = or11(_WebSockets2, _WebSocketsSecure2, and2(_TCP, optional(peerId())), and2(QUIC_V0_OR_V1, optional(peerId())), and2(_IP_OR_DOMAIN, optional(peerId())), _WebRTCDirect2, _WebTransport2, peerId());
  var P2P2 = fmt(_P2P2);
  var _Circuit2 = and2(_P2P2, literal("p2p-circuit"), peerId());
  var Circuit2 = fmt(_Circuit2);
  var _WebRTC = or11(and2(_P2P2, literal("p2p-circuit"), literal("webrtc"), optional(peerId())), and2(_P2P2, literal("webrtc"), optional(peerId())), and2(literal("webrtc"), optional(peerId())));
  var WebRTC2 = fmt(_WebRTC);
  var _HTTP = or11(and2(_IP_OR_DOMAIN, literal("tcp"), number2(), literal("http"), optional(peerId())), and2(_IP_OR_DOMAIN, literal("http"), optional(peerId())));
  var HTTP2 = fmt(_HTTP);
  var _HTTPS = or11(and2(_IP_OR_DOMAIN, literal("tcp"), or11(and2(literal("443"), literal("http")), and2(number2(), literal("https")), and2(number2(), literal("tls"), literal("http"))), optional(peerId())), and2(_IP_OR_DOMAIN, literal("tls"), literal("http"), optional(peerId())), and2(_IP_OR_DOMAIN, literal("https"), optional(peerId())));
  var HTTPS2 = fmt(_HTTPS);
  var _Memory = or11(and2(literal("memory"), string9(), optional(peerId())));
  var Memory = fmt(_Memory);
  var _Unix = or11(and2(literal("unix"), string9(), optional(peerId())));
  var Unix = fmt(_Unix);

  // ../node_modules/@libp2p/identify/dist/src/identify.js
  var Identify2 = class extends AbstractIdentify {
    constructor(components, init = {}) {
      super(components, {
        ...init,
        protocol: `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,
        log: components.logger.forComponent("libp2p:identify")
      });
      if (init.runOnConnectionOpen ?? defaultValues.runOnConnectionOpen) {
        components.events.addEventListener("connection:open", (evt) => {
          const connection = evt.detail;
          this.identify(connection).catch((err) => {
            if (err.name === UnsupportedProtocolError.name) {
              return;
            }
            this.log.error("error during identify trigged by connection:open", err);
          });
        });
      }
    }
    [serviceCapabilities] = [
      "@libp2p/identify"
    ];
    async _identify(connection, options = {}) {
      let stream;
      if (options.signal == null) {
        const signal = AbortSignal.timeout(this.timeout);
        setMaxListeners(Infinity, signal);
        options = {
          ...options,
          signal
        };
      }
      try {
        stream = await connection.newStream(this.protocol, {
          ...options,
          runOnLimitedConnection: this.runOnLimitedConnection
        });
        const pb = pbStream(stream, {
          maxDataLength: this.maxMessageSize
        }).pb(Identify);
        const message2 = await pb.read(options);
        await stream.close(options);
        return message2;
      } catch (err) {
        stream?.abort(err);
        throw err;
      }
    }
    async identify(connection, options = {}) {
      const message2 = await this._identify(connection, options);
      const { publicKey, protocols: protocols2, observedAddr } = message2;
      if (publicKey == null) {
        throw new InvalidMessageError("public key was missing from identify message");
      }
      const key = publicKeyFromProtobuf(publicKey);
      const id = peerIdFromCID(key.toCID());
      if (!connection.remotePeer.equals(id)) {
        throw new InvalidMessageError("identified peer does not match the expected peer");
      }
      if (this.peerId.equals(id)) {
        throw new InvalidMessageError("identified peer is our own peer id?");
      }
      this.maybeAddObservedAddress(observedAddr);
      this.log("identify completed for peer %p and protocols %o", id, protocols2);
      return consumeIdentifyMessage(this.peerStore, this.events, this.log, connection, message2);
    }
    maybeAddObservedAddress(observedAddr) {
      const cleanObservedAddr = getCleanMultiaddr(observedAddr);
      if (cleanObservedAddr == null) {
        return;
      }
      this.log.trace("our observed address was %a", cleanObservedAddr);
      if (isPrivate(cleanObservedAddr)) {
        this.log.trace("our observed address was private");
        return;
      }
      const tuples = cleanObservedAddr.getComponents();
      if ((tuples[0].code === CODE_IP6 || tuples[0].code === CODE_IP6ZONE && tuples[1].code === CODE_IP6) && !isGlobalUnicast(cleanObservedAddr)) {
        this.log.trace("our observed address was IPv6 but not a global unicast address");
        return;
      }
      if (TCP2.exactMatch(cleanObservedAddr)) {
        return;
      }
      this.log.trace("storing the observed address");
      this.addressManager.addObservedAddr(cleanObservedAddr);
    }
    /**
     * Sends the `Identify` response with the Signed Peer Record
     * to the requesting peer over the given `connection`
     */
    async handleProtocol(data) {
      const { connection, stream } = data;
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      try {
        const peerData = await this.peerStore.get(this.peerId);
        const multiaddrs = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(protocols("p2p").code));
        let signedPeerRecord = peerData.peerRecordEnvelope;
        if (multiaddrs.length > 0 && signedPeerRecord == null) {
          const peerRecord = new PeerRecord2({
            peerId: this.peerId,
            multiaddrs
          });
          const envelope = await RecordEnvelope.seal(peerRecord, this.privateKey);
          signedPeerRecord = envelope.marshal().subarray();
        }
        let observedAddr = connection.remoteAddr.bytes;
        if (!IP_OR_DOMAIN.matches(connection.remoteAddr)) {
          observedAddr = void 0;
        }
        const pb = pbStream(stream).pb(Identify);
        await pb.write({
          protocolVersion: this.host.protocolVersion,
          agentVersion: this.host.agentVersion,
          publicKey: publicKeyToProtobuf(this.privateKey.publicKey),
          listenAddrs: multiaddrs.map((addr) => addr.bytes),
          signedPeerRecord,
          observedAddr,
          protocols: peerData.protocols
        }, {
          signal
        });
        await stream.close({
          signal
        });
      } catch (err) {
        this.log.error("could not respond to identify request", err);
        stream.abort(err);
      }
    }
  };

  // ../node_modules/@libp2p/identify/dist/src/index.js
  function identify(init = {}) {
    return (components) => new Identify2(components, init);
  }

  // ../node_modules/get-iterator/dist/src/index.js
  function getIterator(obj) {
    if (obj != null) {
      if (typeof obj[Symbol.iterator] === "function") {
        return obj[Symbol.iterator]();
      }
      if (typeof obj[Symbol.asyncIterator] === "function") {
        return obj[Symbol.asyncIterator]();
      }
      if (typeof obj.next === "function") {
        return obj;
      }
    }
    throw new Error("argument is not an iterator or iterable");
  }

  // ../node_modules/@libp2p/utils/dist/src/is-promise.js
  function isPromise2(thing) {
    if (thing == null) {
      return false;
    }
    return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
  }

  // ../node_modules/@libp2p/utils/dist/src/close-source.js
  function closeSource(source, log33) {
    const res = getIterator(source).return?.();
    if (isPromise2(res)) {
      res.catch((err) => {
        log33.error("could not cause iterator to return", err);
      });
    }
  }

  // ../node_modules/delay/index.js
  var createAbortError = () => {
    const error = new Error("Delay aborted");
    error.name = "AbortError";
    return error;
  };
  var clearMethods = /* @__PURE__ */ new WeakMap();
  function createDelay({ clearTimeout: defaultClear, setTimeout: defaultSet } = {}) {
    return (milliseconds, { value, signal } = {}) => {
      if (signal?.aborted) {
        return Promise.reject(createAbortError());
      }
      let timeoutId;
      let settle;
      let rejectFunction;
      const clear = defaultClear ?? clearTimeout;
      const signalListener = () => {
        clear(timeoutId);
        rejectFunction(createAbortError());
      };
      const cleanup = () => {
        if (signal) {
          signal.removeEventListener("abort", signalListener);
        }
      };
      const delayPromise = new Promise((resolve, reject) => {
        settle = () => {
          cleanup();
          resolve(value);
        };
        rejectFunction = reject;
        timeoutId = (defaultSet ?? setTimeout)(settle, milliseconds);
      });
      if (signal) {
        signal.addEventListener("abort", signalListener, { once: true });
      }
      clearMethods.set(delayPromise, () => {
        clear(timeoutId);
        timeoutId = null;
        settle();
      });
      return delayPromise;
    };
  }
  var delay = createDelay();
  var delay_default = delay;

  // ../node_modules/@libp2p/utils/dist/src/errors.js
  var RateLimitError = class extends Error {
    remainingPoints;
    msBeforeNext;
    consumedPoints;
    isFirstInDuration;
    constructor(message2 = "Rate limit exceeded", props) {
      super(message2);
      this.name = "RateLimitError";
      this.remainingPoints = props.remainingPoints;
      this.msBeforeNext = props.msBeforeNext;
      this.consumedPoints = props.consumedPoints;
      this.isFirstInDuration = props.isFirstInDuration;
    }
  };
  var QueueFullError = class extends Error {
    static name = "QueueFullError";
    constructor(message2 = "The queue was full") {
      super(message2);
      this.name = "QueueFullError";
    }
  };

  // ../node_modules/@libp2p/utils/dist/src/rate-limiter.js
  var RateLimiter = class {
    memoryStorage;
    points;
    duration;
    blockDuration;
    execEvenly;
    execEvenlyMinDelayMs;
    keyPrefix;
    constructor(opts = {}) {
      this.points = opts.points ?? 4;
      this.duration = opts.duration ?? 1;
      this.blockDuration = opts.blockDuration ?? 0;
      this.execEvenly = opts.execEvenly ?? false;
      this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs ?? this.duration * 1e3 / this.points;
      this.keyPrefix = opts.keyPrefix ?? "rlflx";
      this.memoryStorage = new MemoryStorage();
    }
    async consume(key, pointsToConsume = 1, options = {}) {
      const rlKey = this.getKey(key);
      const secDuration = this._getKeySecDuration(options);
      let res = this.memoryStorage.incrby(rlKey, pointsToConsume, secDuration);
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      if (res.consumedPoints > this.points) {
        if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {
          res = this.memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);
        }
        throw new RateLimitError("Rate limit exceeded", res);
      } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
        let delayMs = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
        if (delayMs < this.execEvenlyMinDelayMs) {
          delayMs = res.consumedPoints * this.execEvenlyMinDelayMs;
        }
        await delay_default(delayMs);
      }
      return res;
    }
    penalty(key, points = 1, options = {}) {
      const rlKey = this.getKey(key);
      const secDuration = this._getKeySecDuration(options);
      const res = this.memoryStorage.incrby(rlKey, points, secDuration);
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      return res;
    }
    reward(key, points = 1, options = {}) {
      const rlKey = this.getKey(key);
      const secDuration = this._getKeySecDuration(options);
      const res = this.memoryStorage.incrby(rlKey, -points, secDuration);
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      return res;
    }
    /**
     * Block any key for secDuration seconds
     *
     * @param key
     * @param secDuration
     */
    block(key, secDuration) {
      const msDuration = secDuration * 1e3;
      const initPoints = this.points + 1;
      this.memoryStorage.set(this.getKey(key), initPoints, secDuration);
      return {
        remainingPoints: 0,
        msBeforeNext: msDuration === 0 ? -1 : msDuration,
        consumedPoints: initPoints,
        isFirstInDuration: false
      };
    }
    set(key, points, secDuration = 0) {
      const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
      this.memoryStorage.set(this.getKey(key), points, secDuration);
      return {
        remainingPoints: 0,
        msBeforeNext: msDuration === 0 ? -1 : msDuration,
        consumedPoints: points,
        isFirstInDuration: false
      };
    }
    get(key) {
      const res = this.memoryStorage.get(this.getKey(key));
      if (res != null) {
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      }
      return res;
    }
    delete(key) {
      this.memoryStorage.delete(this.getKey(key));
    }
    _getKeySecDuration(options) {
      if (options?.customDuration != null && options.customDuration >= 0) {
        return options.customDuration;
      }
      return this.duration;
    }
    getKey(key) {
      return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;
    }
    parseKey(rlKey) {
      return rlKey.substring(this.keyPrefix.length);
    }
  };
  var MemoryStorage = class {
    storage;
    constructor() {
      this.storage = /* @__PURE__ */ new Map();
    }
    incrby(key, value, durationSec) {
      const existing = this.storage.get(key);
      if (existing != null) {
        const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
        if (existing.expiresAt == null || msBeforeExpires > 0) {
          existing.value += value;
          return {
            remainingPoints: 0,
            msBeforeNext: msBeforeExpires,
            consumedPoints: existing.value,
            isFirstInDuration: false
          };
        }
        return this.set(key, value, durationSec);
      }
      return this.set(key, value, durationSec);
    }
    set(key, value, durationSec) {
      const durationMs = durationSec * 1e3;
      const existing = this.storage.get(key);
      if (existing != null) {
        clearTimeout(existing.timeoutId);
      }
      const record = {
        value,
        expiresAt: durationMs > 0 ? new Date(Date.now() + durationMs) : void 0
      };
      this.storage.set(key, record);
      if (durationMs > 0) {
        record.timeoutId = setTimeout(() => {
          this.storage.delete(key);
        }, durationMs);
        if (record.timeoutId.unref != null) {
          record.timeoutId.unref();
        }
      }
      return {
        remainingPoints: 0,
        msBeforeNext: durationMs === 0 ? -1 : durationMs,
        consumedPoints: record.value,
        isFirstInDuration: true
      };
    }
    get(key) {
      const existing = this.storage.get(key);
      if (existing != null) {
        const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
        return {
          remainingPoints: 0,
          msBeforeNext: msBeforeExpires,
          consumedPoints: existing.value,
          isFirstInDuration: false
        };
      }
    }
    delete(key) {
      const record = this.storage.get(key);
      if (record != null) {
        if (record.timeoutId != null) {
          clearTimeout(record.timeoutId);
        }
        this.storage.delete(key);
        return true;
      }
      return false;
    }
  };

  // ../node_modules/@libp2p/mplex/node_modules/uint8arrays/dist/src/alloc.js
  function allocUnsafe13(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports9 = {};
  __export(base10_exports9, {
    base10: () => base109
  });

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bytes.js
  var empty10 = new Uint8Array(0);
  function equals23(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce10(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function fromString17(str) {
    return new TextEncoder().encode(str);
  }
  function toString14(b) {
    return new TextDecoder().decode(b);
  }

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/vendor/base-x.js
  function base14(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src10 = base14;
  var _brrp__multiformats_scope_baseX10 = src10;
  var base_x_default10 = _brrp__multiformats_scope_baseX10;

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base.js
  var Encoder11 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder11 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or12(this, decoder);
    }
  };
  var ComposedDecoder10 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or12(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or12(left, right) {
    return new ComposedDecoder10({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec10 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder11(name19, prefix, baseEncode);
      this.decoder = new Decoder11(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from18({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec10(name19, prefix, encode79, decode99);
  }
  function baseX10({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default10(alphabet18, name19);
    return from18({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce10(decode99(text))
    });
  }
  function decode45(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode37(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx10(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc464810({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx10(alphabet18);
    return from18({
      prefix,
      name: name19,
      encode(input) {
        return encode37(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode45(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base10.js
  var base109 = baseX10({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports9 = {};
  __export(base16_exports9, {
    base16: () => base169,
    base16upper: () => base16upper9
  });
  var base169 = rfc464810({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper9 = rfc464810({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports9 = {};
  __export(base2_exports9, {
    base2: () => base29
  });
  var base29 = rfc464810({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports9 = {};
  __export(base256emoji_exports9, {
    base256emoji: () => base256emoji9
  });
  var alphabet9 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars9 = alphabet9.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes9 = alphabet9.reduce((p, c, i) => {
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
  }, []);
  function encode38(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars9[c];
      return p;
    }, "");
  }
  function decode46(str) {
    const byts = [];
    for (const char of str) {
      const codePoint = char.codePointAt(0);
      if (codePoint == null) {
        throw new Error(`Invalid character: ${char}`);
      }
      const byt = alphabetCharsToBytes9[codePoint];
      if (byt == null) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji9 = from18({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode38,
    decode: decode46
  });

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports9 = {};
  __export(base32_exports9, {
    base32: () => base329,
    base32hex: () => base32hex9,
    base32hexpad: () => base32hexpad9,
    base32hexpadupper: () => base32hexpadupper9,
    base32hexupper: () => base32hexupper9,
    base32pad: () => base32pad9,
    base32padupper: () => base32padupper9,
    base32upper: () => base32upper9,
    base32z: () => base32z9
  });
  var base329 = rfc464810({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper9 = rfc464810({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad9 = rfc464810({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper9 = rfc464810({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex9 = rfc464810({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper9 = rfc464810({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad9 = rfc464810({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper9 = rfc464810({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z9 = rfc464810({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports9 = {};
  __export(base36_exports9, {
    base36: () => base369,
    base36upper: () => base36upper9
  });
  var base369 = baseX10({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper9 = baseX10({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports9 = {};
  __export(base58_exports9, {
    base58btc: () => base58btc10,
    base58flickr: () => base58flickr10
  });
  var base58btc10 = baseX10({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr10 = baseX10({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports9 = {};
  __export(base64_exports9, {
    base64: () => base6410,
    base64pad: () => base64pad10,
    base64url: () => base64url10,
    base64urlpad: () => base64urlpad10
  });
  var base6410 = rfc464810({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad10 = rfc464810({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url10 = rfc464810({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad10 = rfc464810({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports9 = {};
  __export(base8_exports9, {
    base8: () => base89
  });
  var base89 = rfc464810({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports17 = {};
  __export(identity_exports17, {
    identity: () => identity17
  });
  var identity17 = from18({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString14(buf),
    decode: (str) => fromString17(str)
  });

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/codecs/json.js
  var textEncoder9 = new TextEncoder();
  var textDecoder9 = new TextDecoder();

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports18 = {};
  __export(identity_exports18, {
    identity: () => identity18
  });

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_19 = encode39;
  var MSB10 = 128;
  var REST10 = 127;
  var MSBALL9 = ~REST10;
  var INT9 = Math.pow(2, 31);
  function encode39(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT9) {
      out[offset++] = num & 255 | MSB10;
      num /= 128;
    }
    while (num & MSBALL9) {
      out[offset++] = num & 255 | MSB10;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode39.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode47 = read10;
  var MSB$19 = 128;
  var REST$19 = 127;
  function read10(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read10.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$19) << shift : (b & REST$19) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$19);
    read10.bytes = counter - offset;
    return res;
  }
  var N110 = Math.pow(2, 7);
  var N210 = Math.pow(2, 14);
  var N310 = Math.pow(2, 21);
  var N410 = Math.pow(2, 28);
  var N510 = Math.pow(2, 35);
  var N610 = Math.pow(2, 42);
  var N710 = Math.pow(2, 49);
  var N89 = Math.pow(2, 56);
  var N99 = Math.pow(2, 63);
  var length10 = function(value) {
    return value < N110 ? 1 : value < N210 ? 2 : value < N310 ? 3 : value < N410 ? 4 : value < N510 ? 5 : value < N610 ? 6 : value < N710 ? 7 : value < N89 ? 8 : value < N99 ? 9 : 10;
  };
  var varint9 = {
    encode: encode_19,
    decode: decode47,
    encodingLength: length10
  };
  var _brrp_varint9 = varint9;
  var varint_default9 = _brrp_varint9;

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/varint.js
  function decode48(data, offset = 0) {
    const code18 = varint_default9.decode(data, offset);
    return [code18, varint_default9.decode.bytes];
  }
  function encodeTo9(int, target, offset = 0) {
    varint_default9.encode(int, target, offset);
    return target;
  }
  function encodingLength10(int) {
    return varint_default9.encodingLength(int);
  }

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/hashes/digest.js
  function create9(code18, digest18) {
    const size = digest18.byteLength;
    const sizeOffset = encodingLength10(code18);
    const digestOffset = sizeOffset + encodingLength10(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo9(code18, bytes2, 0);
    encodeTo9(size, bytes2, sizeOffset);
    bytes2.set(digest18, digestOffset);
    return new Digest9(code18, size, digest18, bytes2);
  }
  function decode49(multihash) {
    const bytes2 = coerce10(multihash);
    const [code18, sizeOffset] = decode48(bytes2);
    const [size, digestOffset] = decode48(bytes2.subarray(sizeOffset));
    const digest18 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest18.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest9(code18, size, digest18, bytes2);
  }
  function equals24(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals23(a.bytes, data.bytes);
    }
  }
  var Digest9 = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code18, size, digest18, bytes2) {
      this.code = code18;
      this.size = size;
      this.digest = digest18;
      this.bytes = bytes2;
    }
  };

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/hashes/identity.js
  var code9 = 0;
  var name9 = "identity";
  var encode40 = coerce10;
  function digest9(input) {
    return create9(code9, encode40(input));
  }
  var identity18 = { code: code9, name: name9, encode: encode40, digest: digest9 };

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports9 = {};
  __export(sha2_browser_exports9, {
    sha256: () => sha25612,
    sha512: () => sha51211
  });

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/hashes/hasher.js
  function from19({ name: name19, code: code18, encode: encode79 }) {
    return new Hasher9(name19, code18, encode79);
  }
  var Hasher9 = class {
    name;
    code;
    encode;
    constructor(name19, code18, encode79) {
      this.name = name19;
      this.code = code18;
      this.encode = encode79;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create9(this.code, result) : result.then((digest18) => create9(this.code, digest18));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  function sha9(name19) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name19, data));
  }
  var sha25612 = from19({
    name: "sha2-256",
    code: 18,
    encode: sha9("SHA-256")
  });
  var sha51211 = from19({
    name: "sha2-512",
    code: 19,
    encode: sha9("SHA-512")
  });

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/cid.js
  function format9(link, base37) {
    const { bytes: bytes2, version: version5 } = link;
    switch (version5) {
      case 0:
        return toStringV09(bytes2, baseCache9(link), base37 ?? base58btc10.encoder);
      default:
        return toStringV19(bytes2, baseCache9(link), base37 ?? base329.encoder);
    }
  }
  var cache9 = /* @__PURE__ */ new WeakMap();
  function baseCache9(cid) {
    const baseCache19 = cache9.get(cid);
    if (baseCache19 == null) {
      const baseCache20 = /* @__PURE__ */ new Map();
      cache9.set(cid, baseCache20);
      return baseCache20;
    }
    return baseCache19;
  }
  var CID9 = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version5, code18, multihash, bytes2) {
      this.code = code18;
      this.version = version5;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code18, multihash } = this;
          if (code18 !== DAG_PB_CODE9) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE9) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code18, digest: digest18 } = this.multihash;
          const multihash = create9(code18, digest18);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals24(self2.multihash, unknown.multihash);
    }
    toString(base37) {
      return format9(this, base37);
    }
    toJSON() {
      return { "/": format9(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version5, code: code18, multihash, bytes: bytes2 } = value;
        return new _CID(version5, code18, multihash, bytes2 ?? encodeCID9(version5, code18, multihash.bytes));
      } else if (value[cidSymbol9] === true) {
        const { version: version5, multihash, code: code18 } = value;
        const digest18 = decode49(multihash);
        return _CID.create(version5, code18, digest18);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version5, code18, digest18) {
      if (typeof code18 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest18.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version5) {
        case 0: {
          if (code18 !== DAG_PB_CODE9) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE9}) block encoding`);
          } else {
            return new _CID(version5, code18, digest18, digest18.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID9(version5, code18, digest18.bytes);
          return new _CID(version5, code18, digest18, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest18) {
      return _CID.create(0, DAG_PB_CODE9, digest18);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code18, digest18) {
      return _CID.create(1, code18, digest18);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes2) {
      const [cid, remainder] = _CID.decodeFirst(bytes2);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes2) {
      const specs = _CID.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce10(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest18 = new Digest9(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest18) : _CID.createV1(specs.codec, digest18);
      return [cid, bytes2.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length21] = decode48(initialBytes.subarray(offset));
        offset += length21;
        return i;
      };
      let version5 = next();
      let codec = DAG_PB_CODE9;
      if (version5 === 18) {
        version5 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version5 !== 0 && version5 !== 1) {
        throw new RangeError(`Invalid CID version ${version5}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version5, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base37) {
      const [prefix, bytes2] = parseCIDtoBytes9(source, base37);
      const cid = _CID.decode(bytes2);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache9(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes9(source, base37) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base37 ?? base58btc10;
        return [
          base58btc10.prefix,
          decoder.decode(`${base58btc10.prefix}${source}`)
        ];
      }
      case base58btc10.prefix: {
        const decoder = base37 ?? base58btc10;
        return [base58btc10.prefix, decoder.decode(source)];
      }
      case base329.prefix: {
        const decoder = base37 ?? base329;
        return [base329.prefix, decoder.decode(source)];
      }
      case base369.prefix: {
        const decoder = base37 ?? base369;
        return [base369.prefix, decoder.decode(source)];
      }
      default: {
        if (base37 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base37.decode(source)];
      }
    }
  }
  function toStringV09(bytes2, cache20, base37) {
    const { prefix } = base37;
    if (prefix !== base58btc10.prefix) {
      throw Error(`Cannot string encode V0 in ${base37.name} encoding`);
    }
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2).slice(1);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV19(bytes2, cache20, base37) {
    const { prefix } = base37;
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE9 = 112;
  var SHA_256_CODE9 = 18;
  function encodeCID9(version5, code18, multihash) {
    const codeOffset = encodingLength10(version5);
    const hashOffset = codeOffset + encodingLength10(code18);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo9(version5, bytes2, 0);
    encodeTo9(code18, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  }
  var cidSymbol9 = Symbol.for("@ipld/js-cid/CID");

  // ../node_modules/@libp2p/mplex/node_modules/multiformats/dist/src/basics.js
  var bases9 = { ...identity_exports17, ...base2_exports9, ...base8_exports9, ...base10_exports9, ...base16_exports9, ...base32_exports9, ...base36_exports9, ...base58_exports9, ...base64_exports9, ...base256emoji_exports9 };
  var hashes9 = { ...sha2_browser_exports9, ...identity_exports18 };

  // ../node_modules/@libp2p/mplex/node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec10(name19, prefix, encode79, decode99) {
    return {
      name: name19,
      prefix,
      encoder: {
        name: name19,
        prefix,
        encode: encode79
      },
      decoder: {
        decode: decode99
      }
    };
  }
  var string10 = createCodec10("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder3 = new TextEncoder();
    return encoder3.encode(str.substring(1));
  });
  var ascii9 = createCodec10("ascii", "a", (buf) => {
    let string19 = "a";
    for (let i = 0; i < buf.length; i++) {
      string19 += String.fromCharCode(buf[i]);
    }
    return string19;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe13(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  var BASES9 = {
    utf8: string10,
    "utf-8": string10,
    hex: bases9.base16,
    latin1: ascii9,
    ascii: ascii9,
    binary: ascii9,
    ...bases9
  };
  var bases_default9 = BASES9;

  // ../node_modules/@libp2p/mplex/node_modules/uint8arrays/dist/src/from-string.js
  function fromString18(string19, encoding = "utf8") {
    const base37 = bases_default9[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.decoder.decode(`${base37.prefix}${string19}`);
  }

  // ../node_modules/@libp2p/mplex/node_modules/uint8arrays/dist/src/to-string.js
  function toString15(array, encoding = "utf8") {
    const base37 = bases_default9[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.encoder.encode(array).substring(1);
  }

  // ../node_modules/@libp2p/mplex/dist/src/message-types.js
  var MessageTypes;
  (function(MessageTypes2) {
    MessageTypes2[MessageTypes2["NEW_STREAM"] = 0] = "NEW_STREAM";
    MessageTypes2[MessageTypes2["MESSAGE_RECEIVER"] = 1] = "MESSAGE_RECEIVER";
    MessageTypes2[MessageTypes2["MESSAGE_INITIATOR"] = 2] = "MESSAGE_INITIATOR";
    MessageTypes2[MessageTypes2["CLOSE_RECEIVER"] = 3] = "CLOSE_RECEIVER";
    MessageTypes2[MessageTypes2["CLOSE_INITIATOR"] = 4] = "CLOSE_INITIATOR";
    MessageTypes2[MessageTypes2["RESET_RECEIVER"] = 5] = "RESET_RECEIVER";
    MessageTypes2[MessageTypes2["RESET_INITIATOR"] = 6] = "RESET_INITIATOR";
  })(MessageTypes || (MessageTypes = {}));
  var MessageTypeNames = Object.freeze({
    0: "NEW_STREAM",
    1: "MESSAGE_RECEIVER",
    2: "MESSAGE_INITIATOR",
    3: "CLOSE_RECEIVER",
    4: "CLOSE_INITIATOR",
    5: "RESET_RECEIVER",
    6: "RESET_INITIATOR"
  });
  var InitiatorMessageTypes = Object.freeze({
    NEW_STREAM: MessageTypes.NEW_STREAM,
    MESSAGE: MessageTypes.MESSAGE_INITIATOR,
    CLOSE: MessageTypes.CLOSE_INITIATOR,
    RESET: MessageTypes.RESET_INITIATOR
  });
  var ReceiverMessageTypes = Object.freeze({
    MESSAGE: MessageTypes.MESSAGE_RECEIVER,
    CLOSE: MessageTypes.CLOSE_RECEIVER,
    RESET: MessageTypes.RESET_RECEIVER
  });

  // ../node_modules/@libp2p/mplex/dist/src/decode.js
  var MAX_MSG_SIZE = 1 << 20;
  var MAX_MSG_QUEUE_SIZE = 4 << 20;
  var Decoder12 = class {
    _buffer;
    _headerInfo;
    _maxMessageSize;
    _maxUnprocessedMessageQueueSize;
    constructor(maxMessageSize = MAX_MSG_SIZE, maxUnprocessedMessageQueueSize = MAX_MSG_QUEUE_SIZE) {
      this._buffer = new Uint8ArrayList();
      this._headerInfo = null;
      this._maxMessageSize = maxMessageSize;
      this._maxUnprocessedMessageQueueSize = maxUnprocessedMessageQueueSize;
    }
    write(chunk) {
      if (chunk == null || chunk.length === 0) {
        return [];
      }
      this._buffer.append(chunk);
      if (this._buffer.byteLength > this._maxUnprocessedMessageQueueSize) {
        throw new InvalidMessageError("Unprocessed message queue size too large!");
      }
      const msgs = [];
      while (this._buffer.length !== 0) {
        if (this._headerInfo == null) {
          try {
            this._headerInfo = this._decodeHeader(this._buffer);
          } catch (err) {
            if (err.name === "InvalidMessageError") {
              throw err;
            }
            break;
          }
        }
        const { id, type, length: length21, offset } = this._headerInfo;
        const bufferedDataLength = this._buffer.length - offset;
        if (bufferedDataLength < length21) {
          break;
        }
        const msg = {
          id,
          type
        };
        if (type === MessageTypes.NEW_STREAM || type === MessageTypes.MESSAGE_INITIATOR || type === MessageTypes.MESSAGE_RECEIVER) {
          msg.data = this._buffer.sublist(offset, offset + length21);
        }
        msgs.push(msg);
        this._buffer.consume(offset + length21);
        this._headerInfo = null;
      }
      return msgs;
    }
    /**
     * Attempts to decode the message header from the buffer
     */
    _decodeHeader(data) {
      const { value: h2, offset } = readVarInt(data);
      const { value: length21, offset: end } = readVarInt(data, offset);
      const type = h2 & 7;
      if (MessageTypeNames[type] == null) {
        throw new Error(`Invalid type received: ${type}`);
      }
      if (length21 > this._maxMessageSize) {
        throw new InvalidMessageError("Message size too large");
      }
      return { id: h2 >> 3, type, offset: offset + end, length: length21 };
    }
  };
  var MSB11 = 128;
  var REST11 = 127;
  function readVarInt(buf, offset = 0) {
    let res = 0;
    let shift = 0;
    let counter = offset;
    let b;
    const l = buf.length;
    do {
      if (counter >= l || shift > 49) {
        offset = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf.get(counter++);
      res += shift < 28 ? (b & REST11) << shift : (b & REST11) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB11);
    offset = counter - offset;
    return {
      value: res,
      offset
    };
  }

  // ../node_modules/@libp2p/mplex/dist/src/encode.js
  var POOL_SIZE = 10 * 1024;
  var Encoder12 = class {
    _pool;
    _poolOffset;
    constructor() {
      this._pool = allocUnsafe13(POOL_SIZE);
      this._poolOffset = 0;
    }
    /**
     * Encodes the given message and adds it to the passed list
     */
    write(msg, list) {
      const pool2 = this._pool;
      let offset = this._poolOffset;
      encode(msg.id << 3 | msg.type, pool2, offset);
      offset += encodingLength(msg.id << 3 | msg.type);
      if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
        encode(msg.data.length, pool2, offset);
        offset += encodingLength(msg.data.length);
      } else {
        encode(0, pool2, offset);
        offset += encodingLength(0);
      }
      const header = pool2.subarray(this._poolOffset, offset);
      if (POOL_SIZE - offset < 100) {
        this._pool = allocUnsafe13(POOL_SIZE);
        this._poolOffset = 0;
      } else {
        this._poolOffset = offset;
      }
      list.append(header);
      if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
        list.append(msg.data);
      }
    }
  };
  var encoder = new Encoder12();
  async function* encode41(source) {
    for await (const message2 of source) {
      const list = new Uint8ArrayList();
      encoder.write(message2, list);
      yield list;
    }
  }

  // ../node_modules/@libp2p/mplex/dist/src/errors.js
  var StreamInputBufferError = class extends Error {
    constructor(message2 = "Stream input buffer error") {
      super(message2);
      this.name = "StreamInputBufferError";
    }
  };

  // ../node_modules/@libp2p/utils/dist/src/abstract-stream.js
  var DEFAULT_SEND_CLOSE_WRITE_TIMEOUT = 5e3;
  function isPromise3(thing) {
    if (thing == null) {
      return false;
    }
    return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
  }
  var AbstractStream = class {
    id;
    direction;
    timeline;
    protocol;
    metadata;
    source;
    status;
    readStatus;
    writeStatus;
    log;
    sinkController;
    sinkEnd;
    closed;
    endErr;
    streamSource;
    onEnd;
    onCloseRead;
    onCloseWrite;
    onReset;
    onAbort;
    sendCloseWriteTimeout;
    sendingData;
    constructor(init) {
      this.sinkController = new AbortController();
      this.sinkEnd = pDefer();
      this.closed = pDefer();
      this.log = init.log;
      this.status = "open";
      this.readStatus = "ready";
      this.writeStatus = "ready";
      this.id = init.id;
      this.metadata = init.metadata ?? {};
      this.direction = init.direction;
      this.timeline = {
        open: Date.now()
      };
      this.sendCloseWriteTimeout = init.sendCloseWriteTimeout ?? DEFAULT_SEND_CLOSE_WRITE_TIMEOUT;
      this.onEnd = init.onEnd;
      this.onCloseRead = init.onCloseRead;
      this.onCloseWrite = init.onCloseWrite;
      this.onReset = init.onReset;
      this.onAbort = init.onAbort;
      this.source = this.streamSource = pushable({
        onEnd: (err) => {
          if (err != null) {
            this.log.trace("source ended with error", err);
          } else {
            this.log.trace("source ended");
          }
          this.onSourceEnd(err);
        }
      });
      this.sink = this.sink.bind(this);
    }
    async sink(source) {
      if (this.writeStatus !== "ready") {
        throw new StreamStateError(`writable end state is "${this.writeStatus}" not "ready"`);
      }
      try {
        this.writeStatus = "writing";
        const options = {
          signal: this.sinkController.signal
        };
        if (this.direction === "outbound") {
          const res = this.sendNewStream(options);
          if (isPromise3(res)) {
            await res;
          }
        }
        const abortListener = () => {
          closeSource(source, this.log);
        };
        try {
          this.sinkController.signal.addEventListener("abort", abortListener);
          this.log.trace("sink reading from source");
          for await (let data of source) {
            data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data;
            const res = this.sendData(data, options);
            if (isPromise3(res)) {
              this.sendingData = pDefer();
              await res;
              this.sendingData.resolve();
              this.sendingData = void 0;
            }
          }
        } finally {
          this.sinkController.signal.removeEventListener("abort", abortListener);
        }
        this.log.trace('sink finished reading from source, write status is "%s"', this.writeStatus);
        if (this.writeStatus === "writing") {
          this.writeStatus = "closing";
          this.log.trace("send close write to remote");
          await this.sendCloseWrite({
            signal: AbortSignal.timeout(this.sendCloseWriteTimeout)
          });
          this.writeStatus = "closed";
        }
        this.onSinkEnd();
      } catch (err) {
        this.log.trace("sink ended with error, calling abort with error", err);
        this.abort(err);
        throw err;
      } finally {
        this.log.trace("resolve sink end");
        this.sinkEnd.resolve();
      }
    }
    onSourceEnd(err) {
      if (this.timeline.closeRead != null) {
        return;
      }
      this.timeline.closeRead = Date.now();
      this.readStatus = "closed";
      if (err != null && this.endErr == null) {
        this.endErr = err;
      }
      this.onCloseRead?.();
      if (this.timeline.closeWrite != null) {
        this.log.trace("source and sink ended");
        this.timeline.close = Date.now();
        if (this.status !== "aborted" && this.status !== "reset") {
          this.status = "closed";
        }
        if (this.onEnd != null) {
          this.onEnd(this.endErr);
        }
        this.closed.resolve();
      } else {
        this.log.trace("source ended, waiting for sink to end");
      }
    }
    onSinkEnd(err) {
      if (this.timeline.closeWrite != null) {
        return;
      }
      this.timeline.closeWrite = Date.now();
      this.writeStatus = "closed";
      if (err != null && this.endErr == null) {
        this.endErr = err;
      }
      this.onCloseWrite?.();
      if (this.timeline.closeRead != null) {
        this.log.trace("sink and source ended");
        this.timeline.close = Date.now();
        if (this.status !== "aborted" && this.status !== "reset") {
          this.status = "closed";
        }
        if (this.onEnd != null) {
          this.onEnd(this.endErr);
        }
        this.closed.resolve();
      } else {
        this.log.trace("sink ended, waiting for source to end");
      }
    }
    // Close for both Reading and Writing
    async close(options) {
      if (this.status !== "open") {
        return;
      }
      this.log.trace("closing gracefully");
      this.status = "closing";
      await raceSignal(Promise.all([
        this.closeWrite(options),
        this.closeRead(options),
        this.closed.promise
      ]), options?.signal);
      this.status = "closed";
      this.log.trace("closed gracefully");
    }
    async closeRead(options = {}) {
      if (this.readStatus === "closing" || this.readStatus === "closed") {
        return;
      }
      this.log.trace('closing readable end of stream with starting read status "%s"', this.readStatus);
      const readStatus = this.readStatus;
      this.readStatus = "closing";
      if (this.status !== "reset" && this.status !== "aborted" && this.timeline.closeRead == null) {
        this.log.trace("send close read to remote");
        await this.sendCloseRead(options);
      }
      if (readStatus === "ready") {
        this.log.trace("ending internal source queue with %d queued bytes", this.streamSource.readableLength);
        this.streamSource.end();
      }
      this.log.trace("closed readable end of stream");
    }
    async closeWrite(options = {}) {
      if (this.writeStatus === "closing" || this.writeStatus === "closed") {
        return;
      }
      this.log.trace('closing writable end of stream with starting write status "%s"', this.writeStatus);
      if (this.writeStatus === "ready") {
        this.log.trace("sink was never sunk, sink an empty array");
        await raceSignal(this.sink([]), options.signal);
      }
      if (this.writeStatus === "writing") {
        if (this.sendingData != null) {
          await raceSignal(this.sendingData.promise, options.signal);
        }
        this.log.trace("aborting source passed to .sink");
        this.sinkController.abort();
        await raceSignal(this.sinkEnd.promise, options.signal);
      }
      this.writeStatus = "closed";
      this.log.trace("closed writable end of stream");
    }
    /**
     * Close immediately for reading and writing and send a reset message (local
     * error)
     */
    abort(err) {
      if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
        return;
      }
      this.log("abort with error", err);
      this.log("try to send reset to remote");
      const res = this.sendReset();
      if (isPromise3(res)) {
        res.catch((err2) => {
          this.log.error("error sending reset message", err2);
        });
      }
      this.status = "aborted";
      this.timeline.abort = Date.now();
      this._closeSinkAndSource(err);
      this.onAbort?.(err);
    }
    /**
     * Receive a reset message - close immediately for reading and writing (remote
     * error)
     */
    reset() {
      if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
        return;
      }
      const err = new StreamResetError("stream reset");
      this.status = "reset";
      this.timeline.reset = Date.now();
      this._closeSinkAndSource(err);
      this.onReset?.();
    }
    _closeSinkAndSource(err) {
      this._closeSink(err);
      this._closeSource(err);
    }
    _closeSink(err) {
      if (this.writeStatus === "writing") {
        this.log.trace("end sink source");
        this.sinkController.abort();
      }
      this.onSinkEnd(err);
    }
    _closeSource(err) {
      if (this.readStatus !== "closing" && this.readStatus !== "closed") {
        this.log.trace("ending source with %d bytes to be read by consumer", this.streamSource.readableLength);
        this.readStatus = "closing";
        this.streamSource.end(err);
      }
    }
    /**
     * The remote closed for writing so we should expect to receive no more
     * messages
     */
    remoteCloseWrite() {
      if (this.readStatus === "closing" || this.readStatus === "closed") {
        this.log("received remote close write but local source is already closed");
        return;
      }
      this.log.trace("remote close write");
      this._closeSource();
    }
    /**
     * The remote closed for reading so we should not send any more
     * messages
     */
    remoteCloseRead() {
      if (this.writeStatus === "closing" || this.writeStatus === "closed") {
        this.log("received remote close read but local sink is already closed");
        return;
      }
      this.log.trace("remote close read");
      this._closeSink();
    }
    /**
     * The underlying muxer has closed, no more messages can be sent or will
     * be received, close immediately to free up resources
     */
    destroy() {
      if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
        this.log("received destroy but we are already closed");
        return;
      }
      this.log.trace("stream destroyed");
      this._closeSinkAndSource();
    }
    /**
     * When an extending class reads data from it's implementation-specific source,
     * call this method to allow the stream consumer to read the data.
     */
    sourcePush(data) {
      this.streamSource.push(data);
    }
    /**
     * Returns the amount of unread data - can be used to prevent large amounts of
     * data building up when the stream consumer is too slow.
     */
    sourceReadableLength() {
      return this.streamSource.readableLength;
    }
  };

  // ../node_modules/@libp2p/mplex/dist/src/stream.js
  var MplexStream = class extends AbstractStream {
    name;
    streamId;
    send;
    types;
    maxDataSize;
    constructor(init) {
      super(init);
      this.types = init.direction === "outbound" ? InitiatorMessageTypes : ReceiverMessageTypes;
      this.send = init.send;
      this.name = init.name;
      this.streamId = init.streamId;
      this.maxDataSize = init.maxDataSize;
    }
    async sendNewStream() {
      await this.send({ id: this.streamId, type: InitiatorMessageTypes.NEW_STREAM, data: new Uint8ArrayList(fromString18(this.name)) });
    }
    async sendData(data) {
      data = data.sublist();
      while (data.byteLength > 0) {
        const toSend = Math.min(data.byteLength, this.maxDataSize);
        await this.send({
          id: this.streamId,
          type: this.types.MESSAGE,
          data: data.sublist(0, toSend)
        });
        data.consume(toSend);
      }
    }
    async sendReset() {
      await this.send({ id: this.streamId, type: this.types.RESET });
    }
    async sendCloseWrite() {
      await this.send({ id: this.streamId, type: this.types.CLOSE });
    }
    async sendCloseRead() {
    }
  };
  function createStream(options) {
    const { id, name: name19, send: send2, onEnd, type = "initiator", maxMsgSize = MAX_MSG_SIZE } = options;
    return new MplexStream({
      id: type === "initiator" ? `i${id}` : `r${id}`,
      streamId: id,
      name: `${name19 ?? id}`,
      direction: type === "initiator" ? "outbound" : "inbound",
      maxDataSize: maxMsgSize,
      onEnd,
      send: send2,
      log: options.logger.forComponent(`libp2p:mplex:stream:${type}:${id}`)
    });
  }

  // ../node_modules/@libp2p/mplex/dist/src/mplex.js
  var MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024;
  var MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024;
  var MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4;
  var DISCONNECT_THRESHOLD = 5;
  var CLOSE_TIMEOUT = 500;
  function printMessage(msg) {
    const output2 = {
      ...msg,
      type: `${MessageTypeNames[msg.type]} (${msg.type})`
    };
    if (msg.type === MessageTypes.NEW_STREAM) {
      output2.data = toString15(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray());
    }
    if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {
      output2.data = toString15(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), "base16");
    }
    return output2;
  }
  var MplexStreamMuxer = class {
    protocol = "/mplex/6.7.0";
    sink;
    source;
    log;
    _streamId;
    _streams;
    _init;
    _source;
    closeController;
    rateLimiter;
    closeTimeout;
    logger;
    constructor(components, init) {
      init = init ?? {};
      this.log = components.logger.forComponent("libp2p:mplex");
      this.logger = components.logger;
      this._streamId = 0;
      this._streams = {
        /**
         * Stream to ids map
         */
        initiators: /* @__PURE__ */ new Map(),
        /**
         * Stream to ids map
         */
        receivers: /* @__PURE__ */ new Map()
      };
      this._init = init;
      this.closeTimeout = init.closeTimeout ?? CLOSE_TIMEOUT;
      this.sink = this._createSink();
      this._source = pushable({
        objectMode: true,
        onEnd: () => {
          for (const stream of this._streams.initiators.values()) {
            stream.destroy();
          }
          for (const stream of this._streams.receivers.values()) {
            stream.destroy();
          }
        }
      });
      this.source = pipe(this._source, (source) => encode41(source));
      this.closeController = new AbortController();
      this.rateLimiter = new RateLimiter({
        points: init.disconnectThreshold ?? DISCONNECT_THRESHOLD,
        duration: 1
      });
    }
    /**
     * Returns a Map of streams and their ids
     */
    get streams() {
      const streams = [];
      for (const stream of this._streams.initiators.values()) {
        streams.push(stream);
      }
      for (const stream of this._streams.receivers.values()) {
        streams.push(stream);
      }
      return streams;
    }
    /**
     * Initiate a new stream with the given name. If no name is
     * provided, the id of the stream will be used.
     */
    newStream(name19) {
      if (this.closeController.signal.aborted) {
        throw new MuxerClosedError("Muxer already closed");
      }
      const id = this._streamId++;
      name19 = name19 == null ? id.toString() : name19.toString();
      const registry2 = this._streams.initiators;
      return this._newStream({ id, name: name19, type: "initiator", registry: registry2 });
    }
    /**
     * Close or abort all tracked streams and stop the muxer
     */
    async close(options) {
      if (this.closeController.signal.aborted) {
        return;
      }
      const signal = options?.signal ?? AbortSignal.timeout(this.closeTimeout);
      try {
        await Promise.all(this.streams.map(async (s2) => s2.close({
          signal
        })));
        this._source.end();
        await this._source.onEmpty({
          signal
        });
        this.closeController.abort();
      } catch (err) {
        this.abort(err);
      }
    }
    abort(err) {
      if (this.closeController.signal.aborted) {
        return;
      }
      this.streams.forEach((s2) => {
        s2.abort(err);
      });
      this.closeController.abort(err);
    }
    /**
     * Called whenever an inbound stream is created
     */
    _newReceiverStream(options) {
      const { id, name: name19 } = options;
      const registry2 = this._streams.receivers;
      return this._newStream({ id, name: name19, type: "receiver", registry: registry2 });
    }
    _newStream(options) {
      const { id, name: name19, type, registry: registry2 } = options;
      this.log("new %s stream %s", type, id);
      if (type === "initiator" && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {
        throw new TooManyOutboundProtocolStreamsError("Too many outbound streams open");
      }
      if (registry2.has(id)) {
        throw new Error(`${type} stream ${id} already exists!`);
      }
      const send2 = async (msg) => {
        if (this.log.enabled) {
          this.log.trace("%s stream %s send", type, id, printMessage(msg));
        }
        this._source.push(msg);
      };
      const onEnd = () => {
        this.log("%s stream with id %s and protocol %s ended", type, id, stream.protocol);
        registry2.delete(id);
        if (this._init.onStreamEnd != null) {
          this._init.onStreamEnd(stream);
        }
      };
      const stream = createStream({ id, name: name19, send: send2, type, onEnd, maxMsgSize: this._init.maxMsgSize, logger: this.logger });
      registry2.set(id, stream);
      return stream;
    }
    /**
     * Creates a sink with an abortable source. Incoming messages will
     * also have their size restricted. All messages will be varint decoded.
     */
    _createSink() {
      const sink = async (source) => {
        const abortListener = () => {
          closeSource(source, this.log);
        };
        this.closeController.signal.addEventListener("abort", abortListener);
        try {
          const decoder = new Decoder12(this._init.maxMsgSize, this._init.maxUnprocessedMessageQueueSize);
          for await (const chunk of source) {
            for (const msg of decoder.write(chunk)) {
              await this._handleIncoming(msg);
            }
          }
          this._source.end();
        } catch (err) {
          this.log("error in sink", err);
          this._source.end(err);
        } finally {
          this.closeController.signal.removeEventListener("abort", abortListener);
        }
      };
      return sink;
    }
    async _handleIncoming(message2) {
      const { id, type } = message2;
      if (this.log.enabled) {
        this.log.trace("incoming message", printMessage(message2));
      }
      if (message2.type === MessageTypes.NEW_STREAM) {
        if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {
          this.log("too many inbound streams open");
          this._source.push({
            id,
            type: MessageTypes.RESET_RECEIVER
          });
          try {
            await this.rateLimiter.consume("new-stream", 1);
          } catch {
            this.log("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection");
            this.abort(new Error("Too many open streams"));
            return;
          }
          return;
        }
        const stream2 = this._newReceiverStream({ id, name: toString15(message2.data instanceof Uint8Array ? message2.data : message2.data.subarray()) });
        if (this._init.onIncomingStream != null) {
          this._init.onIncomingStream(stream2);
        }
        return;
      }
      const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers;
      const stream = list.get(id);
      if (stream == null) {
        this.log("missing stream %s for message type %s", id, MessageTypeNames[type]);
        try {
          await this.rateLimiter.consume("missing-stream", 1);
        } catch {
          this.log("rate limit hit when receiving messages for streams that do not exist - closing remote connection");
          this.abort(new Error("Too many messages for missing streams"));
          return;
        }
        return;
      }
      const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE;
      try {
        switch (type) {
          case MessageTypes.MESSAGE_INITIATOR:
          case MessageTypes.MESSAGE_RECEIVER:
            if (stream.sourceReadableLength() > maxBufferSize) {
              this._source.push({
                id: message2.id,
                type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR
              });
              throw new StreamInputBufferError("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers");
            }
            stream.sourcePush(message2.data);
            break;
          case MessageTypes.CLOSE_INITIATOR:
          case MessageTypes.CLOSE_RECEIVER:
            stream.remoteCloseWrite();
            break;
          case MessageTypes.RESET_INITIATOR:
          case MessageTypes.RESET_RECEIVER:
            stream.reset();
            break;
          default:
            this.log("unknown message type %s", type);
        }
      } catch (err) {
        this.log.error("error while processing message", err);
        stream.abort(err);
      }
    }
  };

  // ../node_modules/@libp2p/mplex/dist/src/index.js
  var Mplex = class {
    protocol = "/mplex/6.7.0";
    _init;
    components;
    constructor(components, init = {}) {
      this.components = components;
      this._init = init;
    }
    [Symbol.toStringTag] = "@libp2p/mplex";
    [serviceCapabilities] = [
      "@libp2p/stream-multiplexing"
    ];
    createStreamMuxer(init = {}) {
      return new MplexStreamMuxer(this.components, {
        ...init,
        ...this._init
      });
    }
  };
  function mplex(init = {}) {
    return (components) => new Mplex(components, init);
  }

  // ../node_modules/@libp2p/ping/node_modules/uint8arrays/dist/src/equals.js
  function equals26(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }

  // ../node_modules/@libp2p/ping/dist/src/constants.js
  var PING_LENGTH = 32;
  var PROTOCOL_VERSION = "1.0.0";
  var PROTOCOL_NAME = "ping";
  var PROTOCOL_PREFIX = "ipfs";
  var TIMEOUT = 1e4;
  var MAX_INBOUND_STREAMS = 2;
  var MAX_OUTBOUND_STREAMS = 1;

  // ../node_modules/@libp2p/ping/dist/src/ping.js
  var Ping = class {
    protocol;
    components;
    started;
    timeout;
    maxInboundStreams;
    maxOutboundStreams;
    runOnLimitedConnection;
    log;
    constructor(components, init = {}) {
      this.components = components;
      this.log = components.logger.forComponent("libp2p:ping");
      this.started = false;
      this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
      this.timeout = init.timeout ?? TIMEOUT;
      this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS;
      this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS;
      this.runOnLimitedConnection = init.runOnLimitedConnection ?? true;
      this.handleMessage = this.handleMessage.bind(this);
    }
    [Symbol.toStringTag] = "@libp2p/ping";
    [serviceCapabilities] = [
      "@libp2p/ping"
    ];
    async start() {
      await this.components.registrar.handle(this.protocol, this.handleMessage, {
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams,
        runOnLimitedConnection: this.runOnLimitedConnection
      });
      this.started = true;
    }
    async stop() {
      await this.components.registrar.unhandle(this.protocol);
      this.started = false;
    }
    isStarted() {
      return this.started;
    }
    /**
     * A handler to register with Libp2p to process ping messages
     */
    handleMessage(data) {
      this.log("incoming ping from %p", data.connection.remotePeer);
      const { stream } = data;
      const start2 = Date.now();
      const bytes2 = byteStream(stream);
      let pinged = false;
      Promise.resolve().then(async () => {
        while (true) {
          const signal = AbortSignal.timeout(this.timeout);
          setMaxListeners(Infinity, signal);
          signal.addEventListener("abort", () => {
            stream?.abort(new TimeoutError("ping timeout"));
          });
          const buf = await bytes2.read({
            bytes: PING_LENGTH,
            signal
          });
          await bytes2.write(buf, {
            signal
          });
          pinged = true;
        }
      }).catch((err) => {
        if (pinged && err.name === "UnexpectedEOFError" && stream.readStatus !== "ready") {
          return;
        }
        this.log.error("incoming ping from %p failed with error - %e", data.connection.remotePeer, err);
        stream?.abort(err);
      }).finally(() => {
        const ms2 = Date.now() - start2;
        this.log("incoming ping from %p complete in %dms", data.connection.remotePeer, ms2);
        const signal = AbortSignal.timeout(this.timeout);
        setMaxListeners(Infinity, signal);
        stream.close({
          signal
        }).catch((err) => {
          this.log.error("error closing ping stream from %p - %e", data.connection.remotePeer, err);
          stream?.abort(err);
        });
      });
    }
    /**
     * Ping a given peer and wait for its response, getting the operation latency.
     */
    async ping(peer, options = {}) {
      this.log("pinging %p", peer);
      const start2 = Date.now();
      const data = randomBytes3(PING_LENGTH);
      const connection = await this.components.connectionManager.openConnection(peer, options);
      let stream;
      if (options.signal == null) {
        const signal = AbortSignal.timeout(this.timeout);
        options = {
          ...options,
          signal
        };
      }
      try {
        stream = await connection.newStream(this.protocol, {
          ...options,
          runOnLimitedConnection: this.runOnLimitedConnection
        });
        const bytes2 = byteStream(stream);
        const [, result] = await Promise.all([
          bytes2.write(data, options),
          bytes2.read({
            ...options,
            bytes: PING_LENGTH
          })
        ]);
        const ms2 = Date.now() - start2;
        if (!equals26(data, result.subarray())) {
          throw new ProtocolError2(`Received wrong ping ack after ${ms2}ms`);
        }
        this.log("ping %p complete in %dms", connection.remotePeer, ms2);
        return ms2;
      } catch (err) {
        this.log.error("error while pinging %p", connection.remotePeer, err);
        stream?.abort(err);
        throw err;
      } finally {
        if (stream != null) {
          await stream.close(options);
        }
      }
    }
  };

  // ../node_modules/@libp2p/ping/dist/src/index.js
  function ping(init = {}) {
    return (components) => new Ping(components, init);
  }

  // ../node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js
  var ASSUME_HTTP_CODES = [
    CODE_TCP,
    CODE_DNS,
    CODE_DNSADDR,
    CODE_DNS4,
    CODE_DNS6
  ];
  function extractSNI(ma) {
    return extractTuple("sni", ma)?.value;
  }
  function extractPort(ma) {
    const port = extractTuple("tcp", ma)?.value;
    if (port == null) {
      return "";
    }
    return `:${port}`;
  }
  function extractTuple(name19, ma) {
    return ma.find((component) => component.name === name19);
  }
  function hasTLS(ma) {
    return ma.some(({ code: code18 }) => code18 === CODE_TLS);
  }
  function interpretNext(head, rest) {
    const interpreter = interpreters[head.name];
    if (interpreter == null) {
      throw new Error(`Can't interpret protocol ${head.name}`);
    }
    const restVal = interpreter(head, rest);
    if (head.code === CODE_IP6) {
      return `[${restVal}]`;
    }
    return restVal;
  }
  var interpreters = {
    ip4: (head, rest) => head.value,
    ip6: (head, rest) => {
      if (rest.length === 0) {
        return head.value;
      }
      return `[${head.value}]`;
    },
    tcp: (head, rest) => {
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      return `tcp://${interpretNext(tail, rest)}:${head.value}`;
    },
    udp: (head, rest) => {
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      return `udp://${interpretNext(tail, rest)}:${head.value}`;
    },
    dnsaddr: (head, rest) => head.value,
    dns4: (head, rest) => head.value,
    dns6: (head, rest) => head.value,
    dns: (head, rest) => head.value,
    ipfs: (head, rest) => {
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      return `${interpretNext(tail, rest)}`;
    },
    p2p: (head, rest) => {
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      return `${interpretNext(tail, rest)}`;
    },
    http: (head, rest) => {
      const maHasTLS = hasTLS(rest);
      const sni = extractSNI(rest);
      const port = extractPort(rest);
      if (maHasTLS && sni != null) {
        return `https://${sni}${port}`;
      }
      const protocol = maHasTLS ? "https://" : "http://";
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      let baseVal = interpretNext(tail, rest);
      baseVal = baseVal?.replace("tcp://", "");
      return `${protocol}${baseVal}`;
    },
    "http-path": (head, rest) => {
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      const baseVal = interpretNext(tail, rest);
      const decodedValue = decodeURIComponent(head.value ?? "");
      return `${baseVal}${decodedValue}`;
    },
    tls: (head, rest) => {
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      return interpretNext(tail, rest);
    },
    sni: (head, rest) => {
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      return interpretNext(tail, rest);
    },
    https: (head, rest) => {
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      let baseVal = interpretNext(tail, rest);
      baseVal = baseVal?.replace("tcp://", "");
      return `https://${baseVal}`;
    },
    ws: (head, rest) => {
      const maHasTLS = hasTLS(rest);
      const sni = extractSNI(rest);
      const port = extractPort(rest);
      if (maHasTLS && sni != null) {
        return `wss://${sni}${port}`;
      }
      const protocol = maHasTLS ? "wss://" : "ws://";
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      let baseVal = interpretNext(tail, rest);
      baseVal = baseVal?.replace("tcp://", "");
      return `${protocol}${baseVal}`;
    },
    wss: (head, rest) => {
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      let baseVal = interpretNext(tail, rest);
      baseVal = baseVal?.replace("tcp://", "");
      return `wss://${baseVal}`;
    }
  };
  function multiaddrToUri(input, opts) {
    const ma = multiaddr(input);
    const components = ma.getComponents();
    const head = components.pop();
    if (head == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    const interpreter = interpreters[head.name];
    if (interpreter == null) {
      throw new Error(`No interpreter found for ${head.name}`);
    }
    let uri = interpreter(head, components) ?? "";
    if (opts?.assumeHttp !== false && ASSUME_HTTP_CODES.includes(head.code)) {
      uri = uri.replace(/^.*:\/\//, "");
      if (head.value === "443") {
        uri = `https://${uri}`;
      } else {
        uri = `http://${uri}`;
      }
    }
    if (uri.startsWith("http://") || uri.startsWith("https://") || uri.startsWith("ws://") || uri.startsWith("wss://")) {
      uri = new URL(uri).toString();
      if (uri.endsWith("/")) {
        uri = uri.substring(0, uri.length - 1);
      }
    }
    return uri;
  }

  // ../node_modules/it-ws/dist/src/ready.js
  var ready_default = async (socket) => {
    if (socket.readyState >= 2) {
      throw new Error("socket closed");
    }
    if (socket.readyState === 1) {
      return;
    }
    await new Promise((resolve, reject) => {
      function cleanup() {
        socket.removeEventListener("open", handleOpen);
        socket.removeEventListener("error", handleErr);
      }
      function handleOpen() {
        cleanup();
        resolve();
      }
      function handleErr(event) {
        cleanup();
        reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
      }
      socket.addEventListener("open", handleOpen);
      socket.addEventListener("error", handleErr);
    });
  };

  // ../node_modules/it-ws/dist/src/sink.js
  var sink_default = (socket, options) => {
    options = options ?? {};
    options.closeOnEnd = options.closeOnEnd !== false;
    const sink = async (source) => {
      for await (const data of source) {
        try {
          await ready_default(socket);
        } catch (err) {
          if (err.message === "socket closed")
            break;
          throw err;
        }
        if (socket.readyState === socket.CLOSING || socket.readyState === socket.CLOSED) {
          break;
        }
        socket.send(data);
      }
      if (options.closeOnEnd != null && socket.readyState <= 1) {
        await new Promise((resolve, reject) => {
          socket.addEventListener("close", (event) => {
            if (event.wasClean || event.code === 1006) {
              resolve();
            } else {
              const err = Object.assign(new Error("ws error"), { event });
              reject(err);
            }
          });
          setTimeout(() => {
            socket.close();
          });
        });
      }
    };
    return sink;
  };

  // ../node_modules/it-ws/dist/src/source.js
  var import_event_iterator = __toESM(require_dom(), 1);

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports10 = {};
  __export(base10_exports10, {
    base10: () => base1010
  });

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/bytes.js
  var empty11 = new Uint8Array(0);
  function equals27(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce11(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function fromString19(str) {
    return new TextEncoder().encode(str);
  }
  function toString16(b) {
    return new TextDecoder().decode(b);
  }

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/vendor/base-x.js
  function base15(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src11 = base15;
  var _brrp__multiformats_scope_baseX11 = src11;
  var base_x_default11 = _brrp__multiformats_scope_baseX11;

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/bases/base.js
  var Encoder13 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder13 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or13(this, decoder);
    }
  };
  var ComposedDecoder11 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or13(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or13(left, right) {
    return new ComposedDecoder11({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec11 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder13(name19, prefix, baseEncode);
      this.decoder = new Decoder13(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from20({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec11(name19, prefix, encode79, decode99);
  }
  function baseX11({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default11(alphabet18, name19);
    return from20({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce11(decode99(text))
    });
  }
  function decode50(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode42(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx11(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc464811({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx11(alphabet18);
    return from20({
      prefix,
      name: name19,
      encode(input) {
        return encode42(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode50(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/bases/base10.js
  var base1010 = baseX11({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports10 = {};
  __export(base16_exports10, {
    base16: () => base1610,
    base16upper: () => base16upper10
  });
  var base1610 = rfc464811({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper10 = rfc464811({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports10 = {};
  __export(base2_exports10, {
    base2: () => base210
  });
  var base210 = rfc464811({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports10 = {};
  __export(base256emoji_exports10, {
    base256emoji: () => base256emoji10
  });
  var alphabet10 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars10 = alphabet10.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes10 = alphabet10.reduce((p, c, i) => {
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
  }, []);
  function encode43(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars10[c];
      return p;
    }, "");
  }
  function decode51(str) {
    const byts = [];
    for (const char of str) {
      const codePoint = char.codePointAt(0);
      if (codePoint == null) {
        throw new Error(`Invalid character: ${char}`);
      }
      const byt = alphabetCharsToBytes10[codePoint];
      if (byt == null) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji10 = from20({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode43,
    decode: decode51
  });

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports10 = {};
  __export(base32_exports10, {
    base32: () => base3210,
    base32hex: () => base32hex10,
    base32hexpad: () => base32hexpad10,
    base32hexpadupper: () => base32hexpadupper10,
    base32hexupper: () => base32hexupper10,
    base32pad: () => base32pad10,
    base32padupper: () => base32padupper10,
    base32upper: () => base32upper10,
    base32z: () => base32z10
  });
  var base3210 = rfc464811({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper10 = rfc464811({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad10 = rfc464811({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper10 = rfc464811({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex10 = rfc464811({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper10 = rfc464811({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad10 = rfc464811({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper10 = rfc464811({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z10 = rfc464811({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports10 = {};
  __export(base36_exports10, {
    base36: () => base3610,
    base36upper: () => base36upper10
  });
  var base3610 = baseX11({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper10 = baseX11({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports10 = {};
  __export(base58_exports10, {
    base58btc: () => base58btc11,
    base58flickr: () => base58flickr11
  });
  var base58btc11 = baseX11({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr11 = baseX11({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports10 = {};
  __export(base64_exports10, {
    base64: () => base6411,
    base64pad: () => base64pad11,
    base64url: () => base64url11,
    base64urlpad: () => base64urlpad11
  });
  var base6411 = rfc464811({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad11 = rfc464811({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url11 = rfc464811({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad11 = rfc464811({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports10 = {};
  __export(base8_exports10, {
    base8: () => base810
  });
  var base810 = rfc464811({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports19 = {};
  __export(identity_exports19, {
    identity: () => identity19
  });
  var identity19 = from20({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString16(buf),
    decode: (str) => fromString19(str)
  });

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/codecs/json.js
  var textEncoder10 = new TextEncoder();
  var textDecoder10 = new TextDecoder();

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports20 = {};
  __export(identity_exports20, {
    identity: () => identity20
  });

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_110 = encode44;
  var MSB12 = 128;
  var REST12 = 127;
  var MSBALL10 = ~REST12;
  var INT10 = Math.pow(2, 31);
  function encode44(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT10) {
      out[offset++] = num & 255 | MSB12;
      num /= 128;
    }
    while (num & MSBALL10) {
      out[offset++] = num & 255 | MSB12;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode44.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode52 = read11;
  var MSB$110 = 128;
  var REST$110 = 127;
  function read11(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read11.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$110) << shift : (b & REST$110) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$110);
    read11.bytes = counter - offset;
    return res;
  }
  var N111 = Math.pow(2, 7);
  var N211 = Math.pow(2, 14);
  var N311 = Math.pow(2, 21);
  var N411 = Math.pow(2, 28);
  var N511 = Math.pow(2, 35);
  var N611 = Math.pow(2, 42);
  var N711 = Math.pow(2, 49);
  var N810 = Math.pow(2, 56);
  var N910 = Math.pow(2, 63);
  var length11 = function(value) {
    return value < N111 ? 1 : value < N211 ? 2 : value < N311 ? 3 : value < N411 ? 4 : value < N511 ? 5 : value < N611 ? 6 : value < N711 ? 7 : value < N810 ? 8 : value < N910 ? 9 : 10;
  };
  var varint10 = {
    encode: encode_110,
    decode: decode52,
    encodingLength: length11
  };
  var _brrp_varint10 = varint10;
  var varint_default10 = _brrp_varint10;

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/varint.js
  function decode53(data, offset = 0) {
    const code18 = varint_default10.decode(data, offset);
    return [code18, varint_default10.decode.bytes];
  }
  function encodeTo10(int, target, offset = 0) {
    varint_default10.encode(int, target, offset);
    return target;
  }
  function encodingLength11(int) {
    return varint_default10.encodingLength(int);
  }

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/hashes/digest.js
  function create10(code18, digest18) {
    const size = digest18.byteLength;
    const sizeOffset = encodingLength11(code18);
    const digestOffset = sizeOffset + encodingLength11(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo10(code18, bytes2, 0);
    encodeTo10(size, bytes2, sizeOffset);
    bytes2.set(digest18, digestOffset);
    return new Digest10(code18, size, digest18, bytes2);
  }
  function decode54(multihash) {
    const bytes2 = coerce11(multihash);
    const [code18, sizeOffset] = decode53(bytes2);
    const [size, digestOffset] = decode53(bytes2.subarray(sizeOffset));
    const digest18 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest18.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest10(code18, size, digest18, bytes2);
  }
  function equals28(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals27(a.bytes, data.bytes);
    }
  }
  var Digest10 = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code18, size, digest18, bytes2) {
      this.code = code18;
      this.size = size;
      this.digest = digest18;
      this.bytes = bytes2;
    }
  };

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/hashes/identity.js
  var code10 = 0;
  var name10 = "identity";
  var encode45 = coerce11;
  function digest10(input) {
    return create10(code10, encode45(input));
  }
  var identity20 = { code: code10, name: name10, encode: encode45, digest: digest10 };

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports10 = {};
  __export(sha2_browser_exports10, {
    sha256: () => sha25613,
    sha512: () => sha51212
  });

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/hashes/hasher.js
  function from21({ name: name19, code: code18, encode: encode79 }) {
    return new Hasher10(name19, code18, encode79);
  }
  var Hasher10 = class {
    name;
    code;
    encode;
    constructor(name19, code18, encode79) {
      this.name = name19;
      this.code = code18;
      this.encode = encode79;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create10(this.code, result) : result.then((digest18) => create10(this.code, digest18));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  function sha10(name19) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name19, data));
  }
  var sha25613 = from21({
    name: "sha2-256",
    code: 18,
    encode: sha10("SHA-256")
  });
  var sha51212 = from21({
    name: "sha2-512",
    code: 19,
    encode: sha10("SHA-512")
  });

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/cid.js
  function format10(link, base37) {
    const { bytes: bytes2, version: version5 } = link;
    switch (version5) {
      case 0:
        return toStringV010(bytes2, baseCache10(link), base37 ?? base58btc11.encoder);
      default:
        return toStringV110(bytes2, baseCache10(link), base37 ?? base3210.encoder);
    }
  }
  var cache10 = /* @__PURE__ */ new WeakMap();
  function baseCache10(cid) {
    const baseCache19 = cache10.get(cid);
    if (baseCache19 == null) {
      const baseCache20 = /* @__PURE__ */ new Map();
      cache10.set(cid, baseCache20);
      return baseCache20;
    }
    return baseCache19;
  }
  var CID10 = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version5, code18, multihash, bytes2) {
      this.code = code18;
      this.version = version5;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code18, multihash } = this;
          if (code18 !== DAG_PB_CODE10) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE10) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code18, digest: digest18 } = this.multihash;
          const multihash = create10(code18, digest18);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals28(self2.multihash, unknown.multihash);
    }
    toString(base37) {
      return format10(this, base37);
    }
    toJSON() {
      return { "/": format10(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version5, code: code18, multihash, bytes: bytes2 } = value;
        return new _CID(version5, code18, multihash, bytes2 ?? encodeCID10(version5, code18, multihash.bytes));
      } else if (value[cidSymbol10] === true) {
        const { version: version5, multihash, code: code18 } = value;
        const digest18 = decode54(multihash);
        return _CID.create(version5, code18, digest18);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version5, code18, digest18) {
      if (typeof code18 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest18.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version5) {
        case 0: {
          if (code18 !== DAG_PB_CODE10) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE10}) block encoding`);
          } else {
            return new _CID(version5, code18, digest18, digest18.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID10(version5, code18, digest18.bytes);
          return new _CID(version5, code18, digest18, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest18) {
      return _CID.create(0, DAG_PB_CODE10, digest18);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code18, digest18) {
      return _CID.create(1, code18, digest18);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes2) {
      const [cid, remainder] = _CID.decodeFirst(bytes2);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes2) {
      const specs = _CID.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce11(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest18 = new Digest10(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest18) : _CID.createV1(specs.codec, digest18);
      return [cid, bytes2.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length21] = decode53(initialBytes.subarray(offset));
        offset += length21;
        return i;
      };
      let version5 = next();
      let codec = DAG_PB_CODE10;
      if (version5 === 18) {
        version5 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version5 !== 0 && version5 !== 1) {
        throw new RangeError(`Invalid CID version ${version5}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version5, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base37) {
      const [prefix, bytes2] = parseCIDtoBytes10(source, base37);
      const cid = _CID.decode(bytes2);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache10(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes10(source, base37) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base37 ?? base58btc11;
        return [
          base58btc11.prefix,
          decoder.decode(`${base58btc11.prefix}${source}`)
        ];
      }
      case base58btc11.prefix: {
        const decoder = base37 ?? base58btc11;
        return [base58btc11.prefix, decoder.decode(source)];
      }
      case base3210.prefix: {
        const decoder = base37 ?? base3210;
        return [base3210.prefix, decoder.decode(source)];
      }
      case base3610.prefix: {
        const decoder = base37 ?? base3610;
        return [base3610.prefix, decoder.decode(source)];
      }
      default: {
        if (base37 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base37.decode(source)];
      }
    }
  }
  function toStringV010(bytes2, cache20, base37) {
    const { prefix } = base37;
    if (prefix !== base58btc11.prefix) {
      throw Error(`Cannot string encode V0 in ${base37.name} encoding`);
    }
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2).slice(1);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV110(bytes2, cache20, base37) {
    const { prefix } = base37;
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE10 = 112;
  var SHA_256_CODE10 = 18;
  function encodeCID10(version5, code18, multihash) {
    const codeOffset = encodingLength11(version5);
    const hashOffset = codeOffset + encodingLength11(code18);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo10(version5, bytes2, 0);
    encodeTo10(code18, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  }
  var cidSymbol10 = Symbol.for("@ipld/js-cid/CID");

  // ../node_modules/it-ws/node_modules/multiformats/dist/src/basics.js
  var bases10 = { ...identity_exports19, ...base2_exports10, ...base8_exports10, ...base10_exports10, ...base16_exports10, ...base32_exports10, ...base36_exports10, ...base58_exports10, ...base64_exports10, ...base256emoji_exports10 };
  var hashes10 = { ...sha2_browser_exports10, ...identity_exports20 };

  // ../node_modules/it-ws/node_modules/uint8arrays/dist/src/alloc.js
  function allocUnsafe14(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/it-ws/node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec11(name19, prefix, encode79, decode99) {
    return {
      name: name19,
      prefix,
      encoder: {
        name: name19,
        prefix,
        encode: encode79
      },
      decoder: {
        decode: decode99
      }
    };
  }
  var string11 = createCodec11("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder3 = new TextEncoder();
    return encoder3.encode(str.substring(1));
  });
  var ascii10 = createCodec11("ascii", "a", (buf) => {
    let string19 = "a";
    for (let i = 0; i < buf.length; i++) {
      string19 += String.fromCharCode(buf[i]);
    }
    return string19;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe14(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  var BASES10 = {
    utf8: string11,
    "utf-8": string11,
    hex: bases10.base16,
    latin1: ascii10,
    ascii: ascii10,
    binary: ascii10,
    ...bases10
  };
  var bases_default10 = BASES10;

  // ../node_modules/it-ws/node_modules/uint8arrays/dist/src/from-string.js
  function fromString20(string19, encoding = "utf8") {
    const base37 = bases_default10[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.decoder.decode(`${base37.prefix}${string19}`);
  }

  // ../node_modules/it-ws/dist/src/source.js
  function isArrayBuffer(obj) {
    return obj instanceof ArrayBuffer || obj?.constructor?.name === "ArrayBuffer" && typeof obj?.byteLength === "number";
  }
  var source_default = (socket) => {
    socket.binaryType = "arraybuffer";
    const connected = async () => {
      await new Promise((resolve, reject) => {
        if (isConnected) {
          resolve();
          return;
        }
        if (connError != null) {
          reject(connError);
          return;
        }
        const cleanUp = (cont) => {
          socket.removeEventListener("open", onOpen);
          socket.removeEventListener("error", onError);
          cont();
        };
        const onOpen = () => {
          cleanUp(resolve);
        };
        const onError = (event) => {
          cleanUp(() => {
            reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
          });
        };
        socket.addEventListener("open", onOpen);
        socket.addEventListener("error", onError);
      });
    };
    const source = (async function* () {
      const messages2 = new import_event_iterator.EventIterator(({ push, stop: stop2, fail }) => {
        const onMessage = (event) => {
          let data = null;
          if (typeof event.data === "string") {
            data = fromString20(event.data);
          }
          if (isArrayBuffer(event.data)) {
            data = new Uint8Array(event.data);
          }
          if (event.data instanceof Uint8Array) {
            data = event.data;
          }
          if (data == null) {
            return;
          }
          push(data);
        };
        const onError = (event) => {
          fail(event.error ?? new Error("Socket error"));
        };
        socket.addEventListener("message", onMessage);
        socket.addEventListener("error", onError);
        socket.addEventListener("close", stop2);
        return () => {
          socket.removeEventListener("message", onMessage);
          socket.removeEventListener("error", onError);
          socket.removeEventListener("close", stop2);
        };
      }, { highWaterMark: Infinity });
      await connected();
      for await (const chunk of messages2) {
        yield isArrayBuffer(chunk) ? new Uint8Array(chunk) : chunk;
      }
    })();
    let isConnected = socket.readyState === 1;
    let connError;
    socket.addEventListener("open", () => {
      isConnected = true;
      connError = null;
    });
    socket.addEventListener("close", () => {
      isConnected = false;
      connError = null;
    });
    socket.addEventListener("error", (event) => {
      if (!isConnected) {
        connError = event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`);
      }
    });
    return Object.assign(source, {
      connected
    });
  };

  // ../node_modules/it-ws/dist/src/duplex.js
  var duplex_default = (socket, options) => {
    options = options ?? {};
    const connectedSource = source_default(socket);
    let remoteAddress = options.remoteAddress;
    let remotePort = options.remotePort;
    if (socket.url != null) {
      try {
        const url = new URL(socket.url);
        remoteAddress = url.hostname;
        remotePort = parseInt(url.port, 10);
      } catch {
      }
    }
    if (remoteAddress == null || remotePort == null) {
      throw new Error("Remote connection did not have address and/or port");
    }
    const duplex = {
      sink: sink_default(socket, options),
      source: connectedSource,
      connected: async () => {
        await connectedSource.connected();
      },
      close: async () => {
        if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {
          await new Promise((resolve) => {
            socket.addEventListener("close", () => {
              resolve();
            });
            socket.close();
          });
        }
      },
      destroy: () => {
        if (socket.terminate != null) {
          socket.terminate();
        } else {
          socket.close();
        }
      },
      remoteAddress,
      remotePort,
      socket
    };
    return duplex;
  };

  // ../node_modules/it-ws/dist/src/web-socket.browser.js
  var web_socket_browser_default = WebSocket;

  // ../node_modules/it-ws/dist/src/ws-url.js
  var map = { "http:": "ws:", "https:": "wss:" };
  var defaultProtocol = "ws:";
  var ws_url_default = (url, location) => {
    if (url.startsWith("//")) {
      url = `${location?.protocol ?? defaultProtocol}${url}`;
    }
    if (url.startsWith("/") && location != null) {
      const proto = location.protocol ?? defaultProtocol;
      const host = location.host;
      const port = location.port != null && host?.endsWith(`:${location.port}`) !== true ? `:${location.port}` : "";
      url = `${proto}//${host}${port}${url}`;
    }
    const wsUrl = new URL(url);
    for (const [httpProto, wsProto] of Object.entries(map)) {
      if (wsUrl.protocol === httpProto) {
        wsUrl.protocol = wsProto;
      }
    }
    return wsUrl;
  };

  // ../node_modules/it-ws/dist/src/client.js
  function connect(addr, opts) {
    const location = typeof window === "undefined" ? void 0 : window.location;
    opts = opts ?? {};
    const url = ws_url_default(addr, location);
    const socket = new web_socket_browser_default(url.toString(), opts.websocket);
    return duplex_default(socket, opts);
  }

  // ../node_modules/progress-events/dist/src/index.js
  var CustomProgressEvent = class extends Event {
    type;
    detail;
    constructor(type, detail) {
      super(type);
      this.type = type;
      this.detail = detail;
    }
  };

  // ../node_modules/@libp2p/websockets/dist/src/filters.js
  function all2(multiaddrs) {
    return multiaddrs.filter((ma) => {
      return WebSocketsSecure2.exactMatch(ma) || WebSockets2.exactMatch(ma);
    });
  }
  function wss(multiaddrs) {
    return multiaddrs.filter((ma) => {
      return WebSocketsSecure2.exactMatch(ma);
    });
  }

  // ../node_modules/@libp2p/websockets/dist/src/listener.browser.js
  function createListener() {
    throw new Error("WebSocket Servers can not be created in the browser!");
  }

  // ../node_modules/@libp2p/websockets/dist/src/constants.js
  var CLOSE_TIMEOUT2 = 500;

  // ../node_modules/@libp2p/websockets/dist/src/socket-to-conn.js
  function socketToMaConn(stream, remoteAddr, options) {
    const log33 = options.logger.forComponent("libp2p:websockets:maconn");
    const metrics = options.metrics;
    const metricPrefix = options.metricPrefix ?? "";
    const maConn = {
      log: log33,
      async sink(source) {
        try {
          await stream.sink((async function* () {
            for await (const buf of source) {
              if (buf instanceof Uint8Array) {
                yield buf;
              } else {
                yield buf.subarray();
              }
            }
          })());
        } catch (err) {
          if (err.type !== "aborted") {
            log33.error(err);
          }
        }
      },
      source: stream.source,
      remoteAddr,
      timeline: { open: Date.now() },
      async close(options2 = {}) {
        const start2 = Date.now();
        if (options2.signal == null) {
          const signal = AbortSignal.timeout(CLOSE_TIMEOUT2);
          options2 = {
            ...options2,
            signal
          };
        }
        const listener = () => {
          const { host, port } = maConn.remoteAddr.toOptions();
          log33("timeout closing stream to %s:%s after %dms, destroying it manually", host, port, Date.now() - start2);
          this.abort(new AbortError3("Socket close timeout"));
        };
        options2.signal?.addEventListener("abort", listener);
        try {
          await stream.close();
        } catch (err) {
          log33.error("error closing WebSocket gracefully", err);
          this.abort(err);
        } finally {
          options2.signal?.removeEventListener("abort", listener);
          maConn.timeline.close = Date.now();
        }
      },
      abort(err) {
        const { host, port } = maConn.remoteAddr.toOptions();
        log33("timeout closing stream to %s:%s due to error", host, port, err);
        stream.destroy();
        maConn.timeline.close = Date.now();
        metrics?.increment({ [`${metricPrefix}error`]: true });
      }
    };
    stream.socket.addEventListener("close", () => {
      metrics?.increment({ [`${metricPrefix}close`]: true });
      if (maConn.timeline.close == null) {
        maConn.timeline.close = Date.now();
      }
    }, { once: true });
    return maConn;
  }

  // ../node_modules/@libp2p/websockets/dist/src/index.js
  var WebSockets3 = class {
    log;
    init;
    logger;
    metrics;
    components;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:websockets");
      this.logger = components.logger;
      this.components = components;
      this.init = init;
      if (components.metrics != null) {
        this.metrics = {
          dialerEvents: components.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total", {
            label: "event",
            help: "Total count of WebSockets dialer events by type"
          })
        };
      }
    }
    [transportSymbol] = true;
    [Symbol.toStringTag] = "@libp2p/websockets";
    [serviceCapabilities] = [
      "@libp2p/transport"
    ];
    async dial(ma, options) {
      this.log("dialing %s", ma);
      options = options ?? {};
      const socket = await this._connect(ma, options);
      const maConn = socketToMaConn(socket, ma, {
        logger: this.logger,
        metrics: this.metrics?.dialerEvents
      });
      this.log("new outbound connection %s", maConn.remoteAddr);
      const conn = await options.upgrader.upgradeOutbound(maConn, options);
      this.log("outbound connection %s upgraded", maConn.remoteAddr);
      return conn;
    }
    async _connect(ma, options) {
      options?.signal?.throwIfAborted();
      const cOpts = ma.toOptions();
      this.log("dialing %s:%s", cOpts.host, cOpts.port);
      const errorPromise = pDefer();
      const rawSocket = connect(multiaddrToUri(ma), this.init);
      rawSocket.socket.addEventListener("error", () => {
        const err = new ConnectionFailedError(`Could not connect to ${ma.toString()}`);
        this.log.error("connection error:", err);
        this.metrics?.dialerEvents.increment({ error: true });
        errorPromise.reject(err);
      });
      try {
        options.onProgress?.(new CustomProgressEvent("websockets:open-connection"));
        await raceSignal(Promise.race([rawSocket.connected(), errorPromise.promise]), options.signal);
      } catch (err) {
        if (options.signal?.aborted) {
          this.metrics?.dialerEvents.increment({ abort: true });
        }
        rawSocket.close().catch((err2) => {
          this.log.error("error closing raw socket", err2);
        });
        throw err;
      }
      this.log("connected %s", ma);
      this.metrics?.dialerEvents.increment({ connect: true });
      return rawSocket;
    }
    /**
     * Creates a WebSockets listener. The provided `handler` function will be called
     * anytime a new incoming Connection has been successfully upgraded via
     * `upgrader.upgradeInbound`
     */
    createListener(options) {
      return createListener({
        logger: this.logger,
        events: this.components.events,
        metrics: this.components.metrics
      }, {
        ...this.init,
        ...options
      });
    }
    /**
     * Takes a list of `Multiaddr`s and returns only valid WebSockets addresses.
     * By default, in a browser environment only DNS+WSS multiaddr is accepted,
     * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.
     */
    listenFilter(multiaddrs) {
      multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
      if (this.init?.filter != null) {
        return this.init?.filter(multiaddrs);
      }
      return all2(multiaddrs);
    }
    /**
     * Filter check for all Multiaddrs that this transport can dial
     */
    dialFilter(multiaddrs) {
      return this.listenFilter(multiaddrs);
    }
  };
  function webSockets(init = {}) {
    return (components) => {
      return new WebSockets3(components, init);
    };
  }

  // ../node_modules/@libp2p/utils/node_modules/is-plain-obj/index.js
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
  }

  // ../node_modules/@libp2p/utils/dist/src/merge-options.js
  var { hasOwnProperty } = Object.prototype;
  var { propertyIsEnumerable } = Object;
  var defineProperty = (object, name19, value) => {
    Object.defineProperty(object, name19, {
      value,
      writable: true,
      enumerable: true,
      configurable: true
    });
  };
  var globalThis2 = void 0;
  var defaultMergeOptions = {
    concatArrays: false,
    ignoreUndefined: false
  };
  var getEnumerableOwnPropertyKeys = (value) => {
    const keys = [];
    for (const key in value) {
      if (hasOwnProperty.call(value, key)) {
        keys.push(key);
      }
    }
    if (Object.getOwnPropertySymbols) {
      const symbols = Object.getOwnPropertySymbols(value);
      for (const symbol3 of symbols) {
        if (propertyIsEnumerable.call(value, symbol3)) {
          keys.push(symbol3);
        }
      }
    }
    return keys;
  };
  function clone(value) {
    if (Array.isArray(value)) {
      return cloneArray(value);
    }
    if (isPlainObject(value)) {
      return cloneOptionObject(value);
    }
    return value;
  }
  function cloneArray(array) {
    const result = array.slice(0, 0);
    getEnumerableOwnPropertyKeys(array).forEach((key) => {
      defineProperty(result, key, clone(array[key]));
    });
    return result;
  }
  function cloneOptionObject(object) {
    const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
    getEnumerableOwnPropertyKeys(object).forEach((key) => {
      defineProperty(result, key, clone(object[key]));
    });
    return result;
  }
  var mergeKeys = (merged, source, keys, config) => {
    keys.forEach((key) => {
      if (typeof source[key] === "undefined" && config.ignoreUndefined) {
        return;
      }
      if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
        defineProperty(merged, key, merge2(merged[key], source[key], config));
      } else {
        defineProperty(merged, key, clone(source[key]));
      }
    });
    return merged;
  };
  var concatArrays = (merged, source, config) => {
    let result = merged.slice(0, 0);
    let resultIndex = 0;
    [merged, source].forEach((array) => {
      const indices = [];
      for (let k = 0; k < array.length; k++) {
        if (!hasOwnProperty.call(array, k)) {
          continue;
        }
        indices.push(String(k));
        if (array === merged) {
          defineProperty(result, resultIndex++, array[k]);
        } else {
          defineProperty(result, resultIndex++, clone(array[k]));
        }
      }
      result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config);
    });
    return result;
  };
  function merge2(merged, source, config) {
    if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
      return concatArrays(merged, source, config);
    }
    if (!isPlainObject(source) || !isPlainObject(merged)) {
      return clone(source);
    }
    return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
  }
  function mergeOptions(...options) {
    const config = merge2(clone(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
    let merged = { _: {} };
    for (const option of options) {
      if (option === void 0) {
        continue;
      }
      if (!isPlainObject(option)) {
        throw new TypeError("`" + option + "` is not an Option Object");
      }
      merged = merge2(merged, { _: option }, config);
    }
    return merged._;
  }

  // ../node_modules/eventemitter3/index.mjs
  var import_index19 = __toESM(require_eventemitter3(), 1);

  // ../node_modules/p-timeout/index.js
  var TimeoutError2 = class extends Error {
    constructor(message2) {
      super(message2);
      this.name = "TimeoutError";
    }
  };
  var AbortError4 = class extends Error {
    constructor(message2) {
      super();
      this.name = "AbortError";
      this.message = message2;
    }
  };
  var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError4(errorMessage) : new DOMException(errorMessage);
  var getAbortedReason = (signal) => {
    const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
    return reason instanceof Error ? reason : getDOMException(reason);
  };
  function pTimeout(promise, options) {
    const {
      milliseconds,
      fallback,
      message: message2,
      customTimers = { setTimeout, clearTimeout }
    } = options;
    let timer;
    let abortHandler;
    const wrappedPromise = new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
        throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
      }
      if (options.signal) {
        const { signal } = options;
        if (signal.aborted) {
          reject(getAbortedReason(signal));
        }
        abortHandler = () => {
          reject(getAbortedReason(signal));
        };
        signal.addEventListener("abort", abortHandler, { once: true });
      }
      if (milliseconds === Number.POSITIVE_INFINITY) {
        promise.then(resolve, reject);
        return;
      }
      const timeoutError = new TimeoutError2();
      timer = customTimers.setTimeout.call(void 0, () => {
        if (fallback) {
          try {
            resolve(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        if (message2 === false) {
          resolve();
        } else if (message2 instanceof Error) {
          reject(message2);
        } else {
          timeoutError.message = message2 ?? `Promise timed out after ${milliseconds} milliseconds`;
          reject(timeoutError);
        }
      }, milliseconds);
      (async () => {
        try {
          resolve(await promise);
        } catch (error) {
          reject(error);
        }
      })();
    });
    const cancelablePromise = wrappedPromise.finally(() => {
      cancelablePromise.clear();
      if (abortHandler && options.signal) {
        options.signal.removeEventListener("abort", abortHandler);
      }
    });
    cancelablePromise.clear = () => {
      customTimers.clearTimeout.call(void 0, timer);
      timer = void 0;
    };
    return cancelablePromise;
  }

  // ../node_modules/p-queue/dist/lower-bound.js
  function lowerBound(array, value, comparator) {
    let first = 0;
    let count = array.length;
    while (count > 0) {
      const step = Math.trunc(count / 2);
      let it = first + step;
      if (comparator(array[it], value) <= 0) {
        first = ++it;
        count -= step + 1;
      } else {
        count = step;
      }
    }
    return first;
  }

  // ../node_modules/p-queue/dist/priority-queue.js
  var PriorityQueue = class {
    #queue = [];
    enqueue(run, options) {
      options = {
        priority: 0,
        ...options
      };
      const element = {
        priority: options.priority,
        id: options.id,
        run
      };
      if (this.size === 0 || this.#queue[this.size - 1].priority >= options.priority) {
        this.#queue.push(element);
        return;
      }
      const index = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);
      this.#queue.splice(index, 0, element);
    }
    setPriority(id, priority) {
      const index = this.#queue.findIndex((element) => element.id === id);
      if (index === -1) {
        throw new ReferenceError(`No promise function with the id "${id}" exists in the queue.`);
      }
      const [item] = this.#queue.splice(index, 1);
      this.enqueue(item.run, { priority, id });
    }
    dequeue() {
      const item = this.#queue.shift();
      return item?.run;
    }
    filter(options) {
      return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);
    }
    get size() {
      return this.#queue.length;
    }
  };

  // ../node_modules/p-queue/dist/index.js
  var PQueue = class extends import_index19.default {
    #carryoverConcurrencyCount;
    #isIntervalIgnored;
    #intervalCount = 0;
    #intervalCap;
    #interval;
    #intervalEnd = 0;
    #intervalId;
    #timeoutId;
    #queue;
    #queueClass;
    #pending = 0;
    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
    #concurrency;
    #isPaused;
    #throwOnTimeout;
    // Use to assign a unique identifier to a promise function, if not explicitly specified
    #idAssigner = 1n;
    /**
        Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.
    
        Applies to each future operation.
        */
    timeout;
    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
    constructor(options) {
      super();
      options = {
        carryoverConcurrencyCount: false,
        intervalCap: Number.POSITIVE_INFINITY,
        interval: 0,
        concurrency: Number.POSITIVE_INFINITY,
        autoStart: true,
        queueClass: PriorityQueue,
        ...options
      };
      if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
        throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${options.intervalCap?.toString() ?? ""}\` (${typeof options.intervalCap})`);
      }
      if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
        throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${options.interval?.toString() ?? ""}\` (${typeof options.interval})`);
      }
      this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;
      this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;
      this.#intervalCap = options.intervalCap;
      this.#interval = options.interval;
      this.#queue = new options.queueClass();
      this.#queueClass = options.queueClass;
      this.concurrency = options.concurrency;
      this.timeout = options.timeout;
      this.#throwOnTimeout = options.throwOnTimeout === true;
      this.#isPaused = options.autoStart === false;
    }
    get #doesIntervalAllowAnother() {
      return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;
    }
    get #doesConcurrentAllowAnother() {
      return this.#pending < this.#concurrency;
    }
    #next() {
      this.#pending--;
      this.#tryToStartAnother();
      this.emit("next");
    }
    #onResumeInterval() {
      this.#onInterval();
      this.#initializeIntervalIfNeeded();
      this.#timeoutId = void 0;
    }
    get #isIntervalPaused() {
      const now = Date.now();
      if (this.#intervalId === void 0) {
        const delay2 = this.#intervalEnd - now;
        if (delay2 < 0) {
          this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
        } else {
          if (this.#timeoutId === void 0) {
            this.#timeoutId = setTimeout(() => {
              this.#onResumeInterval();
            }, delay2);
          }
          return true;
        }
      }
      return false;
    }
    #tryToStartAnother() {
      if (this.#queue.size === 0) {
        if (this.#intervalId) {
          clearInterval(this.#intervalId);
        }
        this.#intervalId = void 0;
        this.emit("empty");
        if (this.#pending === 0) {
          this.emit("idle");
        }
        return false;
      }
      if (!this.#isPaused) {
        const canInitializeInterval = !this.#isIntervalPaused;
        if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {
          const job = this.#queue.dequeue();
          if (!job) {
            return false;
          }
          this.emit("active");
          job();
          if (canInitializeInterval) {
            this.#initializeIntervalIfNeeded();
          }
          return true;
        }
      }
      return false;
    }
    #initializeIntervalIfNeeded() {
      if (this.#isIntervalIgnored || this.#intervalId !== void 0) {
        return;
      }
      this.#intervalId = setInterval(() => {
        this.#onInterval();
      }, this.#interval);
      this.#intervalEnd = Date.now() + this.#interval;
    }
    #onInterval() {
      if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {
        clearInterval(this.#intervalId);
        this.#intervalId = void 0;
      }
      this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
      this.#processQueue();
    }
    /**
    Executes all queued functions until it reaches the limit.
    */
    #processQueue() {
      while (this.#tryToStartAnother()) {
      }
    }
    get concurrency() {
      return this.#concurrency;
    }
    set concurrency(newConcurrency) {
      if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
      }
      this.#concurrency = newConcurrency;
      this.#processQueue();
    }
    async #throwOnAbort(signal) {
      return new Promise((_resolve, reject) => {
        signal.addEventListener("abort", () => {
          reject(signal.reason);
        }, { once: true });
      });
    }
    /**
        Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.
    
        For example, this can be used to prioritize a promise function to run earlier.
    
        ```js
        import PQueue from 'p-queue';
    
        const queue = new PQueue({concurrency: 1});
    
        queue.add(async () => '🦄', {priority: 1});
        queue.add(async () => '🦀', {priority: 0, id: '🦀'});
        queue.add(async () => '🦄', {priority: 1});
        queue.add(async () => '🦄', {priority: 1});
    
        queue.setPriority('🦀', 2);
        ```
    
        In this case, the promise function with `id: '🦀'` runs second.
    
        You can also deprioritize a promise function to delay its execution:
    
        ```js
        import PQueue from 'p-queue';
    
        const queue = new PQueue({concurrency: 1});
    
        queue.add(async () => '🦄', {priority: 1});
        queue.add(async () => '🦀', {priority: 1, id: '🦀'});
        queue.add(async () => '🦄');
        queue.add(async () => '🦄', {priority: 0});
    
        queue.setPriority('🦀', -1);
        ```
        Here, the promise function with `id: '🦀'` executes last.
        */
    setPriority(id, priority) {
      this.#queue.setPriority(id, priority);
    }
    async add(function_, options = {}) {
      options.id ??= (this.#idAssigner++).toString();
      options = {
        timeout: this.timeout,
        throwOnTimeout: this.#throwOnTimeout,
        ...options
      };
      return new Promise((resolve, reject) => {
        this.#queue.enqueue(async () => {
          this.#pending++;
          this.#intervalCount++;
          try {
            options.signal?.throwIfAborted();
            let operation = function_({ signal: options.signal });
            if (options.timeout) {
              operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });
            }
            if (options.signal) {
              operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);
            }
            const result = await operation;
            resolve(result);
            this.emit("completed", result);
          } catch (error) {
            if (error instanceof TimeoutError2 && !options.throwOnTimeout) {
              resolve();
              return;
            }
            reject(error);
            this.emit("error", error);
          } finally {
            this.#next();
          }
        }, options);
        this.emit("add");
        this.#tryToStartAnother();
      });
    }
    async addAll(functions, options) {
      return Promise.all(functions.map(async (function_) => this.add(function_, options)));
    }
    /**
    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
    */
    start() {
      if (!this.#isPaused) {
        return this;
      }
      this.#isPaused = false;
      this.#processQueue();
      return this;
    }
    /**
    Put queue execution on hold.
    */
    pause() {
      this.#isPaused = true;
    }
    /**
    Clear the queue.
    */
    clear() {
      this.#queue = new this.#queueClass();
    }
    /**
        Can be called multiple times. Useful if you for example add additional items at a later time.
    
        @returns A promise that settles when the queue becomes empty.
        */
    async onEmpty() {
      if (this.#queue.size === 0) {
        return;
      }
      await this.#onEvent("empty");
    }
    /**
        @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
    
        If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
    
        Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
        */
    async onSizeLessThan(limit) {
      if (this.#queue.size < limit) {
        return;
      }
      await this.#onEvent("next", () => this.#queue.size < limit);
    }
    /**
        The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
    
        @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
        */
    async onIdle() {
      if (this.#pending === 0 && this.#queue.size === 0) {
        return;
      }
      await this.#onEvent("idle");
    }
    async #onEvent(event, filter2) {
      return new Promise((resolve) => {
        const listener = () => {
          if (filter2 && !filter2()) {
            return;
          }
          this.off(event, listener);
          resolve();
        };
        this.on(event, listener);
      });
    }
    /**
    Size of the queue, the number of queued items waiting to run.
    */
    get size() {
      return this.#queue.size;
    }
    /**
        Size of the queue, filtered by the given options.
    
        For example, this can be used to find the number of items remaining in the queue with a specific priority level.
        */
    sizeBy(options) {
      return this.#queue.filter(options).length;
    }
    /**
    Number of running items (no longer in the queue).
    */
    get pending() {
      return this.#pending;
    }
    /**
    Whether the queue is currently paused.
    */
    get isPaused() {
      return this.#isPaused;
    }
  };

  // ../node_modules/@multiformats/dns/dist/src/utils/get-types.js
  function getTypes(types) {
    const DEFAULT_TYPES = [
      RecordType.A
    ];
    if (types == null) {
      return DEFAULT_TYPES;
    }
    if (Array.isArray(types)) {
      if (types.length === 0) {
        return DEFAULT_TYPES;
      }
      return types;
    }
    return [
      types
    ];
  }

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports11 = {};
  __export(base10_exports11, {
    base10: () => base1011
  });

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bytes.js
  var empty12 = new Uint8Array(0);
  function equals29(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce12(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function fromString21(str) {
    return new TextEncoder().encode(str);
  }
  function toString17(b) {
    return new TextDecoder().decode(b);
  }

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/vendor/base-x.js
  function base17(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src12 = base17;
  var _brrp__multiformats_scope_baseX12 = src12;
  var base_x_default12 = _brrp__multiformats_scope_baseX12;

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base.js
  var Encoder14 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder14 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or14(this, decoder);
    }
  };
  var ComposedDecoder12 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or14(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or14(left, right) {
    return new ComposedDecoder12({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec12 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder14(name19, prefix, baseEncode);
      this.decoder = new Decoder14(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from22({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec12(name19, prefix, encode79, decode99);
  }
  function baseX12({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default12(alphabet18, name19);
    return from22({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce12(decode99(text))
    });
  }
  function decode55(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode46(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx12(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc464812({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx12(alphabet18);
    return from22({
      prefix,
      name: name19,
      encode(input) {
        return encode46(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode55(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base10.js
  var base1011 = baseX12({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports11 = {};
  __export(base16_exports11, {
    base16: () => base1611,
    base16upper: () => base16upper11
  });
  var base1611 = rfc464812({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper11 = rfc464812({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports11 = {};
  __export(base2_exports11, {
    base2: () => base211
  });
  var base211 = rfc464812({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports11 = {};
  __export(base256emoji_exports11, {
    base256emoji: () => base256emoji11
  });
  var alphabet11 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars11 = alphabet11.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes11 = alphabet11.reduce((p, c, i) => {
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
  }, []);
  function encode47(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars11[c];
      return p;
    }, "");
  }
  function decode56(str) {
    const byts = [];
    for (const char of str) {
      const codePoint = char.codePointAt(0);
      if (codePoint == null) {
        throw new Error(`Invalid character: ${char}`);
      }
      const byt = alphabetCharsToBytes11[codePoint];
      if (byt == null) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji11 = from22({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode47,
    decode: decode56
  });

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports11 = {};
  __export(base32_exports11, {
    base32: () => base3211,
    base32hex: () => base32hex11,
    base32hexpad: () => base32hexpad11,
    base32hexpadupper: () => base32hexpadupper11,
    base32hexupper: () => base32hexupper11,
    base32pad: () => base32pad11,
    base32padupper: () => base32padupper11,
    base32upper: () => base32upper11,
    base32z: () => base32z11
  });
  var base3211 = rfc464812({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper11 = rfc464812({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad11 = rfc464812({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper11 = rfc464812({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex11 = rfc464812({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper11 = rfc464812({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad11 = rfc464812({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper11 = rfc464812({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z11 = rfc464812({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports11 = {};
  __export(base36_exports11, {
    base36: () => base3611,
    base36upper: () => base36upper11
  });
  var base3611 = baseX12({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper11 = baseX12({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports11 = {};
  __export(base58_exports11, {
    base58btc: () => base58btc12,
    base58flickr: () => base58flickr12
  });
  var base58btc12 = baseX12({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr12 = baseX12({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports11 = {};
  __export(base64_exports11, {
    base64: () => base6412,
    base64pad: () => base64pad12,
    base64url: () => base64url12,
    base64urlpad: () => base64urlpad12
  });
  var base6412 = rfc464812({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad12 = rfc464812({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url12 = rfc464812({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad12 = rfc464812({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports11 = {};
  __export(base8_exports11, {
    base8: () => base811
  });
  var base811 = rfc464812({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports21 = {};
  __export(identity_exports21, {
    identity: () => identity21
  });
  var identity21 = from22({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString17(buf),
    decode: (str) => fromString21(str)
  });

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/codecs/json.js
  var textEncoder11 = new TextEncoder();
  var textDecoder11 = new TextDecoder();

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports22 = {};
  __export(identity_exports22, {
    identity: () => identity22
  });

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_111 = encode48;
  var MSB13 = 128;
  var REST13 = 127;
  var MSBALL11 = ~REST13;
  var INT11 = Math.pow(2, 31);
  function encode48(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT11) {
      out[offset++] = num & 255 | MSB13;
      num /= 128;
    }
    while (num & MSBALL11) {
      out[offset++] = num & 255 | MSB13;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode48.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode57 = read12;
  var MSB$111 = 128;
  var REST$111 = 127;
  function read12(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read12.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$111) << shift : (b & REST$111) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$111);
    read12.bytes = counter - offset;
    return res;
  }
  var N112 = Math.pow(2, 7);
  var N212 = Math.pow(2, 14);
  var N312 = Math.pow(2, 21);
  var N412 = Math.pow(2, 28);
  var N512 = Math.pow(2, 35);
  var N612 = Math.pow(2, 42);
  var N712 = Math.pow(2, 49);
  var N811 = Math.pow(2, 56);
  var N911 = Math.pow(2, 63);
  var length12 = function(value) {
    return value < N112 ? 1 : value < N212 ? 2 : value < N312 ? 3 : value < N412 ? 4 : value < N512 ? 5 : value < N612 ? 6 : value < N712 ? 7 : value < N811 ? 8 : value < N911 ? 9 : 10;
  };
  var varint11 = {
    encode: encode_111,
    decode: decode57,
    encodingLength: length12
  };
  var _brrp_varint11 = varint11;
  var varint_default11 = _brrp_varint11;

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/varint.js
  function decode58(data, offset = 0) {
    const code18 = varint_default11.decode(data, offset);
    return [code18, varint_default11.decode.bytes];
  }
  function encodeTo11(int, target, offset = 0) {
    varint_default11.encode(int, target, offset);
    return target;
  }
  function encodingLength12(int) {
    return varint_default11.encodingLength(int);
  }

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/hashes/digest.js
  function create11(code18, digest18) {
    const size = digest18.byteLength;
    const sizeOffset = encodingLength12(code18);
    const digestOffset = sizeOffset + encodingLength12(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo11(code18, bytes2, 0);
    encodeTo11(size, bytes2, sizeOffset);
    bytes2.set(digest18, digestOffset);
    return new Digest11(code18, size, digest18, bytes2);
  }
  function decode59(multihash) {
    const bytes2 = coerce12(multihash);
    const [code18, sizeOffset] = decode58(bytes2);
    const [size, digestOffset] = decode58(bytes2.subarray(sizeOffset));
    const digest18 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest18.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest11(code18, size, digest18, bytes2);
  }
  function equals30(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals29(a.bytes, data.bytes);
    }
  }
  var Digest11 = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code18, size, digest18, bytes2) {
      this.code = code18;
      this.size = size;
      this.digest = digest18;
      this.bytes = bytes2;
    }
  };

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/hashes/identity.js
  var code11 = 0;
  var name11 = "identity";
  var encode49 = coerce12;
  function digest11(input) {
    return create11(code11, encode49(input));
  }
  var identity22 = { code: code11, name: name11, encode: encode49, digest: digest11 };

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports11 = {};
  __export(sha2_browser_exports11, {
    sha256: () => sha25614,
    sha512: () => sha51213
  });

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/hashes/hasher.js
  function from23({ name: name19, code: code18, encode: encode79 }) {
    return new Hasher11(name19, code18, encode79);
  }
  var Hasher11 = class {
    name;
    code;
    encode;
    constructor(name19, code18, encode79) {
      this.name = name19;
      this.code = code18;
      this.encode = encode79;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create11(this.code, result) : result.then((digest18) => create11(this.code, digest18));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  function sha11(name19) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name19, data));
  }
  var sha25614 = from23({
    name: "sha2-256",
    code: 18,
    encode: sha11("SHA-256")
  });
  var sha51213 = from23({
    name: "sha2-512",
    code: 19,
    encode: sha11("SHA-512")
  });

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/cid.js
  function format11(link, base37) {
    const { bytes: bytes2, version: version5 } = link;
    switch (version5) {
      case 0:
        return toStringV011(bytes2, baseCache11(link), base37 ?? base58btc12.encoder);
      default:
        return toStringV111(bytes2, baseCache11(link), base37 ?? base3211.encoder);
    }
  }
  var cache11 = /* @__PURE__ */ new WeakMap();
  function baseCache11(cid) {
    const baseCache19 = cache11.get(cid);
    if (baseCache19 == null) {
      const baseCache20 = /* @__PURE__ */ new Map();
      cache11.set(cid, baseCache20);
      return baseCache20;
    }
    return baseCache19;
  }
  var CID11 = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version5, code18, multihash, bytes2) {
      this.code = code18;
      this.version = version5;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code18, multihash } = this;
          if (code18 !== DAG_PB_CODE11) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE11) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code18, digest: digest18 } = this.multihash;
          const multihash = create11(code18, digest18);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals30(self2.multihash, unknown.multihash);
    }
    toString(base37) {
      return format11(this, base37);
    }
    toJSON() {
      return { "/": format11(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version5, code: code18, multihash, bytes: bytes2 } = value;
        return new _CID(version5, code18, multihash, bytes2 ?? encodeCID11(version5, code18, multihash.bytes));
      } else if (value[cidSymbol11] === true) {
        const { version: version5, multihash, code: code18 } = value;
        const digest18 = decode59(multihash);
        return _CID.create(version5, code18, digest18);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version5, code18, digest18) {
      if (typeof code18 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest18.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version5) {
        case 0: {
          if (code18 !== DAG_PB_CODE11) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE11}) block encoding`);
          } else {
            return new _CID(version5, code18, digest18, digest18.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID11(version5, code18, digest18.bytes);
          return new _CID(version5, code18, digest18, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest18) {
      return _CID.create(0, DAG_PB_CODE11, digest18);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code18, digest18) {
      return _CID.create(1, code18, digest18);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes2) {
      const [cid, remainder] = _CID.decodeFirst(bytes2);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes2) {
      const specs = _CID.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce12(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest18 = new Digest11(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest18) : _CID.createV1(specs.codec, digest18);
      return [cid, bytes2.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length21] = decode58(initialBytes.subarray(offset));
        offset += length21;
        return i;
      };
      let version5 = next();
      let codec = DAG_PB_CODE11;
      if (version5 === 18) {
        version5 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version5 !== 0 && version5 !== 1) {
        throw new RangeError(`Invalid CID version ${version5}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version5, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base37) {
      const [prefix, bytes2] = parseCIDtoBytes11(source, base37);
      const cid = _CID.decode(bytes2);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache11(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes11(source, base37) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base37 ?? base58btc12;
        return [
          base58btc12.prefix,
          decoder.decode(`${base58btc12.prefix}${source}`)
        ];
      }
      case base58btc12.prefix: {
        const decoder = base37 ?? base58btc12;
        return [base58btc12.prefix, decoder.decode(source)];
      }
      case base3211.prefix: {
        const decoder = base37 ?? base3211;
        return [base3211.prefix, decoder.decode(source)];
      }
      case base3611.prefix: {
        const decoder = base37 ?? base3611;
        return [base3611.prefix, decoder.decode(source)];
      }
      default: {
        if (base37 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base37.decode(source)];
      }
    }
  }
  function toStringV011(bytes2, cache20, base37) {
    const { prefix } = base37;
    if (prefix !== base58btc12.prefix) {
      throw Error(`Cannot string encode V0 in ${base37.name} encoding`);
    }
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2).slice(1);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV111(bytes2, cache20, base37) {
    const { prefix } = base37;
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE11 = 112;
  var SHA_256_CODE11 = 18;
  function encodeCID11(version5, code18, multihash) {
    const codeOffset = encodingLength12(version5);
    const hashOffset = codeOffset + encodingLength12(code18);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo11(version5, bytes2, 0);
    encodeTo11(code18, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  }
  var cidSymbol11 = Symbol.for("@ipld/js-cid/CID");

  // ../node_modules/@multiformats/dns/node_modules/multiformats/dist/src/basics.js
  var bases11 = { ...identity_exports21, ...base2_exports11, ...base8_exports11, ...base10_exports11, ...base16_exports11, ...base32_exports11, ...base36_exports11, ...base58_exports11, ...base64_exports11, ...base256emoji_exports11 };
  var hashes11 = { ...sha2_browser_exports11, ...identity_exports22 };

  // ../node_modules/@multiformats/dns/node_modules/uint8arrays/dist/src/alloc.js
  function allocUnsafe15(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/@multiformats/dns/node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec12(name19, prefix, encode79, decode99) {
    return {
      name: name19,
      prefix,
      encoder: {
        name: name19,
        prefix,
        encode: encode79
      },
      decoder: {
        decode: decode99
      }
    };
  }
  var string12 = createCodec12("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder3 = new TextEncoder();
    return encoder3.encode(str.substring(1));
  });
  var ascii11 = createCodec12("ascii", "a", (buf) => {
    let string19 = "a";
    for (let i = 0; i < buf.length; i++) {
      string19 += String.fromCharCode(buf[i]);
    }
    return string19;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe15(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  var BASES11 = {
    utf8: string12,
    "utf-8": string12,
    hex: bases11.base16,
    latin1: ascii11,
    ascii: ascii11,
    binary: ascii11,
    ...bases11
  };
  var bases_default11 = BASES11;

  // ../node_modules/@multiformats/dns/node_modules/uint8arrays/dist/src/to-string.js
  function toString18(array, encoding = "utf8") {
    const base37 = bases_default11[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.encoder.encode(array).substring(1);
  }

  // ../node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js
  var DEFAULT_TTL = 60;
  function toDNSResponse(obj) {
    return {
      Status: obj.Status ?? 0,
      TC: obj.TC ?? obj.flag_tc ?? false,
      RD: obj.RD ?? obj.flag_rd ?? false,
      RA: obj.RA ?? obj.flag_ra ?? false,
      AD: obj.AD ?? obj.flag_ad ?? false,
      CD: obj.CD ?? obj.flag_cd ?? false,
      Question: (obj.Question ?? obj.questions ?? []).map((question) => {
        return {
          name: question.name,
          type: RecordType[question.type]
        };
      }),
      Answer: (obj.Answer ?? obj.answers ?? []).map((answer) => {
        return {
          name: answer.name,
          type: RecordType[answer.type],
          TTL: answer.TTL ?? answer.ttl ?? DEFAULT_TTL,
          data: answer.data instanceof Uint8Array ? toString18(answer.data) : answer.data
        };
      })
    };
  }

  // ../node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js
  var DEFAULT_QUERY_CONCURRENCY = 4;
  function dnsJsonOverHttps(url, init = {}) {
    const httpQueue = new PQueue({
      concurrency: init.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY
    });
    return async (fqdn, options = {}) => {
      const searchParams = new URLSearchParams();
      searchParams.set("name", fqdn);
      getTypes(options.types).forEach((type) => {
        searchParams.append("type", RecordType[type]);
      });
      options.onProgress?.(new CustomProgressEvent("dns:query", { detail: fqdn }));
      const response = await httpQueue.add(async () => {
        const res = await fetch(`${url}?${searchParams}`, {
          headers: {
            accept: "application/dns-json"
          },
          signal: options?.signal
        });
        if (res.status !== 200) {
          throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`);
        }
        const response2 = toDNSResponse(await res.json());
        options.onProgress?.(new CustomProgressEvent("dns:response", { detail: response2 }));
        return response2;
      }, {
        signal: options.signal
      });
      if (response == null) {
        throw new Error("No DNS response received");
      }
      return response;
    };
  }

  // ../node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js
  function defaultResolver() {
    return [
      dnsJsonOverHttps("https://cloudflare-dns.com/dns-query"),
      dnsJsonOverHttps("https://dns.google/resolve")
    ];
  }

  // ../node_modules/@multiformats/dns/dist/src/utils/cache.js
  var import_hashlru = __toESM(require_hashlru(), 1);
  var CachedAnswers = class {
    lru;
    constructor(maxSize) {
      this.lru = (0, import_hashlru.default)(maxSize);
    }
    get(fqdn, types) {
      let foundAllAnswers = true;
      const answers = [];
      for (const type of types) {
        const cached = this.getAnswers(fqdn, type);
        if (cached.length === 0) {
          foundAllAnswers = false;
          break;
        }
        answers.push(...cached);
      }
      if (foundAllAnswers) {
        return toDNSResponse({ answers });
      }
    }
    getAnswers(domain, type) {
      const key = `${domain.toLowerCase()}-${type}`;
      const answers = this.lru.get(key);
      if (answers != null) {
        const cachedAnswers = answers.filter((entry) => {
          return entry.expires > Date.now();
        }).map(({ expires, value }) => ({
          ...value,
          TTL: Math.round((expires - Date.now()) / 1e3),
          type: RecordType[value.type]
        }));
        if (cachedAnswers.length === 0) {
          this.lru.remove(key);
        }
        return cachedAnswers;
      }
      return [];
    }
    add(domain, answer) {
      const key = `${domain.toLowerCase()}-${answer.type}`;
      const answers = this.lru.get(key) ?? [];
      answers.push({
        expires: Date.now() + (answer.TTL ?? DEFAULT_TTL) * 1e3,
        value: answer
      });
      this.lru.set(key, answers);
    }
    remove(domain, type) {
      const key = `${domain.toLowerCase()}-${type}`;
      this.lru.remove(key);
    }
    clear() {
      this.lru.clear();
    }
  };
  function cache12(size) {
    return new CachedAnswers(size);
  }

  // ../node_modules/@multiformats/dns/dist/src/dns.js
  var DEFAULT_ANSWER_CACHE_SIZE = 1e3;
  var DNS3 = class {
    resolvers;
    cache;
    constructor(init) {
      this.resolvers = {};
      this.cache = cache12(init.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE);
      Object.entries(init.resolvers ?? {}).forEach(([tld, resolver]) => {
        if (!Array.isArray(resolver)) {
          resolver = [resolver];
        }
        if (!tld.endsWith(".")) {
          tld = `${tld}.`;
        }
        this.resolvers[tld] = resolver;
      });
      if (this.resolvers["."] == null) {
        this.resolvers["."] = defaultResolver();
      }
    }
    /**
     * Queries DNS resolvers for the passed record types for the passed domain.
     *
     * If cached records exist for all desired types they will be returned
     * instead.
     *
     * Any new responses will be added to the cache for subsequent requests.
     */
    async query(domain, options = {}) {
      const types = getTypes(options.types);
      const cached = options.cached !== false ? this.cache.get(domain, types) : void 0;
      if (cached != null) {
        options.onProgress?.(new CustomProgressEvent("dns:cache", { detail: cached }));
        return cached;
      }
      const tld = `${domain.split(".").pop()}.`;
      const resolvers2 = (this.resolvers[tld] ?? this.resolvers["."]).sort(() => {
        return Math.random() > 0.5 ? -1 : 1;
      });
      const errors = [];
      for (const resolver of resolvers2) {
        if (options.signal?.aborted === true) {
          break;
        }
        try {
          const result = await resolver(domain, {
            ...options,
            types
          });
          for (const answer of result.Answer) {
            this.cache.add(domain, answer);
          }
          return result;
        } catch (err) {
          errors.push(err);
          options.onProgress?.(new CustomProgressEvent("dns:error", { detail: err }));
        }
      }
      if (errors.length === 1) {
        throw errors[0];
      }
      throw new AggregateError(errors, `DNS lookup of ${domain} ${types} failed`);
    }
  };

  // ../node_modules/@multiformats/dns/dist/src/index.js
  var RecordType;
  (function(RecordType2) {
    RecordType2[RecordType2["A"] = 1] = "A";
    RecordType2[RecordType2["CNAME"] = 5] = "CNAME";
    RecordType2[RecordType2["TXT"] = 16] = "TXT";
    RecordType2[RecordType2["AAAA"] = 28] = "AAAA";
  })(RecordType || (RecordType = {}));
  function dns(init = {}) {
    return new DNS3(init);
  }

  // ../node_modules/@multiformats/multiaddr/dist/src/protocols-table.js
  var V2 = -1;
  var names = {};
  var codes = {};
  var table = [
    [4, 32, "ip4"],
    [6, 16, "tcp"],
    [33, 16, "dccp"],
    [41, 128, "ip6"],
    [42, V2, "ip6zone"],
    [43, 8, "ipcidr"],
    [53, V2, "dns", true],
    [54, V2, "dns4", true],
    [55, V2, "dns6", true],
    [56, V2, "dnsaddr", true],
    [132, 16, "sctp"],
    [273, 16, "udp"],
    [275, 0, "p2p-webrtc-star"],
    [276, 0, "p2p-webrtc-direct"],
    [277, 0, "p2p-stardust"],
    [280, 0, "webrtc-direct"],
    [281, 0, "webrtc"],
    [290, 0, "p2p-circuit"],
    [301, 0, "udt"],
    [302, 0, "utp"],
    [400, V2, "unix", false, true],
    // `ipfs` is added before `p2p` for legacy support.
    // All text representations will default to `p2p`, but `ipfs` will
    // still be supported
    [421, V2, "ipfs"],
    // `p2p` is the preferred name for 421, and is now the default
    [421, V2, "p2p"],
    [443, 0, "https"],
    [444, 96, "onion"],
    [445, 296, "onion3"],
    [446, V2, "garlic64"],
    [448, 0, "tls"],
    [449, V2, "sni"],
    [460, 0, "quic"],
    [461, 0, "quic-v1"],
    [465, 0, "webtransport"],
    [466, V2, "certhash"],
    [477, 0, "ws"],
    [478, 0, "wss"],
    [479, 0, "p2p-websocket-star"],
    [480, 0, "http"],
    [481, V2, "http-path"],
    [777, V2, "memory"]
  ];
  table.forEach((row) => {
    const proto = createProtocol(...row);
    codes[proto.code] = proto;
    names[proto.name] = proto;
  });
  function createProtocol(code18, size, name19, resolvable, path) {
    return {
      code: code18,
      size,
      name: name19,
      resolvable: Boolean(resolvable),
      path: Boolean(path)
    };
  }
  function getProtocol(proto) {
    if (typeof proto === "number") {
      if (codes[proto] != null) {
        return codes[proto];
      }
      throw new Error(`no protocol with code: ${proto}`);
    } else if (typeof proto === "string") {
      if (names[proto] != null) {
        return names[proto];
      }
      throw new Error(`no protocol with name: ${proto}`);
    }
    throw new Error(`invalid protocol id type: ${typeof proto}`);
  }

  // ../node_modules/@multiformats/multiaddr/dist/src/resolvers/dnsaddr.js
  var MAX_RECURSIVE_DEPTH = 32;
  var { code: dnsaddrCode } = getProtocol("dnsaddr");
  var RecursionLimitError = class extends Error {
    constructor(message2 = "Max recursive depth reached") {
      super(message2);
      this.name = "RecursionLimitError";
    }
  };
  var dnsaddrResolver = async function dnsaddrResolver2(ma, options = {}) {
    const recursionLimit = options.maxRecursiveDepth ?? MAX_RECURSIVE_DEPTH;
    if (recursionLimit === 0) {
      throw new RecursionLimitError("Max recursive depth reached");
    }
    const [, hostname] = ma.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? [];
    const resolver = options?.dns ?? dns();
    const result = await resolver.query(`_dnsaddr.${hostname}`, {
      signal: options?.signal,
      types: [
        RecordType.TXT
      ]
    });
    const peerId2 = ma.getPeerId();
    const output2 = [];
    for (const answer of result.Answer) {
      const addr = answer.data.replace(/["']/g, "").trim().split("=")[1];
      if (addr == null) {
        continue;
      }
      if (peerId2 != null && !addr.includes(peerId2)) {
        continue;
      }
      const ma2 = multiaddr(addr);
      if (addr.startsWith("/dnsaddr")) {
        const resolved = await ma2.resolve({
          ...options,
          maxRecursiveDepth: recursionLimit - 1
        });
        output2.push(...resolved.map((ma3) => ma3.toString()));
      } else {
        output2.push(ma2.toString());
      }
    }
    return output2;
  };

  // ../node_modules/libp2p/dist/src/config.js
  var DefaultConfig = {
    addresses: {
      listen: [],
      announce: [],
      noAnnounce: [],
      announceFilter: (multiaddrs) => multiaddrs
    },
    connectionManager: {
      resolvers: {
        dnsaddr: dnsaddrResolver
      }
    },
    transportManager: {
      faultTolerance: FaultTolerance.FATAL_ALL
    }
  };
  async function validateConfig(opts) {
    const resultingOptions = mergeOptions(DefaultConfig, opts);
    if (resultingOptions.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) {
      throw new InvalidParametersError("Private network is enforced, but no protector was provided");
    }
    return resultingOptions;
  }

  // ../node_modules/@libp2p/logger/node_modules/multiformats/dist/src/bytes.js
  var empty13 = new Uint8Array(0);
  function coerce13(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }

  // ../node_modules/@libp2p/logger/node_modules/multiformats/dist/src/vendor/base-x.js
  function base18(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src13 = base18;
  var _brrp__multiformats_scope_baseX13 = src13;
  var base_x_default13 = _brrp__multiformats_scope_baseX13;

  // ../node_modules/@libp2p/logger/node_modules/multiformats/dist/src/bases/base.js
  var Encoder15 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder15 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or15(this, decoder);
    }
  };
  var ComposedDecoder13 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or15(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or15(left, right) {
    return new ComposedDecoder13({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec13 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder15(name19, prefix, baseEncode);
      this.decoder = new Decoder15(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from24({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec13(name19, prefix, encode79, decode99);
  }
  function baseX13({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default13(alphabet18, name19);
    return from24({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce13(decode99(text))
    });
  }
  function decode60(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode50(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx13(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc464813({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx13(alphabet18);
    return from24({
      prefix,
      name: name19,
      encode(input) {
        return encode50(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode60(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/@libp2p/logger/node_modules/multiformats/dist/src/bases/base32.js
  var base3212 = rfc464813({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper12 = rfc464813({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad12 = rfc464813({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper12 = rfc464813({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex12 = rfc464813({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper12 = rfc464813({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad12 = rfc464813({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper12 = rfc464813({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z12 = rfc464813({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // ../node_modules/@libp2p/logger/node_modules/multiformats/dist/src/bases/base58.js
  var base58btc13 = baseX13({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr13 = baseX13({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/@libp2p/logger/node_modules/multiformats/dist/src/bases/base64.js
  var base6413 = rfc464813({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad13 = rfc464813({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url13 = rfc464813({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad13 = rfc464813({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // ../node_modules/weald/node_modules/ms/dist/index.mjs
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  function ms(value, options) {
    try {
      if (typeof value === "string" && value.length > 0) {
        return parse(value);
      } else if (typeof value === "number" && isFinite(value)) {
        return options?.long ? fmtLong(value) : fmtShort(value);
      }
      throw new Error("Value is not a string or number.");
    } catch (error) {
      const message2 = isError(error) ? `${error.message}. value=${JSON.stringify(value)}` : "An unknown error has occured.";
      throw new Error(message2);
    }
  }
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      throw new Error("Value exceeds the maximum length of 100 characters.");
    }
    const match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return NaN;
    }
    const n = parseFloat(match[1]);
    const type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        throw new Error(`The unit ${type} was matched, but no matching case exists.`);
    }
  }
  var dist_default = ms;
  function fmtShort(ms2) {
    const msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return `${Math.round(ms2 / d)}d`;
    }
    if (msAbs >= h) {
      return `${Math.round(ms2 / h)}h`;
    }
    if (msAbs >= m) {
      return `${Math.round(ms2 / m)}m`;
    }
    if (msAbs >= s) {
      return `${Math.round(ms2 / s)}s`;
    }
    return `${ms2}ms`;
  }
  function fmtLong(ms2) {
    const msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return `${ms2} ms`;
  }
  function plural(ms2, msAbs, n, name19) {
    const isPlural = msAbs >= n * 1.5;
    return `${Math.round(ms2 / n)} ${name19}${isPlural ? "s" : ""}`;
  }
  function isError(error) {
    return typeof error === "object" && error !== null && "message" in error;
  }

  // ../node_modules/weald/dist/src/common.js
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce22;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = dist_default;
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash2 = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format19) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format19];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split4 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split4.length;
      for (i = 0; i < len; i++) {
        if (!split4[i]) {
          continue;
        }
        namespaces = split4[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name19) {
      if (name19[name19.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name19)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name19)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce22(val) {
      if (val instanceof Error) {
        return val.stack ?? val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.setupFormatters(createDebug.formatters);
    createDebug.enable(createDebug.load());
    return createDebug;
  }

  // ../node_modules/weald/dist/src/browser.js
  var storage = localstorage();
  var colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/) != null) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement?.style?.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    // @ts-expect-error window.console.firebug and window.console.exception are not in the types
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/) != null && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + dist_default(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  var log21 = console.debug ?? console.log ?? (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        storage?.setItem("debug", namespaces);
      } else {
        storage?.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = storage?.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof globalThis.process !== "undefined" && "env" in globalThis.process) {
      r = globalThis.process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  function setupFormatters(formatters) {
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
  var browser_default = setup({ formatArgs, save, load, useColors, setupFormatters, colors, storage, log: log21 });

  // ../node_modules/weald/dist/src/index.js
  var src_default4 = browser_default;

  // ../node_modules/@libp2p/logger/dist/src/index.js
  src_default4.formatters.b = (v) => {
    return v == null ? "undefined" : base58btc13.baseEncode(v);
  };
  src_default4.formatters.t = (v) => {
    return v == null ? "undefined" : base3212.baseEncode(v);
  };
  src_default4.formatters.m = (v) => {
    return v == null ? "undefined" : base6413.baseEncode(v);
  };
  src_default4.formatters.p = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  src_default4.formatters.c = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  src_default4.formatters.k = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  src_default4.formatters.a = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  src_default4.formatters.e = (v) => {
    return v == null ? "undefined" : notEmpty(v.stack) ?? notEmpty(v.message) ?? v.toString();
  };
  function createDisabledLogger(namespace) {
    const logger5 = () => {
    };
    logger5.enabled = false;
    logger5.color = "";
    logger5.diff = 0;
    logger5.log = () => {
    };
    logger5.namespace = namespace;
    logger5.destroy = () => true;
    logger5.extend = () => logger5;
    return logger5;
  }
  function defaultLogger() {
    return {
      forComponent(name19) {
        return logger(name19);
      }
    };
  }
  function logger(name19) {
    let trace = createDisabledLogger(`${name19}:trace`);
    if (src_default4.enabled(`${name19}:trace`) && src_default4.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
      trace = src_default4(`${name19}:trace`);
    }
    return Object.assign(src_default4(name19), {
      error: src_default4(`${name19}:error`),
      trace
    });
  }
  function notEmpty(str) {
    if (str == null) {
      return;
    }
    str = str.trim();
    if (str.length === 0) {
      return;
    }
    return str;
  }

  // ../node_modules/@libp2p/peer-collections/node_modules/multiformats/dist/src/bytes.js
  var empty14 = new Uint8Array(0);
  function coerce14(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }

  // ../node_modules/@libp2p/peer-collections/node_modules/multiformats/dist/src/vendor/base-x.js
  function base19(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src14 = base19;
  var _brrp__multiformats_scope_baseX14 = src14;
  var base_x_default14 = _brrp__multiformats_scope_baseX14;

  // ../node_modules/@libp2p/peer-collections/node_modules/multiformats/dist/src/bases/base.js
  var Encoder16 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder16 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or16(this, decoder);
    }
  };
  var ComposedDecoder14 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or16(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or16(left, right) {
    return new ComposedDecoder14({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec14 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder16(name19, prefix, baseEncode);
      this.decoder = new Decoder16(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from25({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec14(name19, prefix, encode79, decode99);
  }
  function baseX14({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default14(alphabet18, name19);
    return from25({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce14(decode99(text))
    });
  }

  // ../node_modules/@libp2p/peer-collections/node_modules/multiformats/dist/src/bases/base58.js
  var base58btc14 = baseX14({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr14 = baseX14({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/@libp2p/peer-collections/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_112 = encode51;
  var MSB14 = 128;
  var REST14 = 127;
  var MSBALL12 = ~REST14;
  var INT12 = Math.pow(2, 31);
  function encode51(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT12) {
      out[offset++] = num & 255 | MSB14;
      num /= 128;
    }
    while (num & MSBALL12) {
      out[offset++] = num & 255 | MSB14;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode51.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode61 = read13;
  var MSB$112 = 128;
  var REST$112 = 127;
  function read13(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read13.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$112) << shift : (b & REST$112) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$112);
    read13.bytes = counter - offset;
    return res;
  }
  var N113 = Math.pow(2, 7);
  var N213 = Math.pow(2, 14);
  var N313 = Math.pow(2, 21);
  var N413 = Math.pow(2, 28);
  var N513 = Math.pow(2, 35);
  var N613 = Math.pow(2, 42);
  var N713 = Math.pow(2, 49);
  var N812 = Math.pow(2, 56);
  var N912 = Math.pow(2, 63);
  var length13 = function(value) {
    return value < N113 ? 1 : value < N213 ? 2 : value < N313 ? 3 : value < N413 ? 4 : value < N513 ? 5 : value < N613 ? 6 : value < N713 ? 7 : value < N812 ? 8 : value < N912 ? 9 : 10;
  };
  var varint12 = {
    encode: encode_112,
    decode: decode61,
    encodingLength: length13
  };
  var _brrp_varint12 = varint12;
  var varint_default12 = _brrp_varint12;

  // ../node_modules/@libp2p/peer-collections/node_modules/multiformats/dist/src/varint.js
  function decode62(data, offset = 0) {
    const code18 = varint_default12.decode(data, offset);
    return [code18, varint_default12.decode.bytes];
  }

  // ../node_modules/@libp2p/peer-collections/node_modules/multiformats/dist/src/hashes/digest.js
  function decode63(multihash) {
    const bytes2 = coerce14(multihash);
    const [code18, sizeOffset] = decode62(bytes2);
    const [size, digestOffset] = decode62(bytes2.subarray(sizeOffset));
    const digest18 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest18.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest12(code18, size, digest18, bytes2);
  }
  var Digest12 = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code18, size, digest18, bytes2) {
      this.code = code18;
      this.size = size;
      this.digest = digest18;
      this.bytes = bytes2;
    }
  };

  // ../node_modules/@libp2p/peer-collections/dist/src/util.js
  function mapIterable(iter, map2) {
    const iterator = {
      [Symbol.iterator]: () => {
        return iterator;
      },
      next: () => {
        const next = iter.next();
        const val = next.value;
        if (next.done === true || val == null) {
          const result = {
            done: true,
            value: void 0
          };
          return result;
        }
        return {
          done: false,
          value: map2(val)
        };
      }
    };
    return iterator;
  }
  function peerIdFromString2(str) {
    const multihash = decode63(base58btc14.decode(`z${str}`));
    return peerIdFromMultihash(multihash);
  }

  // ../node_modules/@libp2p/peer-collections/dist/src/map.js
  var PeerMap = class {
    map;
    constructor(map2) {
      this.map = /* @__PURE__ */ new Map();
      if (map2 != null) {
        for (const [key, value] of map2.entries()) {
          this.map.set(key.toString(), { key, value });
        }
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    clear() {
      this.map.clear();
    }
    delete(peer) {
      return this.map.delete(peer.toString());
    }
    entries() {
      return mapIterable(this.map.entries(), (val) => {
        return [val[1].key, val[1].value];
      });
    }
    forEach(fn) {
      this.map.forEach((value, key) => {
        fn(value.value, value.key, this);
      });
    }
    get(peer) {
      return this.map.get(peer.toString())?.value;
    }
    has(peer) {
      return this.map.has(peer.toString());
    }
    set(peer, value) {
      this.map.set(peer.toString(), { key: peer, value });
    }
    keys() {
      return mapIterable(this.map.values(), (val) => {
        return val.key;
      });
    }
    values() {
      return mapIterable(this.map.values(), (val) => val.value);
    }
    get size() {
      return this.map.size;
    }
  };

  // ../node_modules/@libp2p/peer-collections/dist/src/set.js
  var PeerSet = class _PeerSet {
    set;
    constructor(set) {
      this.set = /* @__PURE__ */ new Set();
      if (set != null) {
        for (const key of set) {
          this.set.add(key.toString());
        }
      }
    }
    get size() {
      return this.set.size;
    }
    [Symbol.iterator]() {
      return this.values();
    }
    add(peer) {
      this.set.add(peer.toString());
    }
    clear() {
      this.set.clear();
    }
    delete(peer) {
      this.set.delete(peer.toString());
    }
    entries() {
      return mapIterable(this.set.entries(), (val) => {
        const peerId2 = peerIdFromString2(val[0]);
        return [peerId2, peerId2];
      });
    }
    forEach(predicate) {
      this.set.forEach((str) => {
        const peerId2 = peerIdFromString2(str);
        predicate(peerId2, peerId2, this);
      });
    }
    has(peer) {
      return this.set.has(peer.toString());
    }
    values() {
      return mapIterable(this.set.values(), (val) => {
        return peerIdFromString2(val);
      });
    }
    intersection(other) {
      const output2 = new _PeerSet();
      for (const peerId2 of other) {
        if (this.has(peerId2)) {
          output2.add(peerId2);
        }
      }
      return output2;
    }
    difference(other) {
      const output2 = new _PeerSet();
      for (const peerId2 of this) {
        if (!other.has(peerId2)) {
          output2.add(peerId2);
        }
      }
      return output2;
    }
    union(other) {
      const output2 = new _PeerSet();
      for (const peerId2 of other) {
        output2.add(peerId2);
      }
      for (const peerId2 of this) {
        output2.add(peerId2);
      }
      return output2;
    }
  };

  // ../node_modules/@libp2p/utils/node_modules/uint8arrays/dist/src/alloc.js
  function alloc6(size = 0) {
    return new Uint8Array(size);
  }
  function allocUnsafe16(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports12 = {};
  __export(base10_exports12, {
    base10: () => base1012
  });

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bytes.js
  var empty15 = new Uint8Array(0);
  function equals32(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce15(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function fromString22(str) {
    return new TextEncoder().encode(str);
  }
  function toString19(b) {
    return new TextDecoder().decode(b);
  }

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/vendor/base-x.js
  function base20(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src15 = base20;
  var _brrp__multiformats_scope_baseX15 = src15;
  var base_x_default15 = _brrp__multiformats_scope_baseX15;

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base.js
  var Encoder17 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder17 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or17(this, decoder);
    }
  };
  var ComposedDecoder15 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or17(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or17(left, right) {
    return new ComposedDecoder15({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec15 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder17(name19, prefix, baseEncode);
      this.decoder = new Decoder17(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from26({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec15(name19, prefix, encode79, decode99);
  }
  function baseX15({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default15(alphabet18, name19);
    return from26({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce15(decode99(text))
    });
  }
  function decode64(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode52(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx14(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc464814({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx14(alphabet18);
    return from26({
      prefix,
      name: name19,
      encode(input) {
        return encode52(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode64(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base10.js
  var base1012 = baseX15({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports12 = {};
  __export(base16_exports12, {
    base16: () => base1612,
    base16upper: () => base16upper12
  });
  var base1612 = rfc464814({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper12 = rfc464814({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports12 = {};
  __export(base2_exports12, {
    base2: () => base212
  });
  var base212 = rfc464814({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports12 = {};
  __export(base256emoji_exports12, {
    base256emoji: () => base256emoji12
  });
  var alphabet12 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars12 = alphabet12.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes12 = alphabet12.reduce((p, c, i) => {
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
  }, []);
  function encode53(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars12[c];
      return p;
    }, "");
  }
  function decode65(str) {
    const byts = [];
    for (const char of str) {
      const codePoint = char.codePointAt(0);
      if (codePoint == null) {
        throw new Error(`Invalid character: ${char}`);
      }
      const byt = alphabetCharsToBytes12[codePoint];
      if (byt == null) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji12 = from26({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode53,
    decode: decode65
  });

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports12 = {};
  __export(base32_exports12, {
    base32: () => base3213,
    base32hex: () => base32hex13,
    base32hexpad: () => base32hexpad13,
    base32hexpadupper: () => base32hexpadupper13,
    base32hexupper: () => base32hexupper13,
    base32pad: () => base32pad13,
    base32padupper: () => base32padupper13,
    base32upper: () => base32upper13,
    base32z: () => base32z13
  });
  var base3213 = rfc464814({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper13 = rfc464814({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad13 = rfc464814({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper13 = rfc464814({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex13 = rfc464814({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper13 = rfc464814({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad13 = rfc464814({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper13 = rfc464814({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z13 = rfc464814({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports12 = {};
  __export(base36_exports12, {
    base36: () => base3612,
    base36upper: () => base36upper12
  });
  var base3612 = baseX15({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper12 = baseX15({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports12 = {};
  __export(base58_exports12, {
    base58btc: () => base58btc15,
    base58flickr: () => base58flickr15
  });
  var base58btc15 = baseX15({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr15 = baseX15({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports12 = {};
  __export(base64_exports12, {
    base64: () => base6414,
    base64pad: () => base64pad14,
    base64url: () => base64url14,
    base64urlpad: () => base64urlpad14
  });
  var base6414 = rfc464814({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad14 = rfc464814({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url14 = rfc464814({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad14 = rfc464814({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports12 = {};
  __export(base8_exports12, {
    base8: () => base812
  });
  var base812 = rfc464814({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports23 = {};
  __export(identity_exports23, {
    identity: () => identity23
  });
  var identity23 = from26({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString19(buf),
    decode: (str) => fromString22(str)
  });

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/codecs/json.js
  var textEncoder12 = new TextEncoder();
  var textDecoder12 = new TextDecoder();

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports24 = {};
  __export(identity_exports24, {
    identity: () => identity24
  });

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_113 = encode54;
  var MSB15 = 128;
  var REST15 = 127;
  var MSBALL13 = ~REST15;
  var INT13 = Math.pow(2, 31);
  function encode54(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT13) {
      out[offset++] = num & 255 | MSB15;
      num /= 128;
    }
    while (num & MSBALL13) {
      out[offset++] = num & 255 | MSB15;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode54.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode66 = read14;
  var MSB$113 = 128;
  var REST$113 = 127;
  function read14(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read14.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$113) << shift : (b & REST$113) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$113);
    read14.bytes = counter - offset;
    return res;
  }
  var N114 = Math.pow(2, 7);
  var N214 = Math.pow(2, 14);
  var N314 = Math.pow(2, 21);
  var N414 = Math.pow(2, 28);
  var N514 = Math.pow(2, 35);
  var N614 = Math.pow(2, 42);
  var N714 = Math.pow(2, 49);
  var N813 = Math.pow(2, 56);
  var N913 = Math.pow(2, 63);
  var length14 = function(value) {
    return value < N114 ? 1 : value < N214 ? 2 : value < N314 ? 3 : value < N414 ? 4 : value < N514 ? 5 : value < N614 ? 6 : value < N714 ? 7 : value < N813 ? 8 : value < N913 ? 9 : 10;
  };
  var varint13 = {
    encode: encode_113,
    decode: decode66,
    encodingLength: length14
  };
  var _brrp_varint13 = varint13;
  var varint_default13 = _brrp_varint13;

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/varint.js
  function decode67(data, offset = 0) {
    const code18 = varint_default13.decode(data, offset);
    return [code18, varint_default13.decode.bytes];
  }
  function encodeTo13(int, target, offset = 0) {
    varint_default13.encode(int, target, offset);
    return target;
  }
  function encodingLength14(int) {
    return varint_default13.encodingLength(int);
  }

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/hashes/digest.js
  function create12(code18, digest18) {
    const size = digest18.byteLength;
    const sizeOffset = encodingLength14(code18);
    const digestOffset = sizeOffset + encodingLength14(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo13(code18, bytes2, 0);
    encodeTo13(size, bytes2, sizeOffset);
    bytes2.set(digest18, digestOffset);
    return new Digest13(code18, size, digest18, bytes2);
  }
  function decode68(multihash) {
    const bytes2 = coerce15(multihash);
    const [code18, sizeOffset] = decode67(bytes2);
    const [size, digestOffset] = decode67(bytes2.subarray(sizeOffset));
    const digest18 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest18.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest13(code18, size, digest18, bytes2);
  }
  function equals33(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals32(a.bytes, data.bytes);
    }
  }
  var Digest13 = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code18, size, digest18, bytes2) {
      this.code = code18;
      this.size = size;
      this.digest = digest18;
      this.bytes = bytes2;
    }
  };

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/hashes/identity.js
  var code12 = 0;
  var name12 = "identity";
  var encode55 = coerce15;
  function digest12(input) {
    return create12(code12, encode55(input));
  }
  var identity24 = { code: code12, name: name12, encode: encode55, digest: digest12 };

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports12 = {};
  __export(sha2_browser_exports12, {
    sha256: () => sha25615,
    sha512: () => sha51214
  });

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/hashes/hasher.js
  function from27({ name: name19, code: code18, encode: encode79 }) {
    return new Hasher12(name19, code18, encode79);
  }
  var Hasher12 = class {
    name;
    code;
    encode;
    constructor(name19, code18, encode79) {
      this.name = name19;
      this.code = code18;
      this.encode = encode79;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create12(this.code, result) : result.then((digest18) => create12(this.code, digest18));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  function sha12(name19) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name19, data));
  }
  var sha25615 = from27({
    name: "sha2-256",
    code: 18,
    encode: sha12("SHA-256")
  });
  var sha51214 = from27({
    name: "sha2-512",
    code: 19,
    encode: sha12("SHA-512")
  });

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/cid.js
  function format12(link, base37) {
    const { bytes: bytes2, version: version5 } = link;
    switch (version5) {
      case 0:
        return toStringV012(bytes2, baseCache12(link), base37 ?? base58btc15.encoder);
      default:
        return toStringV112(bytes2, baseCache12(link), base37 ?? base3213.encoder);
    }
  }
  var cache13 = /* @__PURE__ */ new WeakMap();
  function baseCache12(cid) {
    const baseCache19 = cache13.get(cid);
    if (baseCache19 == null) {
      const baseCache20 = /* @__PURE__ */ new Map();
      cache13.set(cid, baseCache20);
      return baseCache20;
    }
    return baseCache19;
  }
  var CID12 = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version5, code18, multihash, bytes2) {
      this.code = code18;
      this.version = version5;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code18, multihash } = this;
          if (code18 !== DAG_PB_CODE12) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE12) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code18, digest: digest18 } = this.multihash;
          const multihash = create12(code18, digest18);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals33(self2.multihash, unknown.multihash);
    }
    toString(base37) {
      return format12(this, base37);
    }
    toJSON() {
      return { "/": format12(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version5, code: code18, multihash, bytes: bytes2 } = value;
        return new _CID(version5, code18, multihash, bytes2 ?? encodeCID12(version5, code18, multihash.bytes));
      } else if (value[cidSymbol12] === true) {
        const { version: version5, multihash, code: code18 } = value;
        const digest18 = decode68(multihash);
        return _CID.create(version5, code18, digest18);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version5, code18, digest18) {
      if (typeof code18 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest18.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version5) {
        case 0: {
          if (code18 !== DAG_PB_CODE12) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE12}) block encoding`);
          } else {
            return new _CID(version5, code18, digest18, digest18.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID12(version5, code18, digest18.bytes);
          return new _CID(version5, code18, digest18, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest18) {
      return _CID.create(0, DAG_PB_CODE12, digest18);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code18, digest18) {
      return _CID.create(1, code18, digest18);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes2) {
      const [cid, remainder] = _CID.decodeFirst(bytes2);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes2) {
      const specs = _CID.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce15(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest18 = new Digest13(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest18) : _CID.createV1(specs.codec, digest18);
      return [cid, bytes2.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length21] = decode67(initialBytes.subarray(offset));
        offset += length21;
        return i;
      };
      let version5 = next();
      let codec = DAG_PB_CODE12;
      if (version5 === 18) {
        version5 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version5 !== 0 && version5 !== 1) {
        throw new RangeError(`Invalid CID version ${version5}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version5, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base37) {
      const [prefix, bytes2] = parseCIDtoBytes12(source, base37);
      const cid = _CID.decode(bytes2);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache12(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes12(source, base37) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base37 ?? base58btc15;
        return [
          base58btc15.prefix,
          decoder.decode(`${base58btc15.prefix}${source}`)
        ];
      }
      case base58btc15.prefix: {
        const decoder = base37 ?? base58btc15;
        return [base58btc15.prefix, decoder.decode(source)];
      }
      case base3213.prefix: {
        const decoder = base37 ?? base3213;
        return [base3213.prefix, decoder.decode(source)];
      }
      case base3612.prefix: {
        const decoder = base37 ?? base3612;
        return [base3612.prefix, decoder.decode(source)];
      }
      default: {
        if (base37 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base37.decode(source)];
      }
    }
  }
  function toStringV012(bytes2, cache20, base37) {
    const { prefix } = base37;
    if (prefix !== base58btc15.prefix) {
      throw Error(`Cannot string encode V0 in ${base37.name} encoding`);
    }
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2).slice(1);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV112(bytes2, cache20, base37) {
    const { prefix } = base37;
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE12 = 112;
  var SHA_256_CODE12 = 18;
  function encodeCID12(version5, code18, multihash) {
    const codeOffset = encodingLength14(version5);
    const hashOffset = codeOffset + encodingLength14(code18);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo13(version5, bytes2, 0);
    encodeTo13(code18, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  }
  var cidSymbol12 = Symbol.for("@ipld/js-cid/CID");

  // ../node_modules/@libp2p/utils/node_modules/multiformats/dist/src/basics.js
  var bases12 = { ...identity_exports23, ...base2_exports12, ...base8_exports12, ...base10_exports12, ...base16_exports12, ...base32_exports12, ...base36_exports12, ...base58_exports12, ...base64_exports12, ...base256emoji_exports12 };
  var hashes12 = { ...sha2_browser_exports12, ...identity_exports24 };

  // ../node_modules/@libp2p/utils/node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec13(name19, prefix, encode79, decode99) {
    return {
      name: name19,
      prefix,
      encoder: {
        name: name19,
        prefix,
        encode: encode79
      },
      decoder: {
        decode: decode99
      }
    };
  }
  var string13 = createCodec13("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder3 = new TextEncoder();
    return encoder3.encode(str.substring(1));
  });
  var ascii12 = createCodec13("ascii", "a", (buf) => {
    let string19 = "a";
    for (let i = 0; i < buf.length; i++) {
      string19 += String.fromCharCode(buf[i]);
    }
    return string19;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe16(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  var BASES12 = {
    utf8: string13,
    "utf-8": string13,
    hex: bases12.base16,
    latin1: ascii12,
    ascii: ascii12,
    binary: ascii12,
    ...bases12
  };
  var bases_default12 = BASES12;

  // ../node_modules/@libp2p/utils/node_modules/uint8arrays/dist/src/from-string.js
  function fromString23(string19, encoding = "utf8") {
    const base37 = bases_default12[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.decoder.decode(`${base37.prefix}${string19}`);
  }

  // ../node_modules/@sindresorhus/fnv1a/index.js
  var FNV_PRIMES = {
    32: 16777619n,
    64: 1099511628211n,
    128: 309485009821345068724781371n,
    256: 374144419156711147060143317175368453031918731002211n,
    512: 35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,
    1024: 5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n
  };
  var FNV_OFFSETS = {
    32: 2166136261n,
    64: 14695981039346656037n,
    128: 144066263297769815596495629667062367629n,
    256: 100029257958052580907070968620625704837092796014241193945225284501741471925557n,
    512: 9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,
    1024: 14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n
  };
  var cachedEncoder = new globalThis.TextEncoder();
  function fnv1aUint8Array(uint8Array, size) {
    const fnvPrime = FNV_PRIMES[size];
    let hash2 = FNV_OFFSETS[size];
    for (let index = 0; index < uint8Array.length; index++) {
      hash2 ^= BigInt(uint8Array[index]);
      hash2 = BigInt.asUintN(size, hash2 * fnvPrime);
    }
    return hash2;
  }
  function fnv1aEncodeInto(string19, size, utf8Buffer) {
    if (utf8Buffer.length === 0) {
      throw new Error("The `utf8Buffer` option must have a length greater than zero");
    }
    const fnvPrime = FNV_PRIMES[size];
    let hash2 = FNV_OFFSETS[size];
    let remaining = string19;
    while (remaining.length > 0) {
      const result = cachedEncoder.encodeInto(remaining, utf8Buffer);
      remaining = remaining.slice(result.read);
      for (let index = 0; index < result.written; index++) {
        hash2 ^= BigInt(utf8Buffer[index]);
        hash2 = BigInt.asUintN(size, hash2 * fnvPrime);
      }
    }
    return hash2;
  }
  function fnv1a(value, { size = 32, utf8Buffer } = {}) {
    if (!FNV_PRIMES[size]) {
      throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");
    }
    if (typeof value === "string") {
      if (utf8Buffer) {
        return fnv1aEncodeInto(value, size, utf8Buffer);
      }
      value = cachedEncoder.encode(value);
    }
    return fnv1aUint8Array(value, size);
  }

  // ../node_modules/@libp2p/utils/dist/src/filters/hashes.js
  var fnv1a2 = {
    hash: (input) => {
      return Number(fnv1a(input, {
        size: 32
      }));
    },
    hashV: (input, seed) => {
      return numberToBuffer(fnv1a2.hash(input, seed));
    }
  };
  function numberToBuffer(num) {
    let hex = num.toString(16);
    if (hex.length % 2 === 1) {
      hex = `0${hex}`;
    }
    return fromString23(hex, "base16");
  }

  // ../node_modules/@libp2p/utils/node_modules/uint8arrays/dist/src/equals.js
  function equals34(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }

  // ../node_modules/@libp2p/utils/dist/src/filters/fingerprint.js
  var MAX_FINGERPRINT_SIZE = 64;
  var Fingerprint = class {
    fp;
    h;
    seed;
    constructor(buf, hash2, seed, fingerprintSize = 2) {
      if (fingerprintSize > MAX_FINGERPRINT_SIZE) {
        throw new TypeError("Invalid Fingerprint Size");
      }
      const fnv = hash2.hashV(buf, seed);
      const fp = alloc6(fingerprintSize);
      for (let i = 0; i < fp.length; i++) {
        fp[i] = fnv[i];
      }
      if (fp.length === 0) {
        fp[0] = 7;
      }
      this.fp = fp;
      this.h = hash2;
      this.seed = seed;
    }
    hash() {
      return this.h.hash(this.fp, this.seed);
    }
    equals(other) {
      if (!(other?.fp instanceof Uint8Array)) {
        return false;
      }
      return equals34(this.fp, other.fp);
    }
  };

  // ../node_modules/@libp2p/utils/dist/src/filters/utils.js
  function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
  }

  // ../node_modules/@libp2p/utils/dist/src/filters/bucket.js
  var Bucket = class {
    contents;
    constructor(size) {
      this.contents = new Array(size).fill(null);
    }
    has(fingerprint) {
      if (!(fingerprint instanceof Fingerprint)) {
        throw new TypeError("Invalid Fingerprint");
      }
      return this.contents.some((fp) => {
        return fingerprint.equals(fp);
      });
    }
    add(fingerprint) {
      if (!(fingerprint instanceof Fingerprint)) {
        throw new TypeError("Invalid Fingerprint");
      }
      for (let i = 0; i < this.contents.length; i++) {
        if (this.contents[i] == null) {
          this.contents[i] = fingerprint;
          return true;
        }
      }
      return true;
    }
    swap(fingerprint) {
      if (!(fingerprint instanceof Fingerprint)) {
        throw new TypeError("Invalid Fingerprint");
      }
      const i = getRandomInt(0, this.contents.length - 1);
      const current = this.contents[i];
      this.contents[i] = fingerprint;
      return current;
    }
    remove(fingerprint) {
      if (!(fingerprint instanceof Fingerprint)) {
        throw new TypeError("Invalid Fingerprint");
      }
      const found = this.contents.findIndex((fp) => {
        return fingerprint.equals(fp);
      });
      if (found > -1) {
        this.contents[found] = null;
        return true;
      } else {
        return false;
      }
    }
  };

  // ../node_modules/@libp2p/utils/dist/src/filters/cuckoo-filter.js
  var maxCuckooCount = 500;
  var CuckooFilter = class {
    bucketSize;
    filterSize;
    fingerprintSize;
    buckets;
    count;
    hash;
    seed;
    constructor(init) {
      this.filterSize = init.filterSize;
      this.bucketSize = init.bucketSize ?? 4;
      this.fingerprintSize = init.fingerprintSize ?? 2;
      this.count = 0;
      this.buckets = [];
      this.hash = init.hash ?? fnv1a2;
      this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10));
    }
    add(item) {
      if (typeof item === "string") {
        item = fromString23(item);
      }
      const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
      const j = this.hash.hash(item, this.seed) % this.filterSize;
      const k = (j ^ fingerprint.hash()) % this.filterSize;
      if (this.buckets[j] == null) {
        this.buckets[j] = new Bucket(this.bucketSize);
      }
      if (this.buckets[k] == null) {
        this.buckets[k] = new Bucket(this.bucketSize);
      }
      if (this.buckets[j].add(fingerprint) || this.buckets[k].add(fingerprint)) {
        this.count++;
        return true;
      }
      const rand = [j, k];
      let i = rand[getRandomInt(0, rand.length - 1)];
      if (this.buckets[i] == null) {
        this.buckets[i] = new Bucket(this.bucketSize);
      }
      for (let n = 0; n < maxCuckooCount; n++) {
        const swapped = this.buckets[i].swap(fingerprint);
        if (swapped == null) {
          continue;
        }
        i = (i ^ swapped.hash()) % this.filterSize;
        if (this.buckets[i] == null) {
          this.buckets[i] = new Bucket(this.bucketSize);
        }
        if (this.buckets[i].add(swapped)) {
          this.count++;
          return true;
        } else {
          continue;
        }
      }
      return false;
    }
    has(item) {
      if (typeof item === "string") {
        item = fromString23(item);
      }
      const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
      const j = this.hash.hash(item, this.seed) % this.filterSize;
      const inJ = this.buckets[j]?.has(fingerprint) ?? false;
      if (inJ) {
        return inJ;
      }
      const k = (j ^ fingerprint.hash()) % this.filterSize;
      return this.buckets[k]?.has(fingerprint) ?? false;
    }
    remove(item) {
      if (typeof item === "string") {
        item = fromString23(item);
      }
      const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
      const j = this.hash.hash(item, this.seed) % this.filterSize;
      const inJ = this.buckets[j]?.remove(fingerprint) ?? false;
      if (inJ) {
        this.count--;
        return inJ;
      }
      const k = (j ^ fingerprint.hash()) % this.filterSize;
      const inK = this.buckets[k]?.remove(fingerprint) ?? false;
      if (inK) {
        this.count--;
      }
      return inK;
    }
    get reliable() {
      return Math.floor(100 * (this.count / this.filterSize)) <= 90;
    }
  };
  var MAX_LOAD = {
    1: 0.5,
    2: 0.84,
    4: 0.95,
    8: 0.98
  };
  function calculateBucketSize(errorRate = 1e-3) {
    if (errorRate > 2e-3) {
      return 2;
    }
    if (errorRate > 1e-5) {
      return 4;
    }
    return 8;
  }
  function optimize(maxItems, errorRate = 1e-3) {
    const bucketSize = calculateBucketSize(errorRate);
    const load2 = MAX_LOAD[bucketSize];
    const filterSize = Math.round(maxItems / load2);
    const fingerprintSize = Math.min(Math.ceil(Math.log2(1 / errorRate) + Math.log2(2 * bucketSize)), MAX_FINGERPRINT_SIZE);
    return {
      filterSize,
      bucketSize,
      fingerprintSize
    };
  }

  // ../node_modules/@libp2p/utils/dist/src/filters/scalable-cuckoo-filter.js
  var ScalableCuckooFilter = class {
    filterSize;
    bucketSize;
    fingerprintSize;
    scale;
    filterSeries;
    hash;
    seed;
    constructor(init) {
      this.bucketSize = init.bucketSize ?? 4;
      this.filterSize = init.filterSize ?? (1 << 18) / this.bucketSize;
      this.fingerprintSize = init.fingerprintSize ?? 2;
      this.scale = init.scale ?? 2;
      this.hash = init.hash ?? fnv1a2;
      this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10));
      this.filterSeries = [
        new CuckooFilter({
          filterSize: this.filterSize,
          bucketSize: this.bucketSize,
          fingerprintSize: this.fingerprintSize,
          hash: this.hash,
          seed: this.seed
        })
      ];
    }
    add(item) {
      if (typeof item === "string") {
        item = fromString23(item);
      }
      if (this.has(item)) {
        return true;
      }
      let current = this.filterSeries.find((cuckoo) => {
        return cuckoo.reliable;
      });
      if (current == null) {
        const curSize = this.filterSize * Math.pow(this.scale, this.filterSeries.length);
        current = new CuckooFilter({
          filterSize: curSize,
          bucketSize: this.bucketSize,
          fingerprintSize: this.fingerprintSize,
          hash: this.hash,
          seed: this.seed
        });
        this.filterSeries.push(current);
      }
      return current.add(item);
    }
    has(item) {
      if (typeof item === "string") {
        item = fromString23(item);
      }
      for (let i = 0; i < this.filterSeries.length; i++) {
        if (this.filterSeries[i].has(item)) {
          return true;
        }
      }
      return false;
    }
    remove(item) {
      if (typeof item === "string") {
        item = fromString23(item);
      }
      for (let i = 0; i < this.filterSeries.length; i++) {
        if (this.filterSeries[i].remove(item)) {
          return true;
        }
      }
      return false;
    }
    get count() {
      return this.filterSeries.reduce((acc, curr) => {
        return acc + curr.count;
      }, 0);
    }
  };
  function createScalableCuckooFilter(maxItems, errorRate = 1e-3, options) {
    return new ScalableCuckooFilter({
      ...optimize(maxItems, errorRate),
      ...options ?? {}
    });
  }

  // ../node_modules/@libp2p/peer-collections/dist/src/tracked-map.js
  var TrackedPeerMap = class extends PeerMap {
    metric;
    constructor(init) {
      super();
      const { name: name19, metrics } = init;
      this.metric = metrics.registerMetric(name19);
      this.updateComponentMetric();
    }
    set(key, value) {
      super.set(key, value);
      this.updateComponentMetric();
      return this;
    }
    delete(key) {
      const deleted = super.delete(key);
      this.updateComponentMetric();
      return deleted;
    }
    clear() {
      super.clear();
      this.updateComponentMetric();
    }
    updateComponentMetric() {
      this.metric.update(this.size);
    }
  };
  function trackedPeerMap(config) {
    const { name: name19, metrics } = config;
    let map2;
    if (metrics != null) {
      map2 = new TrackedPeerMap({ name: name19, metrics });
    } else {
      map2 = new PeerMap();
    }
    return map2;
  }

  // ../node_modules/abort-error/dist/src/index.js
  var AbortError5 = class extends Error {
    static name = "AbortError";
    name = "AbortError";
    constructor(message2 = "The operation was aborted", ...rest) {
      super(message2, ...rest);
    }
  };

  // ../node_modules/race-event/dist/src/index.js
  async function raceEvent(emitter, eventName, signal, opts) {
    const error = new AbortError5(opts?.errorMessage);
    if (opts?.errorCode != null) {
      error.code = opts.errorCode;
    }
    const errorEvent = opts?.errorEvent ?? "error";
    if (signal?.aborted === true) {
      return Promise.reject(error);
    }
    return new Promise((resolve, reject) => {
      function removeListeners() {
        removeListener(signal, "abort", abortListener);
        removeListener(emitter, eventName, eventListener);
        removeListener(emitter, errorEvent, errorEventListener);
      }
      const eventListener = (evt) => {
        try {
          if (opts?.filter?.(evt) === false) {
            return;
          }
        } catch (err) {
          removeListeners();
          reject(err);
          return;
        }
        removeListeners();
        resolve(evt);
      };
      const errorEventListener = (evt) => {
        removeListeners();
        if (evt instanceof Error) {
          reject(evt);
          return;
        }
        reject(evt.detail ?? opts?.error ?? new Error(`The "${opts?.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`));
      };
      const abortListener = () => {
        removeListeners();
        reject(error);
      };
      addListener(signal, "abort", abortListener);
      addListener(emitter, eventName, eventListener);
      addListener(emitter, errorEvent, errorEventListener);
    });
  }
  function addListener(emitter, event, listener) {
    if (emitter == null) {
      return;
    }
    if (isEventTarget(emitter)) {
      emitter.addEventListener(event, listener);
    } else {
      emitter.addListener(event, listener);
    }
  }
  function removeListener(emitter, event, listener) {
    if (emitter == null) {
      return;
    }
    if (isEventTarget(emitter)) {
      emitter.removeEventListener(event, listener);
    } else {
      emitter.removeListener(event, listener);
    }
  }
  function isEventTarget(emitter) {
    return typeof emitter.addEventListener === "function" && typeof emitter.removeEventListener === "function";
  }

  // ../node_modules/it-queue/dist/src/errors.js
  var QueueFullError2 = class extends Error {
    static name = "QueueFullError";
    constructor(message2 = "The queue was full") {
      super(message2);
      this.name = "QueueFullError";
    }
  };

  // ../node_modules/it-queue/dist/src/recipient.js
  var JobRecipient = class {
    deferred;
    signal;
    constructor(signal) {
      this.signal = signal;
      this.deferred = Promise.withResolvers();
      this.onAbort = this.onAbort.bind(this);
      this.signal?.addEventListener("abort", this.onAbort);
    }
    onAbort() {
      this.deferred.reject(this.signal?.reason ?? new AbortError5());
    }
    cleanup() {
      this.signal?.removeEventListener("abort", this.onAbort);
    }
  };

  // ../node_modules/it-queue/dist/src/job.js
  function randomId() {
    return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
  }
  var Job = class {
    id;
    fn;
    options;
    recipients;
    status;
    timeline;
    controller;
    constructor(fn, options) {
      this.id = randomId();
      this.status = "queued";
      this.fn = fn;
      this.options = options;
      this.recipients = [];
      this.timeline = {
        created: Date.now()
      };
      this.controller = new AbortController();
      setMaxListeners(Infinity, this.controller.signal);
      this.onAbort = this.onAbort.bind(this);
    }
    abort(err) {
      this.controller.abort(err);
    }
    onAbort() {
      const allAborted = this.recipients.reduce((acc, curr) => {
        return acc && curr.signal?.aborted === true;
      }, true);
      if (allAborted) {
        this.controller.abort(new AbortError5());
        this.cleanup();
      }
    }
    async join(options = {}) {
      const recipient = new JobRecipient(options.signal);
      this.recipients.push(recipient);
      options.signal?.addEventListener("abort", this.onAbort);
      return recipient.deferred.promise;
    }
    async run() {
      this.status = "running";
      this.timeline.started = Date.now();
      try {
        this.controller.signal.throwIfAborted();
        const result = await raceSignal(this.fn({
          ...this.options ?? {},
          signal: this.controller.signal
        }), this.controller.signal);
        this.recipients.forEach((recipient) => {
          recipient.deferred.resolve(result);
        });
        this.status = "complete";
      } catch (err) {
        this.recipients.forEach((recipient) => {
          recipient.deferred.reject(err);
        });
        this.status = "errored";
      } finally {
        this.timeline.finished = Date.now();
        this.cleanup();
      }
    }
    cleanup() {
      this.recipients.forEach((recipient) => {
        recipient.cleanup();
        recipient.signal?.removeEventListener("abort", this.onAbort);
      });
    }
  };

  // ../node_modules/it-queue/dist/src/utils.js
  function debounce2(func2, wait) {
    let timeout2;
    const output2 = function() {
      const later = function() {
        timeout2 = void 0;
        void func2();
      };
      clearTimeout(timeout2);
      timeout2 = setTimeout(later, wait);
    };
    output2.start = () => {
    };
    output2.stop = () => {
      clearTimeout(timeout2);
    };
    return output2;
  }

  // ../node_modules/it-queue/dist/src/index.js
  var Queue = class extends TypedEventEmitter {
    concurrency;
    maxSize;
    queue;
    pending;
    sort;
    autoStart;
    constructor(init = {}) {
      super();
      this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
      this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY;
      this.pending = 0;
      this.autoStart = init.autoStart ?? true;
      this.sort = init.sort;
      this.queue = [];
      this.emitEmpty = debounce2(this.emitEmpty.bind(this), 1);
      this.emitIdle = debounce2(this.emitIdle.bind(this), 1);
    }
    [Symbol.asyncIterator]() {
      return this.toGenerator();
    }
    emitEmpty() {
      if (this.size !== 0) {
        return;
      }
      this.safeDispatchEvent("empty");
    }
    emitIdle() {
      if (this.running !== 0) {
        return;
      }
      this.safeDispatchEvent("idle");
    }
    tryToStartAnother() {
      if (this.size === 0) {
        this.emitEmpty();
        if (this.running === 0) {
          this.emitIdle();
        }
        return false;
      }
      if (this.pending < this.concurrency) {
        let job;
        for (const j of this.queue) {
          if (j.status === "queued") {
            job = j;
            break;
          }
        }
        if (job == null) {
          return false;
        }
        this.safeDispatchEvent("active");
        this.pending++;
        void job.run().finally(() => {
          for (let i = 0; i < this.queue.length; i++) {
            if (this.queue[i] === job) {
              this.queue.splice(i, 1);
              break;
            }
          }
          this.pending--;
          this.safeDispatchEvent("next");
          if (this.autoStart) {
            this.tryToStartAnother();
          }
        });
        return true;
      }
      return false;
    }
    enqueue(job) {
      this.queue.push(job);
      if (this.sort != null) {
        this.queue.sort(this.sort);
      }
    }
    /**
     * Start the queue. If the `autoStart` parameter passed to the constructor was
     * not `false` this is a no-op
     */
    start() {
      if (this.autoStart !== false) {
        return;
      }
      this.autoStart = true;
      this.tryToStartAnother();
    }
    /**
     * Prevent further jobs from running - call `.start` to start the queue again
     */
    pause() {
      this.autoStart = false;
    }
    /**
     * Adds a sync or async task to the queue. Always returns a promise.
     */
    async add(fn, options) {
      options?.signal?.throwIfAborted();
      if (this.size === this.maxSize) {
        throw new QueueFullError2();
      }
      const job = new Job(fn, options);
      this.enqueue(job);
      this.safeDispatchEvent("add");
      if (this.autoStart) {
        this.tryToStartAnother();
      }
      return job.join(options).then((result) => {
        this.safeDispatchEvent("success", { detail: { job, result } });
        return result;
      }).catch((err) => {
        if (job.status === "queued") {
          for (let i = 0; i < this.queue.length; i++) {
            if (this.queue[i] === job) {
              this.queue.splice(i, 1);
              break;
            }
          }
        }
        this.safeDispatchEvent("failure", { detail: { job, error: err } });
        throw err;
      });
    }
    /**
     * Clear the queue
     */
    clear() {
      this.queue.splice(0, this.queue.length);
    }
    /**
     * Abort all jobs in the queue and clear it
     */
    abort() {
      this.queue.forEach((job) => {
        job.abort(new AbortError5());
      });
      this.clear();
    }
    /**
     * Can be called multiple times. Useful if you for example add additional items at a later time.
     *
     * @returns A promise that settles when the queue becomes empty.
     */
    async onEmpty(options) {
      if (this.size === 0) {
        return;
      }
      await raceEvent(this, "empty", options?.signal);
    }
    /**
     * @returns A promise that settles when the queue size is less than the given
     * limit: `queue.size < limit`.
     *
     * If you want to avoid having the queue grow beyond a certain size you can
     * `await queue.onSizeLessThan()` before adding a new item.
     *
     * Note that this only limits the number of items waiting to start. There
     * could still be up to `concurrency` jobs already running that this call does
     * not include in its calculation.
     */
    async onSizeLessThan(limit, options) {
      if (this.size < limit) {
        return;
      }
      await raceEvent(this, "next", options?.signal, {
        filter: () => this.size < limit
      });
    }
    /**
     * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
     * from the queue has finished. `.onEmpty` merely signals that the queue is
     * empty, but it could mean that some promises haven't completed yet.
     *
     * @returns A promise that settles when the queue becomes empty, and all
     * promises have completed; `queue.size === 0 && queue.pending === 0`.
     */
    async onIdle(options) {
      if (this.pending === 0 && this.size === 0) {
        return;
      }
      await raceEvent(this, "idle", options?.signal);
    }
    /**
     * Size of the queue including running items
     */
    get size() {
      return this.queue.length;
    }
    /**
     * The number of queued items waiting to run.
     */
    get queued() {
      return this.queue.length - this.pending;
    }
    /**
     * The number of items currently running.
     */
    get running() {
      return this.pending;
    }
    /**
     * Returns an async generator that makes it easy to iterate over the results
     * of jobs added to the queue.
     *
     * The generator will end when the queue becomes idle, that is there are no
     * jobs running and no jobs that have yet to run.
     *
     * If you need to keep the queue open indefinitely, consider using it-pushable
     * instead.
     */
    async *toGenerator(options) {
      options?.signal?.throwIfAborted();
      const stream = pushable({
        objectMode: true
      });
      const cleanup = (err) => {
        if (err != null) {
          this.abort();
        } else {
          this.clear();
        }
        stream.end(err);
      };
      const onQueueJobComplete = (evt) => {
        if (evt.detail != null) {
          stream.push(evt.detail.result);
        }
      };
      const onQueueError = (evt) => {
        cleanup(evt.detail.error);
      };
      const onQueueIdle = () => {
        cleanup();
      };
      const onSignalAbort = () => {
        cleanup(new AbortError5("Queue aborted"));
      };
      this.addEventListener("success", onQueueJobComplete);
      this.addEventListener("failure", onQueueError);
      this.addEventListener("idle", onQueueIdle);
      options?.signal?.addEventListener("abort", onSignalAbort);
      try {
        yield* stream;
      } finally {
        this.removeEventListener("success", onQueueJobComplete);
        this.removeEventListener("failure", onQueueError);
        this.removeEventListener("idle", onQueueIdle);
        options?.signal?.removeEventListener("abort", onSignalAbort);
        cleanup();
      }
    }
  };

  // ../node_modules/mortice/dist/src/constants.js
  var WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
  var WORKER_ABORT_READ_LOCK_REQUEST = "lock:worker:abort-read-request";
  var WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
  var MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
  var MASTER_READ_LOCK_ERROR = "lock:master:error-read";
  var WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
  var WORKER_ABORT_WRITE_LOCK_REQUEST = "lock:worker:abort-write-request";
  var WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
  var MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";
  var MASTER_WRITE_LOCK_ERROR = "lock:master:error-write";
  var WORKER_FINALIZE = "lock:worker:finalize";
  var BROADCAST_CHANNEL_NAME = "mortice";
  var defaultOptions = {
    singleProcess: false
  };

  // ../node_modules/mortice/dist/src/main/channel.js
  var handleChannelWorkerLockRequest = (emitter, channel, masterEvent, abortMasterEvent, requestType, abortType, errorType, releaseType, grantType) => {
    return (event) => {
      if (event.data == null) {
        return;
      }
      const requestEvent = {
        type: event.data.type,
        name: event.data.name,
        identifier: event.data.identifier
      };
      if (requestEvent.type === requestType) {
        emitter.safeDispatchEvent(masterEvent, {
          detail: {
            name: requestEvent.name,
            identifier: requestEvent.identifier,
            handler: async () => {
              channel.postMessage({
                type: grantType,
                name: requestEvent.name,
                identifier: requestEvent.identifier
              });
              await new Promise((resolve) => {
                const releaseEventListener = (event2) => {
                  if (event2?.data == null) {
                    return;
                  }
                  const releaseEvent = {
                    type: event2.data.type,
                    name: event2.data.name,
                    identifier: event2.data.identifier
                  };
                  if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                    channel.removeEventListener("message", releaseEventListener);
                    resolve();
                  }
                };
                channel.addEventListener("message", releaseEventListener);
              });
            },
            onError: (err) => {
              channel.postMessage({
                type: errorType,
                name: requestEvent.name,
                identifier: requestEvent.identifier,
                error: {
                  message: err.message,
                  name: err.name,
                  stack: err.stack
                }
              });
            }
          }
        });
      }
      if (requestEvent.type === abortType) {
        emitter.safeDispatchEvent(abortMasterEvent, {
          detail: {
            name: requestEvent.name,
            identifier: requestEvent.identifier
          }
        });
      }
      if (requestEvent.type === WORKER_FINALIZE) {
        emitter.safeDispatchEvent("finalizeRequest", {
          detail: {
            name: requestEvent.name
          }
        });
      }
    };
  };

  // ../node_modules/mortice/dist/src/utils.js
  var nanoid = (size = 10) => {
    return Math.random().toString().substring(2, size + 2);
  };

  // ../node_modules/mortice/dist/src/workers/channel.js
  var MorticeChannelWorker = class {
    name;
    channel;
    constructor(name19) {
      this.name = name19;
      this.channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
    }
    readLock(options) {
      return this.sendRequest(WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, MASTER_GRANT_READ_LOCK, MASTER_READ_LOCK_ERROR, WORKER_RELEASE_READ_LOCK, options);
    }
    writeLock(options) {
      return this.sendRequest(WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, MASTER_GRANT_WRITE_LOCK, MASTER_WRITE_LOCK_ERROR, WORKER_RELEASE_WRITE_LOCK, options);
    }
    finalize() {
      this.channel.postMessage({
        type: WORKER_FINALIZE,
        name: this.name
      });
      this.channel.close();
    }
    async sendRequest(requestType, abortType, grantType, errorType, releaseType, options) {
      options?.signal?.throwIfAborted();
      const id = nanoid();
      this.channel.postMessage({
        type: requestType,
        identifier: id,
        name: this.name
      });
      return new Promise((resolve, reject) => {
        const abortListener = () => {
          this.channel.postMessage({
            type: abortType,
            identifier: id,
            name: this.name
          });
        };
        options?.signal?.addEventListener("abort", abortListener, {
          once: true
        });
        const listener = (event) => {
          if (event.data?.identifier !== id) {
            return;
          }
          if (event.data?.type === grantType) {
            this.channel.removeEventListener("message", listener);
            options?.signal?.removeEventListener("abort", abortListener);
            resolve(() => {
              this.channel.postMessage({
                type: releaseType,
                identifier: id,
                name: this.name
              });
            });
          }
          if (event.data.type === errorType) {
            this.channel.removeEventListener("message", listener);
            options?.signal?.removeEventListener("abort", abortListener);
            const err = new Error();
            if (event.data.error != null) {
              err.message = event.data.error.message;
              err.name = event.data.error.name;
              err.stack = event.data.error.stack;
            }
            reject(err);
          }
        };
        this.channel.addEventListener("message", listener);
      });
    }
  };

  // ../node_modules/mortice/dist/src/browser.js
  var browser_default2 = (options) => {
    options = Object.assign({}, defaultOptions, options);
    const isPrimary = Boolean(globalThis.document) || options.singleProcess;
    if (isPrimary) {
      const channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
      const emitter = new TypedEventEmitter();
      channel.addEventListener("message", handleChannelWorkerLockRequest(emitter, channel, "requestReadLock", "abortReadLockRequest", WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, MASTER_READ_LOCK_ERROR, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
      channel.addEventListener("message", handleChannelWorkerLockRequest(emitter, channel, "requestWriteLock", "abortWriteLockRequest", WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, MASTER_WRITE_LOCK_ERROR, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
      return emitter;
    }
    return new MorticeChannelWorker(options.name);
  };

  // ../node_modules/mortice/dist/src/mortice.js
  var mutexes = /* @__PURE__ */ new Map();
  var implementation;
  function isMortice(obj) {
    return typeof obj?.readLock === "function" && typeof obj?.writeLock === "function";
  }
  function getImplementation(opts) {
    if (implementation == null) {
      implementation = browser_default2(opts);
      if (!isMortice(implementation)) {
        const emitter = implementation;
        emitter.addEventListener("requestReadLock", (event) => {
          const mutexName = event.detail.name;
          const identifier = event.detail.identifier;
          const mutex = mutexes.get(mutexName);
          if (mutex == null) {
            return;
          }
          const abortController = new AbortController();
          const abortListener = (event2) => {
            if (event2.detail.name !== mutexName || event2.detail.identifier !== identifier) {
              return;
            }
            abortController.abort();
          };
          emitter.addEventListener("abortReadLockRequest", abortListener);
          void mutex.readLock({
            signal: abortController.signal
          }).then(async (release) => {
            await event.detail.handler().finally(() => {
              release();
            });
          }).catch((err) => {
            event.detail.onError(err);
          }).finally(() => {
            emitter.removeEventListener("abortReadLockRequest", abortListener);
          });
        });
        emitter.addEventListener("requestWriteLock", (event) => {
          const mutexName = event.detail.name;
          const identifier = event.detail.identifier;
          const mutex = mutexes.get(mutexName);
          if (mutex == null) {
            return;
          }
          const abortController = new AbortController();
          const abortListener = (event2) => {
            if (event2.detail.name !== mutexName || event2.detail.identifier !== identifier) {
              return;
            }
            abortController.abort();
          };
          emitter.addEventListener("abortWriteLockRequest", abortListener);
          void mutex.writeLock({
            signal: abortController.signal
          }).then(async (release) => {
            await event.detail.handler().finally(() => {
              release();
            });
          }).catch((err) => {
            event.detail.onError(err);
          }).finally(() => {
            emitter.removeEventListener("abortWriteLockRequest", abortListener);
          });
        });
        emitter.addEventListener("finalizeRequest", (event) => {
          const mutexName = event.detail.name;
          const mutex = mutexes.get(mutexName);
          if (mutex == null) {
            return;
          }
          mutex.finalize();
        });
      }
    }
    return implementation;
  }
  async function createReleasable(queue, options) {
    let res;
    let rej;
    const p = new Promise((resolve, reject) => {
      res = resolve;
      rej = reject;
    });
    const listener = () => {
      rej(new AbortError5());
    };
    options?.signal?.addEventListener("abort", listener, {
      once: true
    });
    queue.add(async () => {
      await new Promise((resolve) => {
        res(() => {
          options?.signal?.removeEventListener("abort", listener);
          resolve();
        });
      });
    }, {
      signal: options?.signal
    }).catch((err) => {
      rej(err);
    });
    return p;
  }
  var createMutex = (name19, options) => {
    let mutex = mutexes.get(name19);
    if (mutex != null) {
      return mutex;
    }
    const implementation2 = getImplementation(options);
    if (isMortice(implementation2)) {
      mutex = implementation2;
      mutexes.set(name19, mutex);
      return mutex;
    }
    const masterQueue = new Queue({
      concurrency: 1
    });
    let readQueue;
    mutex = {
      async readLock(opts) {
        if (readQueue != null) {
          return createReleasable(readQueue, opts);
        }
        readQueue = new Queue({
          concurrency: options.concurrency,
          autoStart: false
        });
        const localReadQueue = readQueue;
        const readPromise = createReleasable(readQueue, opts);
        void masterQueue.add(async () => {
          localReadQueue.start();
          await localReadQueue.onIdle().then(() => {
            if (readQueue === localReadQueue) {
              readQueue = null;
            }
          });
        });
        return readPromise;
      },
      async writeLock(opts) {
        readQueue = null;
        return createReleasable(masterQueue, opts);
      },
      finalize: () => {
        mutexes.delete(name19);
      },
      queue: masterQueue
    };
    mutexes.set(name19, mutex);
    if (options.autoFinalize === true) {
      masterQueue.addEventListener("idle", () => {
        mutex.finalize();
      }, {
        once: true
      });
    }
    return mutex;
  };

  // ../node_modules/mortice/dist/src/index.js
  var defaultOptions2 = {
    name: "lock",
    concurrency: Infinity,
    singleProcess: false,
    autoFinalize: false
  };
  function createMortice(options) {
    const opts = Object.assign({}, defaultOptions2, options);
    return createMutex(opts.name, opts);
  }

  // ../node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bytes.js
  var empty16 = new Uint8Array(0);
  function equals35(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce16(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }

  // ../node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/vendor/base-x.js
  function base21(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src16 = base21;
  var _brrp__multiformats_scope_baseX16 = src16;
  var base_x_default16 = _brrp__multiformats_scope_baseX16;

  // ../node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/base.js
  var Encoder18 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder18 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or18(this, decoder);
    }
  };
  var ComposedDecoder16 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or18(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or18(left, right) {
    return new ComposedDecoder16({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec16 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder18(name19, prefix, baseEncode);
      this.decoder = new Decoder18(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from28({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec16(name19, prefix, encode79, decode99);
  }
  function baseX16({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default16(alphabet18, name19);
    return from28({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce16(decode99(text))
    });
  }
  function decode69(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode56(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx15(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc464815({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx15(alphabet18);
    return from28({
      prefix,
      name: name19,
      encode(input) {
        return encode56(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode69(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/base32.js
  var base3214 = rfc464815({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper14 = rfc464815({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad14 = rfc464815({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper14 = rfc464815({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex14 = rfc464815({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper14 = rfc464815({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad14 = rfc464815({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper14 = rfc464815({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z14 = rfc464815({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // ../node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/base36.js
  var base3613 = baseX16({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper13 = baseX16({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // ../node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/bases/base58.js
  var base58btc16 = baseX16({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr16 = baseX16({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_114 = encode57;
  var MSB16 = 128;
  var REST16 = 127;
  var MSBALL14 = ~REST16;
  var INT14 = Math.pow(2, 31);
  function encode57(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT14) {
      out[offset++] = num & 255 | MSB16;
      num /= 128;
    }
    while (num & MSBALL14) {
      out[offset++] = num & 255 | MSB16;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode57.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode70 = read15;
  var MSB$114 = 128;
  var REST$114 = 127;
  function read15(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read15.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$114) << shift : (b & REST$114) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$114);
    read15.bytes = counter - offset;
    return res;
  }
  var N115 = Math.pow(2, 7);
  var N215 = Math.pow(2, 14);
  var N315 = Math.pow(2, 21);
  var N415 = Math.pow(2, 28);
  var N515 = Math.pow(2, 35);
  var N615 = Math.pow(2, 42);
  var N715 = Math.pow(2, 49);
  var N814 = Math.pow(2, 56);
  var N914 = Math.pow(2, 63);
  var length15 = function(value) {
    return value < N115 ? 1 : value < N215 ? 2 : value < N315 ? 3 : value < N415 ? 4 : value < N515 ? 5 : value < N615 ? 6 : value < N715 ? 7 : value < N814 ? 8 : value < N914 ? 9 : 10;
  };
  var varint14 = {
    encode: encode_114,
    decode: decode70,
    encodingLength: length15
  };
  var _brrp_varint14 = varint14;
  var varint_default14 = _brrp_varint14;

  // ../node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/varint.js
  function decode71(data, offset = 0) {
    const code18 = varint_default14.decode(data, offset);
    return [code18, varint_default14.decode.bytes];
  }
  function encodeTo14(int, target, offset = 0) {
    varint_default14.encode(int, target, offset);
    return target;
  }
  function encodingLength15(int) {
    return varint_default14.encodingLength(int);
  }

  // ../node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/hashes/digest.js
  function create13(code18, digest18) {
    const size = digest18.byteLength;
    const sizeOffset = encodingLength15(code18);
    const digestOffset = sizeOffset + encodingLength15(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo14(code18, bytes2, 0);
    encodeTo14(size, bytes2, sizeOffset);
    bytes2.set(digest18, digestOffset);
    return new Digest14(code18, size, digest18, bytes2);
  }
  function decode72(multihash) {
    const bytes2 = coerce16(multihash);
    const [code18, sizeOffset] = decode71(bytes2);
    const [size, digestOffset] = decode71(bytes2.subarray(sizeOffset));
    const digest18 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest18.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest14(code18, size, digest18, bytes2);
  }
  function equals36(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals35(a.bytes, data.bytes);
    }
  }
  var Digest14 = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code18, size, digest18, bytes2) {
      this.code = code18;
      this.size = size;
      this.digest = digest18;
      this.bytes = bytes2;
    }
  };

  // ../node_modules/@libp2p/peer-store/node_modules/multiformats/dist/src/cid.js
  function format13(link, base37) {
    const { bytes: bytes2, version: version5 } = link;
    switch (version5) {
      case 0:
        return toStringV013(bytes2, baseCache13(link), base37 ?? base58btc16.encoder);
      default:
        return toStringV113(bytes2, baseCache13(link), base37 ?? base3214.encoder);
    }
  }
  var cache14 = /* @__PURE__ */ new WeakMap();
  function baseCache13(cid) {
    const baseCache19 = cache14.get(cid);
    if (baseCache19 == null) {
      const baseCache20 = /* @__PURE__ */ new Map();
      cache14.set(cid, baseCache20);
      return baseCache20;
    }
    return baseCache19;
  }
  var CID13 = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version5, code18, multihash, bytes2) {
      this.code = code18;
      this.version = version5;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code18, multihash } = this;
          if (code18 !== DAG_PB_CODE13) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE13) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code18, digest: digest18 } = this.multihash;
          const multihash = create13(code18, digest18);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals36(self2.multihash, unknown.multihash);
    }
    toString(base37) {
      return format13(this, base37);
    }
    toJSON() {
      return { "/": format13(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version5, code: code18, multihash, bytes: bytes2 } = value;
        return new _CID(version5, code18, multihash, bytes2 ?? encodeCID13(version5, code18, multihash.bytes));
      } else if (value[cidSymbol13] === true) {
        const { version: version5, multihash, code: code18 } = value;
        const digest18 = decode72(multihash);
        return _CID.create(version5, code18, digest18);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version5, code18, digest18) {
      if (typeof code18 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest18.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version5) {
        case 0: {
          if (code18 !== DAG_PB_CODE13) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE13}) block encoding`);
          } else {
            return new _CID(version5, code18, digest18, digest18.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID13(version5, code18, digest18.bytes);
          return new _CID(version5, code18, digest18, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest18) {
      return _CID.create(0, DAG_PB_CODE13, digest18);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code18, digest18) {
      return _CID.create(1, code18, digest18);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes2) {
      const [cid, remainder] = _CID.decodeFirst(bytes2);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes2) {
      const specs = _CID.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce16(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest18 = new Digest14(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest18) : _CID.createV1(specs.codec, digest18);
      return [cid, bytes2.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length21] = decode71(initialBytes.subarray(offset));
        offset += length21;
        return i;
      };
      let version5 = next();
      let codec = DAG_PB_CODE13;
      if (version5 === 18) {
        version5 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version5 !== 0 && version5 !== 1) {
        throw new RangeError(`Invalid CID version ${version5}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version5, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base37) {
      const [prefix, bytes2] = parseCIDtoBytes13(source, base37);
      const cid = _CID.decode(bytes2);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache13(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes13(source, base37) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base37 ?? base58btc16;
        return [
          base58btc16.prefix,
          decoder.decode(`${base58btc16.prefix}${source}`)
        ];
      }
      case base58btc16.prefix: {
        const decoder = base37 ?? base58btc16;
        return [base58btc16.prefix, decoder.decode(source)];
      }
      case base3214.prefix: {
        const decoder = base37 ?? base3214;
        return [base3214.prefix, decoder.decode(source)];
      }
      case base3613.prefix: {
        const decoder = base37 ?? base3613;
        return [base3613.prefix, decoder.decode(source)];
      }
      default: {
        if (base37 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base37.decode(source)];
      }
    }
  }
  function toStringV013(bytes2, cache20, base37) {
    const { prefix } = base37;
    if (prefix !== base58btc16.prefix) {
      throw Error(`Cannot string encode V0 in ${base37.name} encoding`);
    }
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2).slice(1);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV113(bytes2, cache20, base37) {
    const { prefix } = base37;
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE13 = 112;
  var SHA_256_CODE13 = 18;
  function encodeCID13(version5, code18, multihash) {
    const codeOffset = encodingLength15(version5);
    const hashOffset = codeOffset + encodingLength15(code18);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo14(version5, bytes2, 0);
    encodeTo14(code18, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  }
  var cidSymbol13 = Symbol.for("@ipld/js-cid/CID");

  // ../node_modules/@libp2p/peer-store/dist/src/constants.js
  var MAX_ADDRESS_AGE = 36e5;
  var MAX_PEER_AGE = 216e5;

  // ../node_modules/@libp2p/peer-store/node_modules/uint8arrays/dist/src/alloc.js
  function alloc7(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/@libp2p/peer-store/dist/src/pb/peer.js
  var Peer;
  (function(Peer2) {
    let Peer$metadataEntry;
    (function(Peer$metadataEntry2) {
      let _codec2;
      Peer$metadataEntry2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w2, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w2.fork();
            }
            if (obj.key != null && obj.key !== "") {
              w2.uint32(10);
              w2.string(obj.key);
            }
            if (obj.value != null && obj.value.byteLength > 0) {
              w2.uint32(18);
              w2.bytes(obj.value);
            }
            if (opts.lengthDelimited !== false) {
              w2.ldelim();
            }
          }, (reader, length21, opts = {}) => {
            const obj = {
              key: "",
              value: alloc7(0)
            };
            const end = length21 == null ? reader.len : reader.pos + length21;
            while (reader.pos < end) {
              const tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  obj.key = reader.string();
                  break;
                }
                case 2: {
                  obj.value = reader.bytes();
                  break;
                }
                default: {
                  reader.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      Peer$metadataEntry2.encode = (obj) => {
        return encodeMessage(obj, Peer$metadataEntry2.codec());
      };
      Peer$metadataEntry2.decode = (buf, opts) => {
        return decodeMessage(buf, Peer$metadataEntry2.codec(), opts);
      };
    })(Peer$metadataEntry = Peer2.Peer$metadataEntry || (Peer2.Peer$metadataEntry = {}));
    let Peer$tagsEntry;
    (function(Peer$tagsEntry2) {
      let _codec2;
      Peer$tagsEntry2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w2, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w2.fork();
            }
            if (obj.key != null && obj.key !== "") {
              w2.uint32(10);
              w2.string(obj.key);
            }
            if (obj.value != null) {
              w2.uint32(18);
              Tag.codec().encode(obj.value, w2);
            }
            if (opts.lengthDelimited !== false) {
              w2.ldelim();
            }
          }, (reader, length21, opts = {}) => {
            const obj = {
              key: ""
            };
            const end = length21 == null ? reader.len : reader.pos + length21;
            while (reader.pos < end) {
              const tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  obj.key = reader.string();
                  break;
                }
                case 2: {
                  obj.value = Tag.codec().decode(reader, reader.uint32(), {
                    limits: opts.limits?.value
                  });
                  break;
                }
                default: {
                  reader.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      Peer$tagsEntry2.encode = (obj) => {
        return encodeMessage(obj, Peer$tagsEntry2.codec());
      };
      Peer$tagsEntry2.decode = (buf, opts) => {
        return decodeMessage(buf, Peer$tagsEntry2.codec(), opts);
      };
    })(Peer$tagsEntry = Peer2.Peer$tagsEntry || (Peer2.Peer$tagsEntry = {}));
    let _codec;
    Peer2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.addresses != null) {
            for (const value of obj.addresses) {
              w2.uint32(10);
              Address.codec().encode(value, w2);
            }
          }
          if (obj.protocols != null) {
            for (const value of obj.protocols) {
              w2.uint32(18);
              w2.string(value);
            }
          }
          if (obj.publicKey != null) {
            w2.uint32(34);
            w2.bytes(obj.publicKey);
          }
          if (obj.peerRecordEnvelope != null) {
            w2.uint32(42);
            w2.bytes(obj.peerRecordEnvelope);
          }
          if (obj.metadata != null && obj.metadata.size !== 0) {
            for (const [key, value] of obj.metadata.entries()) {
              w2.uint32(50);
              Peer2.Peer$metadataEntry.codec().encode({ key, value }, w2);
            }
          }
          if (obj.tags != null && obj.tags.size !== 0) {
            for (const [key, value] of obj.tags.entries()) {
              w2.uint32(58);
              Peer2.Peer$tagsEntry.codec().encode({ key, value }, w2);
            }
          }
          if (obj.updated != null) {
            w2.uint32(64);
            w2.uint64Number(obj.updated);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            addresses: [],
            protocols: [],
            metadata: /* @__PURE__ */ new Map(),
            tags: /* @__PURE__ */ new Map()
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (opts.limits?.addresses != null && obj.addresses.length === opts.limits.addresses) {
                  throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
                }
                obj.addresses.push(Address.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.addresses$
                }));
                break;
              }
              case 2: {
                if (opts.limits?.protocols != null && obj.protocols.length === opts.limits.protocols) {
                  throw new MaxLengthError('Decode error - map field "protocols" had too many elements');
                }
                obj.protocols.push(reader.string());
                break;
              }
              case 4: {
                obj.publicKey = reader.bytes();
                break;
              }
              case 5: {
                obj.peerRecordEnvelope = reader.bytes();
                break;
              }
              case 6: {
                if (opts.limits?.metadata != null && obj.metadata.size === opts.limits.metadata) {
                  throw new MaxSizeError('Decode error - map field "metadata" had too many elements');
                }
                const entry = Peer2.Peer$metadataEntry.codec().decode(reader, reader.uint32());
                obj.metadata.set(entry.key, entry.value);
                break;
              }
              case 7: {
                if (opts.limits?.tags != null && obj.tags.size === opts.limits.tags) {
                  throw new MaxSizeError('Decode error - map field "tags" had too many elements');
                }
                const entry = Peer2.Peer$tagsEntry.codec().decode(reader, reader.uint32(), {
                  limits: {
                    value: opts.limits?.tags$value
                  }
                });
                obj.tags.set(entry.key, entry.value);
                break;
              }
              case 8: {
                obj.updated = reader.uint64Number();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Peer2.encode = (obj) => {
      return encodeMessage(obj, Peer2.codec());
    };
    Peer2.decode = (buf, opts) => {
      return decodeMessage(buf, Peer2.codec(), opts);
    };
  })(Peer || (Peer = {}));
  var Address;
  (function(Address2) {
    let _codec;
    Address2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.multiaddr);
          }
          if (obj.isCertified != null) {
            w2.uint32(16);
            w2.bool(obj.isCertified);
          }
          if (obj.observed != null) {
            w2.uint32(24);
            w2.uint64Number(obj.observed);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            multiaddr: alloc7(0)
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.multiaddr = reader.bytes();
                break;
              }
              case 2: {
                obj.isCertified = reader.bool();
                break;
              }
              case 3: {
                obj.observed = reader.uint64Number();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Address2.encode = (obj) => {
      return encodeMessage(obj, Address2.codec());
    };
    Address2.decode = (buf, opts) => {
      return decodeMessage(buf, Address2.codec(), opts);
    };
  })(Address || (Address = {}));
  var Tag;
  (function(Tag2) {
    let _codec;
    Tag2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.value != null && obj.value !== 0) {
            w2.uint32(8);
            w2.uint32(obj.value);
          }
          if (obj.expiry != null) {
            w2.uint32(16);
            w2.uint64(obj.expiry);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {
            value: 0
          };
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.value = reader.uint32();
                break;
              }
              case 2: {
                obj.expiry = reader.uint64();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Tag2.encode = (obj) => {
      return encodeMessage(obj, Tag2.codec());
    };
    Tag2.decode = (buf, opts) => {
      return decodeMessage(buf, Tag2.codec(), opts);
    };
  })(Tag || (Tag = {}));

  // ../node_modules/@libp2p/peer-store/dist/src/utils/bytes-to-peer.js
  function populatePublicKey(peerId2, protobuf2) {
    if (peerId2.publicKey != null || protobuf2.publicKey == null) {
      return peerId2;
    }
    let digest18;
    if (peerId2.type === "RSA") {
      digest18 = peerId2.toMultihash();
    }
    const publicKey = publicKeyFromProtobuf(protobuf2.publicKey, digest18);
    return peerIdFromPublicKey(publicKey);
  }
  function bytesToPeer(peerId2, buf, maxAddressAge) {
    const peer = Peer.decode(buf);
    return pbToPeer(peerId2, peer, maxAddressAge);
  }
  function pbToPeer(peerId2, peer, maxAddressAge) {
    const tags = /* @__PURE__ */ new Map();
    const now = BigInt(Date.now());
    for (const [key, tag] of peer.tags.entries()) {
      if (tag.expiry != null && tag.expiry < now) {
        continue;
      }
      tags.set(key, tag);
    }
    return {
      ...peer,
      id: populatePublicKey(peerId2, peer),
      addresses: peer.addresses.filter(({ observed }) => observed != null && observed > Date.now() - maxAddressAge).map(({ multiaddr: ma, isCertified }) => {
        return {
          multiaddr: multiaddr(ma),
          isCertified: isCertified ?? false
        };
      }),
      metadata: peer.metadata,
      peerRecordEnvelope: peer.peerRecordEnvelope ?? void 0,
      tags
    };
  }

  // ../node_modules/@libp2p/peer-store/node_modules/uint8arrays/dist/src/equals.js
  function equals37(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }

  // ../node_modules/@libp2p/peer-store/dist/src/utils/peer-equals.js
  function peerEquals(peerA, peerB) {
    return addressesEqual(peerA.addresses, peerB.addresses) && protocolsEqual(peerA.protocols, peerB.protocols) && publicKeyEqual(peerA.publicKey, peerB.publicKey) && peerRecordEnvelope(peerA.peerRecordEnvelope, peerB.peerRecordEnvelope) && metadataEqual(peerA.metadata, peerB.metadata) && tagsEqual(peerA.tags, peerB.tags);
  }
  function addressesEqual(addressesA, addressesB) {
    return compareArrays(addressesA, addressesB, (a, b) => {
      if (a.isCertified !== b.isCertified) {
        return false;
      }
      if (!equals37(a.multiaddr, b.multiaddr)) {
        return false;
      }
      return true;
    });
  }
  function protocolsEqual(protocolsA, protocolsB) {
    return compareArrays(protocolsA, protocolsB, (a, b) => a === b);
  }
  function publicKeyEqual(publicKeyA, publicKeyB) {
    return compareOptionalUint8Arrays(publicKeyA, publicKeyB);
  }
  function peerRecordEnvelope(envelopeA, envelopeB) {
    return compareOptionalUint8Arrays(envelopeA, envelopeB);
  }
  function metadataEqual(metadataA, metadataB) {
    return compareMaps(metadataA, metadataB, (a, b) => equals37(a, b));
  }
  function tagsEqual(metadataA, metadataB) {
    return compareMaps(metadataA, metadataB, (a, b) => a.value === b.value && a.expiry === b.expiry);
  }
  function compareOptionalUint8Arrays(arrA, arrB) {
    if (arrA == null && arrB == null) {
      return true;
    }
    if (arrA != null && arrB != null) {
      return equals37(arrA, arrB);
    }
    return false;
  }
  function compareArrays(arrA, arrB, compare3) {
    if (arrA.length !== arrB.length) {
      return false;
    }
    for (let i = 0; i < arrA.length; i++) {
      if (!compare3(arrA[i], arrB[i])) {
        return false;
      }
    }
    return true;
  }
  function compareMaps(mapA, mapB, compare3) {
    if (mapA.size !== mapB.size) {
      return false;
    }
    for (const [key, value] of mapA.entries()) {
      const valueB = mapB.get(key);
      if (valueB == null) {
        return false;
      }
      if (!compare3(value, valueB)) {
        return false;
      }
    }
    return true;
  }

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports13 = {};
  __export(base10_exports13, {
    base10: () => base1013
  });

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/bytes.js
  var empty17 = new Uint8Array(0);
  function equals38(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce17(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function fromString24(str) {
    return new TextEncoder().encode(str);
  }
  function toString20(b) {
    return new TextDecoder().decode(b);
  }

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/vendor/base-x.js
  function base30(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src17 = base30;
  var _brrp__multiformats_scope_baseX17 = src17;
  var base_x_default17 = _brrp__multiformats_scope_baseX17;

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base.js
  var Encoder19 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder19 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or19(this, decoder);
    }
  };
  var ComposedDecoder17 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or19(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or19(left, right) {
    return new ComposedDecoder17({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec17 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder19(name19, prefix, baseEncode);
      this.decoder = new Decoder19(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from29({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec17(name19, prefix, encode79, decode99);
  }
  function baseX17({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default17(alphabet18, name19);
    return from29({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce17(decode99(text))
    });
  }
  function decode73(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode58(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx16(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc464816({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx16(alphabet18);
    return from29({
      prefix,
      name: name19,
      encode(input) {
        return encode58(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode73(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base10.js
  var base1013 = baseX17({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports13 = {};
  __export(base16_exports13, {
    base16: () => base1613,
    base16upper: () => base16upper13
  });
  var base1613 = rfc464816({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper13 = rfc464816({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports13 = {};
  __export(base2_exports13, {
    base2: () => base213
  });
  var base213 = rfc464816({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports13 = {};
  __export(base256emoji_exports13, {
    base256emoji: () => base256emoji13
  });
  var alphabet13 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars13 = alphabet13.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes13 = alphabet13.reduce((p, c, i) => {
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
  }, []);
  function encode59(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars13[c];
      return p;
    }, "");
  }
  function decode74(str) {
    const byts = [];
    for (const char of str) {
      const codePoint = char.codePointAt(0);
      if (codePoint == null) {
        throw new Error(`Invalid character: ${char}`);
      }
      const byt = alphabetCharsToBytes13[codePoint];
      if (byt == null) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji13 = from29({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode59,
    decode: decode74
  });

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports13 = {};
  __export(base32_exports13, {
    base32: () => base3215,
    base32hex: () => base32hex15,
    base32hexpad: () => base32hexpad15,
    base32hexpadupper: () => base32hexpadupper15,
    base32hexupper: () => base32hexupper15,
    base32pad: () => base32pad15,
    base32padupper: () => base32padupper15,
    base32upper: () => base32upper15,
    base32z: () => base32z15
  });
  var base3215 = rfc464816({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper15 = rfc464816({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad15 = rfc464816({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper15 = rfc464816({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex15 = rfc464816({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper15 = rfc464816({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad15 = rfc464816({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper15 = rfc464816({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z15 = rfc464816({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports13 = {};
  __export(base36_exports13, {
    base36: () => base3614,
    base36upper: () => base36upper14
  });
  var base3614 = baseX17({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper14 = baseX17({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports13 = {};
  __export(base58_exports13, {
    base58btc: () => base58btc17,
    base58flickr: () => base58flickr17
  });
  var base58btc17 = baseX17({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr17 = baseX17({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports13 = {};
  __export(base64_exports13, {
    base64: () => base6415,
    base64pad: () => base64pad15,
    base64url: () => base64url15,
    base64urlpad: () => base64urlpad15
  });
  var base6415 = rfc464816({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad15 = rfc464816({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url15 = rfc464816({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad15 = rfc464816({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports13 = {};
  __export(base8_exports13, {
    base8: () => base813
  });
  var base813 = rfc464816({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports25 = {};
  __export(identity_exports25, {
    identity: () => identity25
  });
  var identity25 = from29({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString20(buf),
    decode: (str) => fromString24(str)
  });

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/codecs/json.js
  var textEncoder13 = new TextEncoder();
  var textDecoder13 = new TextDecoder();

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports26 = {};
  __export(identity_exports26, {
    identity: () => identity26
  });

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_115 = encode60;
  var MSB17 = 128;
  var REST17 = 127;
  var MSBALL15 = ~REST17;
  var INT15 = Math.pow(2, 31);
  function encode60(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT15) {
      out[offset++] = num & 255 | MSB17;
      num /= 128;
    }
    while (num & MSBALL15) {
      out[offset++] = num & 255 | MSB17;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode60.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode75 = read16;
  var MSB$115 = 128;
  var REST$115 = 127;
  function read16(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read16.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$115) << shift : (b & REST$115) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$115);
    read16.bytes = counter - offset;
    return res;
  }
  var N116 = Math.pow(2, 7);
  var N216 = Math.pow(2, 14);
  var N316 = Math.pow(2, 21);
  var N416 = Math.pow(2, 28);
  var N516 = Math.pow(2, 35);
  var N616 = Math.pow(2, 42);
  var N716 = Math.pow(2, 49);
  var N815 = Math.pow(2, 56);
  var N915 = Math.pow(2, 63);
  var length16 = function(value) {
    return value < N116 ? 1 : value < N216 ? 2 : value < N316 ? 3 : value < N416 ? 4 : value < N516 ? 5 : value < N616 ? 6 : value < N716 ? 7 : value < N815 ? 8 : value < N915 ? 9 : 10;
  };
  var varint15 = {
    encode: encode_115,
    decode: decode75,
    encodingLength: length16
  };
  var _brrp_varint15 = varint15;
  var varint_default15 = _brrp_varint15;

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/varint.js
  function decode76(data, offset = 0) {
    const code18 = varint_default15.decode(data, offset);
    return [code18, varint_default15.decode.bytes];
  }
  function encodeTo15(int, target, offset = 0) {
    varint_default15.encode(int, target, offset);
    return target;
  }
  function encodingLength16(int) {
    return varint_default15.encodingLength(int);
  }

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/hashes/digest.js
  function create14(code18, digest18) {
    const size = digest18.byteLength;
    const sizeOffset = encodingLength16(code18);
    const digestOffset = sizeOffset + encodingLength16(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo15(code18, bytes2, 0);
    encodeTo15(size, bytes2, sizeOffset);
    bytes2.set(digest18, digestOffset);
    return new Digest15(code18, size, digest18, bytes2);
  }
  function decode77(multihash) {
    const bytes2 = coerce17(multihash);
    const [code18, sizeOffset] = decode76(bytes2);
    const [size, digestOffset] = decode76(bytes2.subarray(sizeOffset));
    const digest18 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest18.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest15(code18, size, digest18, bytes2);
  }
  function equals39(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals38(a.bytes, data.bytes);
    }
  }
  var Digest15 = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code18, size, digest18, bytes2) {
      this.code = code18;
      this.size = size;
      this.digest = digest18;
      this.bytes = bytes2;
    }
  };

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/hashes/identity.js
  var code13 = 0;
  var name13 = "identity";
  var encode61 = coerce17;
  function digest13(input) {
    return create14(code13, encode61(input));
  }
  var identity26 = { code: code13, name: name13, encode: encode61, digest: digest13 };

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports13 = {};
  __export(sha2_browser_exports13, {
    sha256: () => sha25616,
    sha512: () => sha51215
  });

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/hashes/hasher.js
  function from30({ name: name19, code: code18, encode: encode79 }) {
    return new Hasher13(name19, code18, encode79);
  }
  var Hasher13 = class {
    name;
    code;
    encode;
    constructor(name19, code18, encode79) {
      this.name = name19;
      this.code = code18;
      this.encode = encode79;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create14(this.code, result) : result.then((digest18) => create14(this.code, digest18));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  function sha13(name19) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name19, data));
  }
  var sha25616 = from30({
    name: "sha2-256",
    code: 18,
    encode: sha13("SHA-256")
  });
  var sha51215 = from30({
    name: "sha2-512",
    code: 19,
    encode: sha13("SHA-512")
  });

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/cid.js
  function format14(link, base37) {
    const { bytes: bytes2, version: version5 } = link;
    switch (version5) {
      case 0:
        return toStringV014(bytes2, baseCache14(link), base37 ?? base58btc17.encoder);
      default:
        return toStringV114(bytes2, baseCache14(link), base37 ?? base3215.encoder);
    }
  }
  var cache15 = /* @__PURE__ */ new WeakMap();
  function baseCache14(cid) {
    const baseCache19 = cache15.get(cid);
    if (baseCache19 == null) {
      const baseCache20 = /* @__PURE__ */ new Map();
      cache15.set(cid, baseCache20);
      return baseCache20;
    }
    return baseCache19;
  }
  var CID14 = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version5, code18, multihash, bytes2) {
      this.code = code18;
      this.version = version5;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code18, multihash } = this;
          if (code18 !== DAG_PB_CODE14) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE14) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code18, digest: digest18 } = this.multihash;
          const multihash = create14(code18, digest18);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals39(self2.multihash, unknown.multihash);
    }
    toString(base37) {
      return format14(this, base37);
    }
    toJSON() {
      return { "/": format14(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version5, code: code18, multihash, bytes: bytes2 } = value;
        return new _CID(version5, code18, multihash, bytes2 ?? encodeCID14(version5, code18, multihash.bytes));
      } else if (value[cidSymbol14] === true) {
        const { version: version5, multihash, code: code18 } = value;
        const digest18 = decode77(multihash);
        return _CID.create(version5, code18, digest18);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version5, code18, digest18) {
      if (typeof code18 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest18.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version5) {
        case 0: {
          if (code18 !== DAG_PB_CODE14) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE14}) block encoding`);
          } else {
            return new _CID(version5, code18, digest18, digest18.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID14(version5, code18, digest18.bytes);
          return new _CID(version5, code18, digest18, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest18) {
      return _CID.create(0, DAG_PB_CODE14, digest18);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code18, digest18) {
      return _CID.create(1, code18, digest18);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes2) {
      const [cid, remainder] = _CID.decodeFirst(bytes2);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes2) {
      const specs = _CID.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce17(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest18 = new Digest15(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest18) : _CID.createV1(specs.codec, digest18);
      return [cid, bytes2.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length21] = decode76(initialBytes.subarray(offset));
        offset += length21;
        return i;
      };
      let version5 = next();
      let codec = DAG_PB_CODE14;
      if (version5 === 18) {
        version5 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version5 !== 0 && version5 !== 1) {
        throw new RangeError(`Invalid CID version ${version5}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version5, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base37) {
      const [prefix, bytes2] = parseCIDtoBytes14(source, base37);
      const cid = _CID.decode(bytes2);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache14(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes14(source, base37) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base37 ?? base58btc17;
        return [
          base58btc17.prefix,
          decoder.decode(`${base58btc17.prefix}${source}`)
        ];
      }
      case base58btc17.prefix: {
        const decoder = base37 ?? base58btc17;
        return [base58btc17.prefix, decoder.decode(source)];
      }
      case base3215.prefix: {
        const decoder = base37 ?? base3215;
        return [base3215.prefix, decoder.decode(source)];
      }
      case base3614.prefix: {
        const decoder = base37 ?? base3614;
        return [base3614.prefix, decoder.decode(source)];
      }
      default: {
        if (base37 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base37.decode(source)];
      }
    }
  }
  function toStringV014(bytes2, cache20, base37) {
    const { prefix } = base37;
    if (prefix !== base58btc17.prefix) {
      throw Error(`Cannot string encode V0 in ${base37.name} encoding`);
    }
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2).slice(1);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV114(bytes2, cache20, base37) {
    const { prefix } = base37;
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE14 = 112;
  var SHA_256_CODE14 = 18;
  function encodeCID14(version5, code18, multihash) {
    const codeOffset = encodingLength16(version5);
    const hashOffset = codeOffset + encodingLength16(code18);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo15(version5, bytes2, 0);
    encodeTo15(code18, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  }
  var cidSymbol14 = Symbol.for("@ipld/js-cid/CID");

  // ../node_modules/interface-datastore/node_modules/multiformats/dist/src/basics.js
  var bases13 = { ...identity_exports25, ...base2_exports13, ...base8_exports13, ...base10_exports13, ...base16_exports13, ...base32_exports13, ...base36_exports13, ...base58_exports13, ...base64_exports13, ...base256emoji_exports13 };
  var hashes13 = { ...sha2_browser_exports13, ...identity_exports26 };

  // ../node_modules/interface-datastore/node_modules/uint8arrays/dist/src/alloc.js
  function allocUnsafe17(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/interface-datastore/node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec14(name19, prefix, encode79, decode99) {
    return {
      name: name19,
      prefix,
      encoder: {
        name: name19,
        prefix,
        encode: encode79
      },
      decoder: {
        decode: decode99
      }
    };
  }
  var string14 = createCodec14("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder3 = new TextEncoder();
    return encoder3.encode(str.substring(1));
  });
  var ascii13 = createCodec14("ascii", "a", (buf) => {
    let string19 = "a";
    for (let i = 0; i < buf.length; i++) {
      string19 += String.fromCharCode(buf[i]);
    }
    return string19;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe17(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  var BASES13 = {
    utf8: string14,
    "utf-8": string14,
    hex: bases13.base16,
    latin1: ascii13,
    ascii: ascii13,
    binary: ascii13,
    ...bases13
  };
  var bases_default13 = BASES13;

  // ../node_modules/interface-datastore/node_modules/uint8arrays/dist/src/from-string.js
  function fromString25(string19, encoding = "utf8") {
    const base37 = bases_default13[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.decoder.decode(`${base37.prefix}${string19}`);
  }

  // ../node_modules/interface-datastore/node_modules/uint8arrays/dist/src/to-string.js
  function toString21(array, encoding = "utf8") {
    const base37 = bases_default13[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.encoder.encode(array).substring(1);
  }

  // ../node_modules/interface-datastore/dist/src/key.js
  var pathSepS = "/";
  var pathSepB = new TextEncoder().encode(pathSepS);
  var pathSep = pathSepB[0];
  var Key = class _Key {
    _buf;
    /**
     * @param {string | Uint8Array} s
     * @param {boolean} [clean]
     */
    constructor(s2, clean4) {
      if (typeof s2 === "string") {
        this._buf = fromString25(s2);
      } else if (s2 instanceof Uint8Array) {
        this._buf = s2;
      } else {
        throw new Error("Invalid key, should be String of Uint8Array");
      }
      if (clean4 == null) {
        clean4 = true;
      }
      if (clean4) {
        this.clean();
      }
      if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
        throw new Error("Invalid key");
      }
    }
    /**
     * Convert to the string representation
     *
     * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding] - The encoding to use.
     * @returns {string}
     */
    toString(encoding = "utf8") {
      return toString21(this._buf, encoding);
    }
    /**
     * Return the Uint8Array representation of the key
     *
     * @returns {Uint8Array}
     */
    uint8Array() {
      return this._buf;
    }
    /**
     * Return string representation of the key
     *
     * @returns {string}
     */
    get [Symbol.toStringTag]() {
      return `Key(${this.toString()})`;
    }
    /**
     * Constructs a key out of a namespace array.
     *
     * @param {Array<string>} list - The array of namespaces
     * @returns {Key}
     *
     * @example
     * ```js
     * Key.withNamespaces(['one', 'two'])
     * // => Key('/one/two')
     * ```
     */
    static withNamespaces(list) {
      return new _Key(list.join(pathSepS));
    }
    /**
     * Returns a randomly (uuid) generated key.
     *
     * @returns {Key}
     *
     * @example
     * ```js
     * Key.random()
     * // => Key('/344502982398')
     * ```
     */
    static random() {
      return new _Key(Math.random().toString().substring(2));
    }
    /**
     * @param {*} other
     */
    static asKey(other) {
      if (other instanceof Uint8Array || typeof other === "string") {
        return new _Key(other);
      }
      if (typeof other.uint8Array === "function") {
        return new _Key(other.uint8Array());
      }
      return null;
    }
    /**
     * Cleanup the current key
     *
     * @returns {void}
     */
    clean() {
      if (this._buf == null || this._buf.byteLength === 0) {
        this._buf = pathSepB;
      }
      if (this._buf[0] !== pathSep) {
        const bytes2 = new Uint8Array(this._buf.byteLength + 1);
        bytes2.fill(pathSep, 0, 1);
        bytes2.set(this._buf, 1);
        this._buf = bytes2;
      }
      while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
        this._buf = this._buf.subarray(0, -1);
      }
    }
    /**
     * Check if the given key is sorted lower than ourself.
     *
     * @param {Key} key - The other Key to check against
     * @returns {boolean}
     */
    less(key) {
      const list1 = this.list();
      const list2 = key.list();
      for (let i = 0; i < list1.length; i++) {
        if (list2.length < i + 1) {
          return false;
        }
        const c1 = list1[i];
        const c2 = list2[i];
        if (c1 < c2) {
          return true;
        } else if (c1 > c2) {
          return false;
        }
      }
      return list1.length < list2.length;
    }
    /**
     * Returns the key with all parts in reversed order.
     *
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
     * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
     * ```
     */
    reverse() {
      return _Key.withNamespaces(this.list().slice().reverse());
    }
    /**
     * Returns the `namespaces` making up this Key.
     *
     * @returns {Array<string>}
     */
    namespaces() {
      return this.list();
    }
    /**
     * Returns the "base" namespace of this key.
     *
     * @returns {string}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
     * // => 'Actor:JohnCleese'
     * ```
     */
    baseNamespace() {
      const ns = this.namespaces();
      return ns[ns.length - 1];
    }
    /**
     * Returns the `list` representation of this key.
     *
     * @returns {Array<string>}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
     * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
     * ```
     */
    list() {
      return this.toString().split(pathSepS).slice(1);
    }
    /**
     * Returns the "type" of this key (value of last namespace).
     *
     * @returns {string}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
     * // => 'Actor'
     * ```
     */
    type() {
      return namespaceType(this.baseNamespace());
    }
    /**
     * Returns the "name" of this key (field of last namespace).
     *
     * @returns {string}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
     * // => 'JohnCleese'
     * ```
     */
    name() {
      return namespaceValue(this.baseNamespace());
    }
    /**
     * Returns an "instance" of this type key (appends value to namespace).
     *
     * @param {string} s - The string to append.
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
     * ```
     */
    instance(s2) {
      return new _Key(this.toString() + ":" + s2);
    }
    /**
     * Returns the "path" of this key (parent + type).
     *
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
     * // => Key('/Comedy/MontyPython/Actor')
     * ```
     */
    path() {
      let p = this.parent().toString();
      if (!p.endsWith(pathSepS)) {
        p += pathSepS;
      }
      p += this.type();
      return new _Key(p);
    }
    /**
     * Returns the `parent` Key of this Key.
     *
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
     * // => Key("/Comedy/MontyPython")
     * ```
     */
    parent() {
      const list = this.list();
      if (list.length === 1) {
        return new _Key(pathSepS);
      }
      return new _Key(list.slice(0, -1).join(pathSepS));
    }
    /**
     * Returns the `child` Key of this Key.
     *
     * @param {Key} key - The child Key to add
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
     * ```
     */
    child(key) {
      if (this.toString() === pathSepS) {
        return key;
      } else if (key.toString() === pathSepS) {
        return this;
      }
      return new _Key(this.toString() + key.toString(), false);
    }
    /**
     * Returns whether this key is a prefix of `other`
     *
     * @param {Key} other - The other key to test against
     * @returns {boolean}
     *
     * @example
     * ```js
     * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
     * // => true
     * ```
     */
    isAncestorOf(other) {
      if (other.toString() === this.toString()) {
        return false;
      }
      return other.toString().startsWith(this.toString());
    }
    /**
     * Returns whether this key is a contains another as prefix.
     *
     * @param {Key} other - The other Key to test against
     * @returns {boolean}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
     * // => true
     * ```
     */
    isDecendantOf(other) {
      if (other.toString() === this.toString()) {
        return false;
      }
      return this.toString().startsWith(other.toString());
    }
    /**
     * Checks if this key has only one namespace.
     *
     * @returns {boolean}
     */
    isTopLevel() {
      return this.list().length === 1;
    }
    /**
     * Concats one or more Keys into one new Key.
     *
     * @param {Array<Key>} keys - The array of keys to concatenate
     * @returns {Key}
     */
    concat(...keys) {
      return _Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
    }
  };
  function namespaceType(ns) {
    const parts = ns.split(":");
    if (parts.length < 2) {
      return "";
    }
    return parts.slice(0, -1).join(":");
  }
  function namespaceValue(ns) {
    const parts = ns.split(":");
    return parts[parts.length - 1];
  }
  function flatten(arr) {
    return [].concat(...arr);
  }

  // ../node_modules/@libp2p/peer-store/dist/src/utils/peer-id-to-datastore-key.js
  var NAMESPACE_COMMON = "/peers/";
  function peerIdToDatastoreKey(peerId2) {
    if (!isPeerId(peerId2) || peerId2.type == null) {
      throw new InvalidParametersError("Invalid PeerId");
    }
    const b32key = peerId2.toCID().toString();
    return new Key(`${NAMESPACE_COMMON}${b32key}`);
  }

  // ../node_modules/@libp2p/peer-store/dist/src/utils/dedupe-addresses.js
  async function dedupeFilterAndSortAddresses(peerId2, filter2, addresses, existingAddresses, options) {
    const addressMap = /* @__PURE__ */ new Map();
    for (const addr of addresses) {
      if (addr == null) {
        continue;
      }
      if (addr.multiaddr instanceof Uint8Array) {
        addr.multiaddr = multiaddr(addr.multiaddr);
      }
      if (!isMultiaddr(addr.multiaddr)) {
        throw new InvalidParametersError("Multiaddr was invalid");
      }
      if (!await filter2(peerId2, addr.multiaddr, options)) {
        continue;
      }
      const isCertified = addr.isCertified ?? false;
      const maStr = addr.multiaddr.toString();
      const existingAddr = addressMap.get(maStr);
      if (existingAddr != null) {
        addr.isCertified = existingAddr.isCertified || isCertified;
      } else {
        addressMap.set(maStr, {
          multiaddr: addr.multiaddr,
          isCertified
        });
      }
    }
    return [...addressMap.values()].sort((a, b) => {
      return a.multiaddr.toString().localeCompare(b.multiaddr.toString());
    }).map(({ isCertified, multiaddr: ma }) => {
      const addrPeer = ma.getPeerId();
      if (peerId2.equals(addrPeer)) {
        ma = ma.decapsulate(multiaddr(`/p2p/${peerId2}`));
      }
      return {
        isCertified,
        multiaddr: ma.bytes
      };
    });
  }

  // ../node_modules/@libp2p/peer-store/dist/src/utils/to-peer-pb.js
  async function toPeerPB(peerId2, data, strategy, options) {
    if (data == null) {
      throw new InvalidParametersError("Invalid PeerData");
    }
    if (data.publicKey != null && peerId2.publicKey != null && !data.publicKey.equals(peerId2.publicKey)) {
      throw new InvalidParametersError("publicKey bytes do not match peer id publicKey bytes");
    }
    const existingPeer = options.existingPeer?.peer;
    if (existingPeer != null && !peerId2.equals(existingPeer.id)) {
      throw new InvalidParametersError("peer id did not match existing peer id");
    }
    let addresses = existingPeer?.addresses ?? [];
    let protocols2 = new Set(existingPeer?.protocols ?? []);
    let metadata = existingPeer?.metadata ?? /* @__PURE__ */ new Map();
    let tags = existingPeer?.tags ?? /* @__PURE__ */ new Map();
    let peerRecordEnvelope2 = existingPeer?.peerRecordEnvelope;
    if (strategy === "patch") {
      if (data.multiaddrs != null || data.addresses != null) {
        addresses = [];
        if (data.multiaddrs != null) {
          addresses.push(...data.multiaddrs.map((multiaddr2) => ({
            isCertified: false,
            multiaddr: multiaddr2
          })));
        }
        if (data.addresses != null) {
          addresses.push(...data.addresses);
        }
      }
      if (data.protocols != null) {
        protocols2 = new Set(data.protocols);
      }
      if (data.metadata != null) {
        const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
        metadata = createSortedMap(metadataEntries, {
          validate: validateMetadata
        });
      }
      if (data.tags != null) {
        const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
        tags = createSortedMap(tagsEntries, {
          validate: validateTag,
          map: mapTag
        });
      }
      if (data.peerRecordEnvelope != null) {
        peerRecordEnvelope2 = data.peerRecordEnvelope;
      }
    }
    if (strategy === "merge") {
      if (data.multiaddrs != null) {
        addresses.push(...data.multiaddrs.map((multiaddr2) => ({
          isCertified: false,
          multiaddr: multiaddr2
        })));
      }
      if (data.addresses != null) {
        addresses.push(...data.addresses);
      }
      if (data.protocols != null) {
        protocols2 = /* @__PURE__ */ new Set([...protocols2, ...data.protocols]);
      }
      if (data.metadata != null) {
        const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
        for (const [key, value] of metadataEntries) {
          if (value == null) {
            metadata.delete(key);
          } else {
            metadata.set(key, value);
          }
        }
        metadata = createSortedMap([...metadata.entries()], {
          validate: validateMetadata
        });
      }
      if (data.tags != null) {
        const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
        const mergedTags = new Map(tags);
        for (const [key, value] of tagsEntries) {
          if (value == null) {
            mergedTags.delete(key);
          } else {
            mergedTags.set(key, value);
          }
        }
        tags = createSortedMap([...mergedTags.entries()], {
          validate: validateTag,
          map: mapTag
        });
      }
      if (data.peerRecordEnvelope != null) {
        peerRecordEnvelope2 = data.peerRecordEnvelope;
      }
    }
    let publicKey;
    if (existingPeer?.id.publicKey != null) {
      publicKey = publicKeyToProtobuf(existingPeer.id.publicKey);
    } else if (data.publicKey != null) {
      publicKey = publicKeyToProtobuf(data.publicKey);
    } else if (peerId2.publicKey != null) {
      publicKey = publicKeyToProtobuf(peerId2.publicKey);
    }
    const output2 = {
      addresses: await dedupeFilterAndSortAddresses(peerId2, options.addressFilter ?? (async () => true), addresses, options.existingPeer?.peerPB.addresses, options),
      protocols: [...protocols2.values()].sort((a, b) => {
        return a.localeCompare(b);
      }),
      metadata,
      tags,
      publicKey,
      peerRecordEnvelope: peerRecordEnvelope2
    };
    output2.addresses.forEach((addr) => {
      addr.observed = options.existingPeer?.peerPB.addresses?.find((addr2) => equals37(addr2.multiaddr, addr2.multiaddr))?.observed ?? Date.now();
    });
    if (peerId2.type !== "RSA") {
      delete output2.publicKey;
    }
    return output2;
  }
  function createSortedMap(entries, options) {
    const output2 = /* @__PURE__ */ new Map();
    for (const [key, value] of entries) {
      if (value == null) {
        continue;
      }
      options.validate(key, value);
    }
    for (const [key, value] of entries.sort(([a], [b]) => {
      return a.localeCompare(b);
    })) {
      if (value != null) {
        output2.set(key, options.map?.(key, value) ?? value);
      }
    }
    return output2;
  }
  function validateMetadata(key, value) {
    if (typeof key !== "string") {
      throw new InvalidParametersError("Metadata key must be a string");
    }
    if (!(value instanceof Uint8Array)) {
      throw new InvalidParametersError("Metadata value must be a Uint8Array");
    }
  }
  function validateTag(key, tag) {
    if (typeof key !== "string") {
      throw new InvalidParametersError("Tag name must be a string");
    }
    if (tag.value != null) {
      if (parseInt(`${tag.value}`, 10) !== tag.value) {
        throw new InvalidParametersError("Tag value must be an integer");
      }
      if (tag.value < 0 || tag.value > 100) {
        throw new InvalidParametersError("Tag value must be between 0-100");
      }
    }
    if (tag.ttl != null) {
      if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {
        throw new InvalidParametersError("Tag ttl must be an integer");
      }
      if (tag.ttl < 0) {
        throw new InvalidParametersError("Tag ttl must be between greater than 0");
      }
    }
  }
  function mapTag(key, tag) {
    let expiry;
    if (tag.expiry != null) {
      expiry = tag.expiry;
    }
    if (tag.ttl != null) {
      expiry = BigInt(Date.now() + Number(tag.ttl));
    }
    const output2 = {
      value: tag.value ?? 0
    };
    if (expiry != null) {
      output2.expiry = expiry;
    }
    return output2;
  }

  // ../node_modules/@libp2p/peer-store/dist/src/store.js
  function keyToPeerId(key) {
    const base32Str = key.toString().split("/")[2];
    const buf = CID13.parse(base32Str, base3214);
    return peerIdFromCID(buf);
  }
  function decodePeer(key, value, maxAddressAge) {
    const peerId2 = keyToPeerId(key);
    return bytesToPeer(peerId2, value, maxAddressAge);
  }
  function mapQuery(query, maxAddressAge) {
    return {
      prefix: NAMESPACE_COMMON,
      filters: (query.filters ?? []).map((fn) => ({ key, value }) => {
        return fn(decodePeer(key, value, maxAddressAge));
      }),
      orders: (query.orders ?? []).map((fn) => (a, b) => {
        return fn(decodePeer(a.key, a.value, maxAddressAge), decodePeer(b.key, b.value, maxAddressAge));
      })
    };
  }
  var PersistentStore = class {
    peerId;
    datastore;
    locks;
    addressFilter;
    log;
    maxAddressAge;
    maxPeerAge;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:peer-store");
      this.peerId = components.peerId;
      this.datastore = components.datastore;
      this.addressFilter = init.addressFilter;
      this.locks = trackedPeerMap({
        name: "libp2p_peer_store_locks",
        metrics: components.metrics
      });
      this.maxAddressAge = init.maxAddressAge ?? MAX_ADDRESS_AGE;
      this.maxPeerAge = init.maxPeerAge ?? MAX_PEER_AGE;
    }
    getLock(peerId2) {
      let lock = this.locks.get(peerId2);
      if (lock == null) {
        lock = {
          refs: 0,
          lock: createMortice({
            name: peerId2.toString(),
            singleProcess: true
          })
        };
        this.locks.set(peerId2, lock);
      }
      lock.refs++;
      return lock;
    }
    maybeRemoveLock(peerId2, lock) {
      lock.refs--;
      if (lock.refs === 0) {
        lock.lock.finalize();
        this.locks.delete(peerId2);
      }
    }
    async getReadLock(peerId2, options) {
      const lock = this.getLock(peerId2);
      try {
        const release = await lock.lock.readLock(options);
        return () => {
          release();
          this.maybeRemoveLock(peerId2, lock);
        };
      } catch (err) {
        this.maybeRemoveLock(peerId2, lock);
        throw err;
      }
    }
    async getWriteLock(peerId2, options) {
      const lock = this.getLock(peerId2);
      try {
        const release = await lock.lock.writeLock(options);
        return () => {
          release();
          this.maybeRemoveLock(peerId2, lock);
        };
      } catch (err) {
        this.maybeRemoveLock(peerId2, lock);
        throw err;
      }
    }
    async has(peerId2, options) {
      try {
        await this.load(peerId2, options);
        return true;
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
      return false;
    }
    async delete(peerId2, options) {
      if (this.peerId.equals(peerId2)) {
        return;
      }
      await this.datastore.delete(peerIdToDatastoreKey(peerId2), options);
    }
    async load(peerId2, options) {
      const key = peerIdToDatastoreKey(peerId2);
      const buf = await this.datastore.get(key, options);
      const peer = Peer.decode(buf);
      if (this.#peerIsExpired(peerId2, peer)) {
        await this.datastore.delete(key, options);
        throw new NotFoundError();
      }
      return pbToPeer(peerId2, peer, this.peerId.equals(peerId2) ? Infinity : this.maxAddressAge);
    }
    async save(peerId2, data, options) {
      const existingPeer = await this.#findExistingPeer(peerId2, options);
      const peerPb = await toPeerPB(peerId2, data, "patch", {
        ...options,
        addressFilter: this.addressFilter
      });
      return this.#saveIfDifferent(peerId2, peerPb, existingPeer);
    }
    async patch(peerId2, data, options) {
      const existingPeer = await this.#findExistingPeer(peerId2, options);
      const peerPb = await toPeerPB(peerId2, data, "patch", {
        ...options,
        addressFilter: this.addressFilter,
        existingPeer
      });
      return this.#saveIfDifferent(peerId2, peerPb, existingPeer);
    }
    async merge(peerId2, data, options) {
      const existingPeer = await this.#findExistingPeer(peerId2, options);
      const peerPb = await toPeerPB(peerId2, data, "merge", {
        addressFilter: this.addressFilter,
        existingPeer
      });
      return this.#saveIfDifferent(peerId2, peerPb, existingPeer);
    }
    async *all(options) {
      for await (const { key, value } of this.datastore.query(mapQuery(options ?? {}, this.maxAddressAge), options)) {
        const peerId2 = keyToPeerId(key);
        if (peerId2.equals(this.peerId)) {
          continue;
        }
        const peer = Peer.decode(value);
        if (this.#peerIsExpired(peerId2, peer)) {
          await this.datastore.delete(key, options);
          continue;
        }
        yield pbToPeer(peerId2, peer, this.peerId.equals(peerId2) ? Infinity : this.maxAddressAge);
      }
    }
    async #findExistingPeer(peerId2, options) {
      try {
        const key = peerIdToDatastoreKey(peerId2);
        const buf = await this.datastore.get(key, options);
        const peerPB = Peer.decode(buf);
        if (this.#peerIsExpired(peerId2, peerPB)) {
          await this.datastore.delete(key, options);
          throw new NotFoundError();
        }
        return {
          peerPB,
          peer: pbToPeer(peerId2, peerPB, this.maxAddressAge)
        };
      } catch (err) {
        if (err.name !== "NotFoundError") {
          this.log.error("invalid peer data found in peer store - %e", err);
        }
      }
    }
    async #saveIfDifferent(peerId2, peer, existingPeer, options) {
      peer.updated = Date.now();
      const buf = Peer.encode(peer);
      await this.datastore.put(peerIdToDatastoreKey(peerId2), buf, options);
      return {
        peer: pbToPeer(peerId2, peer, this.maxAddressAge),
        previous: existingPeer?.peer,
        updated: existingPeer == null || !peerEquals(peer, existingPeer.peerPB)
      };
    }
    #peerIsExpired(peerId2, peer) {
      if (peer.updated == null) {
        return true;
      }
      if (this.peerId.equals(peerId2)) {
        return false;
      }
      const expired = peer.updated < Date.now() - this.maxPeerAge;
      const minAddressObserved = Date.now() - this.maxAddressAge;
      const addrs = peer.addresses.filter((addr) => {
        return addr.observed != null && addr.observed > minAddressObserved;
      });
      return expired && addrs.length === 0;
    }
  };

  // ../node_modules/@libp2p/peer-store/dist/src/index.js
  var PersistentPeerStore = class {
    store;
    events;
    peerId;
    log;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:peer-store");
      this.events = components.events;
      this.peerId = components.peerId;
      this.store = new PersistentStore(components, init);
    }
    [Symbol.toStringTag] = "@libp2p/peer-store";
    async forEach(fn, query) {
      for await (const peer of this.store.all(query)) {
        fn(peer);
      }
    }
    async all(query) {
      return src_default(this.store.all(query));
    }
    async delete(peerId2, options) {
      const release = await this.store.getReadLock(peerId2, options);
      try {
        await this.store.delete(peerId2, options);
      } finally {
        release();
      }
    }
    async has(peerId2, options) {
      const release = await this.store.getReadLock(peerId2, options);
      try {
        return await this.store.has(peerId2, options);
      } finally {
        this.log.trace("has release read lock");
        release?.();
      }
    }
    async get(peerId2, options) {
      const release = await this.store.getReadLock(peerId2, options);
      try {
        return await this.store.load(peerId2, options);
      } finally {
        release?.();
      }
    }
    async getInfo(peerId2, options) {
      const peer = await this.get(peerId2, options);
      return {
        id: peer.id,
        multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      };
    }
    async save(id, data, options) {
      const release = await this.store.getWriteLock(id, options);
      try {
        const result = await this.store.save(id, data, options);
        this.#emitIfUpdated(id, result);
        return result.peer;
      } finally {
        release?.();
      }
    }
    async patch(id, data, options) {
      const release = await this.store.getWriteLock(id, options);
      try {
        const result = await this.store.patch(id, data, options);
        this.#emitIfUpdated(id, result);
        return result.peer;
      } finally {
        release?.();
      }
    }
    async merge(id, data, options) {
      const release = await this.store.getWriteLock(id, options);
      try {
        const result = await this.store.merge(id, data, options);
        this.#emitIfUpdated(id, result);
        return result.peer;
      } finally {
        release?.();
      }
    }
    async consumePeerRecord(buf, arg1, arg2) {
      const expectedPeer = isPeerId(arg1) ? arg1 : isPeerId(arg1?.expectedPeer) ? arg1.expectedPeer : void 0;
      const options = isPeerId(arg1) ? arg2 : arg1 === void 0 ? arg2 : arg1;
      const envelope = await RecordEnvelope.openAndCertify(buf, PeerRecord2.DOMAIN, options);
      const peerId2 = peerIdFromCID(envelope.publicKey.toCID());
      if (expectedPeer?.equals(peerId2) === false) {
        this.log("envelope peer id was not the expected peer id - expected: %p received: %p", expectedPeer, peerId2);
        return false;
      }
      const peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
      let peer;
      try {
        peer = await this.get(peerId2, options);
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
      if (peer?.peerRecordEnvelope != null) {
        const storedEnvelope = RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);
        const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
        if (storedRecord.seqNumber >= peerRecord.seqNumber) {
          this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
          return false;
        }
      }
      await this.patch(peerRecord.peerId, {
        peerRecordEnvelope: buf,
        addresses: peerRecord.multiaddrs.map((multiaddr2) => ({
          isCertified: true,
          multiaddr: multiaddr2
        }))
      }, options);
      return true;
    }
    #emitIfUpdated(id, result) {
      if (!result.updated) {
        return;
      }
      if (this.peerId.equals(id)) {
        this.events.safeDispatchEvent("self:peer:update", { detail: result });
      } else {
        this.events.safeDispatchEvent("peer:update", { detail: result });
      }
    }
  };
  function persistentPeerStore(components, init = {}) {
    return new PersistentPeerStore(components, init);
  }

  // ../node_modules/interface-store/dist/src/errors.js
  var NotFoundError2 = class _NotFoundError extends Error {
    static name = "NotFoundError";
    static code = "ERR_NOT_FOUND";
    name = _NotFoundError.name;
    code = _NotFoundError.code;
    constructor(message2 = "Not Found") {
      super(message2);
    }
  };

  // ../node_modules/it-peekable/dist/src/index.js
  function peekable(iterable) {
    const [iterator, symbol3] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
    const queue = [];
    return {
      peek: () => {
        return iterator.next();
      },
      push: (value) => {
        queue.push(value);
      },
      next: () => {
        if (queue.length > 0) {
          return {
            done: false,
            value: queue.shift()
          };
        }
        return iterator.next();
      },
      [symbol3]() {
        return this;
      }
    };
  }
  var src_default5 = peekable;

  // ../node_modules/it-filter/dist/src/index.js
  function isAsyncIterable7(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function filter(source, fn) {
    let index = 0;
    if (isAsyncIterable7(source)) {
      return (async function* () {
        for await (const entry of source) {
          if (await fn(entry, index++)) {
            yield entry;
          }
        }
      })();
    }
    const peekable2 = src_default5(source);
    const { value, done } = peekable2.next();
    if (done === true) {
      return (function* () {
      })();
    }
    const res = fn(value, index++);
    if (typeof res.then === "function") {
      return (async function* () {
        if (await res) {
          yield value;
        }
        for (const entry of peekable2) {
          if (await fn(entry, index++)) {
            yield entry;
          }
        }
      })();
    }
    const func2 = fn;
    return (function* () {
      if (res === true) {
        yield value;
      }
      for (const entry of peekable2) {
        if (func2(entry, index++)) {
          yield entry;
        }
      }
    })();
  }
  var src_default6 = filter;

  // ../node_modules/it-sort/dist/src/index.js
  function isAsyncIterable8(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function sort(source, sorter) {
    if (isAsyncIterable8(source)) {
      return (async function* () {
        const arr = await src_default(source);
        yield* arr.sort(sorter);
      })();
    }
    return (function* () {
      const arr = src_default(source);
      yield* arr.sort(sorter);
    })();
  }
  var src_default7 = sort;

  // ../node_modules/it-take/dist/src/index.js
  function isAsyncIterable9(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function take(source, limit) {
    if (isAsyncIterable9(source)) {
      return (async function* () {
        let items = 0;
        if (limit < 1) {
          return;
        }
        for await (const entry of source) {
          yield entry;
          items++;
          if (items === limit) {
            return;
          }
        }
      })();
    }
    return (function* () {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    })();
  }
  var src_default8 = take;

  // ../node_modules/datastore-core/dist/src/base.js
  var BaseDatastore = class {
    put(key, val, options) {
      return Promise.reject(new Error(".put is not implemented"));
    }
    get(key, options) {
      return Promise.reject(new Error(".get is not implemented"));
    }
    has(key, options) {
      return Promise.reject(new Error(".has is not implemented"));
    }
    delete(key, options) {
      return Promise.reject(new Error(".delete is not implemented"));
    }
    async *putMany(source, options = {}) {
      for await (const { key, value } of source) {
        await this.put(key, value, options);
        yield key;
      }
    }
    async *getMany(source, options = {}) {
      for await (const key of source) {
        yield {
          key,
          value: await this.get(key, options)
        };
      }
    }
    async *deleteMany(source, options = {}) {
      for await (const key of source) {
        await this.delete(key, options);
        yield key;
      }
    }
    batch() {
      let puts = [];
      let dels = [];
      return {
        put(key, value) {
          puts.push({ key, value });
        },
        delete(key) {
          dels.push(key);
        },
        commit: async (options) => {
          await src_default3(this.putMany(puts, options));
          puts = [];
          await src_default3(this.deleteMany(dels, options));
          dels = [];
        }
      };
    }
    /**
     * Extending classes should override `query` or implement this method
     */
    // eslint-disable-next-line require-yield
    async *_all(q, options) {
      throw new Error("._all is not implemented");
    }
    /**
     * Extending classes should override `queryKeys` or implement this method
     */
    // eslint-disable-next-line require-yield
    async *_allKeys(q, options) {
      throw new Error("._allKeys is not implemented");
    }
    query(q, options) {
      let it = this._all(q, options);
      if (q.prefix != null) {
        const prefix = q.prefix;
        it = src_default6(it, (e) => e.key.toString().startsWith(prefix));
      }
      if (Array.isArray(q.filters)) {
        it = q.filters.reduce((it2, f) => src_default6(it2, f), it);
      }
      if (Array.isArray(q.orders)) {
        it = q.orders.reduce((it2, f) => src_default7(it2, f), it);
      }
      if (q.offset != null) {
        let i = 0;
        const offset = q.offset;
        it = src_default6(it, () => i++ >= offset);
      }
      if (q.limit != null) {
        it = src_default8(it, q.limit);
      }
      return it;
    }
    queryKeys(q, options) {
      let it = this._allKeys(q, options);
      if (q.prefix != null) {
        const prefix = q.prefix;
        it = src_default6(it, (key) => key.toString().startsWith(prefix));
      }
      if (Array.isArray(q.filters)) {
        it = q.filters.reduce((it2, f) => src_default6(it2, f), it);
      }
      if (Array.isArray(q.orders)) {
        it = q.orders.reduce((it2, f) => src_default7(it2, f), it);
      }
      if (q.offset != null) {
        const offset = q.offset;
        let i = 0;
        it = src_default6(it, () => i++ >= offset);
      }
      if (q.limit != null) {
        it = src_default8(it, q.limit);
      }
      return it;
    }
  };

  // ../node_modules/datastore-core/dist/src/memory.js
  var MemoryDatastore = class extends BaseDatastore {
    data;
    constructor() {
      super();
      this.data = /* @__PURE__ */ new Map();
    }
    put(key, val, options) {
      options?.signal?.throwIfAborted();
      this.data.set(key.toString(), val);
      return key;
    }
    get(key, options) {
      options?.signal?.throwIfAborted();
      const result = this.data.get(key.toString());
      if (result == null) {
        throw new NotFoundError2();
      }
      return result;
    }
    has(key, options) {
      options?.signal?.throwIfAborted();
      return this.data.has(key.toString());
    }
    delete(key, options) {
      options?.signal?.throwIfAborted();
      this.data.delete(key.toString());
    }
    *_all(q, options) {
      options?.signal?.throwIfAborted();
      for (const [key, value] of this.data.entries()) {
        yield { key: new Key(key), value };
        options?.signal?.throwIfAborted();
      }
    }
    *_allKeys(q, options) {
      options?.signal?.throwIfAborted();
      for (const key of this.data.keys()) {
        yield new Key(key);
        options?.signal?.throwIfAborted();
      }
    }
  };

  // ../node_modules/libp2p/node_modules/uint8arrays/dist/src/alloc.js
  function allocUnsafe18(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/libp2p/node_modules/uint8arrays/dist/src/util/as-uint8array.js
  function asUint8Array7(buf) {
    return buf;
  }

  // ../node_modules/libp2p/node_modules/uint8arrays/dist/src/concat.js
  function concat7(arrays, length21) {
    if (length21 == null) {
      length21 = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output2 = allocUnsafe18(length21);
    let offset = 0;
    for (const arr of arrays) {
      output2.set(arr, offset);
      offset += arr.length;
    }
    return asUint8Array7(output2);
  }

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports14 = {};
  __export(base10_exports14, {
    base10: () => base1014
  });

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/bytes.js
  var empty18 = new Uint8Array(0);
  function equals40(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce18(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function fromString26(str) {
    return new TextEncoder().encode(str);
  }
  function toString22(b) {
    return new TextDecoder().decode(b);
  }

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/vendor/base-x.js
  function base31(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src18 = base31;
  var _brrp__multiformats_scope_baseX18 = src18;
  var base_x_default18 = _brrp__multiformats_scope_baseX18;

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/bases/base.js
  var Encoder20 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder20 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or20(this, decoder);
    }
  };
  var ComposedDecoder18 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or20(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or20(left, right) {
    return new ComposedDecoder18({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec18 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder20(name19, prefix, baseEncode);
      this.decoder = new Decoder20(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from31({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec18(name19, prefix, encode79, decode99);
  }
  function baseX18({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default18(alphabet18, name19);
    return from31({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce18(decode99(text))
    });
  }
  function decode78(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode62(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx17(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc464817({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx17(alphabet18);
    return from31({
      prefix,
      name: name19,
      encode(input) {
        return encode62(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode78(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/bases/base10.js
  var base1014 = baseX18({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports14 = {};
  __export(base16_exports14, {
    base16: () => base1614,
    base16upper: () => base16upper14
  });
  var base1614 = rfc464817({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper14 = rfc464817({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports14 = {};
  __export(base2_exports14, {
    base2: () => base214
  });
  var base214 = rfc464817({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports14 = {};
  __export(base256emoji_exports14, {
    base256emoji: () => base256emoji14
  });
  var alphabet14 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars14 = alphabet14.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes14 = alphabet14.reduce((p, c, i) => {
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
  }, []);
  function encode63(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars14[c];
      return p;
    }, "");
  }
  function decode79(str) {
    const byts = [];
    for (const char of str) {
      const codePoint = char.codePointAt(0);
      if (codePoint == null) {
        throw new Error(`Invalid character: ${char}`);
      }
      const byt = alphabetCharsToBytes14[codePoint];
      if (byt == null) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji14 = from31({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode63,
    decode: decode79
  });

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports14 = {};
  __export(base32_exports14, {
    base32: () => base3216,
    base32hex: () => base32hex16,
    base32hexpad: () => base32hexpad16,
    base32hexpadupper: () => base32hexpadupper16,
    base32hexupper: () => base32hexupper16,
    base32pad: () => base32pad16,
    base32padupper: () => base32padupper16,
    base32upper: () => base32upper16,
    base32z: () => base32z16
  });
  var base3216 = rfc464817({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper16 = rfc464817({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad16 = rfc464817({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper16 = rfc464817({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex16 = rfc464817({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper16 = rfc464817({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad16 = rfc464817({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper16 = rfc464817({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z16 = rfc464817({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports14 = {};
  __export(base36_exports14, {
    base36: () => base3615,
    base36upper: () => base36upper15
  });
  var base3615 = baseX18({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper15 = baseX18({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports14 = {};
  __export(base58_exports14, {
    base58btc: () => base58btc18,
    base58flickr: () => base58flickr18
  });
  var base58btc18 = baseX18({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr18 = baseX18({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports14 = {};
  __export(base64_exports14, {
    base64: () => base6416,
    base64pad: () => base64pad16,
    base64url: () => base64url16,
    base64urlpad: () => base64urlpad16
  });
  var base6416 = rfc464817({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad16 = rfc464817({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url16 = rfc464817({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad16 = rfc464817({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports14 = {};
  __export(base8_exports14, {
    base8: () => base814
  });
  var base814 = rfc464817({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports27 = {};
  __export(identity_exports27, {
    identity: () => identity27
  });
  var identity27 = from31({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString22(buf),
    decode: (str) => fromString26(str)
  });

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/codecs/json.js
  var textEncoder14 = new TextEncoder();
  var textDecoder14 = new TextDecoder();

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports28 = {};
  __export(identity_exports28, {
    identity: () => identity28
  });

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_116 = encode64;
  var MSB18 = 128;
  var REST18 = 127;
  var MSBALL16 = ~REST18;
  var INT16 = Math.pow(2, 31);
  function encode64(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT16) {
      out[offset++] = num & 255 | MSB18;
      num /= 128;
    }
    while (num & MSBALL16) {
      out[offset++] = num & 255 | MSB18;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode64.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode80 = read17;
  var MSB$116 = 128;
  var REST$116 = 127;
  function read17(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read17.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$116) << shift : (b & REST$116) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$116);
    read17.bytes = counter - offset;
    return res;
  }
  var N117 = Math.pow(2, 7);
  var N217 = Math.pow(2, 14);
  var N317 = Math.pow(2, 21);
  var N417 = Math.pow(2, 28);
  var N517 = Math.pow(2, 35);
  var N617 = Math.pow(2, 42);
  var N717 = Math.pow(2, 49);
  var N816 = Math.pow(2, 56);
  var N916 = Math.pow(2, 63);
  var length17 = function(value) {
    return value < N117 ? 1 : value < N217 ? 2 : value < N317 ? 3 : value < N417 ? 4 : value < N517 ? 5 : value < N617 ? 6 : value < N717 ? 7 : value < N816 ? 8 : value < N916 ? 9 : 10;
  };
  var varint16 = {
    encode: encode_116,
    decode: decode80,
    encodingLength: length17
  };
  var _brrp_varint16 = varint16;
  var varint_default16 = _brrp_varint16;

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/varint.js
  function decode81(data, offset = 0) {
    const code18 = varint_default16.decode(data, offset);
    return [code18, varint_default16.decode.bytes];
  }
  function encodeTo16(int, target, offset = 0) {
    varint_default16.encode(int, target, offset);
    return target;
  }
  function encodingLength17(int) {
    return varint_default16.encodingLength(int);
  }

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/hashes/digest.js
  function create15(code18, digest18) {
    const size = digest18.byteLength;
    const sizeOffset = encodingLength17(code18);
    const digestOffset = sizeOffset + encodingLength17(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo16(code18, bytes2, 0);
    encodeTo16(size, bytes2, sizeOffset);
    bytes2.set(digest18, digestOffset);
    return new Digest16(code18, size, digest18, bytes2);
  }
  function decode82(multihash) {
    const bytes2 = coerce18(multihash);
    const [code18, sizeOffset] = decode81(bytes2);
    const [size, digestOffset] = decode81(bytes2.subarray(sizeOffset));
    const digest18 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest18.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest16(code18, size, digest18, bytes2);
  }
  function equals41(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals40(a.bytes, data.bytes);
    }
  }
  var Digest16 = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code18, size, digest18, bytes2) {
      this.code = code18;
      this.size = size;
      this.digest = digest18;
      this.bytes = bytes2;
    }
  };

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/hashes/identity.js
  var code14 = 0;
  var name14 = "identity";
  var encode65 = coerce18;
  function digest14(input) {
    return create15(code14, encode65(input));
  }
  var identity28 = { code: code14, name: name14, encode: encode65, digest: digest14 };

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports14 = {};
  __export(sha2_browser_exports14, {
    sha256: () => sha25617,
    sha512: () => sha51216
  });

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/hashes/hasher.js
  function from32({ name: name19, code: code18, encode: encode79 }) {
    return new Hasher14(name19, code18, encode79);
  }
  var Hasher14 = class {
    name;
    code;
    encode;
    constructor(name19, code18, encode79) {
      this.name = name19;
      this.code = code18;
      this.encode = encode79;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create15(this.code, result) : result.then((digest18) => create15(this.code, digest18));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  function sha14(name19) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name19, data));
  }
  var sha25617 = from32({
    name: "sha2-256",
    code: 18,
    encode: sha14("SHA-256")
  });
  var sha51216 = from32({
    name: "sha2-512",
    code: 19,
    encode: sha14("SHA-512")
  });

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/cid.js
  function format15(link, base37) {
    const { bytes: bytes2, version: version5 } = link;
    switch (version5) {
      case 0:
        return toStringV015(bytes2, baseCache15(link), base37 ?? base58btc18.encoder);
      default:
        return toStringV115(bytes2, baseCache15(link), base37 ?? base3216.encoder);
    }
  }
  var cache16 = /* @__PURE__ */ new WeakMap();
  function baseCache15(cid) {
    const baseCache19 = cache16.get(cid);
    if (baseCache19 == null) {
      const baseCache20 = /* @__PURE__ */ new Map();
      cache16.set(cid, baseCache20);
      return baseCache20;
    }
    return baseCache19;
  }
  var CID15 = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version5, code18, multihash, bytes2) {
      this.code = code18;
      this.version = version5;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code18, multihash } = this;
          if (code18 !== DAG_PB_CODE15) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE15) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code18, digest: digest18 } = this.multihash;
          const multihash = create15(code18, digest18);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals41(self2.multihash, unknown.multihash);
    }
    toString(base37) {
      return format15(this, base37);
    }
    toJSON() {
      return { "/": format15(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version5, code: code18, multihash, bytes: bytes2 } = value;
        return new _CID(version5, code18, multihash, bytes2 ?? encodeCID15(version5, code18, multihash.bytes));
      } else if (value[cidSymbol15] === true) {
        const { version: version5, multihash, code: code18 } = value;
        const digest18 = decode82(multihash);
        return _CID.create(version5, code18, digest18);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version5, code18, digest18) {
      if (typeof code18 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest18.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version5) {
        case 0: {
          if (code18 !== DAG_PB_CODE15) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE15}) block encoding`);
          } else {
            return new _CID(version5, code18, digest18, digest18.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID15(version5, code18, digest18.bytes);
          return new _CID(version5, code18, digest18, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest18) {
      return _CID.create(0, DAG_PB_CODE15, digest18);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code18, digest18) {
      return _CID.create(1, code18, digest18);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes2) {
      const [cid, remainder] = _CID.decodeFirst(bytes2);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes2) {
      const specs = _CID.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce18(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest18 = new Digest16(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest18) : _CID.createV1(specs.codec, digest18);
      return [cid, bytes2.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length21] = decode81(initialBytes.subarray(offset));
        offset += length21;
        return i;
      };
      let version5 = next();
      let codec = DAG_PB_CODE15;
      if (version5 === 18) {
        version5 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version5 !== 0 && version5 !== 1) {
        throw new RangeError(`Invalid CID version ${version5}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version5, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base37) {
      const [prefix, bytes2] = parseCIDtoBytes15(source, base37);
      const cid = _CID.decode(bytes2);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache15(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes15(source, base37) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base37 ?? base58btc18;
        return [
          base58btc18.prefix,
          decoder.decode(`${base58btc18.prefix}${source}`)
        ];
      }
      case base58btc18.prefix: {
        const decoder = base37 ?? base58btc18;
        return [base58btc18.prefix, decoder.decode(source)];
      }
      case base3216.prefix: {
        const decoder = base37 ?? base3216;
        return [base3216.prefix, decoder.decode(source)];
      }
      case base3615.prefix: {
        const decoder = base37 ?? base3615;
        return [base3615.prefix, decoder.decode(source)];
      }
      default: {
        if (base37 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base37.decode(source)];
      }
    }
  }
  function toStringV015(bytes2, cache20, base37) {
    const { prefix } = base37;
    if (prefix !== base58btc18.prefix) {
      throw Error(`Cannot string encode V0 in ${base37.name} encoding`);
    }
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2).slice(1);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV115(bytes2, cache20, base37) {
    const { prefix } = base37;
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE15 = 112;
  var SHA_256_CODE15 = 18;
  function encodeCID15(version5, code18, multihash) {
    const codeOffset = encodingLength17(version5);
    const hashOffset = codeOffset + encodingLength17(code18);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo16(version5, bytes2, 0);
    encodeTo16(code18, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  }
  var cidSymbol15 = Symbol.for("@ipld/js-cid/CID");

  // ../node_modules/libp2p/node_modules/multiformats/dist/src/basics.js
  var bases14 = { ...identity_exports27, ...base2_exports14, ...base8_exports14, ...base10_exports14, ...base16_exports14, ...base32_exports14, ...base36_exports14, ...base58_exports14, ...base64_exports14, ...base256emoji_exports14 };
  var hashes14 = { ...sha2_browser_exports14, ...identity_exports28 };

  // ../node_modules/libp2p/node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec15(name19, prefix, encode79, decode99) {
    return {
      name: name19,
      prefix,
      encoder: {
        name: name19,
        prefix,
        encode: encode79
      },
      decoder: {
        decode: decode99
      }
    };
  }
  var string15 = createCodec15("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder3 = new TextEncoder();
    return encoder3.encode(str.substring(1));
  });
  var ascii14 = createCodec15("ascii", "a", (buf) => {
    let string19 = "a";
    for (let i = 0; i < buf.length; i++) {
      string19 += String.fromCharCode(buf[i]);
    }
    return string19;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe18(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  var BASES14 = {
    utf8: string15,
    "utf-8": string15,
    hex: bases14.base16,
    latin1: ascii14,
    ascii: ascii14,
    binary: ascii14,
    ...bases14
  };
  var bases_default14 = BASES14;

  // ../node_modules/libp2p/node_modules/uint8arrays/dist/src/from-string.js
  function fromString27(string19, encoding = "utf8") {
    const base37 = bases_default14[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.decoder.decode(`${base37.prefix}${string19}`);
  }

  // ../node_modules/@libp2p/utils/dist/src/tracked-map.js
  var TrackedMap = class extends Map {
    metric;
    constructor(init) {
      super();
      const { name: name19, metrics } = init;
      this.metric = metrics.registerMetric(name19);
      this.updateComponentMetric();
    }
    set(key, value) {
      super.set(key, value);
      this.updateComponentMetric();
      return this;
    }
    delete(key) {
      const deleted = super.delete(key);
      this.updateComponentMetric();
      return deleted;
    }
    clear() {
      super.clear();
      this.updateComponentMetric();
    }
    updateComponentMetric() {
      this.metric.update(this.size);
    }
  };
  function trackedMap(config) {
    const { name: name19, metrics } = config;
    let map2;
    if (metrics != null) {
      map2 = new TrackedMap({ name: name19, metrics });
    } else {
      map2 = /* @__PURE__ */ new Map();
    }
    return map2;
  }

  // ../node_modules/libp2p/dist/src/address-manager/dns-mappings.js
  var MAX_DATE = 864e13;
  var CODEC_TLS = 448;
  var CODEC_SNI = 449;
  var CODEC_DNS = 53;
  var CODEC_DNS4 = 54;
  var CODEC_DNS6 = 55;
  var CODEC_DNSADDR = 56;
  var DNSMappings = class {
    log;
    mappings;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:address-manager:dns-mappings");
      this.mappings = trackedMap({
        name: "libp2p_address_manager_dns_mappings",
        metrics: components.metrics
      });
    }
    has(ma) {
      const host = this.findHost(ma);
      for (const mapping of this.mappings.values()) {
        if (mapping.domain === host) {
          return true;
        }
      }
      return false;
    }
    add(domain, addresses) {
      addresses.forEach((ip) => {
        this.log("add DNS mapping %s to %s", ip, domain);
        const verified = isPrivateIp(ip) === true;
        this.mappings.set(ip, {
          domain,
          verified,
          expires: verified ? MAX_DATE - Date.now() : 0,
          lastVerified: verified ? MAX_DATE - Date.now() : void 0
        });
      });
    }
    remove(ma) {
      const host = this.findHost(ma);
      let wasConfident = false;
      for (const [ip, mapping] of this.mappings.entries()) {
        if (mapping.domain === host) {
          this.log("removing %s to %s DNS mapping %e", ip, mapping.domain, new Error("where"));
          this.mappings.delete(ip);
          wasConfident = wasConfident || mapping.verified;
        }
      }
      return wasConfident;
    }
    getAll(addresses) {
      const dnsMappedAddresses = [];
      for (let i = 0; i < addresses.length; i++) {
        const address = addresses[i];
        const tuples = address.multiaddr.stringTuples();
        const host = tuples[0][1];
        if (host == null) {
          continue;
        }
        for (const [ip, mapping] of this.mappings.entries()) {
          if (host !== ip) {
            continue;
          }
          const mappedIp = this.maybeAddSNITuple(tuples, mapping.domain);
          if (mappedIp) {
            addresses.splice(i, 1);
            i--;
            dnsMappedAddresses.push({
              multiaddr: multiaddr(`/${tuples.map((tuple) => {
                return [
                  protocols(tuple[0]).name,
                  tuple[1]
                ].join("/");
              }).join("/")}`),
              verified: mapping.verified,
              type: "dns-mapping",
              expires: mapping.expires,
              lastVerified: mapping.lastVerified
            });
          }
        }
      }
      return dnsMappedAddresses;
    }
    maybeAddSNITuple(tuples, domain) {
      for (let j = 0; j < tuples.length; j++) {
        if (tuples[j][0] === CODEC_TLS && tuples[j + 1]?.[0] !== CODEC_SNI) {
          tuples.splice(j + 1, 0, [CODEC_SNI, domain]);
          return true;
        }
      }
      return false;
    }
    confirm(ma, ttl) {
      const host = this.findHost(ma);
      let startingConfidence = false;
      for (const [ip, mapping] of this.mappings.entries()) {
        if (mapping.domain === host) {
          this.log("marking %s to %s DNS mapping as verified", ip, mapping.domain);
          startingConfidence = mapping.verified;
          mapping.verified = true;
          mapping.expires = Date.now() + ttl;
          mapping.lastVerified = Date.now();
        }
      }
      return startingConfidence;
    }
    unconfirm(ma, ttl) {
      const host = this.findHost(ma);
      let wasConfident = false;
      for (const [ip, mapping] of this.mappings.entries()) {
        if (mapping.domain === host) {
          this.log("removing verification of %s to %s DNS mapping", ip, mapping.domain);
          wasConfident = wasConfident || mapping.verified;
          mapping.verified = false;
          mapping.expires = Date.now() + ttl;
        }
      }
      return wasConfident;
    }
    findHost(ma) {
      for (const tuple of ma.stringTuples()) {
        if (tuple[0] === CODEC_SNI) {
          return tuple[1];
        }
        if (tuple[0] === CODEC_DNS || tuple[0] === CODEC_DNS4 || tuple[0] === CODEC_DNS6 || tuple[0] === CODEC_DNSADDR) {
          return tuple[1];
        }
      }
    }
  };

  // ../node_modules/libp2p/dist/src/address-manager/ip-mappings.js
  var CODEC_IP4 = 4;
  var CODEC_IP6 = 41;
  var CODEC_TCP = 6;
  var CODEC_UDP = 273;
  var IPMappings = class {
    log;
    mappings;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:address-manager:ip-mappings");
      this.mappings = trackedMap({
        name: "libp2p_address_manager_ip_mappings",
        metrics: components.metrics
      });
    }
    has(ma) {
      const tuples = ma.stringTuples();
      for (const mappings of this.mappings.values()) {
        for (const mapping of mappings) {
          if (mapping.externalIp === tuples[0][1]) {
            return true;
          }
        }
      }
      return false;
    }
    add(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
      const key = `${internalIp}-${internalPort}-${protocol}`;
      const mappings = this.mappings.get(key) ?? [];
      const mapping = {
        internalIp,
        internalPort,
        externalIp,
        externalPort,
        externalFamily: isIPv4(externalIp) ? 4 : 6,
        protocol,
        verified: false,
        expires: 0
      };
      mappings.push(mapping);
      this.mappings.set(key, mappings);
    }
    remove(ma) {
      const tuples = ma.stringTuples();
      const host = tuples[0][1] ?? "";
      const protocol = tuples[1][0] === CODEC_TCP ? "tcp" : "udp";
      const port = parseInt(tuples[1][1] ?? "0");
      let wasConfident = false;
      for (const [key, mappings] of this.mappings.entries()) {
        for (let i = 0; i < mappings.length; i++) {
          const mapping = mappings[i];
          if (mapping.externalIp === host && mapping.externalPort === port && mapping.protocol === protocol) {
            this.log("removing %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, host, port, protocol);
            wasConfident = wasConfident || mapping.verified;
            mappings.splice(i, 1);
            i--;
          }
        }
        if (mappings.length === 0) {
          this.mappings.delete(key);
        }
      }
      return wasConfident;
    }
    getAll(addresses) {
      const ipMappedAddresses = [];
      for (const { multiaddr: ma } of addresses) {
        const tuples = ma.stringTuples();
        let tuple;
        if ((tuples[0][0] === CODEC_IP4 || tuples[0][0] === CODEC_IP6) && tuples[1][0] === CODEC_TCP) {
          tuple = `${tuples[0][1]}-${tuples[1][1]}-tcp`;
        } else if ((tuples[0][0] === CODEC_IP4 || tuples[0][0] === CODEC_IP6) && tuples[1][0] === CODEC_UDP) {
          tuple = `${tuples[0][1]}-${tuples[1][1]}-udp`;
        }
        if (tuple == null) {
          continue;
        }
        const mappings = this.mappings.get(tuple);
        if (mappings == null) {
          continue;
        }
        for (const mapping of mappings) {
          tuples[0][0] = mapping.externalFamily === 4 ? CODEC_IP4 : CODEC_IP6;
          tuples[0][1] = mapping.externalIp;
          tuples[1][1] = `${mapping.externalPort}`;
          ipMappedAddresses.push({
            multiaddr: multiaddr(`/${tuples.map((tuple2) => {
              return [
                protocols(tuple2[0]).name,
                tuple2[1]
              ].join("/");
            }).join("/")}`),
            verified: mapping.verified,
            type: "ip-mapping",
            expires: mapping.expires,
            lastVerified: mapping.lastVerified
          });
        }
      }
      return ipMappedAddresses;
    }
    confirm(ma, ttl) {
      const tuples = ma.stringTuples();
      const host = tuples[0][1];
      let startingConfidence = false;
      for (const mappings of this.mappings.values()) {
        for (const mapping of mappings) {
          if (mapping.externalIp === host) {
            this.log("marking %s to %s IP mapping as verified", mapping.internalIp, mapping.externalIp);
            startingConfidence = mapping.verified;
            mapping.verified = true;
            mapping.expires = Date.now() + ttl;
            mapping.lastVerified = Date.now();
          }
        }
      }
      return startingConfidence;
    }
    unconfirm(ma, ttl) {
      const tuples = ma.stringTuples();
      const host = tuples[0][1] ?? "";
      const protocol = tuples[1][0] === CODEC_TCP ? "tcp" : "udp";
      const port = parseInt(tuples[1][1] ?? "0");
      let wasConfident = false;
      for (const mappings of this.mappings.values()) {
        for (let i = 0; i < mappings.length; i++) {
          const mapping = mappings[i];
          if (mapping.externalIp === host && mapping.externalPort === port && mapping.protocol === protocol) {
            this.log("removing verification of %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, host, port, protocol);
            wasConfident = wasConfident || mapping.verified;
            mapping.verified = false;
            mapping.expires = Date.now() + ttl;
          }
        }
      }
      return wasConfident;
    }
  };

  // ../node_modules/@libp2p/utils/dist/src/multiaddr/is-link-local.js
  function isLinkLocal(ma) {
    try {
      for (const { code: code18, value } of ma.getComponents()) {
        if (code18 === CODE_IP6ZONE) {
          continue;
        }
        if (value == null) {
          continue;
        }
        if (code18 === CODE_IP4) {
          return value.startsWith("169.254.");
        }
        if (code18 === CODE_IP6) {
          return value.toLowerCase().startsWith("fe80");
        }
      }
    } catch {
    }
    return false;
  }

  // ../node_modules/libp2p/dist/src/address-manager/observed-addresses.js
  var defaultValues2 = {
    maxObservedAddresses: 10
  };
  var ObservedAddresses = class {
    log;
    addresses;
    maxObservedAddresses;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
      this.addresses = trackedMap({
        name: "libp2p_address_manager_observed_addresses",
        metrics: components.metrics
      });
      this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues2.maxObservedAddresses;
    }
    has(ma) {
      return this.addresses.has(ma.toString());
    }
    removePrefixed(prefix) {
      for (const key of this.addresses.keys()) {
        if (key.toString().startsWith(prefix)) {
          this.addresses.delete(key);
        }
      }
    }
    add(ma) {
      if (this.addresses.size === this.maxObservedAddresses) {
        return;
      }
      if (isPrivate(ma) || isLinkLocal(ma)) {
        return;
      }
      this.log("adding observed address %a", ma);
      this.addresses.set(ma.toString(), {
        verified: false,
        expires: 0
      });
    }
    getAll() {
      return Array.from(this.addresses).map(([ma, metadata]) => ({
        multiaddr: multiaddr(ma),
        verified: metadata.verified,
        type: "observed",
        expires: metadata.expires,
        lastVerified: metadata.lastVerified
      }));
    }
    remove(ma) {
      const startingConfidence = this.addresses.get(ma.toString())?.verified ?? false;
      this.log("removing observed address %a", ma);
      this.addresses.delete(ma.toString());
      return startingConfidence;
    }
    confirm(ma, ttl) {
      const addrString = ma.toString();
      const metadata = this.addresses.get(addrString) ?? {
        verified: false,
        expires: Date.now() + ttl,
        lastVerified: Date.now()
      };
      const startingConfidence = metadata.verified;
      metadata.verified = true;
      metadata.expires = Date.now() + ttl;
      metadata.lastVerified = Date.now();
      this.log("marking observed address %a as verified", addrString);
      this.addresses.set(addrString, metadata);
      return startingConfidence;
    }
  };

  // ../node_modules/@libp2p/utils/dist/src/multiaddr/is-network-address.js
  var NETWORK_CODECS = [
    CODE_IP4,
    CODE_IP6,
    CODE_DNS,
    CODE_DNS4,
    CODE_DNS6,
    CODE_DNSADDR
  ];
  function isNetworkAddress(ma) {
    try {
      for (const { code: code18 } of ma.getComponents()) {
        if (code18 === CODE_IP6ZONE) {
          continue;
        }
        return NETWORK_CODECS.includes(code18);
      }
    } catch {
    }
    return false;
  }

  // ../node_modules/libp2p/dist/src/address-manager/transport-addresses.js
  var defaultValues3 = {
    maxObservedAddresses: 10
  };
  var TransportAddresses = class {
    log;
    addresses;
    maxObservedAddresses;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
      this.addresses = trackedMap({
        name: "libp2p_address_manager_transport_addresses",
        metrics: components.metrics
      });
      this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues3.maxObservedAddresses;
    }
    get(multiaddr2, ttl) {
      if (isPrivate(multiaddr2)) {
        return {
          multiaddr: multiaddr2,
          verified: true,
          type: "transport",
          expires: Date.now() + ttl,
          lastVerified: Date.now()
        };
      }
      const key = this.toKey(multiaddr2);
      let metadata = this.addresses.get(key);
      if (metadata == null) {
        metadata = {
          verified: !isNetworkAddress(multiaddr2),
          expires: 0
        };
        this.addresses.set(key, metadata);
      }
      return {
        multiaddr: multiaddr2,
        verified: metadata.verified,
        type: "transport",
        expires: metadata.expires,
        lastVerified: metadata.lastVerified
      };
    }
    has(ma) {
      const key = this.toKey(ma);
      return this.addresses.has(key);
    }
    remove(ma) {
      const key = this.toKey(ma);
      const startingConfidence = this.addresses.get(key)?.verified ?? false;
      this.log("removing observed address %a", ma);
      this.addresses.delete(key);
      return startingConfidence;
    }
    confirm(ma, ttl) {
      const key = this.toKey(ma);
      const metadata = this.addresses.get(key) ?? {
        verified: false,
        expires: 0,
        lastVerified: 0
      };
      const startingConfidence = metadata.verified;
      metadata.verified = true;
      metadata.expires = Date.now() + ttl;
      metadata.lastVerified = Date.now();
      this.addresses.set(key, metadata);
      return startingConfidence;
    }
    unconfirm(ma, ttl) {
      const key = this.toKey(ma);
      const metadata = this.addresses.get(key) ?? {
        verified: false,
        expires: 0
      };
      const startingConfidence = metadata.verified;
      metadata.verified = false;
      metadata.expires = Date.now() + ttl;
      this.addresses.set(key, metadata);
      return startingConfidence;
    }
    toKey(ma) {
      if (isNetworkAddress(ma)) {
        const options = ma.toOptions();
        return `${options.host}-${options.port}-${options.transport}`;
      }
      return ma.toString();
    }
  };

  // ../node_modules/libp2p/dist/src/address-manager/index.js
  var ONE_MINUTE = 6e4;
  var defaultValues4 = {
    maxObservedAddresses: 10,
    addressVerificationTTL: ONE_MINUTE * 10,
    addressVerificationRetry: ONE_MINUTE * 5
  };
  var defaultAddressFilter = (addrs) => addrs;
  function stripPeerId(ma, peerId2) {
    const observedPeerIdStr = ma.getPeerId();
    if (observedPeerIdStr != null) {
      const observedPeerId = peerIdFromString(observedPeerIdStr);
      if (observedPeerId.equals(peerId2)) {
        ma = ma.decapsulate(multiaddr(`/p2p/${peerId2.toString()}`));
      }
    }
    return ma;
  }
  var AddressManager = class {
    log;
    components;
    // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`
    listen;
    announce;
    appendAnnounce;
    announceFilter;
    observed;
    dnsMappings;
    ipMappings;
    transportAddresses;
    observedAddressFilter;
    addressVerificationTTL;
    addressVerificationRetry;
    /**
     * Responsible for managing the peer addresses.
     * Peers can specify their listen and announce addresses.
     * The listen addresses will be used by the libp2p transports to listen for new connections,
     * while the announce addresses will be used for the peer addresses' to other peers in the network.
     */
    constructor(components, init = {}) {
      const { listen = [], announce = [], appendAnnounce = [] } = init;
      this.components = components;
      this.log = components.logger.forComponent("libp2p:address-manager");
      this.listen = listen.map((ma) => ma.toString());
      this.announce = new Set(announce.map((ma) => ma.toString()));
      this.appendAnnounce = new Set(appendAnnounce.map((ma) => ma.toString()));
      this.observed = new ObservedAddresses(components, init);
      this.dnsMappings = new DNSMappings(components, init);
      this.ipMappings = new IPMappings(components, init);
      this.transportAddresses = new TransportAddresses(components, init);
      this.announceFilter = init.announceFilter ?? defaultAddressFilter;
      this.observedAddressFilter = createScalableCuckooFilter(1024);
      this.addressVerificationTTL = init.addressVerificationTTL ?? defaultValues4.addressVerificationTTL;
      this.addressVerificationRetry = init.addressVerificationRetry ?? defaultValues4.addressVerificationRetry;
      this._updatePeerStoreAddresses = debounce(this._updatePeerStoreAddresses.bind(this), 1e3);
      components.events.addEventListener("transport:listening", () => {
        this._updatePeerStoreAddresses();
      });
      components.events.addEventListener("transport:close", () => {
        this._updatePeerStoreAddresses();
      });
    }
    [Symbol.toStringTag] = "@libp2p/address-manager";
    _updatePeerStoreAddresses() {
      const addrs = this.getAddresses().map((ma) => {
        if (ma.getPeerId() === this.components.peerId.toString()) {
          return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`);
        }
        return ma;
      });
      this.components.peerStore.patch(this.components.peerId, {
        multiaddrs: addrs
      }).catch((err) => {
        this.log.error("error updating addresses", err);
      });
    }
    /**
     * Get peer listen multiaddrs
     */
    getListenAddrs() {
      return Array.from(this.listen).map((a) => multiaddr(a));
    }
    /**
     * Get peer announcing multiaddrs
     */
    getAnnounceAddrs() {
      return Array.from(this.announce).map((a) => multiaddr(a));
    }
    /**
     * Get peer announcing multiaddrs
     */
    getAppendAnnounceAddrs() {
      return Array.from(this.appendAnnounce).map((a) => multiaddr(a));
    }
    /**
     * Get observed multiaddrs
     */
    getObservedAddrs() {
      return this.observed.getAll().map((addr) => addr.multiaddr);
    }
    /**
     * Add peer observed addresses
     */
    addObservedAddr(addr) {
      const tuples = addr.stringTuples();
      const socketAddress = `${tuples[0][1]}:${tuples[1][1]}`;
      if (this.observedAddressFilter.has(socketAddress)) {
        return;
      }
      this.observedAddressFilter.add(socketAddress);
      addr = stripPeerId(addr, this.components.peerId);
      if (this.ipMappings.has(addr)) {
        return;
      }
      if (this.dnsMappings.has(addr)) {
        return;
      }
      this.observed.add(addr);
    }
    confirmObservedAddr(addr, options) {
      addr = stripPeerId(addr, this.components.peerId);
      let startingConfidence = true;
      if (options?.type === "transport" || this.transportAddresses.has(addr)) {
        const transportStartingConfidence = this.transportAddresses.confirm(addr, options?.ttl ?? this.addressVerificationTTL);
        if (!transportStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if (options?.type === "dns-mapping" || this.dnsMappings.has(addr)) {
        const dnsMappingStartingConfidence = this.dnsMappings.confirm(addr, options?.ttl ?? this.addressVerificationTTL);
        if (!dnsMappingStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if (options?.type === "ip-mapping" || this.ipMappings.has(addr)) {
        const ipMappingStartingConfidence = this.ipMappings.confirm(addr, options?.ttl ?? this.addressVerificationTTL);
        if (!ipMappingStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if (options?.type === "observed" || this.observed.has(addr)) {
        if (this.maybeUpgradeToIPMapping(addr)) {
          this.ipMappings.confirm(addr, options?.ttl ?? this.addressVerificationTTL);
          startingConfidence = false;
        } else {
          const observedStartingConfidence = this.observed.confirm(addr, options?.ttl ?? this.addressVerificationTTL);
          if (!observedStartingConfidence && startingConfidence) {
            startingConfidence = false;
          }
        }
      }
      if (!startingConfidence) {
        this._updatePeerStoreAddresses();
      }
    }
    removeObservedAddr(addr, options) {
      addr = stripPeerId(addr, this.components.peerId);
      let startingConfidence = false;
      if (this.observed.has(addr)) {
        const observedStartingConfidence = this.observed.remove(addr);
        if (!observedStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if (this.transportAddresses.has(addr)) {
        const transportStartingConfidence = this.transportAddresses.unconfirm(addr, options?.ttl ?? this.addressVerificationRetry);
        if (!transportStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if (this.dnsMappings.has(addr)) {
        const dnsMappingStartingConfidence = this.dnsMappings.unconfirm(addr, options?.ttl ?? this.addressVerificationRetry);
        if (!dnsMappingStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if (this.ipMappings.has(addr)) {
        const ipMappingStartingConfidence = this.ipMappings.unconfirm(addr, options?.ttl ?? this.addressVerificationRetry);
        if (!ipMappingStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if (startingConfidence) {
        this._updatePeerStoreAddresses();
      }
    }
    getAddresses() {
      const addresses = /* @__PURE__ */ new Set();
      const multiaddrs = this.getAddressesWithMetadata().filter((addr) => {
        if (!addr.verified) {
          return false;
        }
        const maStr = addr.multiaddr.toString();
        if (addresses.has(maStr)) {
          return false;
        }
        addresses.add(maStr);
        return true;
      }).map((address) => address.multiaddr);
      return this.announceFilter(multiaddrs.map((str) => {
        const ma = multiaddr(str);
        const lastComponent = ma.getComponents().pop();
        if (lastComponent?.value === this.components.peerId.toString()) {
          return ma;
        }
        return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);
      }));
    }
    getAddressesWithMetadata() {
      const announceMultiaddrs = this.getAnnounceAddrs();
      if (announceMultiaddrs.length > 0) {
        this.components.transportManager.getListeners().forEach((listener) => {
          listener.updateAnnounceAddrs(announceMultiaddrs);
        });
        return announceMultiaddrs.map((multiaddr2) => ({
          multiaddr: multiaddr2,
          verified: true,
          type: "announce",
          expires: Date.now() + this.addressVerificationTTL,
          lastVerified: Date.now()
        }));
      }
      let addresses = [];
      addresses = addresses.concat(this.components.transportManager.getAddrs().map((multiaddr2) => this.transportAddresses.get(multiaddr2, this.addressVerificationTTL)));
      const appendAnnounceMultiaddrs = this.getAppendAnnounceAddrs();
      if (appendAnnounceMultiaddrs.length > 0) {
        this.components.transportManager.getListeners().forEach((listener) => {
          listener.updateAnnounceAddrs(appendAnnounceMultiaddrs);
        });
        addresses = addresses.concat(appendAnnounceMultiaddrs.map((multiaddr2) => ({
          multiaddr: multiaddr2,
          verified: true,
          type: "announce",
          expires: Date.now() + this.addressVerificationTTL,
          lastVerified: Date.now()
        })));
      }
      addresses = addresses.concat(this.observed.getAll());
      addresses = addresses.concat(this.ipMappings.getAll(addresses));
      addresses = addresses.concat(this.dnsMappings.getAll(addresses));
      return addresses;
    }
    addDNSMapping(domain, addresses) {
      this.dnsMappings.add(domain, addresses);
    }
    removeDNSMapping(domain) {
      if (this.dnsMappings.remove(multiaddr(`/dns/${domain}`))) {
        this._updatePeerStoreAddresses();
      }
    }
    addPublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
      this.ipMappings.add(internalIp, internalPort, externalIp, externalPort, protocol);
      this.observed.removePrefixed(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`);
    }
    removePublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
      if (this.ipMappings.remove(multiaddr(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`))) {
        this._updatePeerStoreAddresses();
      }
    }
    /**
     * Where an external service (router, gateway, etc) is forwarding traffic to
     * us, attempt to add an IP mapping for the external address - this will
     * include the observed mapping in the address list where we also have a DNS
     * mapping for the external IP.
     *
     * Returns true if we added a new mapping
     */
    maybeUpgradeToIPMapping(ma) {
      if (this.ipMappings.has(ma)) {
        return false;
      }
      const maOptions = ma.toOptions();
      if (maOptions.family === 6 || maOptions.host === "127.0.0.1" || isPrivateIp(maOptions.host) === true) {
        return false;
      }
      const listeners = this.components.transportManager.getListeners();
      const transportMatchers = [
        (ma2) => WebSockets2.exactMatch(ma2) || WebSocketsSecure2.exactMatch(ma2),
        (ma2) => TCP2.exactMatch(ma2),
        (ma2) => QUICV12.exactMatch(ma2)
      ];
      for (const matcher of transportMatchers) {
        if (!matcher(ma)) {
          continue;
        }
        const transportListeners = listeners.filter((listener) => {
          return listener.getAddrs().filter((ma2) => {
            return ma2.toOptions().family === 4 && matcher(ma2);
          }).length > 0;
        });
        if (transportListeners.length !== 1) {
          continue;
        }
        const linkLocalAddr = transportListeners[0].getAddrs().filter((ma2) => {
          return ma2.toOptions().host !== "127.0.0.1";
        }).pop();
        if (linkLocalAddr == null) {
          continue;
        }
        const linkLocalOptions = linkLocalAddr.toOptions();
        this.observed.remove(ma);
        this.ipMappings.add(linkLocalOptions.host, linkLocalOptions.port, maOptions.host, maOptions.port, maOptions.transport);
        return true;
      }
      return false;
    }
  };

  // ../node_modules/libp2p/dist/src/errors.js
  var messages;
  (function(messages2) {
    messages2["NOT_STARTED_YET"] = "The libp2p node is not started yet";
    messages2["NOT_FOUND"] = "Not found";
  })(messages || (messages = {}));
  var MissingServiceError = class extends Error {
    constructor(message2 = "Missing service") {
      super(message2);
      this.name = "MissingServiceError";
    }
  };
  var UnmetServiceDependenciesError = class extends Error {
    constructor(message2 = "Unmet service dependencies") {
      super(message2);
      this.name = "UnmetServiceDependenciesError";
    }
  };
  var NoContentRoutersError = class extends Error {
    constructor(message2 = "No content routers available") {
      super(message2);
      this.name = "NoContentRoutersError";
    }
  };
  var NoPeerRoutersError = class extends Error {
    constructor(message2 = "No peer routers available") {
      super(message2);
      this.name = "NoPeerRoutersError";
    }
  };
  var QueriedForSelfError = class extends Error {
    constructor(message2 = "Should not try to find self") {
      super(message2);
      this.name = "QueriedForSelfError";
    }
  };
  var UnhandledProtocolError = class extends Error {
    constructor(message2 = "Unhandled protocol error") {
      super(message2);
      this.name = "UnhandledProtocolError";
    }
  };
  var DuplicateProtocolHandlerError = class extends Error {
    constructor(message2 = "Duplicate protocol handler error") {
      super(message2);
      this.name = "DuplicateProtocolHandlerError";
    }
  };
  var DialDeniedError = class extends Error {
    constructor(message2 = "Dial denied error") {
      super(message2);
      this.name = "DialDeniedError";
    }
  };
  var UnsupportedListenAddressError = class extends Error {
    constructor(message2 = "No transport was configured to listen on this address") {
      super(message2);
      this.name = "UnsupportedListenAddressError";
    }
  };
  var UnsupportedListenAddressesError = class extends Error {
    constructor(message2 = "Configured listen addresses could not be listened on") {
      super(message2);
      this.name = "UnsupportedListenAddressesError";
    }
  };
  var NoValidAddressesError = class extends Error {
    constructor(message2 = "No valid addresses") {
      super(message2);
      this.name = "NoValidAddressesError";
    }
  };
  var ConnectionInterceptedError = class extends Error {
    constructor(message2 = "Connection intercepted") {
      super(message2);
      this.name = "ConnectionInterceptedError";
    }
  };
  var ConnectionDeniedError = class extends Error {
    constructor(message2 = "Connection denied") {
      super(message2);
      this.name = "ConnectionDeniedError";
    }
  };
  var MuxerUnavailableError = class extends Error {
    constructor(message2 = "Stream is not multiplexed") {
      super(message2);
      this.name = "MuxerUnavailableError";
    }
  };
  var EncryptionFailedError = class extends Error {
    constructor(message2 = "Encryption failed") {
      super(message2);
      this.name = "EncryptionFailedError";
    }
  };
  var TransportUnavailableError = class extends Error {
    constructor(message2 = "Transport unavailable") {
      super(message2);
      this.name = "TransportUnavailableError";
    }
  };

  // ../node_modules/libp2p/dist/src/components.js
  var DefaultComponents = class {
    components = {};
    _started = false;
    constructor(init = {}) {
      this.components = {};
      for (const [key, value] of Object.entries(init)) {
        this.components[key] = value;
      }
      if (this.components.logger == null) {
        this.components.logger = defaultLogger();
      }
    }
    isStarted() {
      return this._started;
    }
    async _invokeStartableMethod(methodName) {
      await Promise.all(Object.values(this.components).filter((obj) => isStartable(obj)).map(async (startable) => {
        await startable[methodName]?.();
      }));
    }
    async beforeStart() {
      await this._invokeStartableMethod("beforeStart");
    }
    async start() {
      await this._invokeStartableMethod("start");
      this._started = true;
    }
    async afterStart() {
      await this._invokeStartableMethod("afterStart");
    }
    async beforeStop() {
      await this._invokeStartableMethod("beforeStop");
    }
    async stop() {
      await this._invokeStartableMethod("stop");
      this._started = false;
    }
    async afterStop() {
      await this._invokeStartableMethod("afterStop");
    }
  };
  var OPTIONAL_SERVICES = [
    "metrics",
    "connectionProtector",
    "dns"
  ];
  var NON_SERVICE_PROPERTIES = [
    "components",
    "isStarted",
    "beforeStart",
    "start",
    "afterStart",
    "beforeStop",
    "stop",
    "afterStop",
    "then",
    "_invokeStartableMethod"
  ];
  function defaultComponents(init = {}) {
    const components = new DefaultComponents(init);
    const proxy = new Proxy(components, {
      get(target, prop, receiver) {
        if (typeof prop === "string" && !NON_SERVICE_PROPERTIES.includes(prop)) {
          const service = components.components[prop];
          if (service == null && !OPTIONAL_SERVICES.includes(prop)) {
            throw new MissingServiceError(`${prop} not set`);
          }
          return service;
        }
        return Reflect.get(target, prop, receiver);
      },
      set(target, prop, value) {
        if (typeof prop === "string") {
          components.components[prop] = value;
        } else {
          Reflect.set(target, prop, value);
        }
        return true;
      }
    });
    return proxy;
  }
  function checkServiceDependencies(components) {
    const serviceCapabilities2 = {};
    for (const service of Object.values(components.components)) {
      for (const capability of getServiceCapabilities(service)) {
        serviceCapabilities2[capability] = true;
      }
    }
    for (const service of Object.values(components.components)) {
      for (const capability of getServiceDependencies(service)) {
        if (serviceCapabilities2[capability] !== true) {
          throw new UnmetServiceDependenciesError(`Service "${getServiceName(service)}" required capability "${capability}" but it was not provided by any component, you may need to add additional configuration when creating your node.`);
        }
      }
    }
  }
  function getServiceCapabilities(service) {
    if (Array.isArray(service?.[serviceCapabilities])) {
      return service[serviceCapabilities];
    }
    return [];
  }
  function getServiceDependencies(service) {
    if (Array.isArray(service?.[serviceDependencies])) {
      return service[serviceDependencies];
    }
    return [];
  }
  function getServiceName(service) {
    return service?.[Symbol.toStringTag] ?? service?.toString() ?? "unknown";
  }

  // ../node_modules/libp2p/dist/src/config/connection-gater.browser.js
  var CODEC_IP42 = 4;
  var CODEC_IP62 = 41;
  function connectionGater(gater = {}) {
    return {
      denyDialPeer: async () => false,
      denyDialMultiaddr: async (multiaddr2) => {
        if (WebSockets2.matches(multiaddr2)) {
          return false;
        }
        const tuples = multiaddr2.stringTuples();
        if (tuples[0][0] === CODEC_IP42 || tuples[0][0] === CODEC_IP62) {
          return Boolean(isPrivateIp(`${tuples[0][1]}`));
        }
        return false;
      },
      denyInboundConnection: async () => false,
      denyOutboundConnection: async () => false,
      denyInboundEncryptedConnection: async () => false,
      denyOutboundEncryptedConnection: async () => false,
      denyInboundUpgradedConnection: async () => false,
      denyOutboundUpgradedConnection: async () => false,
      filterMultiaddrForPeer: async () => true,
      ...gater
    };
  }

  // ../node_modules/libp2p/dist/src/get-peer.js
  function getPeerAddress(peer) {
    if (isPeerId(peer)) {
      return { peerId: peer, multiaddrs: [] };
    }
    let multiaddrs = Array.isArray(peer) ? peer : [peer];
    let peerId2;
    if (multiaddrs.length > 0) {
      const peerIdStr = multiaddrs[0].getPeerId();
      peerId2 = peerIdStr == null ? void 0 : peerIdFromString(peerIdStr);
      multiaddrs.forEach((ma) => {
        if (!isMultiaddr(ma)) {
          throw new InvalidMultiaddrError("Invalid multiaddr");
        }
        const maPeerIdStr = ma.getPeerId();
        if (maPeerIdStr == null) {
          if (peerId2 != null) {
            throw new InvalidParametersError("Multiaddrs must all have the same peer id or have no peer id");
          }
        } else {
          const maPeerId = peerIdFromString(maPeerIdStr);
          if (peerId2?.equals(maPeerId) !== true) {
            throw new InvalidParametersError("Multiaddrs must all have the same peer id or have no peer id");
          }
        }
      });
    }
    multiaddrs = multiaddrs.filter((ma) => {
      return !PEER_ID.exactMatch(ma);
    });
    return {
      peerId: peerId2,
      multiaddrs
    };
  }

  // ../node_modules/@libp2p/utils/dist/src/close.js
  var DEFAULT_CLOSABLE_PROTOCOLS = [
    // identify
    "/ipfs/id/1.0.0",
    // identify-push
    "/ipfs/id/push/1.0.0",
    // autonat
    "/libp2p/autonat/1.0.0",
    // dcutr
    "/libp2p/dcutr"
  ];
  async function safelyCloseConnectionIfUnused(connection, options) {
    const streamProtocols = connection?.streams?.map((stream) => stream.protocol) ?? [];
    const closableProtocols = options?.closableProtocols ?? DEFAULT_CLOSABLE_PROTOCOLS;
    if (streamProtocols.filter((proto) => proto != null && !closableProtocols.includes(proto)).length > 0) {
      return;
    }
    try {
      await connection?.close(options);
    } catch (err) {
      connection?.abort(err);
    }
  }

  // ../node_modules/libp2p/dist/src/connection-manager/utils.js
  async function resolveMultiaddrs(ma, options) {
    let resolvable = false;
    for (const key of resolvers.keys()) {
      resolvable = ma.protoNames().includes(key);
      if (resolvable) {
        break;
      }
    }
    if (!resolvable) {
      return [ma];
    }
    const output2 = await ma.resolve(options);
    options.log("resolved %s to", ma, output2.map((ma2) => ma2.toString()));
    return output2;
  }
  function multiaddrToIpNet(ma) {
    try {
      let parsedMa;
      if (typeof ma === "string") {
        parsedMa = multiaddr(ma);
      } else {
        parsedMa = ma;
      }
      if (!parsedMa.protoNames().includes("ipcidr")) {
        const isIPv62 = parsedMa.protoNames().includes("ip6");
        const cidr = isIPv62 ? "/ipcidr/128" : "/ipcidr/32";
        parsedMa = parsedMa.encapsulate(cidr);
      }
      return convertToIpNet(parsedMa);
    } catch (error) {
      throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${ma}`);
    }
  }

  // ../node_modules/libp2p/dist/src/connection-manager/connection-pruner.js
  var ConnectionPruner = class {
    connectionManager;
    peerStore;
    allow;
    events;
    log;
    constructor(components, init = {}) {
      this.allow = (init.allow ?? []).map((ma) => multiaddrToIpNet(ma));
      this.connectionManager = components.connectionManager;
      this.peerStore = components.peerStore;
      this.events = components.events;
      this.log = components.logger.forComponent("libp2p:connection-manager:connection-pruner");
      this.maybePruneConnections = this.maybePruneConnections.bind(this);
    }
    start() {
      this.events.addEventListener("connection:open", this.maybePruneConnections);
    }
    stop() {
      this.events.removeEventListener("connection:open", this.maybePruneConnections);
    }
    maybePruneConnections() {
      this._maybePruneConnections().catch((err) => {
        this.log.error("error while pruning connections %e", err);
      });
    }
    /**
     * If we have more connections than our maximum, select some excess connections
     * to prune based on peer value
     */
    async _maybePruneConnections() {
      const connections = this.connectionManager.getConnections();
      const numConnections = connections.length;
      const maxConnections = this.connectionManager.getMaxConnections();
      this.log("checking max connections limit %d/%d", numConnections, maxConnections);
      if (numConnections <= maxConnections) {
        return;
      }
      const peerValues = new PeerMap();
      for (const connection of connections) {
        const remotePeer = connection.remotePeer;
        if (peerValues.has(remotePeer)) {
          continue;
        }
        peerValues.set(remotePeer, 0);
        try {
          const peer = await this.peerStore.get(remotePeer);
          peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {
            return acc + curr.value;
          }, 0));
        } catch (err) {
          if (err.name !== "NotFoundError") {
            this.log.error("error loading peer tags", err);
          }
        }
      }
      const sortedConnections = this.sortConnections(connections, peerValues);
      const toPrune = Math.max(numConnections - maxConnections, 0);
      const toClose = [];
      for (const connection of sortedConnections) {
        this.log("too many connections open - closing a connection to %p", connection.remotePeer);
        const connectionInAllowList = this.allow.some((ipNet) => {
          return ipNet.contains(connection.remoteAddr.nodeAddress().address);
        });
        if (!connectionInAllowList) {
          toClose.push(connection);
        }
        if (toClose.length === toPrune) {
          break;
        }
      }
      await Promise.all(toClose.map(async (connection) => {
        await safelyCloseConnectionIfUnused(connection, {
          signal: AbortSignal.timeout(1e3)
        });
      }));
      this.events.safeDispatchEvent("connection:prune", { detail: toClose });
    }
    sortConnections(connections, peerValues) {
      return connections.sort((a, b) => {
        const connectionALifespan = a.timeline.open;
        const connectionBLifespan = b.timeline.open;
        if (connectionALifespan < connectionBLifespan) {
          return 1;
        }
        if (connectionALifespan > connectionBLifespan) {
          return -1;
        }
        return 0;
      }).sort((a, b) => {
        if (a.direction === "outbound" && b.direction === "inbound") {
          return 1;
        }
        if (a.direction === "inbound" && b.direction === "outbound") {
          return -1;
        }
        return 0;
      }).sort((a, b) => {
        if (a.streams.length > b.streams.length) {
          return 1;
        }
        if (a.streams.length < b.streams.length) {
          return -1;
        }
        return 0;
      }).sort((a, b) => {
        const peerAValue = peerValues.get(a.remotePeer) ?? 0;
        const peerBValue = peerValues.get(b.remotePeer) ?? 0;
        if (peerAValue > peerBValue) {
          return 1;
        }
        if (peerAValue < peerBValue) {
          return -1;
        }
        return 0;
      });
    }
  };

  // ../node_modules/libp2p/dist/src/connection-manager/constants.defaults.js
  var DIAL_TIMEOUT = 1e4;
  var INBOUND_UPGRADE_TIMEOUT = 1e4;
  var PROTOCOL_NEGOTIATION_TIMEOUT = 1e4;
  var MAX_PEER_ADDRS_TO_DIAL = 25;
  var INBOUND_CONNECTION_THRESHOLD = 5;
  var MAX_INCOMING_PENDING_CONNECTIONS = 10;
  var MAX_PARALLEL_RECONNECTS = 5;
  var LAST_DIAL_FAILURE_KEY = "last-dial-failure";
  var LAST_DIAL_SUCCESS_KEY = "last-dial-success";
  var MAX_DIAL_QUEUE_LENGTH = 500;

  // ../node_modules/libp2p/dist/src/connection-manager/constants.browser.js
  var MAX_CONNECTIONS = 100;
  var MAX_PARALLEL_DIALS = 50;

  // ../node_modules/@libp2p/utils/dist/src/queue/recipient.js
  var JobRecipient2 = class {
    deferred;
    signal;
    constructor(signal) {
      this.signal = signal;
      this.deferred = pDefer();
      this.onAbort = this.onAbort.bind(this);
      this.signal?.addEventListener("abort", this.onAbort);
    }
    onAbort() {
      this.deferred.reject(this.signal?.reason ?? new AbortError3());
    }
    cleanup() {
      this.signal?.removeEventListener("abort", this.onAbort);
    }
  };

  // ../node_modules/@libp2p/utils/dist/src/queue/job.js
  function randomId2() {
    return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
  }
  var Job2 = class {
    id;
    fn;
    options;
    recipients;
    status;
    timeline;
    controller;
    constructor(fn, options) {
      this.id = randomId2();
      this.status = "queued";
      this.fn = fn;
      this.options = options;
      this.recipients = [];
      this.timeline = {
        created: Date.now()
      };
      this.controller = new AbortController();
      setMaxListeners(Infinity, this.controller.signal);
      this.onAbort = this.onAbort.bind(this);
    }
    abort(err) {
      this.controller.abort(err);
    }
    onAbort() {
      const allAborted = this.recipients.reduce((acc, curr) => {
        return acc && curr.signal?.aborted === true;
      }, true);
      if (allAborted) {
        this.controller.abort(new AbortError3());
        this.cleanup();
      }
    }
    async join(options = {}) {
      const recipient = new JobRecipient2(options.signal);
      this.recipients.push(recipient);
      options.signal?.addEventListener("abort", this.onAbort);
      return recipient.deferred.promise;
    }
    async run() {
      this.status = "running";
      this.timeline.started = Date.now();
      try {
        this.controller.signal.throwIfAborted();
        const result = await raceSignal(this.fn({
          ...this.options ?? {},
          signal: this.controller.signal
        }), this.controller.signal);
        this.recipients.forEach((recipient) => {
          recipient.deferred.resolve(result);
        });
        this.status = "complete";
      } catch (err) {
        this.recipients.forEach((recipient) => {
          recipient.deferred.reject(err);
        });
        this.status = "errored";
      } finally {
        this.timeline.finished = Date.now();
        this.cleanup();
      }
    }
    cleanup() {
      this.recipients.forEach((recipient) => {
        recipient.cleanup();
        recipient.signal?.removeEventListener("abort", this.onAbort);
      });
    }
  };

  // ../node_modules/@libp2p/utils/dist/src/queue/index.js
  var Queue2 = class extends TypedEventEmitter {
    concurrency;
    maxSize;
    queue;
    pending;
    sort;
    constructor(init = {}) {
      super();
      this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
      this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY;
      this.pending = 0;
      if (init.metricName != null) {
        init.metrics?.registerMetricGroup(init.metricName, {
          calculate: () => {
            return {
              size: this.queue.length,
              running: this.pending,
              queued: this.queue.length - this.pending
            };
          }
        });
      }
      this.sort = init.sort;
      this.queue = [];
      this.emitEmpty = debounce(this.emitEmpty.bind(this), 1);
      this.emitIdle = debounce(this.emitIdle.bind(this), 1);
    }
    emitEmpty() {
      if (this.size !== 0) {
        return;
      }
      this.safeDispatchEvent("empty");
    }
    emitIdle() {
      if (this.running !== 0) {
        return;
      }
      this.safeDispatchEvent("idle");
    }
    tryToStartAnother() {
      if (this.size === 0) {
        this.emitEmpty();
        if (this.running === 0) {
          this.emitIdle();
        }
        return false;
      }
      if (this.pending < this.concurrency) {
        let job;
        for (const j of this.queue) {
          if (j.status === "queued") {
            job = j;
            break;
          }
        }
        if (job == null) {
          return false;
        }
        this.safeDispatchEvent("active");
        this.pending++;
        void job.run().finally(() => {
          for (let i = 0; i < this.queue.length; i++) {
            if (this.queue[i] === job) {
              this.queue.splice(i, 1);
              break;
            }
          }
          this.pending--;
          this.tryToStartAnother();
          this.safeDispatchEvent("next");
        });
        return true;
      }
      return false;
    }
    enqueue(job) {
      this.queue.push(job);
      if (this.sort != null) {
        this.queue.sort(this.sort);
      }
    }
    /**
     * Adds a sync or async task to the queue. Always returns a promise.
     */
    async add(fn, options) {
      options?.signal?.throwIfAborted();
      if (this.size === this.maxSize) {
        throw new QueueFullError();
      }
      const job = new Job2(fn, options);
      this.enqueue(job);
      this.safeDispatchEvent("add");
      this.tryToStartAnother();
      return job.join(options).then((result) => {
        this.safeDispatchEvent("completed", { detail: result });
        this.safeDispatchEvent("success", { detail: { job, result } });
        return result;
      }).catch((err) => {
        if (job.status === "queued") {
          for (let i = 0; i < this.queue.length; i++) {
            if (this.queue[i] === job) {
              this.queue.splice(i, 1);
              break;
            }
          }
        }
        this.safeDispatchEvent("error", { detail: err });
        this.safeDispatchEvent("failure", { detail: { job, error: err } });
        throw err;
      });
    }
    /**
     * Clear the queue
     */
    clear() {
      this.queue.splice(0, this.queue.length);
    }
    /**
     * Abort all jobs in the queue and clear it
     */
    abort() {
      this.queue.forEach((job) => {
        job.abort(new AbortError3());
      });
      this.clear();
    }
    /**
     * Can be called multiple times. Useful if you for example add additional items at a later time.
     *
     * @returns A promise that settles when the queue becomes empty.
     */
    async onEmpty(options) {
      if (this.size === 0) {
        return;
      }
      await raceEvent(this, "empty", options?.signal);
    }
    /**
     * @returns A promise that settles when the queue size is less than the given
     * limit: `queue.size < limit`.
     *
     * If you want to avoid having the queue grow beyond a certain size you can
     * `await queue.onSizeLessThan()` before adding a new item.
     *
     * Note that this only limits the number of items waiting to start. There
     * could still be up to `concurrency` jobs already running that this call does
     * not include in its calculation.
     */
    async onSizeLessThan(limit, options) {
      if (this.size < limit) {
        return;
      }
      await raceEvent(this, "next", options?.signal, {
        filter: () => this.size < limit
      });
    }
    /**
     * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
     * from the queue has finished. `.onEmpty` merely signals that the queue is
     * empty, but it could mean that some promises haven't completed yet.
     *
     * @returns A promise that settles when the queue becomes empty, and all
     * promises have completed; `queue.size === 0 && queue.pending === 0`.
     */
    async onIdle(options) {
      if (this.pending === 0 && this.size === 0) {
        return;
      }
      await raceEvent(this, "idle", options?.signal);
    }
    /**
     * Size of the queue including running items
     */
    get size() {
      return this.queue.length;
    }
    /**
     * The number of queued items waiting to run.
     */
    get queued() {
      return this.queue.length - this.pending;
    }
    /**
     * The number of items currently running.
     */
    get running() {
      return this.pending;
    }
    /**
     * Returns an async generator that makes it easy to iterate over the results
     * of jobs added to the queue.
     *
     * The generator will end when the queue becomes idle, that is there are no
     * jobs running and no jobs that have yet to run.
     *
     * If you need to keep the queue open indefinitely, consider using it-pushable
     * instead.
     */
    async *toGenerator(options) {
      options?.signal?.throwIfAborted();
      const stream = pushable({
        objectMode: true
      });
      const cleanup = (err) => {
        if (err != null) {
          this.abort();
        } else {
          this.clear();
        }
        stream.end(err);
      };
      const onQueueJobComplete = (evt) => {
        if (evt.detail != null) {
          stream.push(evt.detail);
        }
      };
      const onQueueError = (evt) => {
        cleanup(evt.detail);
      };
      const onQueueIdle = () => {
        cleanup();
      };
      const onSignalAbort = () => {
        cleanup(new AbortError3("Queue aborted"));
      };
      this.addEventListener("completed", onQueueJobComplete);
      this.addEventListener("error", onQueueError);
      this.addEventListener("idle", onQueueIdle);
      options?.signal?.addEventListener("abort", onSignalAbort);
      try {
        yield* stream;
      } finally {
        this.removeEventListener("completed", onQueueJobComplete);
        this.removeEventListener("error", onQueueError);
        this.removeEventListener("idle", onQueueIdle);
        options?.signal?.removeEventListener("abort", onSignalAbort);
        cleanup();
      }
    }
  };

  // ../node_modules/@libp2p/utils/dist/src/priority-queue.js
  var PriorityQueue2 = class extends Queue2 {
    constructor(init = {}) {
      super({
        ...init,
        sort: (a, b) => {
          if (a.options.priority > b.options.priority) {
            return -1;
          }
          if (a.options.priority < b.options.priority) {
            return 1;
          }
          return 0;
        }
      });
    }
  };

  // ../node_modules/any-signal/dist/src/index.js
  function anySignal(signals) {
    const controller = new globalThis.AbortController();
    function onAbort() {
      controller.abort();
      for (const signal2 of signals) {
        if (signal2?.removeEventListener != null) {
          signal2.removeEventListener("abort", onAbort);
        }
      }
    }
    for (const signal2 of signals) {
      if (signal2?.aborted === true) {
        onAbort();
        break;
      }
      if (signal2?.addEventListener != null) {
        signal2.addEventListener("abort", onAbort);
      }
    }
    function clear() {
      for (const signal2 of signals) {
        if (signal2?.removeEventListener != null) {
          signal2.removeEventListener("abort", onAbort);
        }
      }
    }
    const signal = controller.signal;
    signal.clear = clear;
    return signal;
  }

  // ../node_modules/is-loopback-addr/dist/src/index.js
  function isLoopbackAddr(ip) {
    return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(ip) || /^::1$/.test(ip);
  }

  // ../node_modules/@libp2p/utils/dist/src/multiaddr/is-loopback.js
  function isLoopback(ma) {
    if (!isIpBased(ma)) {
      return false;
    }
    const { address } = ma.nodeAddress();
    return isLoopbackAddr(address);
  }

  // ../node_modules/libp2p/dist/src/connection-manager/address-sorter.js
  function reliableTransportsFirst(a, b) {
    const isATcp = TCP2.exactMatch(a.multiaddr);
    const isBTcp = TCP2.exactMatch(b.multiaddr);
    if (isATcp && !isBTcp) {
      return -1;
    }
    if (!isATcp && isBTcp) {
      return 1;
    }
    const isAWebSocketSecure = WebSocketsSecure2.exactMatch(a.multiaddr);
    const isBWebSocketSecure = WebSocketsSecure2.exactMatch(b.multiaddr);
    if (isAWebSocketSecure && !isBWebSocketSecure) {
      return -1;
    }
    if (!isAWebSocketSecure && isBWebSocketSecure) {
      return 1;
    }
    const isAWebSocket = WebSockets2.exactMatch(a.multiaddr);
    const isBWebSocket = WebSockets2.exactMatch(b.multiaddr);
    if (isAWebSocket && !isBWebSocket) {
      return -1;
    }
    if (!isAWebSocket && isBWebSocket) {
      return 1;
    }
    const isAWebRTC = WebRTC2.exactMatch(a.multiaddr);
    const isBWebRTC = WebRTC2.exactMatch(b.multiaddr);
    if (isAWebRTC && !isBWebRTC) {
      return -1;
    }
    if (!isAWebRTC && isBWebRTC) {
      return 1;
    }
    const isAWebRTCDirect = WebRTCDirect2.exactMatch(a.multiaddr);
    const isBWebRTCDirect = WebRTCDirect2.exactMatch(b.multiaddr);
    if (isAWebRTCDirect && !isBWebRTCDirect) {
      return -1;
    }
    if (!isAWebRTCDirect && isBWebRTCDirect) {
      return 1;
    }
    const isAWebTransport = WebTransport2.exactMatch(a.multiaddr);
    const isBWebTransport = WebTransport2.exactMatch(b.multiaddr);
    if (isAWebTransport && !isBWebTransport) {
      return -1;
    }
    if (!isAWebTransport && isBWebTransport) {
      return 1;
    }
    return 0;
  }
  function loopbackAddressLast(a, b) {
    const isALoopback = isLoopback(a.multiaddr);
    const isBLoopback = isLoopback(b.multiaddr);
    if (isALoopback && !isBLoopback) {
      return 1;
    } else if (!isALoopback && isBLoopback) {
      return -1;
    }
    return 0;
  }
  function publicAddressesFirst(a, b) {
    const isAPrivate = isPrivate(a.multiaddr);
    const isBPrivate = isPrivate(b.multiaddr);
    if (isAPrivate && !isBPrivate) {
      return 1;
    } else if (!isAPrivate && isBPrivate) {
      return -1;
    }
    return 0;
  }
  function certifiedAddressesFirst(a, b) {
    if (a.isCertified && !b.isCertified) {
      return -1;
    } else if (!a.isCertified && b.isCertified) {
      return 1;
    }
    return 0;
  }
  function circuitRelayAddressesLast(a, b) {
    const isACircuit = Circuit2.exactMatch(a.multiaddr);
    const isBCircuit = Circuit2.exactMatch(b.multiaddr);
    if (isACircuit && !isBCircuit) {
      return 1;
    } else if (!isACircuit && isBCircuit) {
      return -1;
    }
    return 0;
  }
  function defaultAddressSorter(addresses) {
    return addresses.sort(reliableTransportsFirst).sort(certifiedAddressesFirst).sort(circuitRelayAddressesLast).sort(publicAddressesFirst).sort(loopbackAddressLast);
  }

  // ../node_modules/libp2p/dist/src/connection-manager/dial-queue.js
  var defaultOptions3 = {
    maxParallelDials: MAX_PARALLEL_DIALS,
    maxDialQueueLength: MAX_DIAL_QUEUE_LENGTH,
    maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,
    dialTimeout: DIAL_TIMEOUT,
    resolvers: {
      dnsaddr: dnsaddrResolver
    }
  };
  var DialQueue = class {
    queue;
    components;
    addressSorter;
    maxPeerAddrsToDial;
    maxDialQueueLength;
    dialTimeout;
    shutDownController;
    connections;
    log;
    constructor(components, init = {}) {
      this.addressSorter = init.addressSorter;
      this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions3.maxPeerAddrsToDial;
      this.maxDialQueueLength = init.maxDialQueueLength ?? defaultOptions3.maxDialQueueLength;
      this.dialTimeout = init.dialTimeout ?? defaultOptions3.dialTimeout;
      this.connections = init.connections ?? new PeerMap();
      this.log = components.logger.forComponent("libp2p:connection-manager:dial-queue");
      this.components = components;
      this.shutDownController = new AbortController();
      setMaxListeners(Infinity, this.shutDownController.signal);
      for (const [key, value] of Object.entries(init.resolvers ?? {})) {
        resolvers.set(key, value);
      }
      this.queue = new PriorityQueue2({
        concurrency: init.maxParallelDials ?? defaultOptions3.maxParallelDials,
        metricName: "libp2p_dial_queue",
        metrics: components.metrics
      });
      this.queue.addEventListener("error", (event) => {
        if (event.detail?.name !== AbortError3.name) {
          this.log.error("error in dial queue - %e", event.detail);
        }
      });
    }
    start() {
      this.shutDownController = new AbortController();
      setMaxListeners(Infinity, this.shutDownController.signal);
    }
    /**
     * Clears any pending dials
     */
    stop() {
      this.shutDownController.abort();
      this.queue.abort();
    }
    /**
     * Connects to a given peer, multiaddr or list of multiaddrs.
     *
     * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or
     * multiaddrs are passed only those will be dialled.
     *
     * Where a list of multiaddrs is passed, if any contain a peer id then all
     * multiaddrs in the list must contain the same peer id.
     *
     * The dial to the first address that is successfully able to upgrade a
     * connection will be used, all other dials will be aborted when that happens.
     */
    async dial(peerIdOrMultiaddr, options = {}) {
      const { peerId: peerId2, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);
      const existingConnection = Array.from(this.connections.values()).flat().find((conn) => {
        if (options.force === true) {
          return false;
        }
        if (conn.remotePeer.equals(peerId2)) {
          return true;
        }
        return multiaddrs.find((addr) => {
          return addr.equals(conn.remoteAddr);
        });
      });
      if (existingConnection?.status === "open") {
        this.log("already connected to %a", existingConnection.remoteAddr);
        options.onProgress?.(new CustomProgressEvent("dial-queue:already-connected"));
        return existingConnection;
      }
      const existingDial = this.queue.queue.find((job) => {
        if (peerId2?.equals(job.options.peerId) === true) {
          return true;
        }
        const addresses = job.options.multiaddrs;
        if (addresses == null) {
          return false;
        }
        for (const multiaddr2 of multiaddrs) {
          if (addresses.has(multiaddr2.toString())) {
            return true;
          }
        }
        return false;
      });
      if (existingDial != null) {
        this.log("joining existing dial target for %p", peerId2);
        for (const multiaddr2 of multiaddrs) {
          existingDial.options.multiaddrs.add(multiaddr2.toString());
        }
        options.onProgress?.(new CustomProgressEvent("dial-queue:already-in-dial-queue"));
        return existingDial.join(options);
      }
      if (this.queue.size >= this.maxDialQueueLength) {
        throw new DialError("Dial queue is full");
      }
      this.log("creating dial target for %p", peerId2, multiaddrs.map((ma) => ma.toString()));
      options.onProgress?.(new CustomProgressEvent("dial-queue:add-to-dial-queue"));
      return this.queue.add(async (options2) => {
        options2.onProgress?.(new CustomProgressEvent("dial-queue:start-dial"));
        const signal = anySignal([
          this.shutDownController.signal,
          options2.signal
        ]);
        setMaxListeners(Infinity, signal);
        try {
          return await this.dialPeer(options2, signal);
        } finally {
          signal.clear();
        }
      }, {
        peerId: peerId2,
        priority: options.priority ?? DEFAULT_DIAL_PRIORITY,
        multiaddrs: new Set(multiaddrs.map((ma) => ma.toString())),
        signal: options.signal ?? AbortSignal.timeout(this.dialTimeout),
        onProgress: options.onProgress
      });
    }
    async dialPeer(options, signal) {
      const peerId2 = options.peerId;
      const multiaddrs = options.multiaddrs;
      const failedMultiaddrs = /* @__PURE__ */ new Set();
      let forcePeerLookup = options.multiaddrs.size === 0;
      let dialed = 0;
      let dialIteration = 0;
      const errors = [];
      this.log("starting dial to %p", peerId2);
      while (forcePeerLookup || multiaddrs.size > 0) {
        dialIteration++;
        forcePeerLookup = false;
        const addrsToDial = [];
        const addrs = new Set(options.multiaddrs);
        multiaddrs.clear();
        this.log("calculating addrs to dial %p from %s", peerId2, [...addrs]);
        const calculatedAddrs = await this.calculateMultiaddrs(peerId2, addrs, {
          ...options,
          signal
        });
        for (const addr of calculatedAddrs) {
          if (failedMultiaddrs.has(addr.multiaddr.toString())) {
            this.log.trace("skipping previously failed multiaddr %a while dialing %p", addr.multiaddr, peerId2);
            continue;
          }
          addrsToDial.push(addr);
        }
        this.log("%s dial to %p with %s", dialIteration === 1 ? "starting" : "continuing", peerId2, addrsToDial.map((ma) => ma.multiaddr.toString()));
        options?.onProgress?.(new CustomProgressEvent("dial-queue:calculated-addresses", addrsToDial));
        for (const address of addrsToDial) {
          if (dialed === this.maxPeerAddrsToDial) {
            this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others", dialed, options.peerId);
            throw new DialError("Peer had more than maxPeerAddrsToDial");
          }
          dialed++;
          try {
            const conn = await this.components.transportManager.dial(address.multiaddr, {
              ...options,
              signal
            });
            this.log("dial to %a succeeded", address.multiaddr);
            try {
              await this.components.peerStore.merge(conn.remotePeer, {
                multiaddrs: [
                  conn.remoteAddr
                ],
                metadata: {
                  [LAST_DIAL_SUCCESS_KEY]: fromString27(Date.now().toString())
                }
              });
            } catch (err) {
              this.log.error("could not update last dial failure key for %p", peerId2, err);
            }
            return conn;
          } catch (err) {
            this.log.error("dial failed to %a", address.multiaddr, err);
            failedMultiaddrs.add(address.multiaddr.toString());
            if (peerId2 != null) {
              try {
                await this.components.peerStore.merge(peerId2, {
                  metadata: {
                    [LAST_DIAL_FAILURE_KEY]: fromString27(Date.now().toString())
                  }
                });
              } catch (err2) {
                this.log.error("could not update last dial failure key for %p", peerId2, err2);
              }
            }
            if (signal.aborted) {
              throw new TimeoutError(err.message);
            }
            errors.push(err);
          }
        }
      }
      if (errors.length === 1) {
        throw errors[0];
      }
      throw new AggregateError(errors, "All multiaddr dials failed");
    }
    // eslint-disable-next-line complexity
    async calculateMultiaddrs(peerId2, multiaddrs = /* @__PURE__ */ new Set(), options = {}) {
      const addrs = [...multiaddrs].map((ma) => ({
        multiaddr: multiaddr(ma),
        isCertified: false
      }));
      if (peerId2 != null) {
        if (this.components.peerId.equals(peerId2)) {
          throw new DialError("Tried to dial self");
        }
        if (await this.components.connectionGater.denyDialPeer?.(peerId2) === true) {
          throw new DialDeniedError("The dial request is blocked by gater.allowDialPeer");
        }
        if (addrs.length === 0) {
          this.log("loading multiaddrs for %p", peerId2);
          try {
            const peer = await this.components.peerStore.get(peerId2);
            addrs.push(...peer.addresses);
            this.log("loaded multiaddrs for %p", peerId2, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
          } catch (err) {
            if (err.name !== "NotFoundError") {
              throw err;
            }
          }
        }
        if (addrs.length === 0) {
          this.log("looking up multiaddrs for %p in the peer routing", peerId2);
          try {
            const peerInfo = await this.components.peerRouting.findPeer(peerId2, options);
            this.log("found multiaddrs for %p in the peer routing", peerId2, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
            addrs.push(...peerInfo.multiaddrs.map((multiaddr2) => ({
              multiaddr: multiaddr2,
              isCertified: false
            })));
          } catch (err) {
            if (err.name === "NoPeerRoutersError") {
              this.log("no peer routers configured", peerId2);
            } else {
              this.log.error("looking up multiaddrs for %p in the peer routing failed - %e", peerId2, err);
            }
          }
        }
      }
      let resolvedAddresses = (await Promise.all(addrs.map(async (addr) => {
        const result = await resolveMultiaddrs(addr.multiaddr, {
          dns: this.components.dns,
          ...options,
          log: this.log
        });
        if (result.length === 1 && result[0].equals(addr.multiaddr)) {
          return addr;
        }
        return result.map((multiaddr2) => ({
          multiaddr: multiaddr2,
          isCertified: false
        }));
      }))).flat();
      if (peerId2 != null) {
        const peerIdMultiaddr = `/p2p/${peerId2.toString()}`;
        resolvedAddresses = resolvedAddresses.map((addr) => {
          const lastComponent = addr.multiaddr.getComponents().pop();
          if (lastComponent?.name !== "p2p") {
            return {
              multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),
              isCertified: addr.isCertified
            };
          }
          return addr;
        });
      }
      const filteredAddrs = resolvedAddresses.filter((addr) => {
        if (this.components.transportManager.dialTransportForMultiaddr(addr.multiaddr) == null) {
          return false;
        }
        const addrPeerId = addr.multiaddr.getPeerId();
        if (peerId2 != null && addrPeerId != null) {
          return peerId2.equals(addrPeerId);
        }
        return true;
      });
      const dedupedAddrs = /* @__PURE__ */ new Map();
      for (const addr of filteredAddrs) {
        const maStr = addr.multiaddr.toString();
        const existing = dedupedAddrs.get(maStr);
        if (existing != null) {
          existing.isCertified = existing.isCertified || addr.isCertified || false;
          continue;
        }
        dedupedAddrs.set(maStr, addr);
      }
      const dedupedMultiaddrs = [...dedupedAddrs.values()];
      if (dedupedMultiaddrs.length === 0) {
        throw new NoValidAddressesError("The dial request has no valid addresses");
      }
      const gatedAddrs = [];
      for (const addr of dedupedMultiaddrs) {
        if (this.components.connectionGater.denyDialMultiaddr != null && await this.components.connectionGater.denyDialMultiaddr(addr.multiaddr)) {
          continue;
        }
        gatedAddrs.push(addr);
      }
      const sortedGatedAddrs = this.addressSorter == null ? defaultAddressSorter(gatedAddrs) : gatedAddrs.sort(this.addressSorter);
      if (sortedGatedAddrs.length === 0) {
        throw new DialDeniedError("The connection gater denied all addresses in the dial request");
      }
      this.log.trace("addresses for %p before filtering", peerId2 ?? "unknown peer", resolvedAddresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
      this.log.trace("addresses for %p after filtering", peerId2 ?? "unknown peer", sortedGatedAddrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
      return sortedGatedAddrs;
    }
    async isDialable(multiaddr2, options = {}) {
      if (!Array.isArray(multiaddr2)) {
        multiaddr2 = [multiaddr2];
      }
      try {
        const addresses = await this.calculateMultiaddrs(void 0, new Set(multiaddr2.map((ma) => ma.toString())), options);
        if (options.runOnLimitedConnection === false) {
          return addresses.find((addr) => {
            return !Circuit2.matches(addr.multiaddr);
          }) != null;
        }
        return true;
      } catch (err) {
        this.log.trace("error calculating if multiaddr(s) were dialable", err);
      }
      return false;
    }
  };

  // ../node_modules/@libp2p/utils/dist/src/peer-queue.js
  var PeerQueue = class extends Queue2 {
    has(peerId2) {
      return this.find(peerId2) != null;
    }
    find(peerId2) {
      return this.queue.find((job) => {
        return peerId2.equals(job.options.peerId);
      });
    }
  };

  // ../node_modules/p-retry/index.js
  var import_retry = __toESM(require_retry2(), 1);

  // ../node_modules/is-network-error/index.js
  var objectToString = Object.prototype.toString;
  var isError2 = (value) => objectToString.call(value) === "[object Error]";
  var errorMessages = /* @__PURE__ */ new Set([
    "network error",
    // Chrome
    "Failed to fetch",
    // Chrome
    "NetworkError when attempting to fetch resource.",
    // Firefox
    "The Internet connection appears to be offline.",
    // Safari 16
    "Load failed",
    // Safari 17+
    "Network request failed",
    // `cross-fetch`
    "fetch failed",
    // Undici (Node.js)
    "terminated"
    // Undici (Node.js)
  ]);
  function isNetworkError(error) {
    const isValid = error && isError2(error) && error.name === "TypeError" && typeof error.message === "string";
    if (!isValid) {
      return false;
    }
    if (error.message === "Load failed") {
      return error.stack === void 0;
    }
    return errorMessages.has(error.message);
  }

  // ../node_modules/p-retry/index.js
  var AbortError6 = class extends Error {
    constructor(message2) {
      super();
      if (message2 instanceof Error) {
        this.originalError = message2;
        ({ message: message2 } = message2);
      } else {
        this.originalError = new Error(message2);
        this.originalError.stack = this.stack;
      }
      this.name = "AbortError";
      this.message = message2;
    }
  };
  var decorateErrorWithCounts = (error, attemptNumber, options) => {
    const retriesLeft = options.retries - (attemptNumber - 1);
    error.attemptNumber = attemptNumber;
    error.retriesLeft = retriesLeft;
    return error;
  };
  async function pRetry(input, options) {
    return new Promise((resolve, reject) => {
      options = { ...options };
      options.onFailedAttempt ??= () => {
      };
      options.shouldRetry ??= () => true;
      options.retries ??= 10;
      const operation = import_retry.default.operation(options);
      const abortHandler = () => {
        operation.stop();
        reject(options.signal?.reason);
      };
      if (options.signal && !options.signal.aborted) {
        options.signal.addEventListener("abort", abortHandler, { once: true });
      }
      const cleanUp = () => {
        options.signal?.removeEventListener("abort", abortHandler);
        operation.stop();
      };
      operation.attempt(async (attemptNumber) => {
        try {
          const result = await input(attemptNumber);
          cleanUp();
          resolve(result);
        } catch (error) {
          try {
            if (!(error instanceof Error)) {
              throw new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
            }
            if (error instanceof AbortError6) {
              throw error.originalError;
            }
            if (error instanceof TypeError && !isNetworkError(error)) {
              throw error;
            }
            decorateErrorWithCounts(error, attemptNumber, options);
            if (!await options.shouldRetry(error)) {
              operation.stop();
              reject(error);
            }
            await options.onFailedAttempt(error);
            if (!operation.retry(error)) {
              throw operation.mainError();
            }
          } catch (finalError) {
            decorateErrorWithCounts(finalError, attemptNumber, options);
            cleanUp();
            reject(finalError);
          }
        }
      });
    });
  }

  // ../node_modules/libp2p/dist/src/connection-manager/reconnect-queue.js
  var ReconnectQueue = class {
    log;
    queue;
    started;
    peerStore;
    retries;
    retryInterval;
    backoffFactor;
    connectionManager;
    events;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:reconnect-queue");
      this.peerStore = components.peerStore;
      this.connectionManager = components.connectionManager;
      this.queue = new PeerQueue({
        concurrency: init.maxParallelReconnects ?? MAX_PARALLEL_RECONNECTS,
        metricName: "libp2p_reconnect_queue",
        metrics: components.metrics
      });
      this.started = false;
      this.retries = init.retries ?? 5;
      this.backoffFactor = init.backoffFactor;
      this.retryInterval = init.retryInterval;
      this.events = components.events;
      components.events.addEventListener("peer:disconnect", (evt) => {
        this.maybeReconnect(evt.detail).catch((err) => {
          this.log.error("failed to maybe reconnect to %p - %e", evt.detail, err);
        });
      });
    }
    async maybeReconnect(peerId2) {
      if (!this.started) {
        return;
      }
      const peer = await this.peerStore.get(peerId2);
      if (!hasKeepAliveTag(peer)) {
        return;
      }
      if (this.queue.has(peerId2)) {
        return;
      }
      this.queue.add(async (options) => {
        await pRetry(async (attempt) => {
          if (!this.started) {
            return;
          }
          try {
            await this.connectionManager.openConnection(peerId2, {
              signal: options?.signal
            });
          } catch (err) {
            this.log("reconnecting to %p attempt %d of %d failed - %e", peerId2, attempt, this.retries, err);
            throw err;
          }
        }, {
          signal: options?.signal,
          retries: this.retries,
          factor: this.backoffFactor,
          minTimeout: this.retryInterval
        });
      }, {
        peerId: peerId2
      }).catch(async (err) => {
        this.log.error("failed to reconnect to %p - %e", peerId2, err);
        const tags = {};
        [...peer.tags.keys()].forEach((key) => {
          if (key.startsWith(KEEP_ALIVE)) {
            tags[key] = void 0;
          }
        });
        await this.peerStore.merge(peerId2, {
          tags
        });
        this.events.safeDispatchEvent("peer:reconnect-failure", {
          detail: peerId2
        });
      }).catch(async (err) => {
        this.log.error("failed to remove keep-alive tag from %p - %e", peerId2, err);
      });
    }
    start() {
      this.started = true;
    }
    async afterStart() {
      void Promise.resolve().then(async () => {
        const keepAlivePeers = await this.peerStore.all({
          filters: [
            (peer) => hasKeepAliveTag(peer)
          ]
        });
        await Promise.all(keepAlivePeers.map(async (peer) => {
          await this.connectionManager.openConnection(peer.id).catch((err) => {
            this.log.error(err);
          });
        }));
      }).catch((err) => {
        this.log.error(err);
      });
    }
    stop() {
      this.started = false;
      this.queue.abort();
    }
  };
  function hasKeepAliveTag(peer) {
    for (const tag of peer.tags.keys()) {
      if (tag.startsWith(KEEP_ALIVE)) {
        return true;
      }
    }
    return false;
  }

  // ../node_modules/libp2p/dist/src/connection-manager/index.js
  var DEFAULT_DIAL_PRIORITY = 50;
  var defaultOptions4 = {
    maxConnections: MAX_CONNECTIONS,
    inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,
    maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS
  };
  var DefaultConnectionManager = class {
    started;
    connections;
    allow;
    deny;
    maxIncomingPendingConnections;
    incomingPendingConnections;
    outboundPendingConnections;
    maxConnections;
    dialQueue;
    reconnectQueue;
    connectionPruner;
    inboundConnectionRateLimiter;
    peerStore;
    metrics;
    events;
    log;
    peerId;
    constructor(components, init = {}) {
      this.maxConnections = init.maxConnections ?? defaultOptions4.maxConnections;
      if (this.maxConnections < 1) {
        throw new InvalidParametersError("Connection Manager maxConnections must be greater than 0");
      }
      this.connections = new PeerMap();
      this.started = false;
      this.peerId = components.peerId;
      this.peerStore = components.peerStore;
      this.metrics = components.metrics;
      this.events = components.events;
      this.log = components.logger.forComponent("libp2p:connection-manager");
      this.onConnect = this.onConnect.bind(this);
      this.onDisconnect = this.onDisconnect.bind(this);
      this.allow = (init.allow ?? []).map((str) => multiaddrToIpNet(str));
      this.deny = (init.deny ?? []).map((str) => multiaddrToIpNet(str));
      this.incomingPendingConnections = 0;
      this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions4.maxIncomingPendingConnections;
      this.outboundPendingConnections = 0;
      this.inboundConnectionRateLimiter = new RateLimiter({
        points: init.inboundConnectionThreshold ?? defaultOptions4.inboundConnectionThreshold,
        duration: 1
      });
      this.connectionPruner = new ConnectionPruner({
        connectionManager: this,
        peerStore: components.peerStore,
        events: components.events,
        logger: components.logger
      }, {
        allow: init.allow?.map((a) => multiaddr(a))
      });
      this.dialQueue = new DialQueue(components, {
        addressSorter: init.addressSorter,
        maxParallelDials: init.maxParallelDials ?? MAX_PARALLEL_DIALS,
        maxDialQueueLength: init.maxDialQueueLength ?? MAX_DIAL_QUEUE_LENGTH,
        maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,
        dialTimeout: init.dialTimeout ?? DIAL_TIMEOUT,
        resolvers: init.resolvers ?? {
          dnsaddr: dnsaddrResolver
        },
        connections: this.connections
      });
      this.reconnectQueue = new ReconnectQueue({
        events: components.events,
        peerStore: components.peerStore,
        logger: components.logger,
        connectionManager: this
      }, {
        retries: init.reconnectRetries,
        retryInterval: init.reconnectRetryInterval,
        backoffFactor: init.reconnectBackoffFactor,
        maxParallelReconnects: init.maxParallelReconnects
      });
    }
    [Symbol.toStringTag] = "@libp2p/connection-manager";
    /**
     * Starts the Connection Manager. If Metrics are not enabled on libp2p
     * only event loop and connection limits will be monitored.
     */
    async start() {
      this.metrics?.registerMetricGroup("libp2p_connection_manager_connections", {
        calculate: () => {
          const metric = {
            inbound: 0,
            "inbound pending": this.incomingPendingConnections,
            outbound: 0,
            "outbound pending": this.outboundPendingConnections
          };
          for (const conns of this.connections.values()) {
            for (const conn of conns) {
              metric[conn.direction]++;
            }
          }
          return metric;
        }
      });
      this.metrics?.registerMetricGroup("libp2p_protocol_streams_total", {
        label: "protocol",
        calculate: () => {
          const metric = {};
          for (const conns of this.connections.values()) {
            for (const conn of conns) {
              for (const stream of conn.streams) {
                const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
                metric[key] = (metric[key] ?? 0) + 1;
              }
            }
          }
          return metric;
        }
      });
      this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile", {
        label: "protocol",
        calculate: () => {
          const allStreams = {};
          for (const conns of this.connections.values()) {
            for (const conn of conns) {
              const streams = {};
              for (const stream of conn.streams) {
                const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
                streams[key] = (streams[key] ?? 0) + 1;
              }
              for (const [protocol, count] of Object.entries(streams)) {
                allStreams[protocol] = allStreams[protocol] ?? [];
                allStreams[protocol].push(count);
              }
            }
          }
          const metric = {};
          for (let [protocol, counts] of Object.entries(allStreams)) {
            counts = counts.sort((a, b) => a - b);
            const index = Math.floor(counts.length * 0.9);
            metric[protocol] = counts[index];
          }
          return metric;
        }
      });
      this.events.addEventListener("connection:open", this.onConnect);
      this.events.addEventListener("connection:close", this.onDisconnect);
      await start(this.dialQueue, this.reconnectQueue, this.connectionPruner);
      this.started = true;
      this.log("started");
    }
    /**
     * Stops the Connection Manager
     */
    async stop() {
      this.events.removeEventListener("connection:open", this.onConnect);
      this.events.removeEventListener("connection:close", this.onDisconnect);
      await stop(this.reconnectQueue, this.dialQueue, this.connectionPruner);
      const tasks = [];
      for (const connectionList of this.connections.values()) {
        for (const connection of connectionList) {
          tasks.push((async () => {
            try {
              await connection.close();
            } catch (err) {
              this.log.error(err);
            }
          })());
        }
      }
      this.log("closing %d connections", tasks.length);
      await Promise.all(tasks);
      this.connections.clear();
      this.log("stopped");
    }
    getMaxConnections() {
      return this.maxConnections;
    }
    setMaxConnections(maxConnections) {
      if (this.maxConnections < 1) {
        throw new InvalidParametersError("Connection Manager maxConnections must be greater than 0");
      }
      let needsPrune = false;
      if (maxConnections < this.maxConnections) {
        needsPrune = true;
      }
      this.maxConnections = maxConnections;
      if (needsPrune) {
        this.connectionPruner.maybePruneConnections();
      }
    }
    onConnect(evt) {
      void this._onConnect(evt).catch((err) => {
        this.log.error(err);
      });
    }
    /**
     * Tracks the incoming connection and check the connection limit
     */
    async _onConnect(evt) {
      const { detail: connection } = evt;
      if (!this.started) {
        await connection.close();
        return;
      }
      if (connection.status !== "open") {
        return;
      }
      const peerId2 = connection.remotePeer;
      const isNewPeer = !this.connections.has(peerId2);
      const storedConns = this.connections.get(peerId2) ?? [];
      storedConns.push(connection);
      this.connections.set(peerId2, storedConns);
      if (peerId2.publicKey != null && peerId2.type === "RSA") {
        await this.peerStore.patch(peerId2, {
          publicKey: peerId2.publicKey
        });
      }
      if (isNewPeer) {
        this.events.safeDispatchEvent("peer:connect", { detail: connection.remotePeer });
      }
    }
    /**
     * Removes the connection from tracking
     */
    onDisconnect(evt) {
      const { detail: connection } = evt;
      const peerId2 = connection.remotePeer;
      const peerConns = this.connections.get(peerId2) ?? [];
      const filteredPeerConns = peerConns.filter((conn) => conn.id !== connection.id);
      this.connections.set(peerId2, filteredPeerConns);
      if (filteredPeerConns.length === 0) {
        this.log("onDisconnect remove all connections for peer %p", peerId2);
        this.connections.delete(peerId2);
        this.events.safeDispatchEvent("peer:disconnect", { detail: connection.remotePeer });
      }
    }
    getConnections(peerId2) {
      if (peerId2 != null) {
        return this.connections.get(peerId2) ?? [];
      }
      let conns = [];
      for (const c of this.connections.values()) {
        conns = conns.concat(c);
      }
      return conns;
    }
    getConnectionsMap() {
      return this.connections;
    }
    async openConnection(peerIdOrMultiaddr, options = {}) {
      if (!this.started) {
        throw new NotStartedError("Not started");
      }
      this.outboundPendingConnections++;
      try {
        options.signal?.throwIfAborted();
        const { peerId: peerId2 } = getPeerAddress(peerIdOrMultiaddr);
        if (this.peerId.equals(peerId2)) {
          throw new InvalidPeerIdError("Can not dial self");
        }
        if (peerId2 != null && options.force !== true) {
          this.log("dial %p", peerId2);
          const existingConnection = this.getConnections(peerId2).find((conn) => conn.limits == null);
          if (existingConnection != null) {
            this.log("had an existing non-limited connection to %p", peerId2);
            options.onProgress?.(new CustomProgressEvent("dial-queue:already-connected"));
            return existingConnection;
          }
        }
        const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {
          ...options,
          priority: options.priority ?? DEFAULT_DIAL_PRIORITY
        });
        if (connection.status !== "open") {
          throw new ConnectionClosedError("Remote closed connection during opening");
        }
        let peerConnections = this.connections.get(connection.remotePeer);
        if (peerConnections == null) {
          peerConnections = [];
          this.connections.set(connection.remotePeer, peerConnections);
        }
        let trackedConnection = false;
        for (const conn of peerConnections) {
          if (conn.id === connection.id) {
            trackedConnection = true;
          }
          if (options.force !== true && conn.id !== connection.id && conn.remoteAddr.equals(connection.remoteAddr)) {
            connection.abort(new InvalidMultiaddrError("Duplicate multiaddr connection"));
            return conn;
          }
        }
        if (!trackedConnection) {
          peerConnections.push(connection);
        }
        return connection;
      } finally {
        this.outboundPendingConnections--;
      }
    }
    async closeConnections(peerId2, options = {}) {
      const connections = this.connections.get(peerId2) ?? [];
      await Promise.all(connections.map(async (connection) => {
        try {
          await connection.close(options);
        } catch (err) {
          connection.abort(err);
        }
      }));
    }
    async acceptIncomingConnection(maConn) {
      const denyConnection = this.deny.some((ma) => {
        return ma.contains(maConn.remoteAddr.nodeAddress().address);
      });
      if (denyConnection) {
        this.log("connection from %a refused - connection remote address was in deny list", maConn.remoteAddr);
        return false;
      }
      const allowConnection = this.allow.some((ipNet) => {
        return ipNet.contains(maConn.remoteAddr.nodeAddress().address);
      });
      if (allowConnection) {
        this.incomingPendingConnections++;
        return true;
      }
      if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {
        this.log("connection from %a refused - incomingPendingConnections exceeded by host", maConn.remoteAddr);
        return false;
      }
      if (maConn.remoteAddr.isThinWaistAddress()) {
        const host = maConn.remoteAddr.nodeAddress().address;
        try {
          await this.inboundConnectionRateLimiter.consume(host, 1);
        } catch {
          this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s", maConn.remoteAddr, host);
          return false;
        }
      }
      if (this.getConnections().length < this.maxConnections) {
        this.incomingPendingConnections++;
        return true;
      }
      this.log("connection from %a refused - maxConnections exceeded", maConn.remoteAddr);
      return false;
    }
    afterUpgradeInbound() {
      this.incomingPendingConnections--;
    }
    getDialQueue() {
      const statusMap = {
        queued: "queued",
        running: "active",
        errored: "error",
        complete: "success"
      };
      return this.dialQueue.queue.queue.map((job) => {
        return {
          id: job.id,
          status: statusMap[job.status],
          peerId: job.options.peerId,
          multiaddrs: [...job.options.multiaddrs].map((ma) => multiaddr(ma))
        };
      });
    }
    async isDialable(multiaddr2, options = {}) {
      return this.dialQueue.isDialable(multiaddr2, options);
    }
  };

  // ../node_modules/@libp2p/utils/dist/src/moving-average.js
  var MovingAverage = class {
    movingAverage;
    variance;
    deviation;
    forecast;
    timeSpan;
    previousTime;
    constructor(timeSpan) {
      this.timeSpan = timeSpan;
      this.movingAverage = 0;
      this.variance = 0;
      this.deviation = 0;
      this.forecast = 0;
    }
    alpha(t, pt) {
      return 1 - Math.exp(-(t - pt) / this.timeSpan);
    }
    push(value, time = Date.now()) {
      if (this.previousTime != null) {
        const a = this.alpha(time, this.previousTime);
        const diff = value - this.movingAverage;
        const incr = a * diff;
        this.movingAverage = a * value + (1 - a) * this.movingAverage;
        this.variance = (1 - a) * (this.variance + diff * incr);
        this.deviation = Math.sqrt(this.variance);
        this.forecast = this.movingAverage + a * diff;
      } else {
        this.movingAverage = value;
      }
      this.previousTime = time;
    }
  };

  // ../node_modules/@libp2p/utils/dist/src/adaptive-timeout.js
  var DEFAULT_TIMEOUT_MULTIPLIER = 1.2;
  var DEFAULT_FAILURE_MULTIPLIER = 2;
  var DEFAULT_MIN_TIMEOUT = 5e3;
  var DEFAULT_MAX_TIMEOUT = 6e4;
  var DEFAULT_INTERVAL = 5e3;
  var AdaptiveTimeout = class {
    success;
    failure;
    next;
    metric;
    timeoutMultiplier;
    failureMultiplier;
    minTimeout;
    maxTimeout;
    constructor(init = {}) {
      const interval = init.interval ?? DEFAULT_INTERVAL;
      this.success = new MovingAverage(interval);
      this.failure = new MovingAverage(interval);
      this.next = new MovingAverage(interval);
      this.failureMultiplier = init.failureMultiplier ?? DEFAULT_FAILURE_MULTIPLIER;
      this.timeoutMultiplier = init.timeoutMultiplier ?? DEFAULT_TIMEOUT_MULTIPLIER;
      this.minTimeout = init.minTimeout ?? DEFAULT_MIN_TIMEOUT;
      this.maxTimeout = init.maxTimeout ?? DEFAULT_MAX_TIMEOUT;
      if (init.metricName != null) {
        this.metric = init.metrics?.registerMetricGroup(init.metricName);
      }
    }
    getTimeoutSignal(options = {}) {
      let timeout2 = Math.round(this.next.movingAverage * (options.timeoutFactor ?? this.timeoutMultiplier));
      if (timeout2 < this.minTimeout) {
        timeout2 = this.minTimeout;
      }
      if (timeout2 > this.maxTimeout) {
        timeout2 = this.maxTimeout;
      }
      const sendTimeout = AbortSignal.timeout(timeout2);
      const timeoutSignal = anySignal([options.signal, sendTimeout]);
      setMaxListeners(Infinity, timeoutSignal, sendTimeout);
      timeoutSignal.start = Date.now();
      timeoutSignal.timeout = timeout2;
      return timeoutSignal;
    }
    cleanUp(signal) {
      const time = Date.now() - signal.start;
      if (signal.aborted) {
        this.failure.push(time);
        this.next.push(time * this.failureMultiplier);
        this.metric?.update({
          failureMovingAverage: this.failure.movingAverage,
          failureDeviation: this.failure.deviation,
          failureForecast: this.failure.forecast,
          failureVariance: this.failure.variance,
          failure: time
        });
      } else {
        this.success.push(time);
        this.next.push(time);
        this.metric?.update({
          successMovingAverage: this.success.movingAverage,
          successDeviation: this.success.deviation,
          successForecast: this.success.forecast,
          successVariance: this.success.variance,
          success: time
        });
      }
    }
  };

  // ../node_modules/libp2p/dist/src/connection-monitor.js
  var DEFAULT_PING_INTERVAL_MS = 1e4;
  var PROTOCOL_VERSION2 = "1.0.0";
  var PROTOCOL_NAME2 = "ping";
  var PROTOCOL_PREFIX2 = "ipfs";
  var PING_LENGTH2 = 32;
  var DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE = true;
  var ConnectionMonitor = class {
    protocol;
    components;
    log;
    heartbeatInterval;
    pingIntervalMs;
    abortController;
    timeout;
    abortConnectionOnPingFailure;
    constructor(components, init = {}) {
      this.components = components;
      this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX2}/${PROTOCOL_NAME2}/${PROTOCOL_VERSION2}`;
      this.log = components.logger.forComponent("libp2p:connection-monitor");
      this.pingIntervalMs = init.pingInterval ?? DEFAULT_PING_INTERVAL_MS;
      this.abortConnectionOnPingFailure = init.abortConnectionOnPingFailure ?? DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE;
      this.timeout = new AdaptiveTimeout({
        ...init.pingTimeout ?? {},
        metrics: components.metrics,
        metricName: "libp2p_connection_monitor_ping_time_milliseconds"
      });
    }
    [Symbol.toStringTag] = "@libp2p/connection-monitor";
    [serviceCapabilities] = [
      "@libp2p/connection-monitor"
    ];
    start() {
      this.abortController = new AbortController();
      setMaxListeners(Infinity, this.abortController.signal);
      this.heartbeatInterval = setInterval(() => {
        this.components.connectionManager.getConnections().forEach((conn) => {
          Promise.resolve().then(async () => {
            let start2 = Date.now();
            try {
              const signal = this.timeout.getTimeoutSignal({
                signal: this.abortController?.signal
              });
              const stream = await conn.newStream(this.protocol, {
                signal,
                runOnLimitedConnection: true
              });
              const bs = byteStream(stream);
              start2 = Date.now();
              await Promise.all([
                bs.write(randomBytes3(PING_LENGTH2), {
                  signal
                }),
                bs.read({
                  bytes: PING_LENGTH2,
                  signal
                })
              ]);
              conn.rtt = Date.now() - start2;
              await bs.unwrap().close({
                signal
              });
            } catch (err) {
              if (err.name !== "UnsupportedProtocolError") {
                throw err;
              }
              conn.rtt = (Date.now() - start2) / 2;
            }
          }).catch((err) => {
            this.log.error("error during heartbeat", err);
            if (this.abortConnectionOnPingFailure) {
              this.log.error("aborting connection due to ping failure");
              conn.abort(err);
            } else {
              this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag");
            }
          });
        });
      }, this.pingIntervalMs);
    }
    stop() {
      this.abortController?.abort();
      if (this.heartbeatInterval != null) {
        clearInterval(this.heartbeatInterval);
      }
    }
  };

  // ../node_modules/libp2p/node_modules/uint8arrays/dist/src/to-string.js
  function toString23(array, encoding = "utf8") {
    const base37 = bases_default14[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.encoder.encode(array).substring(1);
  }

  // ../node_modules/libp2p/dist/src/content-routing.js
  var CompoundContentRouting = class {
    routers;
    started;
    components;
    constructor(components, init) {
      this.routers = init.routers ?? [];
      this.started = false;
      this.components = components;
      this.findProviders = components.metrics?.traceFunction("libp2p.contentRouting.findProviders", this.findProviders.bind(this), {
        optionsIndex: 1,
        getAttributesFromArgs: ([cid], attrs) => {
          return {
            ...attrs,
            cid: cid.toString()
          };
        },
        getAttributesFromYieldedValue: (value, attrs) => {
          return {
            ...attrs,
            providers: [...Array.isArray(attrs.providers) ? attrs.providers : [], value.id.toString()]
          };
        }
      }) ?? this.findProviders;
      this.provide = components.metrics?.traceFunction("libp2p.contentRouting.provide", this.provide.bind(this), {
        optionsIndex: 1,
        getAttributesFromArgs: ([cid], attrs) => {
          return {
            ...attrs,
            cid: cid.toString()
          };
        }
      }) ?? this.provide;
      this.cancelReprovide = components.metrics?.traceFunction("libp2p.contentRouting.cancelReprovide", this.cancelReprovide.bind(this), {
        optionsIndex: 1,
        getAttributesFromArgs: ([cid], attrs) => {
          return {
            ...attrs,
            cid: cid.toString()
          };
        }
      }) ?? this.cancelReprovide;
      this.put = components.metrics?.traceFunction("libp2p.contentRouting.put", this.put.bind(this), {
        optionsIndex: 2,
        getAttributesFromArgs: ([key]) => {
          return {
            key: toString23(key, "base36")
          };
        }
      }) ?? this.put;
      this.get = components.metrics?.traceFunction("libp2p.contentRouting.get", this.get.bind(this), {
        optionsIndex: 1,
        getAttributesFromArgs: ([key]) => {
          return {
            key: toString23(key, "base36")
          };
        }
      }) ?? this.get;
    }
    [Symbol.toStringTag] = "@libp2p/content-routing";
    isStarted() {
      return this.started;
    }
    async start() {
      this.started = true;
    }
    async stop() {
      this.started = false;
    }
    /**
     * Iterates over all content routers in parallel to find providers of the given key
     */
    async *findProviders(key, options = {}) {
      if (this.routers.length === 0) {
        throw new NoContentRoutersError("No content routers available");
      }
      const self2 = this;
      const seen = new PeerSet();
      for await (const peer of src_default2(...self2.routers.filter((router) => router.findProviders instanceof Function).map((router) => router.findProviders(key, options)))) {
        if (peer == null) {
          continue;
        }
        if (peer.multiaddrs.length > 0) {
          await this.components.peerStore.merge(peer.id, {
            multiaddrs: peer.multiaddrs
          }, options);
        }
        if (seen.has(peer.id)) {
          continue;
        }
        seen.add(peer.id);
        yield peer;
      }
    }
    /**
     * Iterates over all content routers in parallel to notify it is
     * a provider of the given key
     */
    async provide(key, options = {}) {
      if (this.routers.length === 0) {
        throw new NoContentRoutersError("No content routers available");
      }
      await Promise.all(this.routers.filter((router) => router.provide instanceof Function).map(async (router) => {
        await router.provide(key, options);
      }));
    }
    async cancelReprovide(key, options = {}) {
      if (this.routers.length === 0) {
        throw new NoContentRoutersError("No content routers available");
      }
      await Promise.all(this.routers.filter((router) => router.cancelReprovide instanceof Function).map(async (router) => {
        await router.cancelReprovide(key, options);
      }));
    }
    /**
     * Store the given key/value pair in the available content routings
     */
    async put(key, value, options) {
      if (!this.isStarted()) {
        throw new NotStartedError();
      }
      await Promise.all(this.routers.filter((router) => router.put instanceof Function).map(async (router) => {
        await router.put(key, value, options);
      }));
    }
    /**
     * Get the value to the given key.
     * Times out after 1 minute by default.
     */
    async get(key, options) {
      if (!this.isStarted()) {
        throw new NotStartedError();
      }
      return Promise.any(this.routers.filter((router) => router.get instanceof Function).map(async (router) => {
        return router.get(key, options);
      }));
    }
  };

  // ../node_modules/libp2p/dist/src/peer-routing.js
  var DefaultPeerRouting = class {
    log;
    peerId;
    peerStore;
    routers;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:peer-routing");
      this.peerId = components.peerId;
      this.peerStore = components.peerStore;
      this.routers = init.routers ?? [];
      this.findPeer = components.metrics?.traceFunction("libp2p.peerRouting.findPeer", this.findPeer.bind(this), {
        optionsIndex: 1,
        getAttributesFromArgs: ([peer], attrs) => {
          return {
            ...attrs,
            peer: peer.toString()
          };
        }
      }) ?? this.findPeer;
      this.getClosestPeers = components.metrics?.traceFunction("libp2p.peerRouting.getClosestPeers", this.getClosestPeers.bind(this), {
        optionsIndex: 1,
        getAttributesFromArgs: ([key], attrs) => {
          return {
            ...attrs,
            key: toString23(key, "base36")
          };
        },
        getAttributesFromYieldedValue: (value, attrs) => {
          return {
            ...attrs,
            peers: [...Array.isArray(attrs.peers) ? attrs.peers : [], value.id.toString()]
          };
        }
      }) ?? this.getClosestPeers;
    }
    [Symbol.toStringTag] = "@libp2p/peer-routing";
    /**
     * Iterates over all peer routers in parallel to find the given peer
     */
    async findPeer(id, options) {
      if (this.routers.length === 0) {
        throw new NoPeerRoutersError("No peer routers available");
      }
      if (id.toString() === this.peerId.toString()) {
        throw new QueriedForSelfError("Should not try to find self");
      }
      const self2 = this;
      const source = src_default2(...this.routers.filter((router) => router.findPeer instanceof Function).map((router) => (async function* () {
        try {
          yield await router.findPeer(id, options);
        } catch (err) {
          self2.log.error(err);
        }
      })()));
      for await (const peer of source) {
        if (peer == null) {
          continue;
        }
        if (peer.multiaddrs.length > 0) {
          await this.peerStore.merge(peer.id, {
            multiaddrs: peer.multiaddrs
          }, options);
        }
        return peer;
      }
      throw new NotFoundError();
    }
    /**
     * Attempt to find the closest peers on the network to the given key
     */
    async *getClosestPeers(key, options = {}) {
      if (this.routers.length === 0) {
        throw new NoPeerRoutersError("No peer routers available");
      }
      const self2 = this;
      const seen = createScalableCuckooFilter(1024);
      for await (const peer of parallel((async function* () {
        const source = src_default2(...self2.routers.filter((router) => router.getClosestPeers instanceof Function).map((router) => router.getClosestPeers(key, options)));
        for await (let peer2 of source) {
          yield async () => {
            if (peer2.multiaddrs.length === 0) {
              try {
                peer2 = await self2.findPeer(peer2.id, {
                  ...options,
                  useCache: false
                });
              } catch (err) {
                self2.log.error("could not find peer multiaddrs", err);
                return;
              }
            }
            return peer2;
          };
        }
      })())) {
        if (peer == null) {
          continue;
        }
        if (peer.multiaddrs.length > 0) {
          await this.peerStore.merge(peer.id, {
            multiaddrs: peer.multiaddrs
          }, options);
        }
        if (seen.has(peer.id.toMultihash().bytes)) {
          continue;
        }
        seen.add(peer.id.toMultihash().bytes);
        yield peer;
      }
    }
  };

  // ../node_modules/libp2p/dist/src/random-walk.js
  var RandomWalk = class extends TypedEventEmitter {
    peerRouting;
    log;
    walking;
    walkers;
    shutdownController;
    walkController;
    needNext;
    constructor(components) {
      super();
      this.log = components.logger.forComponent("libp2p:random-walk");
      this.peerRouting = components.peerRouting;
      this.walkers = 0;
      this.walking = false;
      this.shutdownController = new AbortController();
      setMaxListeners(Infinity, this.shutdownController.signal);
    }
    [Symbol.toStringTag] = "@libp2p/random-walk";
    start() {
      this.shutdownController = new AbortController();
      setMaxListeners(Infinity, this.shutdownController.signal);
    }
    stop() {
      this.shutdownController.abort();
    }
    async *walk(options) {
      if (!this.walking) {
        this.startWalk();
      }
      this.walkers++;
      const signal = anySignal([this.shutdownController.signal, options?.signal]);
      setMaxListeners(Infinity, signal);
      try {
        while (true) {
          this.needNext?.resolve();
          this.needNext = pDefer();
          const event = await raceEvent(this, "walk:peer", signal, {
            errorEvent: "walk:error"
          });
          yield event.detail;
        }
      } finally {
        signal.clear();
        this.walkers--;
        if (this.walkers === 0) {
          this.walkController?.abort();
          this.walkController = void 0;
        }
      }
    }
    startWalk() {
      this.walking = true;
      this.walkController = new AbortController();
      setMaxListeners(Infinity, this.walkController.signal);
      const signal = anySignal([this.walkController.signal, this.shutdownController.signal]);
      setMaxListeners(Infinity, signal);
      const start2 = Date.now();
      let found = 0;
      Promise.resolve().then(async () => {
        this.log("start walk");
        while (this.walkers > 0) {
          try {
            const data = randomBytes3(32);
            let s2 = Date.now();
            for await (const peer of this.peerRouting.getClosestPeers(data, { signal })) {
              if (signal.aborted) {
                this.log("aborting walk");
              }
              signal.throwIfAborted();
              this.log("found peer %p after %dms for %d walkers", peer.id, Date.now() - s2, this.walkers);
              found++;
              this.safeDispatchEvent("walk:peer", {
                detail: peer
              });
              if (this.walkers === 1 && this.needNext != null) {
                this.log("wait for need next");
                await raceSignal(this.needNext.promise, signal);
              }
              s2 = Date.now();
            }
            this.log("walk iteration for %b and %d walkers finished, found %d peers", data, this.walkers, found);
          } catch (err) {
            this.log.error("random walk errored", err);
            this.safeDispatchEvent("walk:error", {
              detail: err
            });
          }
        }
        this.log("no walkers left, ended walk");
      }).catch((err) => {
        this.log.error("random walk errored", err);
      }).finally(() => {
        this.log("finished walk, found %d peers after %dms", found, Date.now() - start2);
        this.walking = false;
      });
    }
  };

  // ../node_modules/libp2p/dist/src/registrar.js
  var DEFAULT_MAX_INBOUND_STREAMS = 32;
  var DEFAULT_MAX_OUTBOUND_STREAMS = 64;
  var Registrar = class {
    log;
    topologies;
    handlers;
    components;
    constructor(components) {
      this.components = components;
      this.log = components.logger.forComponent("libp2p:registrar");
      this.topologies = /* @__PURE__ */ new Map();
      components.metrics?.registerMetricGroup("libp2p_registrar_topologies", {
        calculate: () => {
          const output2 = {};
          for (const [key, value] of this.topologies) {
            output2[key] = value.size;
          }
          return output2;
        }
      });
      this.handlers = trackedMap({
        name: "libp2p_registrar_protocol_handlers",
        metrics: components.metrics
      });
      this._onDisconnect = this._onDisconnect.bind(this);
      this._onPeerUpdate = this._onPeerUpdate.bind(this);
      this._onPeerIdentify = this._onPeerIdentify.bind(this);
      this.components.events.addEventListener("peer:disconnect", this._onDisconnect);
      this.components.events.addEventListener("peer:update", this._onPeerUpdate);
      this.components.events.addEventListener("peer:identify", this._onPeerIdentify);
    }
    [Symbol.toStringTag] = "@libp2p/registrar";
    getProtocols() {
      return Array.from(/* @__PURE__ */ new Set([
        ...this.handlers.keys()
      ])).sort();
    }
    getHandler(protocol) {
      const handler = this.handlers.get(protocol);
      if (handler == null) {
        throw new UnhandledProtocolError(`No handler registered for protocol ${protocol}`);
      }
      return handler;
    }
    getTopologies(protocol) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        return [];
      }
      return [
        ...topologies.values()
      ];
    }
    /**
     * Registers the `handler` for each protocol
     */
    async handle(protocol, handler, opts) {
      if (this.handlers.has(protocol) && opts?.force !== true) {
        throw new DuplicateProtocolHandlerError(`Handler already registered for protocol ${protocol}`);
      }
      const options = mergeOptions.bind({ ignoreUndefined: true })({
        maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,
        maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS
      }, opts);
      this.handlers.set(protocol, {
        handler,
        options
      });
      await this.components.peerStore.merge(this.components.peerId, {
        protocols: [protocol]
      }, opts);
    }
    /**
     * Removes the handler for each protocol. The protocol
     * will no longer be supported on streams.
     */
    async unhandle(protocols2, options) {
      const protocolList = Array.isArray(protocols2) ? protocols2 : [protocols2];
      protocolList.forEach((protocol) => {
        this.handlers.delete(protocol);
      });
      await this.components.peerStore.patch(this.components.peerId, {
        protocols: this.getProtocols()
      }, options);
    }
    /**
     * Register handlers for a set of multicodecs given
     */
    async register(protocol, topology) {
      if (topology == null) {
        throw new InvalidParametersError("invalid topology");
      }
      const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
      let topologies = this.topologies.get(protocol);
      if (topologies == null) {
        topologies = /* @__PURE__ */ new Map();
        this.topologies.set(protocol, topologies);
      }
      topologies.set(id, topology);
      return id;
    }
    /**
     * Unregister topology
     */
    unregister(id) {
      for (const [protocol, topologies] of this.topologies.entries()) {
        if (topologies.has(id)) {
          topologies.delete(id);
          if (topologies.size === 0) {
            this.topologies.delete(protocol);
          }
        }
      }
    }
    /**
     * Remove a disconnected peer from the record
     */
    _onDisconnect(evt) {
      const remotePeer = evt.detail;
      const options = {
        signal: AbortSignal.timeout(5e3)
      };
      void this.components.peerStore.get(remotePeer, options).then((peer) => {
        for (const protocol of peer.protocols) {
          const topologies = this.topologies.get(protocol);
          if (topologies == null) {
            continue;
          }
          for (const topology of topologies.values()) {
            if (topology.filter?.has(remotePeer) === false) {
              continue;
            }
            topology.filter?.remove(remotePeer);
            topology.onDisconnect?.(remotePeer);
          }
        }
      }).catch((err) => {
        if (err.name === "NotFoundError") {
          return;
        }
        this.log.error("could not inform topologies of disconnecting peer %p", remotePeer, err);
      });
    }
    /**
     * When a peer is updated, if they have removed supported protocols notify any
     * topologies interested in the removed protocols.
     */
    _onPeerUpdate(evt) {
      const { peer, previous } = evt.detail;
      const removed = (previous?.protocols ?? []).filter((protocol) => !peer.protocols.includes(protocol));
      for (const protocol of removed) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          if (topology.filter?.has(peer.id) === false) {
            continue;
          }
          topology.filter?.remove(peer.id);
          topology.onDisconnect?.(peer.id);
        }
      }
    }
    /**
     * After identify has completed and we have received the list of supported
     * protocols, notify any topologies interested in those protocols.
     */
    _onPeerIdentify(evt) {
      const protocols2 = evt.detail.protocols;
      const connection = evt.detail.connection;
      const peerId2 = evt.detail.peerId;
      for (const protocol of protocols2) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          if (connection.limits != null && topology.notifyOnLimitedConnection !== true) {
            continue;
          }
          if (topology.filter?.has(peerId2) === true) {
            continue;
          }
          topology.filter?.add(peerId2);
          topology.onConnect?.(peerId2, connection);
        }
      }
    }
  };

  // ../node_modules/libp2p/dist/src/transport-manager.js
  var DefaultTransportManager = class {
    log;
    components;
    transports;
    listeners;
    faultTolerance;
    started;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:transports");
      this.components = components;
      this.started = false;
      this.transports = trackedMap({
        name: "libp2p_transport_manager_transports",
        metrics: this.components.metrics
      });
      this.listeners = trackedMap({
        name: "libp2p_transport_manager_listeners",
        metrics: this.components.metrics
      });
      this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL;
    }
    [Symbol.toStringTag] = "@libp2p/transport-manager";
    /**
     * Adds a `Transport` to the manager
     */
    add(transport) {
      const tag = transport[Symbol.toStringTag];
      if (tag == null) {
        throw new InvalidParametersError("Transport must have a valid tag");
      }
      if (this.transports.has(tag)) {
        throw new InvalidParametersError(`There is already a transport with the tag ${tag}`);
      }
      this.log("adding transport %s", tag);
      this.transports.set(tag, transport);
      if (!this.listeners.has(tag)) {
        this.listeners.set(tag, []);
      }
    }
    isStarted() {
      return this.started;
    }
    start() {
      this.started = true;
    }
    async afterStart() {
      const addrs = this.components.addressManager.getListenAddrs();
      await this.listen(addrs);
    }
    /**
     * Stops all listeners
     */
    async stop() {
      const tasks = [];
      for (const [key, listeners] of this.listeners) {
        this.log("closing listeners for %s", key);
        while (listeners.length > 0) {
          const listener = listeners.pop();
          if (listener == null) {
            continue;
          }
          tasks.push(listener.close());
        }
      }
      await Promise.all(tasks);
      this.log("all listeners closed");
      for (const key of this.listeners.keys()) {
        this.listeners.set(key, []);
      }
      this.started = false;
    }
    /**
     * Dials the given Multiaddr over it's supported transport
     */
    async dial(ma, options) {
      const transport = this.dialTransportForMultiaddr(ma);
      if (transport == null) {
        throw new TransportUnavailableError(`No transport available for address ${String(ma)}`);
      }
      options?.onProgress?.(new CustomProgressEvent("transport-manager:selected-transport", transport[Symbol.toStringTag]));
      return transport.dial(ma, {
        ...options,
        upgrader: this.components.upgrader
      });
    }
    /**
     * Returns all Multiaddr's the listeners are using
     */
    getAddrs() {
      let addrs = [];
      for (const listeners of this.listeners.values()) {
        for (const listener of listeners) {
          addrs = [...addrs, ...listener.getAddrs()];
        }
      }
      return addrs;
    }
    /**
     * Returns all the transports instances
     */
    getTransports() {
      return Array.of(...this.transports.values());
    }
    /**
     * Returns all the listener instances
     */
    getListeners() {
      return Array.of(...this.listeners.values()).flat();
    }
    /**
     * Finds a transport that matches the given Multiaddr
     */
    dialTransportForMultiaddr(ma) {
      for (const transport of this.transports.values()) {
        const addrs = transport.dialFilter([ma]);
        if (addrs.length > 0) {
          return transport;
        }
      }
    }
    /**
     * Finds a transport that matches the given Multiaddr
     */
    listenTransportForMultiaddr(ma) {
      for (const transport of this.transports.values()) {
        const addrs = transport.listenFilter([ma]);
        if (addrs.length > 0) {
          return transport;
        }
      }
    }
    /**
     * Starts listeners for each listen Multiaddr
     */
    async listen(addrs) {
      if (!this.isStarted()) {
        throw new NotStartedError("Not started");
      }
      if (addrs == null || addrs.length === 0) {
        this.log("no addresses were provided for listening, this node is dial only");
        return;
      }
      const listenStats = {
        errors: /* @__PURE__ */ new Map(),
        ipv4: {
          success: 0,
          attempts: 0
        },
        ipv6: {
          success: 0,
          attempts: 0
        }
      };
      addrs.forEach((ma) => {
        listenStats.errors.set(ma.toString(), new UnsupportedListenAddressError());
      });
      const tasks = [];
      for (const [key, transport] of this.transports.entries()) {
        const supportedAddrs = transport.listenFilter(addrs);
        for (const addr of supportedAddrs) {
          this.log("creating listener for %s on %a", key, addr);
          const listener = transport.createListener({
            upgrader: this.components.upgrader
          });
          let listeners = this.listeners.get(key) ?? [];
          if (listeners == null) {
            listeners = [];
            this.listeners.set(key, listeners);
          }
          listeners.push(listener);
          listener.addEventListener("listening", () => {
            this.components.events.safeDispatchEvent("transport:listening", {
              detail: listener
            });
          });
          listener.addEventListener("close", () => {
            const index = listeners.findIndex((l) => l === listener);
            listeners.splice(index, 1);
            this.components.events.safeDispatchEvent("transport:close", {
              detail: listener
            });
          });
          if (IP4.matches(addr)) {
            listenStats.ipv4.attempts++;
          } else if (IP6.matches(addr)) {
            listenStats.ipv6.attempts++;
          }
          tasks.push(listener.listen(addr).then(() => {
            listenStats.errors.delete(addr.toString());
            if (IP4.matches(addr)) {
              listenStats.ipv4.success++;
            }
            if (IP6.matches(addr)) {
              listenStats.ipv6.success++;
            }
          }, (err) => {
            this.log.error("transport %s could not listen on address %a - %e", key, addr, err);
            listenStats.errors.set(addr.toString(), err);
            throw err;
          }));
        }
      }
      const results = await Promise.allSettled(tasks);
      if (results.length > 0 && results.every((res) => res.status === "fulfilled")) {
        return;
      }
      if (this.ipv6Unsupported(listenStats)) {
        this.log("all IPv4 addresses succeed but all IPv6 failed");
        return;
      }
      if (this.faultTolerance === FaultTolerance.NO_FATAL) {
        this.log("failed to listen on any address but fault tolerance allows this");
        return;
      }
      throw new UnsupportedListenAddressesError(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...listenStats.errors.entries()].map(([addr, err]) => {
        return `
  ${addr}: ${`${err.stack ?? err}`.split("\n").join("\n  ")}
`;
      }).join("")}`);
    }
    ipv6Unsupported(listenStats) {
      if (listenStats.ipv4.attempts === 0 || listenStats.ipv6.attempts === 0) {
        return false;
      }
      const allIpv4Succeeded = listenStats.ipv4.attempts === listenStats.ipv4.success;
      const allIpv6Failed = listenStats.ipv6.success === 0;
      return allIpv4Succeeded && allIpv6Failed;
    }
    /**
     * Removes the given transport from the manager.
     * If a transport has any running listeners, they will be closed.
     */
    async remove(key) {
      const listeners = this.listeners.get(key) ?? [];
      this.log.trace("removing transport %s", key);
      const tasks = [];
      this.log.trace("closing listeners for %s", key);
      while (listeners.length > 0) {
        const listener = listeners.pop();
        if (listener == null) {
          continue;
        }
        tasks.push(listener.close());
      }
      await Promise.all(tasks);
      this.transports.delete(key);
      this.listeners.delete(key);
    }
    /**
     * Removes all transports from the manager.
     * If any listeners are running, they will be closed.
     *
     * @async
     */
    async removeAll() {
      const tasks = [];
      for (const key of this.transports.keys()) {
        tasks.push(this.remove(key));
      }
      await Promise.all(tasks);
    }
  };

  // ../node_modules/@libp2p/multistream-select/dist/src/constants.js
  var PROTOCOL_ID = "/multistream/1.0.0";
  var MAX_PROTOCOL_LENGTH = 1024;

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports15 = {};
  __export(base10_exports15, {
    base10: () => base1015
  });

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bytes.js
  var empty19 = new Uint8Array(0);
  function equals42(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce19(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function fromString28(str) {
    return new TextEncoder().encode(str);
  }
  function toString24(b) {
    return new TextDecoder().decode(b);
  }

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/vendor/base-x.js
  function base33(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src19 = base33;
  var _brrp__multiformats_scope_baseX19 = src19;
  var base_x_default19 = _brrp__multiformats_scope_baseX19;

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base.js
  var Encoder21 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder21 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or21(this, decoder);
    }
  };
  var ComposedDecoder19 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or21(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or21(left, right) {
    return new ComposedDecoder19({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec19 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder21(name19, prefix, baseEncode);
      this.decoder = new Decoder21(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from33({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec19(name19, prefix, encode79, decode99);
  }
  function baseX19({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default19(alphabet18, name19);
    return from33({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce19(decode99(text))
    });
  }
  function decode83(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode66(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx18(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc464818({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx18(alphabet18);
    return from33({
      prefix,
      name: name19,
      encode(input) {
        return encode66(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode83(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base10.js
  var base1015 = baseX19({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports15 = {};
  __export(base16_exports15, {
    base16: () => base1615,
    base16upper: () => base16upper15
  });
  var base1615 = rfc464818({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper15 = rfc464818({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports15 = {};
  __export(base2_exports15, {
    base2: () => base215
  });
  var base215 = rfc464818({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports15 = {};
  __export(base256emoji_exports15, {
    base256emoji: () => base256emoji15
  });
  var alphabet15 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars15 = alphabet15.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes15 = alphabet15.reduce((p, c, i) => {
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
  }, []);
  function encode67(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars15[c];
      return p;
    }, "");
  }
  function decode84(str) {
    const byts = [];
    for (const char of str) {
      const codePoint = char.codePointAt(0);
      if (codePoint == null) {
        throw new Error(`Invalid character: ${char}`);
      }
      const byt = alphabetCharsToBytes15[codePoint];
      if (byt == null) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji15 = from33({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode67,
    decode: decode84
  });

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports15 = {};
  __export(base32_exports15, {
    base32: () => base3217,
    base32hex: () => base32hex17,
    base32hexpad: () => base32hexpad17,
    base32hexpadupper: () => base32hexpadupper17,
    base32hexupper: () => base32hexupper17,
    base32pad: () => base32pad17,
    base32padupper: () => base32padupper17,
    base32upper: () => base32upper17,
    base32z: () => base32z17
  });
  var base3217 = rfc464818({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper17 = rfc464818({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad17 = rfc464818({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper17 = rfc464818({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex17 = rfc464818({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper17 = rfc464818({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad17 = rfc464818({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper17 = rfc464818({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z17 = rfc464818({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports15 = {};
  __export(base36_exports15, {
    base36: () => base3616,
    base36upper: () => base36upper16
  });
  var base3616 = baseX19({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper16 = baseX19({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports15 = {};
  __export(base58_exports15, {
    base58btc: () => base58btc19,
    base58flickr: () => base58flickr19
  });
  var base58btc19 = baseX19({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr19 = baseX19({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports15 = {};
  __export(base64_exports15, {
    base64: () => base6417,
    base64pad: () => base64pad17,
    base64url: () => base64url17,
    base64urlpad: () => base64urlpad17
  });
  var base6417 = rfc464818({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad17 = rfc464818({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url17 = rfc464818({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad17 = rfc464818({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports15 = {};
  __export(base8_exports15, {
    base8: () => base815
  });
  var base815 = rfc464818({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports29 = {};
  __export(identity_exports29, {
    identity: () => identity29
  });
  var identity29 = from33({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString24(buf),
    decode: (str) => fromString28(str)
  });

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/codecs/json.js
  var textEncoder15 = new TextEncoder();
  var textDecoder15 = new TextDecoder();

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports30 = {};
  __export(identity_exports30, {
    identity: () => identity30
  });

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_117 = encode68;
  var MSB19 = 128;
  var REST19 = 127;
  var MSBALL17 = ~REST19;
  var INT17 = Math.pow(2, 31);
  function encode68(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT17) {
      out[offset++] = num & 255 | MSB19;
      num /= 128;
    }
    while (num & MSBALL17) {
      out[offset++] = num & 255 | MSB19;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode68.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode85 = read18;
  var MSB$117 = 128;
  var REST$117 = 127;
  function read18(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read18.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$117) << shift : (b & REST$117) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$117);
    read18.bytes = counter - offset;
    return res;
  }
  var N118 = Math.pow(2, 7);
  var N218 = Math.pow(2, 14);
  var N318 = Math.pow(2, 21);
  var N418 = Math.pow(2, 28);
  var N518 = Math.pow(2, 35);
  var N618 = Math.pow(2, 42);
  var N718 = Math.pow(2, 49);
  var N817 = Math.pow(2, 56);
  var N917 = Math.pow(2, 63);
  var length18 = function(value) {
    return value < N118 ? 1 : value < N218 ? 2 : value < N318 ? 3 : value < N418 ? 4 : value < N518 ? 5 : value < N618 ? 6 : value < N718 ? 7 : value < N817 ? 8 : value < N917 ? 9 : 10;
  };
  var varint17 = {
    encode: encode_117,
    decode: decode85,
    encodingLength: length18
  };
  var _brrp_varint17 = varint17;
  var varint_default17 = _brrp_varint17;

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/varint.js
  function decode86(data, offset = 0) {
    const code18 = varint_default17.decode(data, offset);
    return [code18, varint_default17.decode.bytes];
  }
  function encodeTo17(int, target, offset = 0) {
    varint_default17.encode(int, target, offset);
    return target;
  }
  function encodingLength18(int) {
    return varint_default17.encodingLength(int);
  }

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/hashes/digest.js
  function create16(code18, digest18) {
    const size = digest18.byteLength;
    const sizeOffset = encodingLength18(code18);
    const digestOffset = sizeOffset + encodingLength18(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo17(code18, bytes2, 0);
    encodeTo17(size, bytes2, sizeOffset);
    bytes2.set(digest18, digestOffset);
    return new Digest17(code18, size, digest18, bytes2);
  }
  function decode87(multihash) {
    const bytes2 = coerce19(multihash);
    const [code18, sizeOffset] = decode86(bytes2);
    const [size, digestOffset] = decode86(bytes2.subarray(sizeOffset));
    const digest18 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest18.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest17(code18, size, digest18, bytes2);
  }
  function equals43(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals42(a.bytes, data.bytes);
    }
  }
  var Digest17 = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code18, size, digest18, bytes2) {
      this.code = code18;
      this.size = size;
      this.digest = digest18;
      this.bytes = bytes2;
    }
  };

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/hashes/identity.js
  var code15 = 0;
  var name15 = "identity";
  var encode69 = coerce19;
  function digest15(input) {
    return create16(code15, encode69(input));
  }
  var identity30 = { code: code15, name: name15, encode: encode69, digest: digest15 };

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports15 = {};
  __export(sha2_browser_exports15, {
    sha256: () => sha25618,
    sha512: () => sha51217
  });

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/hashes/hasher.js
  function from34({ name: name19, code: code18, encode: encode79 }) {
    return new Hasher15(name19, code18, encode79);
  }
  var Hasher15 = class {
    name;
    code;
    encode;
    constructor(name19, code18, encode79) {
      this.name = name19;
      this.code = code18;
      this.encode = encode79;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create16(this.code, result) : result.then((digest18) => create16(this.code, digest18));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  function sha15(name19) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name19, data));
  }
  var sha25618 = from34({
    name: "sha2-256",
    code: 18,
    encode: sha15("SHA-256")
  });
  var sha51217 = from34({
    name: "sha2-512",
    code: 19,
    encode: sha15("SHA-512")
  });

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/cid.js
  function format16(link, base37) {
    const { bytes: bytes2, version: version5 } = link;
    switch (version5) {
      case 0:
        return toStringV016(bytes2, baseCache16(link), base37 ?? base58btc19.encoder);
      default:
        return toStringV116(bytes2, baseCache16(link), base37 ?? base3217.encoder);
    }
  }
  var cache17 = /* @__PURE__ */ new WeakMap();
  function baseCache16(cid) {
    const baseCache19 = cache17.get(cid);
    if (baseCache19 == null) {
      const baseCache20 = /* @__PURE__ */ new Map();
      cache17.set(cid, baseCache20);
      return baseCache20;
    }
    return baseCache19;
  }
  var CID16 = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version5, code18, multihash, bytes2) {
      this.code = code18;
      this.version = version5;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code18, multihash } = this;
          if (code18 !== DAG_PB_CODE16) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE16) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code18, digest: digest18 } = this.multihash;
          const multihash = create16(code18, digest18);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals43(self2.multihash, unknown.multihash);
    }
    toString(base37) {
      return format16(this, base37);
    }
    toJSON() {
      return { "/": format16(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version5, code: code18, multihash, bytes: bytes2 } = value;
        return new _CID(version5, code18, multihash, bytes2 ?? encodeCID16(version5, code18, multihash.bytes));
      } else if (value[cidSymbol16] === true) {
        const { version: version5, multihash, code: code18 } = value;
        const digest18 = decode87(multihash);
        return _CID.create(version5, code18, digest18);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version5, code18, digest18) {
      if (typeof code18 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest18.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version5) {
        case 0: {
          if (code18 !== DAG_PB_CODE16) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE16}) block encoding`);
          } else {
            return new _CID(version5, code18, digest18, digest18.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID16(version5, code18, digest18.bytes);
          return new _CID(version5, code18, digest18, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest18) {
      return _CID.create(0, DAG_PB_CODE16, digest18);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code18, digest18) {
      return _CID.create(1, code18, digest18);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes2) {
      const [cid, remainder] = _CID.decodeFirst(bytes2);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes2) {
      const specs = _CID.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce19(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest18 = new Digest17(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest18) : _CID.createV1(specs.codec, digest18);
      return [cid, bytes2.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length21] = decode86(initialBytes.subarray(offset));
        offset += length21;
        return i;
      };
      let version5 = next();
      let codec = DAG_PB_CODE16;
      if (version5 === 18) {
        version5 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version5 !== 0 && version5 !== 1) {
        throw new RangeError(`Invalid CID version ${version5}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version5, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base37) {
      const [prefix, bytes2] = parseCIDtoBytes16(source, base37);
      const cid = _CID.decode(bytes2);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache16(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes16(source, base37) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base37 ?? base58btc19;
        return [
          base58btc19.prefix,
          decoder.decode(`${base58btc19.prefix}${source}`)
        ];
      }
      case base58btc19.prefix: {
        const decoder = base37 ?? base58btc19;
        return [base58btc19.prefix, decoder.decode(source)];
      }
      case base3217.prefix: {
        const decoder = base37 ?? base3217;
        return [base3217.prefix, decoder.decode(source)];
      }
      case base3616.prefix: {
        const decoder = base37 ?? base3616;
        return [base3616.prefix, decoder.decode(source)];
      }
      default: {
        if (base37 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base37.decode(source)];
      }
    }
  }
  function toStringV016(bytes2, cache20, base37) {
    const { prefix } = base37;
    if (prefix !== base58btc19.prefix) {
      throw Error(`Cannot string encode V0 in ${base37.name} encoding`);
    }
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2).slice(1);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV116(bytes2, cache20, base37) {
    const { prefix } = base37;
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE16 = 112;
  var SHA_256_CODE16 = 18;
  function encodeCID16(version5, code18, multihash) {
    const codeOffset = encodingLength18(version5);
    const hashOffset = codeOffset + encodingLength18(code18);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo17(version5, bytes2, 0);
    encodeTo17(code18, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  }
  var cidSymbol16 = Symbol.for("@ipld/js-cid/CID");

  // ../node_modules/@libp2p/multistream-select/node_modules/multiformats/dist/src/basics.js
  var bases15 = { ...identity_exports29, ...base2_exports15, ...base8_exports15, ...base10_exports15, ...base16_exports15, ...base32_exports15, ...base36_exports15, ...base58_exports15, ...base64_exports15, ...base256emoji_exports15 };
  var hashes15 = { ...sha2_browser_exports15, ...identity_exports30 };

  // ../node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/alloc.js
  function allocUnsafe19(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec16(name19, prefix, encode79, decode99) {
    return {
      name: name19,
      prefix,
      encoder: {
        name: name19,
        prefix,
        encode: encode79
      },
      decoder: {
        decode: decode99
      }
    };
  }
  var string16 = createCodec16("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder3 = new TextEncoder();
    return encoder3.encode(str.substring(1));
  });
  var ascii15 = createCodec16("ascii", "a", (buf) => {
    let string19 = "a";
    for (let i = 0; i < buf.length; i++) {
      string19 += String.fromCharCode(buf[i]);
    }
    return string19;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe19(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  var BASES15 = {
    utf8: string16,
    "utf-8": string16,
    hex: bases15.base16,
    latin1: ascii15,
    ascii: ascii15,
    binary: ascii15,
    ...bases15
  };
  var bases_default15 = BASES15;

  // ../node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/from-string.js
  function fromString29(string19, encoding = "utf8") {
    const base37 = bases_default15[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.decoder.decode(`${base37.prefix}${string19}`);
  }

  // ../node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/to-string.js
  function toString25(array, encoding = "utf8") {
    const base37 = bases_default15[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.encoder.encode(array).substring(1);
  }

  // ../node_modules/@libp2p/multistream-select/dist/src/multistream.js
  var NewLine = fromString29("\n");
  async function write2(writer, buffer, options) {
    await writer.write(buffer, options);
  }
  async function writeAll(writer, buffers, options) {
    await writer.writeV(buffers, options);
  }
  async function read19(reader, options) {
    const buf = await reader.read(options);
    if (buf.byteLength === 0 || buf.get(buf.byteLength - 1) !== NewLine[0]) {
      options.log.error("Invalid mss message - missing newline", buf);
      throw new InvalidMessageError("Missing newline");
    }
    return buf.sublist(0, -1);
  }
  async function readString(reader, options) {
    const buf = await read19(reader, options);
    return toString25(buf.subarray());
  }

  // ../node_modules/@libp2p/multistream-select/dist/src/select.js
  async function select(stream, protocols2, options) {
    protocols2 = Array.isArray(protocols2) ? [...protocols2] : [protocols2];
    if (protocols2.length === 1 && options.negotiateFully === false) {
      return optimisticSelect(stream, protocols2[0], options);
    }
    const lp = lpStream(stream, {
      ...options,
      maxDataLength: MAX_PROTOCOL_LENGTH
    });
    const protocol = protocols2.shift();
    if (protocol == null) {
      throw new Error("At least one protocol must be specified");
    }
    options.log.trace('select: write ["%s", "%s"]', PROTOCOL_ID, protocol);
    const p1 = fromString29(`${PROTOCOL_ID}
`);
    const p2 = fromString29(`${protocol}
`);
    await writeAll(lp, [p1, p2], options);
    options.log.trace("select: reading multistream-select header");
    let response = await readString(lp, options);
    options.log.trace('select: read "%s"', response);
    if (response === PROTOCOL_ID) {
      options.log.trace("select: reading protocol response");
      response = await readString(lp, options);
      options.log.trace('select: read "%s"', response);
    }
    if (response === protocol) {
      return { stream: lp.unwrap(), protocol };
    }
    for (const protocol2 of protocols2) {
      options.log.trace('select: write "%s"', protocol2);
      await write2(lp, fromString29(`${protocol2}
`), options);
      options.log.trace("select: reading protocol response");
      const response2 = await readString(lp, options);
      options.log.trace('select: read "%s" for "%s"', response2, protocol2);
      if (response2 === protocol2) {
        return { stream: lp.unwrap(), protocol: protocol2 };
      }
    }
    throw new UnsupportedProtocolError("protocol selection failed");
  }
  function optimisticSelect(stream, protocol, options) {
    const originalSink = stream.sink.bind(stream);
    const originalSource = stream.source;
    let negotiated = false;
    let negotiating = false;
    const doneNegotiating = pDefer();
    let sentProtocol = false;
    let sendingProtocol = false;
    const doneSendingProtocol = pDefer();
    let readProtocol = false;
    let readingProtocol = false;
    const doneReadingProtocol = pDefer();
    const lp = lpStream({
      sink: originalSink,
      source: originalSource
    }, {
      ...options,
      maxDataLength: MAX_PROTOCOL_LENGTH
    });
    stream.sink = async (source) => {
      const { sink } = lp.unwrap();
      await sink((async function* () {
        let sentData = false;
        for await (const buf of source) {
          if (sendingProtocol) {
            await doneSendingProtocol.promise;
          }
          if (!sentProtocol) {
            sendingProtocol = true;
            options.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength);
            const protocolString = `${protocol}
`;
            yield new Uint8ArrayList(
              Uint8Array.from([19]),
              // length of PROTOCOL_ID plus newline
              fromString29(`${PROTOCOL_ID}
`),
              encode(protocolString.length),
              fromString29(protocolString),
              buf
            ).subarray();
            options.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength);
            sentProtocol = true;
            sendingProtocol = false;
            doneSendingProtocol.resolve();
            negotiate().catch((err) => {
              options.log.error("could not finish optimistic protocol negotiation of %s", protocol, err);
            });
          } else {
            yield buf;
          }
          sentData = true;
        }
        if (!sentData) {
          await negotiate();
        }
      })());
    };
    async function negotiate() {
      if (negotiating) {
        options.log.trace("optimistic: already negotiating %s stream", protocol);
        await doneNegotiating.promise;
        return;
      }
      negotiating = true;
      try {
        if (!sentProtocol) {
          options.log.trace("optimistic: doing send protocol for %s stream", protocol);
          await doSendProtocol();
        }
        if (!readProtocol) {
          options.log.trace("optimistic: doing read protocol for %s stream", protocol);
          await doReadProtocol();
        }
      } finally {
        negotiating = false;
        negotiated = true;
        doneNegotiating.resolve();
      }
    }
    async function doSendProtocol() {
      if (sendingProtocol) {
        await doneSendingProtocol.promise;
        return;
      }
      sendingProtocol = true;
      try {
        options.log.trace('optimistic: write ["%s", "%s", data] in source', PROTOCOL_ID, protocol);
        await lp.writeV([
          fromString29(`${PROTOCOL_ID}
`),
          fromString29(`${protocol}
`)
        ]);
        options.log.trace('optimistic: wrote ["%s", "%s", data] in source', PROTOCOL_ID, protocol);
      } finally {
        sentProtocol = true;
        sendingProtocol = false;
        doneSendingProtocol.resolve();
      }
    }
    async function doReadProtocol() {
      if (readingProtocol) {
        await doneReadingProtocol.promise;
        return;
      }
      readingProtocol = true;
      try {
        options.log.trace("optimistic: reading multistream select header");
        let response = await readString(lp, options);
        options.log.trace('optimistic: read multistream select header "%s"', response);
        if (response === PROTOCOL_ID) {
          response = await readString(lp, options);
        }
        options.log.trace('optimistic: read protocol "%s", expecting "%s"', response, protocol);
        if (response !== protocol) {
          throw new UnsupportedProtocolError("protocol selection failed");
        }
      } finally {
        readProtocol = true;
        readingProtocol = false;
        doneReadingProtocol.resolve();
      }
    }
    stream.source = (async function* () {
      await negotiate();
      options.log.trace('optimistic: reading data from "%s" stream', protocol);
      yield* lp.unwrap().source;
    })();
    if (stream.closeRead != null) {
      const originalCloseRead = stream.closeRead.bind(stream);
      stream.closeRead = async (opts) => {
        if (!negotiated) {
          await negotiate().catch((err) => {
            options.log.error("could not negotiate protocol before close read", err);
          });
        }
        await originalCloseRead(opts);
      };
    }
    if (stream.closeWrite != null) {
      const originalCloseWrite = stream.closeWrite.bind(stream);
      stream.closeWrite = async (opts) => {
        if (!negotiated) {
          await negotiate().catch((err) => {
            options.log.error("could not negotiate protocol before close write", err);
          });
        }
        await originalCloseWrite(opts);
      };
    }
    if (stream.close != null) {
      const originalClose = stream.close.bind(stream);
      stream.close = async (opts) => {
        const tasks = [];
        if (sendingProtocol) {
          tasks.push(doneSendingProtocol.promise);
        }
        if (readingProtocol) {
          tasks.push(doneReadingProtocol.promise);
        }
        if (tasks.length > 0) {
          await raceSignal(Promise.all(tasks), opts?.signal);
        } else {
          negotiated = true;
          negotiating = false;
          doneNegotiating.resolve();
        }
        await originalClose(opts);
      };
    }
    return {
      stream,
      protocol
    };
  }

  // ../node_modules/@libp2p/multistream-select/dist/src/handle.js
  async function handle(stream, protocols2, options) {
    protocols2 = Array.isArray(protocols2) ? protocols2 : [protocols2];
    options.log.trace("handle: available protocols %s", protocols2);
    const lp = lpStream(stream, {
      ...options,
      maxDataLength: MAX_PROTOCOL_LENGTH,
      maxLengthLength: 2
      // 2 bytes is enough to length-prefix MAX_PROTOCOL_LENGTH
    });
    while (true) {
      options.log.trace("handle: reading incoming string");
      const protocol = await readString(lp, options);
      options.log.trace('handle: read "%s"', protocol);
      if (protocol === PROTOCOL_ID) {
        options.log.trace('handle: respond with "%s" for "%s"', PROTOCOL_ID, protocol);
        await write2(lp, fromString29(`${PROTOCOL_ID}
`), options);
        options.log.trace('handle: responded with "%s" for "%s"', PROTOCOL_ID, protocol);
        continue;
      }
      if (protocols2.includes(protocol)) {
        options.log.trace('handle: respond with "%s" for "%s"', protocol, protocol);
        await write2(lp, fromString29(`${protocol}
`), options);
        options.log.trace('handle: responded with "%s" for "%s"', protocol, protocol);
        return { stream: lp.unwrap(), protocol };
      }
      if (protocol === "ls") {
        const protos = new Uint8ArrayList(...protocols2.map((p) => encode23.single(fromString29(`${p}
`))), fromString29("\n"));
        options.log.trace('handle: respond with "%s" for %s', protocols2, protocol);
        await write2(lp, protos, options);
        options.log.trace('handle: responded with "%s" for %s', protocols2, protocol);
        continue;
      }
      options.log.trace('handle: respond with "na" for "%s"', protocol);
      await write2(lp, fromString29("na\n"), options);
      options.log('handle: responded with "na" for "%s"', protocol);
    }
  }

  // ../node_modules/libp2p/dist/src/connection/index.js
  var CLOSE_TIMEOUT3 = 500;
  var ConnectionImpl = class {
    /**
     * Connection identifier.
     */
    id;
    /**
     * Observed multiaddr of the remote peer
     */
    remoteAddr;
    /**
     * Remote peer id
     */
    remotePeer;
    direction;
    timeline;
    multiplexer;
    encryption;
    status;
    limits;
    log;
    /**
     * User provided tags
     *
     */
    tags;
    /**
     * Reference to the new stream function of the multiplexer
     */
    _newStream;
    /**
     * Reference to the close function of the raw connection
     */
    _close;
    _abort;
    /**
     * Reference to the getStreams function of the muxer
     */
    _getStreams;
    /**
     * An implementation of the js-libp2p connection.
     * Any libp2p transport should use an upgrader to return this connection.
     */
    constructor(init) {
      const { remoteAddr, remotePeer, newStream, close, abort, getStreams } = init;
      this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
      this.remoteAddr = remoteAddr;
      this.remotePeer = remotePeer;
      this.direction = init.direction;
      this.status = "open";
      this.timeline = init.timeline;
      this.multiplexer = init.multiplexer;
      this.encryption = init.encryption;
      this.limits = init.limits;
      this.log = init.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`);
      if (this.remoteAddr.getPeerId() == null) {
        this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`);
      }
      this._newStream = newStream;
      this._close = close;
      this._abort = abort;
      this._getStreams = getStreams;
      this.tags = [];
    }
    [Symbol.toStringTag] = "Connection";
    [connectionSymbol] = true;
    /**
     * Get all the streams of the muxer
     */
    get streams() {
      return this._getStreams();
    }
    /**
     * Create a new stream from this connection
     */
    async newStream(protocols2, options) {
      if (this.status === "closing") {
        throw new ConnectionClosingError("the connection is being closed");
      }
      if (this.status === "closed") {
        throw new ConnectionClosedError("the connection is closed");
      }
      if (!Array.isArray(protocols2)) {
        protocols2 = [protocols2];
      }
      if (this.limits != null && options?.runOnLimitedConnection !== true) {
        throw new LimitedConnectionError("Cannot open protocol stream on limited connection");
      }
      const stream = await this._newStream(protocols2, options);
      stream.direction = "outbound";
      return stream;
    }
    /**
     * Close the connection
     */
    async close(options = {}) {
      if (this.status === "closed" || this.status === "closing") {
        return;
      }
      this.log("closing connection to %a", this.remoteAddr);
      this.status = "closing";
      if (options.signal == null) {
        const signal = AbortSignal.timeout(CLOSE_TIMEOUT3);
        setMaxListeners(Infinity, signal);
        options = {
          ...options,
          signal
        };
      }
      try {
        this.log.trace("closing underlying transport");
        await this._close(options);
        this.log.trace("updating timeline with close time");
        this.status = "closed";
        this.timeline.close = Date.now();
      } catch (err) {
        this.log.error("error encountered during graceful close of connection to %a", this.remoteAddr, err);
        this.abort(err);
      }
    }
    abort(err) {
      if (this.status === "closed") {
        return;
      }
      this.log.error("aborting connection to %a due to error", this.remoteAddr, err);
      this.status = "closing";
      this._abort(err);
      this.status = "closed";
      this.timeline.close = Date.now();
    }
  };
  function createConnection(init) {
    return new ConnectionImpl(init);
  }

  // ../node_modules/libp2p/dist/src/upgrader.js
  function findIncomingStreamLimit(protocol, registrar) {
    try {
      const { options } = registrar.getHandler(protocol);
      return options.maxInboundStreams;
    } catch (err) {
      if (err.name !== "UnhandledProtocolError") {
        throw err;
      }
    }
    return DEFAULT_MAX_INBOUND_STREAMS;
  }
  function findOutgoingStreamLimit(protocol, registrar, options = {}) {
    try {
      const { options: options2 } = registrar.getHandler(protocol);
      if (options2.maxOutboundStreams != null) {
        return options2.maxOutboundStreams;
      }
    } catch (err) {
      if (err.name !== "UnhandledProtocolError") {
        throw err;
      }
    }
    return options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;
  }
  function countStreams(protocol, direction, connection) {
    let streamCount = 0;
    connection.streams.forEach((stream) => {
      if (stream.direction === direction && stream.protocol === protocol) {
        streamCount++;
      }
    });
    return streamCount;
  }
  var Upgrader = class {
    components;
    connectionEncrypters;
    streamMuxers;
    inboundUpgradeTimeout;
    inboundStreamProtocolNegotiationTimeout;
    outboundStreamProtocolNegotiationTimeout;
    events;
    metrics;
    constructor(components, init) {
      this.components = components;
      this.connectionEncrypters = trackedMap({
        name: "libp2p_upgrader_connection_encrypters",
        metrics: this.components.metrics
      });
      init.connectionEncrypters.forEach((encrypter) => {
        this.connectionEncrypters.set(encrypter.protocol, encrypter);
      });
      this.streamMuxers = trackedMap({
        name: "libp2p_upgrader_stream_multiplexers",
        metrics: this.components.metrics
      });
      init.streamMuxers.forEach((muxer) => {
        this.streamMuxers.set(muxer.protocol, muxer);
      });
      this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT;
      this.inboundStreamProtocolNegotiationTimeout = init.inboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
      this.outboundStreamProtocolNegotiationTimeout = init.outboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
      this.events = components.events;
      this.metrics = {
        dials: components.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),
        errors: components.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),
        inboundErrors: components.metrics?.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),
        outboundErrors: components.metrics?.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")
      };
    }
    [Symbol.toStringTag] = "@libp2p/upgrader";
    async shouldBlockConnection(method, ...args) {
      const denyOperation = this.components.connectionGater[method];
      if (denyOperation == null) {
        return;
      }
      const result = await denyOperation.apply(this.components.connectionGater, args);
      if (result === true) {
        throw new ConnectionInterceptedError(`The multiaddr connection is blocked by gater.${method}`);
      }
    }
    createInboundAbortSignal(signal) {
      const output2 = anySignal([
        AbortSignal.timeout(this.inboundUpgradeTimeout),
        signal
      ]);
      setMaxListeners(Infinity, output2);
      return output2;
    }
    /**
     * Upgrades an inbound connection
     */
    async upgradeInbound(maConn, opts) {
      let accepted = false;
      const signal = this.createInboundAbortSignal(opts.signal);
      try {
        this.metrics.dials?.increment({
          inbound: true
        });
        accepted = await raceSignal(this.components.connectionManager.acceptIncomingConnection(maConn), signal);
        if (!accepted) {
          throw new ConnectionDeniedError("Connection denied");
        }
        await raceSignal(this.shouldBlockConnection("denyInboundConnection", maConn), signal);
        await this._performUpgrade(maConn, "inbound", {
          ...opts,
          signal
        });
      } catch (err) {
        this.metrics.errors?.increment({
          inbound: true
        });
        this.metrics.inboundErrors?.increment({
          [err.name ?? "Error"]: true
        });
        throw err;
      } finally {
        signal.clear();
        if (accepted) {
          this.components.connectionManager.afterUpgradeInbound();
        }
      }
    }
    /**
     * Upgrades an outbound connection
     */
    async upgradeOutbound(maConn, opts) {
      try {
        this.metrics.dials?.increment({
          outbound: true
        });
        const idStr = maConn.remoteAddr.getPeerId();
        let remotePeerId;
        if (idStr != null) {
          remotePeerId = peerIdFromString(idStr);
          await raceSignal(this.shouldBlockConnection("denyOutboundConnection", remotePeerId, maConn), opts.signal);
        }
        let direction = "outbound";
        if (opts.initiator === false) {
          direction = "inbound";
        }
        return await this._performUpgrade(maConn, direction, opts);
      } catch (err) {
        this.metrics.errors?.increment({
          outbound: true
        });
        this.metrics.outboundErrors?.increment({
          [err.name ?? "Error"]: true
        });
        throw err;
      }
    }
    async _performUpgrade(maConn, direction, opts) {
      let encryptedConn;
      let remotePeer;
      let upgradedConn;
      let muxerFactory;
      let cryptoProtocol;
      this.components.metrics?.trackMultiaddrConnection(maConn);
      maConn.log.trace("starting the %s connection upgrade", direction);
      let protectedConn = maConn;
      if (opts?.skipProtection !== true) {
        const protector = this.components.connectionProtector;
        if (protector != null) {
          maConn.log("protecting the %s connection", direction);
          protectedConn = await protector.protect(maConn, opts);
        }
      }
      try {
        encryptedConn = protectedConn;
        if (opts?.skipEncryption !== true) {
          opts?.onProgress?.(new CustomProgressEvent(`upgrader:encrypt-${direction}-connection`));
          ({
            conn: encryptedConn,
            remotePeer,
            protocol: cryptoProtocol,
            streamMuxer: muxerFactory
          } = await (direction === "inbound" ? this._encryptInbound(protectedConn, opts) : this._encryptOutbound(protectedConn, opts)));
          const maConn2 = {
            ...protectedConn,
            ...encryptedConn
          };
          await this.shouldBlockConnection(direction === "inbound" ? "denyInboundEncryptedConnection" : "denyOutboundEncryptedConnection", remotePeer, maConn2);
        } else {
          const idStr = maConn.remoteAddr.getPeerId();
          if (idStr == null) {
            throw new InvalidMultiaddrError(`${direction} connection that skipped encryption must have a peer id`);
          }
          const remotePeerId = peerIdFromString(idStr);
          cryptoProtocol = "native";
          remotePeer = remotePeerId;
        }
        if (remotePeer.equals(this.components.peerId)) {
          const err = new InvalidPeerIdError("Can not dial self");
          maConn.abort(err);
          throw err;
        }
        upgradedConn = encryptedConn;
        if (opts?.muxerFactory != null) {
          muxerFactory = opts.muxerFactory;
        } else if (muxerFactory == null && this.streamMuxers.size > 0) {
          opts?.onProgress?.(new CustomProgressEvent(`upgrader:multiplex-${direction}-connection`));
          const multiplexed = await (direction === "inbound" ? this._multiplexInbound({
            ...protectedConn,
            ...encryptedConn
          }, this.streamMuxers, opts) : this._multiplexOutbound({
            ...protectedConn,
            ...encryptedConn
          }, this.streamMuxers, opts));
          muxerFactory = multiplexed.muxerFactory;
          upgradedConn = multiplexed.stream;
        }
      } catch (err) {
        maConn.log.error("failed to upgrade inbound connection %s %a - %e", direction === "inbound" ? "from" : "to", maConn.remoteAddr, err);
        throw err;
      }
      await this.shouldBlockConnection(direction === "inbound" ? "denyInboundUpgradedConnection" : "denyOutboundUpgradedConnection", remotePeer, maConn);
      maConn.log("successfully upgraded %s connection", direction);
      return this._createConnection({
        cryptoProtocol,
        direction,
        maConn,
        upgradedConn,
        muxerFactory,
        remotePeer,
        limits: opts?.limits
      });
    }
    /**
     * A convenience method for generating a new `Connection`
     */
    _createConnection(opts) {
      const { cryptoProtocol, direction, maConn, upgradedConn, remotePeer, muxerFactory, limits } = opts;
      let muxer;
      let newStream;
      let connection;
      if (muxerFactory != null) {
        muxer = muxerFactory.createStreamMuxer({
          direction,
          // Run anytime a remote stream is created
          onIncomingStream: (muxedStream) => {
            if (connection == null) {
              return;
            }
            const signal = AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);
            setMaxListeners(Infinity, signal);
            void Promise.resolve().then(async () => {
              const protocols2 = this.components.registrar.getProtocols();
              const { stream, protocol } = await handle(muxedStream, protocols2, {
                signal,
                log: muxedStream.log,
                yieldBytes: false
              });
              if (connection == null) {
                return;
              }
              connection.log("incoming stream opened on %s", protocol);
              const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar);
              const streamCount = countStreams(protocol, "inbound", connection);
              if (streamCount === incomingLimit) {
                const err = new TooManyInboundProtocolStreamsError(`Too many inbound protocol streams for protocol "${protocol}" - limit ${incomingLimit}`);
                muxedStream.abort(err);
                throw err;
              }
              muxedStream.source = stream.source;
              muxedStream.sink = stream.sink;
              muxedStream.protocol = protocol;
              if (stream.closeWrite != null) {
                muxedStream.closeWrite = stream.closeWrite;
              }
              if (stream.closeRead != null) {
                muxedStream.closeRead = stream.closeRead;
              }
              if (stream.close != null) {
                muxedStream.close = stream.close;
              }
              await this.components.peerStore.merge(remotePeer, {
                protocols: [protocol]
              }, {
                signal
              });
              this.components.metrics?.trackProtocolStream(muxedStream, connection);
              this._onStream({ connection, stream: muxedStream, protocol });
            }).catch(async (err) => {
              connection.log.error("error handling incoming stream id %s - %e", muxedStream.id, err);
              if (muxedStream.timeline.close == null) {
                await muxedStream.close({
                  signal
                }).catch((err2) => muxedStream.abort(err2));
              }
            });
          }
        });
        newStream = async (protocols2, options = {}) => {
          if (muxer == null) {
            throw new MuxerUnavailableError("Connection is not multiplexed");
          }
          connection.log.trace("starting new stream for protocols %s", protocols2);
          const muxedStream = await muxer.newStream();
          connection.log.trace("started new stream %s for protocols %s", muxedStream.id, protocols2);
          try {
            if (options.signal == null) {
              muxedStream.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols2);
              const signal = AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);
              setMaxListeners(Infinity, signal);
              options = {
                ...options,
                signal
              };
            }
            muxedStream.log.trace("selecting protocol from protocols %s", protocols2);
            const { stream, protocol } = await select(muxedStream, protocols2, {
              ...options,
              log: muxedStream.log,
              yieldBytes: true
            });
            muxedStream.log.trace("selected protocol %s", protocol);
            const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar, options);
            const streamCount = countStreams(protocol, "outbound", connection);
            if (streamCount >= outgoingLimit) {
              const err = new TooManyOutboundProtocolStreamsError(`Too many outbound protocol streams for protocol "${protocol}" - ${streamCount}/${outgoingLimit}`);
              muxedStream.abort(err);
              throw err;
            }
            await this.components.peerStore.merge(remotePeer, {
              protocols: [protocol]
            });
            muxedStream.source = stream.source;
            muxedStream.sink = stream.sink;
            muxedStream.protocol = protocol;
            if (stream.closeWrite != null) {
              muxedStream.closeWrite = stream.closeWrite;
            }
            if (stream.closeRead != null) {
              muxedStream.closeRead = stream.closeRead;
            }
            if (stream.close != null) {
              muxedStream.close = stream.close;
            }
            this.components.metrics?.trackProtocolStream(muxedStream, connection);
            return muxedStream;
          } catch (err) {
            connection.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e", direction === "inbound" ? "from" : "to", opts.maConn.remoteAddr, protocols2, err);
            if (muxedStream.timeline.close == null) {
              muxedStream.abort(err);
            }
            throw err;
          }
        };
        void Promise.all([
          muxer.sink(upgradedConn.source),
          upgradedConn.sink(muxer.source)
        ]).catch((err) => {
          connection.log.error("error piping data through muxer - %e", err);
        });
      }
      const _timeline = maConn.timeline;
      maConn.timeline = new Proxy(_timeline, {
        set: (...args) => {
          if (args[1] === "close" && args[2] != null && _timeline.close == null) {
            (async () => {
              try {
                if (connection.status === "open") {
                  await connection.close();
                }
              } catch (err) {
                connection.log.error("error closing connection after timeline close %e", err);
              } finally {
                this.events.safeDispatchEvent("connection:close", {
                  detail: connection
                });
              }
            })().catch((err) => {
              connection.log.error("error thrown while dispatching connection:close event %e", err);
            });
          }
          return Reflect.set(...args);
        }
      });
      maConn.timeline.upgraded = Date.now();
      const errConnectionNotMultiplexed = () => {
        throw new MuxerUnavailableError("Connection is not multiplexed");
      };
      connection = createConnection({
        remoteAddr: maConn.remoteAddr,
        remotePeer,
        status: "open",
        direction,
        timeline: maConn.timeline,
        multiplexer: muxer?.protocol,
        encryption: cryptoProtocol,
        limits,
        logger: this.components.logger,
        newStream: newStream ?? errConnectionNotMultiplexed,
        getStreams: () => {
          return muxer?.streams ?? [];
        },
        close: async (options) => {
          await muxer?.close(options);
          await maConn.close(options);
        },
        abort: (err) => {
          maConn.abort(err);
          muxer?.abort(err);
        }
      });
      this.events.safeDispatchEvent("connection:open", {
        detail: connection
      });
      connection.__maConnTimeline = _timeline;
      return connection;
    }
    /**
     * Routes incoming streams to the correct handler
     */
    _onStream(opts) {
      const { connection, stream, protocol } = opts;
      const { handler, options } = this.components.registrar.getHandler(protocol);
      if (connection.limits != null && options.runOnLimitedConnection !== true) {
        throw new LimitedConnectionError("Cannot open protocol stream on limited connection");
      }
      handler({ connection, stream });
    }
    /**
     * Attempts to encrypt the incoming `connection` with the provided `cryptos`
     */
    async _encryptInbound(connection, options) {
      const protocols2 = Array.from(this.connectionEncrypters.keys());
      try {
        const { stream, protocol } = await handle(connection, protocols2, {
          ...options,
          log: connection.log
        });
        const encrypter = this.connectionEncrypters.get(protocol);
        if (encrypter == null) {
          throw new EncryptionFailedError(`no crypto module found for ${protocol}`);
        }
        connection.log("encrypting inbound connection to %a using %s", connection.remoteAddr, protocol);
        return {
          ...await encrypter.secureInbound(stream, options),
          protocol
        };
      } catch (err) {
        connection.log.error("encrypting inbound connection from %a failed", connection.remoteAddr, err);
        throw new EncryptionFailedError(err.message);
      }
    }
    /**
     * Attempts to encrypt the given `connection` with the provided connection encrypters.
     * The first `ConnectionEncrypter` module to succeed will be used
     */
    async _encryptOutbound(connection, options) {
      const protocols2 = Array.from(this.connectionEncrypters.keys());
      try {
        connection.log.trace("selecting encrypter from %s", protocols2);
        const { stream, protocol } = await select(connection, protocols2, {
          ...options,
          log: connection.log,
          yieldBytes: true
        });
        const encrypter = this.connectionEncrypters.get(protocol);
        if (encrypter == null) {
          throw new EncryptionFailedError(`no crypto module found for ${protocol}`);
        }
        connection.log("encrypting outbound connection to %a using %s", connection.remoteAddr, protocol);
        return {
          ...await encrypter.secureOutbound(stream, options),
          protocol
        };
      } catch (err) {
        connection.log.error("encrypting outbound connection to %a failed", connection.remoteAddr, err);
        throw new EncryptionFailedError(err.message);
      }
    }
    /**
     * Selects one of the given muxers via multistream-select. That
     * muxer will be used for all future streams on the connection.
     */
    async _multiplexOutbound(connection, muxers, options) {
      const protocols2 = Array.from(muxers.keys());
      connection.log("outbound selecting muxer %s", protocols2);
      try {
        connection.log.trace("selecting stream muxer from %s", protocols2);
        const { stream, protocol } = await select(connection, protocols2, {
          ...options,
          log: connection.log,
          yieldBytes: true
        });
        connection.log("selected %s as muxer protocol", protocol);
        const muxerFactory = muxers.get(protocol);
        return { stream, muxerFactory };
      } catch (err) {
        connection.log.error("error multiplexing outbound connection", err);
        throw new MuxerUnavailableError(String(err));
      }
    }
    /**
     * Registers support for one of the given muxers via multistream-select. The
     * selected muxer will be used for all future streams on the connection.
     */
    async _multiplexInbound(connection, muxers, options) {
      const protocols2 = Array.from(muxers.keys());
      connection.log("inbound handling muxers %s", protocols2);
      try {
        const { stream, protocol } = await handle(connection, protocols2, {
          ...options,
          log: connection.log
        });
        const muxerFactory = muxers.get(protocol);
        return { stream, muxerFactory };
      } catch (err) {
        connection.log.error("error multiplexing inbound connection", err);
        throw new MuxerUnavailableError(String(err));
      }
    }
    getConnectionEncrypters() {
      return this.connectionEncrypters;
    }
    getStreamMuxers() {
      return this.streamMuxers;
    }
  };

  // ../node_modules/libp2p/dist/src/version.js
  var version = "2.8.11";
  var name16 = "js-libp2p";

  // ../node_modules/libp2p/dist/src/user-agent.browser.js
  function userAgent(name19, version5) {
    return `${name19 ?? name16}/${version5 ?? version} browser/${globalThis.navigator.userAgent}`;
  }

  // ../node_modules/libp2p/dist/src/libp2p.js
  var Libp2p = class extends TypedEventEmitter {
    peerId;
    peerStore;
    contentRouting;
    peerRouting;
    metrics;
    services;
    logger;
    status;
    components;
    log;
    // eslint-disable-next-line complexity
    constructor(init) {
      super();
      this.status = "stopped";
      const events = new TypedEventEmitter();
      const originalDispatch = events.dispatchEvent.bind(events);
      events.dispatchEvent = (evt) => {
        const internalResult = originalDispatch(evt);
        const externalResult = this.dispatchEvent(new CustomEvent(evt.type, { detail: evt.detail }));
        return internalResult || externalResult;
      };
      setMaxListeners(Infinity, events);
      this.peerId = init.peerId;
      this.logger = init.logger ?? defaultLogger();
      this.log = this.logger.forComponent("libp2p");
      this.services = {};
      const nodeInfoName = init.nodeInfo?.name ?? name16;
      const nodeInfoVersion = init.nodeInfo?.version ?? version;
      const components = this.components = defaultComponents({
        peerId: init.peerId,
        privateKey: init.privateKey,
        nodeInfo: {
          name: nodeInfoName,
          version: nodeInfoVersion,
          userAgent: init.nodeInfo?.userAgent ?? userAgent(nodeInfoName, nodeInfoVersion)
        },
        logger: this.logger,
        events,
        datastore: init.datastore ?? new MemoryDatastore(),
        connectionGater: connectionGater(init.connectionGater),
        dns: init.dns
      });
      if (init.metrics != null) {
        this.metrics = this.configureComponent("metrics", init.metrics(this.components));
      }
      this.peerStore = this.configureComponent("peerStore", persistentPeerStore(components, {
        addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
        ...init.peerStore
      }));
      components.events.addEventListener("peer:update", (evt) => {
        if (evt.detail.previous == null) {
          const peerInfo = {
            id: evt.detail.peer.id,
            multiaddrs: evt.detail.peer.addresses.map((a) => a.multiaddr)
          };
          components.events.safeDispatchEvent("peer:discovery", { detail: peerInfo });
        }
      });
      if (init.connectionProtector != null) {
        this.configureComponent("connectionProtector", init.connectionProtector(components));
      }
      this.components.upgrader = new Upgrader(this.components, {
        connectionEncrypters: (init.connectionEncrypters ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),
        streamMuxers: (init.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),
        inboundUpgradeTimeout: init.connectionManager?.inboundUpgradeTimeout,
        inboundStreamProtocolNegotiationTimeout: init.connectionManager?.inboundStreamProtocolNegotiationTimeout ?? init.connectionManager?.protocolNegotiationTimeout,
        outboundStreamProtocolNegotiationTimeout: init.connectionManager?.outboundStreamProtocolNegotiationTimeout ?? init.connectionManager?.protocolNegotiationTimeout
      });
      this.configureComponent("transportManager", new DefaultTransportManager(this.components, init.transportManager));
      this.configureComponent("connectionManager", new DefaultConnectionManager(this.components, init.connectionManager));
      if (init.connectionMonitor?.enabled !== false) {
        this.configureComponent("connectionMonitor", new ConnectionMonitor(this.components, init.connectionMonitor));
      }
      this.configureComponent("registrar", new Registrar(this.components));
      this.configureComponent("addressManager", new AddressManager(this.components, init.addresses));
      const peerRouters = (init.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)));
      this.peerRouting = this.components.peerRouting = this.configureComponent("peerRouting", new DefaultPeerRouting(this.components, {
        routers: peerRouters
      }));
      const contentRouters = (init.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)));
      this.contentRouting = this.components.contentRouting = this.configureComponent("contentRouting", new CompoundContentRouting(this.components, {
        routers: contentRouters
      }));
      this.configureComponent("randomWalk", new RandomWalk(this.components));
      (init.peerDiscovery ?? []).forEach((fn, index) => {
        const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components));
        service.addEventListener("peer", (evt) => {
          this.#onDiscoveryPeer(evt);
        });
      });
      init.transports?.forEach((fn, index) => {
        this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)));
      });
      if (init.services != null) {
        for (const name19 of Object.keys(init.services)) {
          const createService = init.services[name19];
          const service = createService(this.components);
          if (service == null) {
            this.log.error("service factory %s returned null or undefined instance", name19);
            continue;
          }
          this.services[name19] = service;
          this.configureComponent(name19, service);
          if (service[contentRoutingSymbol] != null) {
            this.log("registering service %s for content routing", name19);
            contentRouters.push(service[contentRoutingSymbol]);
          }
          if (service[peerRoutingSymbol] != null) {
            this.log("registering service %s for peer routing", name19);
            peerRouters.push(service[peerRoutingSymbol]);
          }
          if (service[peerDiscoverySymbol] != null) {
            this.log("registering service %s for peer discovery", name19);
            service[peerDiscoverySymbol].addEventListener?.("peer", (evt) => {
              this.#onDiscoveryPeer(evt);
            });
          }
        }
      }
      checkServiceDependencies(components);
    }
    configureComponent(name19, component) {
      if (component == null) {
        this.log.error("component %s was null or undefined", name19);
      }
      this.components[name19] = component;
      return component;
    }
    /**
     * Starts the libp2p node and all its subsystems
     */
    async start() {
      if (this.status !== "stopped") {
        return;
      }
      this.status = "starting";
      this.log("libp2p is starting");
      try {
        await this.components.beforeStart?.();
        await this.components.start();
        await this.components.afterStart?.();
        this.status = "started";
        this.safeDispatchEvent("start", { detail: this });
        this.log("libp2p has started");
      } catch (err) {
        this.log.error("An error occurred starting libp2p", err);
        this.status = "started";
        await this.stop();
        throw err;
      }
    }
    /**
     * Stop the libp2p node by closing its listeners and open connections
     */
    async stop() {
      if (this.status !== "started") {
        return;
      }
      this.log("libp2p is stopping");
      this.status = "stopping";
      await this.components.beforeStop?.();
      await this.components.stop();
      await this.components.afterStop?.();
      this.status = "stopped";
      this.safeDispatchEvent("stop", { detail: this });
      this.log("libp2p has stopped");
    }
    getConnections(peerId2) {
      return this.components.connectionManager.getConnections(peerId2);
    }
    getDialQueue() {
      return this.components.connectionManager.getDialQueue();
    }
    getPeers() {
      const peerSet2 = new PeerSet();
      for (const conn of this.components.connectionManager.getConnections()) {
        peerSet2.add(conn.remotePeer);
      }
      return Array.from(peerSet2);
    }
    async dial(peer, options = {}) {
      return this.components.connectionManager.openConnection(peer, {
        // ensure any userland dials take top priority in the queue
        priority: 75,
        ...options
      });
    }
    async dialProtocol(peer, protocols2, options = {}) {
      if (protocols2 == null) {
        throw new InvalidParametersError("no protocols were provided to open a stream");
      }
      protocols2 = Array.isArray(protocols2) ? protocols2 : [protocols2];
      if (protocols2.length === 0) {
        throw new InvalidParametersError("no protocols were provided to open a stream");
      }
      const connection = await this.dial(peer, options);
      return connection.newStream(protocols2, options);
    }
    getMultiaddrs() {
      return this.components.addressManager.getAddresses();
    }
    getProtocols() {
      return this.components.registrar.getProtocols();
    }
    async hangUp(peer, options = {}) {
      if (isMultiaddr(peer)) {
        peer = peerIdFromString(peer.getPeerId() ?? "");
      }
      await this.components.connectionManager.closeConnections(peer, options);
    }
    async getPublicKey(peer, options = {}) {
      this.log("getPublicKey %p", peer);
      if (peer.publicKey != null) {
        return peer.publicKey;
      }
      try {
        const peerInfo = await this.peerStore.get(peer, options);
        if (peerInfo.id.publicKey != null) {
          return peerInfo.id.publicKey;
        }
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
      const peerKey = concat7([
        fromString27("/pk/"),
        peer.toMultihash().bytes
      ]);
      const bytes2 = await this.contentRouting.get(peerKey, options);
      const publicKey = publicKeyFromProtobuf(bytes2);
      await this.peerStore.patch(peer, {
        publicKey
      }, options);
      return publicKey;
    }
    async handle(protocols2, handler, options) {
      if (!Array.isArray(protocols2)) {
        protocols2 = [protocols2];
      }
      await Promise.all(protocols2.map(async (protocol) => {
        await this.components.registrar.handle(protocol, handler, options);
      }));
    }
    async unhandle(protocols2, options) {
      if (!Array.isArray(protocols2)) {
        protocols2 = [protocols2];
      }
      await Promise.all(protocols2.map(async (protocol) => {
        await this.components.registrar.unhandle(protocol, options);
      }));
    }
    async register(protocol, topology, options) {
      return this.components.registrar.register(protocol, topology, options);
    }
    unregister(id) {
      this.components.registrar.unregister(id);
    }
    async isDialable(multiaddr2, options = {}) {
      return this.components.connectionManager.isDialable(multiaddr2, options);
    }
    /**
     * Called whenever peer discovery services emit `peer` events and adds peers
     * to the peer store.
     */
    #onDiscoveryPeer(evt) {
      const { detail: peer } = evt;
      if (peer.id.toString() === this.peerId.toString()) {
        this.log.error("peer discovery mechanism discovered self");
        return;
      }
      void this.components.peerStore.merge(peer.id, {
        multiaddrs: peer.multiaddrs
      }).catch((err) => {
        this.log.error(err);
      });
    }
  };

  // ../node_modules/libp2p/dist/src/index.js
  async function createLibp2p(options = {}) {
    options.privateKey ??= await generateKeyPair("Ed25519");
    const node2 = new Libp2p({
      ...await validateConfig(options),
      peerId: peerIdFromPrivateKey(options.privateKey)
    });
    if (options.start !== false) {
      await node2.start();
    }
    return node2;
  }

  // ../node_modules/@waku/sdk/dist/env.js
  function isTestEnvironment() {
    try {
      return false;
    } catch (_e) {
      return false;
    }
  }

  // ../node_modules/@waku/discovery/dist/dns/constants.js
  var enrTree = {
    SANDBOX: "enrtree://AIRVQ5DDA4FFWLRBCHJWUWOO6X6S4ZTZ5B667LQ6AJU6PEYDLRD5O@sandbox.waku.nodes.status.im",
    TEST: "enrtree://AOGYWMBYOUIMOENHXCHILPKY3ZRFEULMFI4DOM442QSZ73TT2A7VI@test.waku.nodes.status.im"
  };
  var DEFAULT_BOOTSTRAP_TAG_NAME2 = Tags.BOOTSTRAP;
  var DEFAULT_BOOTSTRAP_TAG_VALUE2 = 50;
  var DEFAULT_BOOTSTRAP_TAG_TTL = 1e8;

  // ../node_modules/@waku/enr/dist/constants.js
  var ERR_INVALID_ID = "Invalid record id";
  var MULTIADDR_LENGTH_SIZE = 2;

  // ../node_modules/@noble/secp256k1/lib/esm/index.js
  var nodeCrypto = __toESM(require_crypto(), 1);
  var _0n13 = BigInt(0);
  var _1n13 = BigInt(1);
  var _2n10 = BigInt(2);
  var _3n5 = BigInt(3);
  var _8n6 = BigInt(8);
  var CURVE = Object.freeze({
    a: _0n13,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: _1n13,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  var divNearest2 = (a, b) => (a + b / _2n10) / b;
  var endo = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(k) {
      const { n } = CURVE;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n13 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest2(b2 * k, n);
      const c2 = divNearest2(-b1 * k, n);
      let k1 = mod4(k - c1 * a1 - c2 * a2, n);
      let k2 = mod4(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  };
  var fieldLen = 32;
  var groupLen = 32;
  var hashLen = 32;
  var compressedLen = fieldLen + 1;
  var uncompressedLen = 2 * fieldLen + 1;
  function weierstrass2(x) {
    const { a, b } = CURVE;
    const x2 = mod4(x * x);
    const x3 = mod4(x2 * x);
    return mod4(x3 + a * x + b);
  }
  var USE_ENDOMORPHISM = CURVE.a === _0n13;
  var ShaError = class extends Error {
    constructor(message2) {
      super(message2);
    }
  };
  function assertJacPoint(other) {
    if (!(other instanceof JacobianPoint))
      throw new TypeError("JacobianPoint expected");
  }
  var JacobianPoint = class _JacobianPoint {
    constructor(x, y2, z) {
      this.x = x;
      this.y = y2;
      this.z = z;
    }
    static fromAffine(p) {
      if (!(p instanceof Point)) {
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      }
      if (p.equals(Point.ZERO))
        return _JacobianPoint.ZERO;
      return new _JacobianPoint(p.x, p.y, _1n13);
    }
    static toAffineBatch(points) {
      const toInv = invertBatch(points.map((p) => p.z));
      return points.map((p, i) => p.toAffine(toInv[i]));
    }
    static normalizeZ(points) {
      return _JacobianPoint.toAffineBatch(points).map(_JacobianPoint.fromAffine);
    }
    equals(other) {
      assertJacPoint(other);
      const { x: X1, y: Y1, z: Z1 } = this;
      const { x: X2, y: Y2, z: Z2 } = other;
      const Z1Z1 = mod4(Z1 * Z1);
      const Z2Z2 = mod4(Z2 * Z2);
      const U1 = mod4(X1 * Z2Z2);
      const U2 = mod4(X2 * Z1Z1);
      const S1 = mod4(mod4(Y1 * Z2) * Z2Z2);
      const S2 = mod4(mod4(Y2 * Z1) * Z1Z1);
      return U1 === U2 && S1 === S2;
    }
    negate() {
      return new _JacobianPoint(this.x, mod4(-this.y), this.z);
    }
    double() {
      const { x: X1, y: Y1, z: Z1 } = this;
      const A = mod4(X1 * X1);
      const B = mod4(Y1 * Y1);
      const C = mod4(B * B);
      const x1b = X1 + B;
      const D = mod4(_2n10 * (mod4(x1b * x1b) - A - C));
      const E = mod4(_3n5 * A);
      const F = mod4(E * E);
      const X3 = mod4(F - _2n10 * D);
      const Y3 = mod4(E * (D - X3) - _8n6 * C);
      const Z3 = mod4(_2n10 * Y1 * Z1);
      return new _JacobianPoint(X3, Y3, Z3);
    }
    add(other) {
      assertJacPoint(other);
      const { x: X1, y: Y1, z: Z1 } = this;
      const { x: X2, y: Y2, z: Z2 } = other;
      if (X2 === _0n13 || Y2 === _0n13)
        return this;
      if (X1 === _0n13 || Y1 === _0n13)
        return other;
      const Z1Z1 = mod4(Z1 * Z1);
      const Z2Z2 = mod4(Z2 * Z2);
      const U1 = mod4(X1 * Z2Z2);
      const U2 = mod4(X2 * Z1Z1);
      const S1 = mod4(mod4(Y1 * Z2) * Z2Z2);
      const S2 = mod4(mod4(Y2 * Z1) * Z1Z1);
      const H = mod4(U2 - U1);
      const r = mod4(S2 - S1);
      if (H === _0n13) {
        if (r === _0n13) {
          return this.double();
        } else {
          return _JacobianPoint.ZERO;
        }
      }
      const HH = mod4(H * H);
      const HHH = mod4(H * HH);
      const V3 = mod4(U1 * HH);
      const X3 = mod4(r * r - HHH - _2n10 * V3);
      const Y3 = mod4(r * (V3 - X3) - S1 * HHH);
      const Z3 = mod4(Z1 * Z2 * H);
      return new _JacobianPoint(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    multiplyUnsafe(scalar) {
      const P0 = _JacobianPoint.ZERO;
      if (typeof scalar === "bigint" && scalar === _0n13)
        return P0;
      let n = normalizeScalar(scalar);
      if (n === _1n13)
        return this;
      if (!USE_ENDOMORPHISM) {
        let p = P0;
        let d3 = this;
        while (n > _0n13) {
          if (n & _1n13)
            p = p.add(d3);
          d3 = d3.double();
          n >>= _1n13;
        }
        return p;
      }
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let k1p = P0;
      let k2p = P0;
      let d2 = this;
      while (k1 > _0n13 || k2 > _0n13) {
        if (k1 & _1n13)
          k1p = k1p.add(d2);
        if (k2 & _1n13)
          k2p = k2p.add(d2);
        d2 = d2.double();
        k1 >>= _1n13;
        k2 >>= _1n13;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new _JacobianPoint(mod4(k2p.x * endo.beta), k2p.y, k2p.z);
      return k1p.add(k2p);
    }
    precomputeWindow(W) {
      const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
      const points = [];
      let p = this;
      let base37 = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base37 = p;
        points.push(base37);
        for (let i = 1; i < 2 ** (W - 1); i++) {
          base37 = base37.add(p);
          points.push(base37);
        }
        p = base37.double();
      }
      return points;
    }
    wNAF(n, affinePoint) {
      if (!affinePoint && this.equals(_JacobianPoint.BASE))
        affinePoint = Point.BASE;
      const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
      if (256 % W) {
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      }
      let precomputes = affinePoint && pointPrecomputes2.get(affinePoint);
      if (!precomputes) {
        precomputes = this.precomputeWindow(W);
        if (affinePoint && W !== 1) {
          precomputes = _JacobianPoint.normalizeZ(precomputes);
          pointPrecomputes2.set(affinePoint, precomputes);
        }
      }
      let p = _JacobianPoint.ZERO;
      let f = _JacobianPoint.BASE;
      const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
      const windowSize = 2 ** (W - 1);
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n13;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    }
    multiply(scalar, affinePoint) {
      let n = normalizeScalar(scalar);
      let point;
      let fake;
      if (USE_ENDOMORPHISM) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
        let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
        k1p = constTimeNegate(k1neg, k1p);
        k2p = constTimeNegate(k2neg, k2p);
        k2p = new _JacobianPoint(mod4(k2p.x * endo.beta), k2p.y, k2p.z);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(n, affinePoint);
        point = p;
        fake = f;
      }
      return _JacobianPoint.normalizeZ([point, fake])[0];
    }
    toAffine(invZ) {
      const { x, y: y2, z } = this;
      const is0 = this.equals(_JacobianPoint.ZERO);
      if (invZ == null)
        invZ = is0 ? _8n6 : invert3(z);
      const iz1 = invZ;
      const iz2 = mod4(iz1 * iz1);
      const iz3 = mod4(iz2 * iz1);
      const ax = mod4(x * iz2);
      const ay = mod4(y2 * iz3);
      const zz = mod4(z * iz1);
      if (is0)
        return Point.ZERO;
      if (zz !== _1n13)
        throw new Error("invZ was invalid");
      return new Point(ax, ay);
    }
  };
  JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n13);
  JacobianPoint.ZERO = new JacobianPoint(_0n13, _1n13, _0n13);
  function constTimeNegate(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
  }
  var pointPrecomputes2 = /* @__PURE__ */ new WeakMap();
  var Point = class _Point {
    constructor(x, y2) {
      this.x = x;
      this.y = y2;
    }
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes2.delete(this);
    }
    hasEvenY() {
      return this.y % _2n10 === _0n13;
    }
    static fromCompressedHex(bytes2) {
      const isShort = bytes2.length === 32;
      const x = bytesToNumber(isShort ? bytes2 : bytes2.subarray(1));
      if (!isValidFieldElement(x))
        throw new Error("Point is not on curve");
      const y2 = weierstrass2(x);
      let y3 = sqrtMod2(y2);
      const isYOdd = (y3 & _1n13) === _1n13;
      if (isShort) {
        if (isYOdd)
          y3 = mod4(-y3);
      } else {
        const isFirstByteOdd = (bytes2[0] & 1) === 1;
        if (isFirstByteOdd !== isYOdd)
          y3 = mod4(-y3);
      }
      const point = new _Point(x, y3);
      point.assertValidity();
      return point;
    }
    static fromUncompressedHex(bytes2) {
      const x = bytesToNumber(bytes2.subarray(1, fieldLen + 1));
      const y2 = bytesToNumber(bytes2.subarray(fieldLen + 1, fieldLen * 2 + 1));
      const point = new _Point(x, y2);
      point.assertValidity();
      return point;
    }
    static fromHex(hex) {
      const bytes2 = ensureBytes3(hex);
      const len = bytes2.length;
      const header = bytes2[0];
      if (len === fieldLen)
        return this.fromCompressedHex(bytes2);
      if (len === compressedLen && (header === 2 || header === 3)) {
        return this.fromCompressedHex(bytes2);
      }
      if (len === uncompressedLen && header === 4)
        return this.fromUncompressedHex(bytes2);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);
    }
    static fromPrivateKey(privateKey) {
      return _Point.BASE.multiply(normalizePrivateKey(privateKey));
    }
    static fromSignature(msgHash, signature, recovery) {
      const { r, s: s2 } = normalizeSignature(signature);
      if (![0, 1, 2, 3].includes(recovery))
        throw new Error("Cannot recover: invalid recovery bit");
      const h2 = truncateHash(ensureBytes3(msgHash));
      const { n } = CURVE;
      const radj = recovery === 2 || recovery === 3 ? r + n : r;
      const rinv = invert3(radj, n);
      const u1 = mod4(-h2 * rinv, n);
      const u2 = mod4(s2 * rinv, n);
      const prefix = recovery & 1 ? "03" : "02";
      const R = _Point.fromHex(prefix + numTo32bStr(radj));
      const Q = _Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("Cannot recover signature: point at infinify");
      Q.assertValidity();
      return Q;
    }
    toRawBytes(isCompressed = false) {
      return hexToBytes4(this.toHex(isCompressed));
    }
    toHex(isCompressed = false) {
      const x = numTo32bStr(this.x);
      if (isCompressed) {
        const prefix = this.hasEvenY() ? "02" : "03";
        return `${prefix}${x}`;
      } else {
        return `04${x}${numTo32bStr(this.y)}`;
      }
    }
    toHexX() {
      return this.toHex(true).slice(2);
    }
    toRawX() {
      return this.toRawBytes(true).slice(1);
    }
    assertValidity() {
      const msg = "Point is not on elliptic curve";
      const { x, y: y2 } = this;
      if (!isValidFieldElement(x) || !isValidFieldElement(y2))
        throw new Error(msg);
      const left = mod4(y2 * y2);
      const right = weierstrass2(x);
      if (mod4(left - right) !== _0n13)
        throw new Error(msg);
    }
    equals(other) {
      return this.x === other.x && this.y === other.y;
    }
    negate() {
      return new _Point(this.x, mod4(-this.y));
    }
    double() {
      return JacobianPoint.fromAffine(this).double().toAffine();
    }
    add(other) {
      return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
    }
    subtract(other) {
      return this.add(other.negate());
    }
    multiply(scalar) {
      return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
    }
    multiplyAndAddUnsafe(Q, a, b) {
      const P = JacobianPoint.fromAffine(this);
      const aP = a === _0n13 || a === _1n13 || this !== _Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
      const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
      const sum = aP.add(bQ);
      return sum.equals(JacobianPoint.ZERO) ? void 0 : sum.toAffine();
    }
  };
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
  Point.ZERO = new Point(_0n13, _0n13);
  function sliceDER(s2) {
    return Number.parseInt(s2[0], 16) >= 8 ? "00" + s2 : s2;
  }
  function parseDERInt(data) {
    if (data.length < 2 || data[0] !== 2) {
      throw new Error(`Invalid signature integer tag: ${bytesToHex4(data)}`);
    }
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len) {
      throw new Error(`Invalid signature integer: wrong length`);
    }
    if (res[0] === 0 && res[1] <= 127) {
      throw new Error("Invalid signature integer: trailing length");
    }
    return { data: bytesToNumber(res), left: data.subarray(len + 2) };
  }
  function parseDERSignature(data) {
    if (data.length < 2 || data[0] != 48) {
      throw new Error(`Invalid signature tag: ${bytesToHex4(data)}`);
    }
    if (data[1] !== data.length - 2) {
      throw new Error("Invalid signature: incorrect length");
    }
    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
    const { data: s2, left: rBytesLeft } = parseDERInt(sBytes);
    if (rBytesLeft.length) {
      throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex4(rBytesLeft)}`);
    }
    return { r, s: s2 };
  }
  var Signature = class _Signature {
    constructor(r, s2) {
      this.r = r;
      this.s = s2;
      this.assertValidity();
    }
    static fromCompact(hex) {
      const arr = hex instanceof Uint8Array;
      const name19 = "Signature.fromCompact";
      if (typeof hex !== "string" && !arr)
        throw new TypeError(`${name19}: Expected string or Uint8Array`);
      const str = arr ? bytesToHex4(hex) : hex;
      if (str.length !== 128)
        throw new Error(`${name19}: Expected 64-byte hex`);
      return new _Signature(hexToNumber3(str.slice(0, 64)), hexToNumber3(str.slice(64, 128)));
    }
    static fromDER(hex) {
      const arr = hex instanceof Uint8Array;
      if (typeof hex !== "string" && !arr)
        throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
      const { r, s: s2 } = parseDERSignature(arr ? hex : hexToBytes4(hex));
      return new _Signature(r, s2);
    }
    static fromHex(hex) {
      return this.fromDER(hex);
    }
    assertValidity() {
      const { r, s: s2 } = this;
      if (!isWithinCurveOrder(r))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!isWithinCurveOrder(s2))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const HALF = CURVE.n >> _1n13;
      return this.s > HALF;
    }
    normalizeS() {
      return this.hasHighS() ? new _Signature(this.r, mod4(-this.s, CURVE.n)) : this;
    }
    toDERRawBytes() {
      return hexToBytes4(this.toDERHex());
    }
    toDERHex() {
      const sHex = sliceDER(numberToHexUnpadded2(this.s));
      const rHex = sliceDER(numberToHexUnpadded2(this.r));
      const sHexL = sHex.length / 2;
      const rHexL = rHex.length / 2;
      const sLen = numberToHexUnpadded2(sHexL);
      const rLen = numberToHexUnpadded2(rHexL);
      const length21 = numberToHexUnpadded2(rHexL + sHexL + 4);
      return `30${length21}02${rLen}${rHex}02${sLen}${sHex}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return hexToBytes4(this.toCompactHex());
    }
    toCompactHex() {
      return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
  };
  function concatBytes4(...arrays) {
    if (!arrays.every((b) => b instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (arrays.length === 1)
      return arrays[0];
    const length21 = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length21);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const arr = arrays[i];
      result.set(arr, pad);
      pad += arr.length;
    }
    return result;
  }
  var hexes3 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex4(uint8a) {
    if (!(uint8a instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let hex = "";
    for (let i = 0; i < uint8a.length; i++) {
      hex += hexes3[uint8a[i]];
    }
    return hex;
  }
  var POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function numTo32bStr(num) {
    if (typeof num !== "bigint")
      throw new Error("Expected bigint");
    if (!(_0n13 <= num && num < POW_2_256))
      throw new Error("Expected number 0 <= n < 2^256");
    return num.toString(16).padStart(64, "0");
  }
  function numTo32b(num) {
    const b = hexToBytes4(numTo32bStr(num));
    if (b.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return b;
  }
  function numberToHexUnpadded2(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
  }
  function hexToNumber3(hex) {
    if (typeof hex !== "string") {
      throw new TypeError("hexToNumber: expected string, got " + typeof hex);
    }
    return BigInt(`0x${hex}`);
  }
  function hexToBytes4(hex) {
    if (typeof hex !== "string") {
      throw new TypeError("hexToBytes: expected string, got " + typeof hex);
    }
    if (hex.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + hex.length);
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
      const j = i * 2;
      const hexByte = hex.slice(j, j + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array[i] = byte;
    }
    return array;
  }
  function bytesToNumber(bytes2) {
    return hexToNumber3(bytesToHex4(bytes2));
  }
  function ensureBytes3(hex) {
    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes4(hex);
  }
  function normalizeScalar(num) {
    if (typeof num === "number" && Number.isSafeInteger(num) && num > 0)
      return BigInt(num);
    if (typeof num === "bigint" && isWithinCurveOrder(num))
      return num;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function mod4(a, b = CURVE.P) {
    const result = a % b;
    return result >= _0n13 ? result : b + result;
  }
  function pow23(x, power) {
    const { P } = CURVE;
    let res = x;
    while (power-- > _0n13) {
      res *= res;
      res %= P;
    }
    return res;
  }
  function sqrtMod2(x) {
    const { P } = CURVE;
    const _6n = BigInt(6);
    const _11n = BigInt(11);
    const _22n = BigInt(22);
    const _23n = BigInt(23);
    const _44n = BigInt(44);
    const _88n = BigInt(88);
    const b2 = x * x * x % P;
    const b3 = b2 * b2 * x % P;
    const b6 = pow23(b3, _3n5) * b3 % P;
    const b9 = pow23(b6, _3n5) * b3 % P;
    const b11 = pow23(b9, _2n10) * b2 % P;
    const b22 = pow23(b11, _11n) * b11 % P;
    const b44 = pow23(b22, _22n) * b22 % P;
    const b88 = pow23(b44, _44n) * b44 % P;
    const b176 = pow23(b88, _88n) * b88 % P;
    const b220 = pow23(b176, _44n) * b44 % P;
    const b223 = pow23(b220, _3n5) * b3 % P;
    const t1 = pow23(b223, _23n) * b22 % P;
    const t2 = pow23(t1, _6n) * b2 % P;
    const rt = pow23(t2, _2n10);
    const xc = rt * rt % P;
    if (xc !== x)
      throw new Error("Cannot find square root");
    return rt;
  }
  function invert3(number3, modulo = CURVE.P) {
    if (number3 === _0n13 || modulo <= _0n13) {
      throw new Error(`invert: expected positive integers, got n=${number3} mod=${modulo}`);
    }
    let a = mod4(number3, modulo);
    let b = modulo;
    let x = _0n13, y2 = _1n13, u = _1n13, v = _0n13;
    while (a !== _0n13) {
      const q = b / a;
      const r = b % a;
      const m2 = x - u * q;
      const n = y2 - v * q;
      b = a, a = r, x = u, y2 = v, u = m2, v = n;
    }
    const gcd = b;
    if (gcd !== _1n13)
      throw new Error("invert: does not exist");
    return mod4(x, modulo);
  }
  function invertBatch(nums, p = CURVE.P) {
    const scratch = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
      if (num === _0n13)
        return acc;
      scratch[i] = acc;
      return mod4(acc * num, p);
    }, _1n13);
    const inverted = invert3(lastMultiplied, p);
    nums.reduceRight((acc, num, i) => {
      if (num === _0n13)
        return acc;
      scratch[i] = mod4(acc * scratch[i], p);
      return mod4(acc * num, p);
    }, inverted);
    return scratch;
  }
  function bits2int_2(bytes2) {
    const delta = bytes2.length * 8 - groupLen * 8;
    const num = bytesToNumber(bytes2);
    return delta > 0 ? num >> BigInt(delta) : num;
  }
  function truncateHash(hash2, truncateOnly = false) {
    const h2 = bits2int_2(hash2);
    if (truncateOnly)
      return h2;
    const { n } = CURVE;
    return h2 >= n ? h2 - n : h2;
  }
  var _sha256Sync;
  var _hmacSha256Sync;
  var HmacDrbg = class {
    constructor(hashLen2, qByteLen) {
      this.hashLen = hashLen2;
      this.qByteLen = qByteLen;
      if (typeof hashLen2 !== "number" || hashLen2 < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(hashLen2).fill(1);
      this.k = new Uint8Array(hashLen2).fill(0);
      this.counter = 0;
    }
    hmac(...values) {
      return utils.hmacSha256(this.k, ...values);
    }
    hmacSync(...values) {
      return _hmacSha256Sync(this.k, ...values);
    }
    checkSync() {
      if (typeof _hmacSha256Sync !== "function")
        throw new ShaError("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(seed = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), seed);
      this.v = await this.hmac(this.v);
      if (seed.length === 0)
        return;
      this.k = await this.hmac(this.v, Uint8Array.from([1]), seed);
      this.v = await this.hmac(this.v);
    }
    reseedSync(seed = new Uint8Array()) {
      this.checkSync();
      this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed);
      this.v = this.hmacSync(this.v);
      if (seed.length === 0)
        return;
      this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed);
      this.v = this.hmacSync(this.v);
    }
    async generate() {
      this.incr();
      let len = 0;
      const out = [];
      while (len < this.qByteLen) {
        this.v = await this.hmac(this.v);
        const sl = this.v.slice();
        out.push(sl);
        len += this.v.length;
      }
      return concatBytes4(...out);
    }
    generateSync() {
      this.checkSync();
      this.incr();
      let len = 0;
      const out = [];
      while (len < this.qByteLen) {
        this.v = this.hmacSync(this.v);
        const sl = this.v.slice();
        out.push(sl);
        len += this.v.length;
      }
      return concatBytes4(...out);
    }
  };
  function isWithinCurveOrder(num) {
    return _0n13 < num && num < CURVE.n;
  }
  function isValidFieldElement(num) {
    return _0n13 < num && num < CURVE.P;
  }
  function kmdToSig(kBytes, m2, d2, lowS = true) {
    const { n } = CURVE;
    const k = truncateHash(kBytes, true);
    if (!isWithinCurveOrder(k))
      return;
    const kinv = invert3(k, n);
    const q = Point.BASE.multiply(k);
    const r = mod4(q.x, n);
    if (r === _0n13)
      return;
    const s2 = mod4(kinv * mod4(m2 + d2 * r, n), n);
    if (s2 === _0n13)
      return;
    let sig = new Signature(r, s2);
    let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n13);
    if (lowS && sig.hasHighS()) {
      sig = sig.normalizeS();
      recovery ^= 1;
    }
    return { sig, recovery };
  }
  function normalizePrivateKey(key) {
    let num;
    if (typeof key === "bigint") {
      num = key;
    } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
      num = BigInt(key);
    } else if (typeof key === "string") {
      if (key.length !== 2 * groupLen)
        throw new Error("Expected 32 bytes of private key");
      num = hexToNumber3(key);
    } else if (key instanceof Uint8Array) {
      if (key.length !== groupLen)
        throw new Error("Expected 32 bytes of private key");
      num = bytesToNumber(key);
    } else {
      throw new TypeError("Expected valid private key");
    }
    if (!isWithinCurveOrder(num))
      throw new Error("Expected private key: 0 < key < n");
    return num;
  }
  function normalizePublicKey(publicKey) {
    if (publicKey instanceof Point) {
      publicKey.assertValidity();
      return publicKey;
    } else {
      return Point.fromHex(publicKey);
    }
  }
  function normalizeSignature(signature) {
    if (signature instanceof Signature) {
      signature.assertValidity();
      return signature;
    }
    try {
      return Signature.fromDER(signature);
    } catch (error) {
      return Signature.fromCompact(signature);
    }
  }
  function bits2int(bytes2) {
    const slice = bytes2.length > fieldLen ? bytes2.slice(0, fieldLen) : bytes2;
    return bytesToNumber(slice);
  }
  function bits2octets(bytes2) {
    const z1 = bits2int(bytes2);
    const z2 = mod4(z1, CURVE.n);
    return int2octets(z2 < _0n13 ? z1 : z2);
  }
  function int2octets(num) {
    return numTo32b(num);
  }
  function initSigArgs(msgHash, privateKey, extraEntropy) {
    if (msgHash == null)
      throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
    const h1 = ensureBytes3(msgHash);
    const d2 = normalizePrivateKey(privateKey);
    const seedArgs = [int2octets(d2), bits2octets(h1)];
    if (extraEntropy != null) {
      if (extraEntropy === true)
        extraEntropy = utils.randomBytes(fieldLen);
      const e = ensureBytes3(extraEntropy);
      if (e.length !== fieldLen)
        throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
      seedArgs.push(e);
    }
    const seed = concatBytes4(...seedArgs);
    const m2 = bits2int(h1);
    return { seed, m: m2, d: d2 };
  }
  function finalizeSig(recSig, opts) {
    const { sig, recovery } = recSig;
    const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);
    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
    return recovered ? [hashed, recovery] : hashed;
  }
  async function sign(msgHash, privKey, opts = {}) {
    const { seed, m: m2, d: d2 } = initSigArgs(msgHash, privKey, opts.extraEntropy);
    const drbg = new HmacDrbg(hashLen, groupLen);
    await drbg.reseed(seed);
    let sig;
    while (!(sig = kmdToSig(await drbg.generate(), m2, d2, opts.canonical)))
      await drbg.reseed();
    return finalizeSig(sig, opts);
  }
  var vopts = { strict: true };
  function verify(signature, msgHash, publicKey, opts = vopts) {
    let sig;
    try {
      sig = normalizeSignature(signature);
      msgHash = ensureBytes3(msgHash);
    } catch (error) {
      return false;
    }
    const { r, s: s2 } = sig;
    if (opts.strict && sig.hasHighS())
      return false;
    const h2 = truncateHash(msgHash);
    let P;
    try {
      P = normalizePublicKey(publicKey);
    } catch (error) {
      return false;
    }
    const { n } = CURVE;
    const sinv = invert3(s2, n);
    const u1 = mod4(h2 * sinv, n);
    const u2 = mod4(r * sinv, n);
    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
    if (!R)
      return false;
    const v = mod4(R.x, n);
    return v === r;
  }
  Point.BASE._setWindowSize(8);
  var crypto4 = {
    node: nodeCrypto,
    web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
  };
  var TAGGED_HASH_PREFIXES = {};
  var utils = {
    bytesToHex: bytesToHex4,
    hexToBytes: hexToBytes4,
    concatBytes: concatBytes4,
    mod: mod4,
    invert: invert3,
    isValidPrivateKey(privateKey) {
      try {
        normalizePrivateKey(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    _bigintTo32Bytes: numTo32b,
    _normalizePrivateKey: normalizePrivateKey,
    hashToPrivateKey: (hash2) => {
      hash2 = ensureBytes3(hash2);
      const minLen = groupLen + 8;
      if (hash2.length < minLen || hash2.length > 1024) {
        throw new Error(`Expected valid bytes of private key as per FIPS 186`);
      }
      const num = mod4(bytesToNumber(hash2), CURVE.n - _1n13) + _1n13;
      return numTo32b(num);
    },
    randomBytes: (bytesLength = 32) => {
      if (crypto4.web) {
        return crypto4.web.getRandomValues(new Uint8Array(bytesLength));
      } else if (crypto4.node) {
        const { randomBytes: randomBytes5 } = crypto4.node;
        return Uint8Array.from(randomBytes5(bytesLength));
      } else {
        throw new Error("The environment doesn't have randomBytes function");
      }
    },
    randomPrivateKey: () => utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),
    precompute(windowSize = 8, point = Point.BASE) {
      const cached = point === Point.BASE ? point : new Point(point.x, point.y);
      cached._setWindowSize(windowSize);
      cached.multiply(_3n5);
      return cached;
    },
    sha256: async (...messages2) => {
      if (crypto4.web) {
        const buffer = await crypto4.web.subtle.digest("SHA-256", concatBytes4(...messages2));
        return new Uint8Array(buffer);
      } else if (crypto4.node) {
        const { createHash } = crypto4.node;
        const hash2 = createHash("sha256");
        messages2.forEach((m2) => hash2.update(m2));
        return Uint8Array.from(hash2.digest());
      } else {
        throw new Error("The environment doesn't have sha256 function");
      }
    },
    hmacSha256: async (key, ...messages2) => {
      if (crypto4.web) {
        const ckey = await crypto4.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
        const message2 = concatBytes4(...messages2);
        const buffer = await crypto4.web.subtle.sign("HMAC", ckey, message2);
        return new Uint8Array(buffer);
      } else if (crypto4.node) {
        const { createHmac } = crypto4.node;
        const hash2 = createHmac("sha256", key);
        messages2.forEach((m2) => hash2.update(m2));
        return Uint8Array.from(hash2.digest());
      } else {
        throw new Error("The environment doesn't have hmac-sha256 function");
      }
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (tag, ...messages2) => {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = concatBytes4(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return utils.sha256(tagP, ...messages2);
    },
    taggedHashSync: (tag, ...messages2) => {
      if (typeof _sha256Sync !== "function")
        throw new ShaError("sha256Sync is undefined, you need to set it");
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = concatBytes4(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return _sha256Sync(tagP, ...messages2);
    },
    _JacobianPoint: JacobianPoint
  };
  Object.defineProperties(utils, {
    sha256Sync: {
      configurable: false,
      get() {
        return _sha256Sync;
      },
      set(val) {
        if (!_sha256Sync)
          _sha256Sync = val;
      }
    },
    hmacSha256Sync: {
      configurable: false,
      get() {
        return _hmacSha256Sync;
      },
      set(val) {
        if (!_hmacSha256Sync)
          _hmacSha256Sync = val;
      }
    }
  });

  // ../node_modules/@waku/enr/dist/crypto.js
  var import_js_sha3 = __toESM(require_sha3(), 1);
  function keccak256(input) {
    return new Uint8Array(import_js_sha3.default.keccak256.arrayBuffer(input));
  }
  function verifySignature(signature, message2, publicKey) {
    try {
      const _signature = Signature.fromCompact(signature.slice(0, 64));
      return verify(_signature, message2, publicKey);
    } catch {
      return false;
    }
  }

  // ../node_modules/@waku/enr/dist/multiaddr_from_fields.js
  function multiaddrFromFields(ipFamily, protocol, ipBytes, protocolBytes) {
    let ma = multiaddr("/" + ipFamily + "/" + convertToString(ipFamily, ipBytes));
    ma = ma.encapsulate(multiaddr("/" + protocol + "/" + convertToString(protocol, protocolBytes)));
    return ma;
  }

  // ../node_modules/@waku/enr/dist/get_multiaddr.js
  function locationMultiaddrFromEnrFields(enr, protocol) {
    switch (protocol) {
      case "udp":
        return locationMultiaddrFromEnrFields(enr, "udp4") || locationMultiaddrFromEnrFields(enr, "udp6");
      case "tcp":
        return locationMultiaddrFromEnrFields(enr, "tcp4") || locationMultiaddrFromEnrFields(enr, "tcp6");
    }
    const isIpv6 = protocol.endsWith("6");
    const ipVal = enr.get(isIpv6 ? "ip6" : "ip");
    if (!ipVal)
      return;
    const protoName = protocol.slice(0, 3);
    let protoVal;
    switch (protoName) {
      case "udp":
        protoVal = isIpv6 ? enr.get("udp6") : enr.get("udp");
        break;
      case "tcp":
        protoVal = isIpv6 ? enr.get("tcp6") : enr.get("tcp");
        break;
      default:
        return;
    }
    if (!protoVal)
      return;
    return multiaddrFromFields(isIpv6 ? "ip6" : "ip4", protoName, ipVal, protoVal);
  }

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports16 = {};
  __export(base58_exports16, {
    base58btc: () => base58btc20,
    base58flickr: () => base58flickr20
  });

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/bytes.js
  var empty20 = new Uint8Array(0);
  function equals44(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce20(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function fromString30(str) {
    return new TextEncoder().encode(str);
  }
  function toString26(b) {
    return new TextDecoder().decode(b);
  }

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/vendor/base-x.js
  function base34(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src20 = base34;
  var _brrp__multiformats_scope_baseX20 = src20;
  var base_x_default20 = _brrp__multiformats_scope_baseX20;

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/bases/base.js
  var Encoder22 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder22 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or22(this, decoder);
    }
  };
  var ComposedDecoder20 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or22(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or22(left, right) {
    return new ComposedDecoder20({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec20 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder22(name19, prefix, baseEncode);
      this.decoder = new Decoder22(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from35({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec20(name19, prefix, encode79, decode99);
  }
  function baseX20({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default20(alphabet18, name19);
    return from35({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce20(decode99(text))
    });
  }
  function decode88(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode70(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx19(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc464819({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx19(alphabet18);
    return from35({
      prefix,
      name: name19,
      encode(input) {
        return encode70(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode88(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/bases/base58.js
  var base58btc20 = baseX20({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr20 = baseX20({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports16 = {};
  __export(base32_exports16, {
    base32: () => base3218,
    base32hex: () => base32hex18,
    base32hexpad: () => base32hexpad18,
    base32hexpadupper: () => base32hexpadupper18,
    base32hexupper: () => base32hexupper18,
    base32pad: () => base32pad18,
    base32padupper: () => base32padupper18,
    base32upper: () => base32upper18,
    base32z: () => base32z18
  });
  var base3218 = rfc464819({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper18 = rfc464819({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad18 = rfc464819({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper18 = rfc464819({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex18 = rfc464819({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper18 = rfc464819({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad18 = rfc464819({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper18 = rfc464819({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z18 = rfc464819({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports16 = {};
  __export(base36_exports16, {
    base36: () => base3617,
    base36upper: () => base36upper17
  });
  var base3617 = baseX20({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper17 = baseX20({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_118 = encode71;
  var MSB20 = 128;
  var REST20 = 127;
  var MSBALL18 = ~REST20;
  var INT18 = Math.pow(2, 31);
  function encode71(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT18) {
      out[offset++] = num & 255 | MSB20;
      num /= 128;
    }
    while (num & MSBALL18) {
      out[offset++] = num & 255 | MSB20;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode71.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode89 = read20;
  var MSB$118 = 128;
  var REST$118 = 127;
  function read20(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read20.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$118) << shift : (b & REST$118) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$118);
    read20.bytes = counter - offset;
    return res;
  }
  var N119 = Math.pow(2, 7);
  var N219 = Math.pow(2, 14);
  var N319 = Math.pow(2, 21);
  var N419 = Math.pow(2, 28);
  var N519 = Math.pow(2, 35);
  var N619 = Math.pow(2, 42);
  var N719 = Math.pow(2, 49);
  var N818 = Math.pow(2, 56);
  var N918 = Math.pow(2, 63);
  var length19 = function(value) {
    return value < N119 ? 1 : value < N219 ? 2 : value < N319 ? 3 : value < N419 ? 4 : value < N519 ? 5 : value < N619 ? 6 : value < N719 ? 7 : value < N818 ? 8 : value < N918 ? 9 : 10;
  };
  var varint18 = {
    encode: encode_118,
    decode: decode89,
    encodingLength: length19
  };
  var _brrp_varint18 = varint18;
  var varint_default18 = _brrp_varint18;

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/varint.js
  function decode90(data, offset = 0) {
    const code18 = varint_default18.decode(data, offset);
    return [code18, varint_default18.decode.bytes];
  }
  function encodeTo18(int, target, offset = 0) {
    varint_default18.encode(int, target, offset);
    return target;
  }
  function encodingLength19(int) {
    return varint_default18.encodingLength(int);
  }

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/hashes/digest.js
  function create17(code18, digest18) {
    const size = digest18.byteLength;
    const sizeOffset = encodingLength19(code18);
    const digestOffset = sizeOffset + encodingLength19(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo18(code18, bytes2, 0);
    encodeTo18(size, bytes2, sizeOffset);
    bytes2.set(digest18, digestOffset);
    return new Digest18(code18, size, digest18, bytes2);
  }
  function decode91(multihash) {
    const bytes2 = coerce20(multihash);
    const [code18, sizeOffset] = decode90(bytes2);
    const [size, digestOffset] = decode90(bytes2.subarray(sizeOffset));
    const digest18 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest18.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest18(code18, size, digest18, bytes2);
  }
  function equals45(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals44(a.bytes, data.bytes);
    }
  }
  var Digest18 = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code18, size, digest18, bytes2) {
      this.code = code18;
      this.size = size;
      this.digest = digest18;
      this.bytes = bytes2;
    }
  };

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/cid.js
  function format17(link, base37) {
    const { bytes: bytes2, version: version5 } = link;
    switch (version5) {
      case 0:
        return toStringV017(bytes2, baseCache17(link), base37 ?? base58btc20.encoder);
      default:
        return toStringV117(bytes2, baseCache17(link), base37 ?? base3218.encoder);
    }
  }
  var cache18 = /* @__PURE__ */ new WeakMap();
  function baseCache17(cid) {
    const baseCache19 = cache18.get(cid);
    if (baseCache19 == null) {
      const baseCache20 = /* @__PURE__ */ new Map();
      cache18.set(cid, baseCache20);
      return baseCache20;
    }
    return baseCache19;
  }
  var CID17 = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version5, code18, multihash, bytes2) {
      this.code = code18;
      this.version = version5;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code18, multihash } = this;
          if (code18 !== DAG_PB_CODE17) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE17) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code18, digest: digest18 } = this.multihash;
          const multihash = create17(code18, digest18);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals45(self2.multihash, unknown.multihash);
    }
    toString(base37) {
      return format17(this, base37);
    }
    toJSON() {
      return { "/": format17(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version5, code: code18, multihash, bytes: bytes2 } = value;
        return new _CID(version5, code18, multihash, bytes2 ?? encodeCID17(version5, code18, multihash.bytes));
      } else if (value[cidSymbol17] === true) {
        const { version: version5, multihash, code: code18 } = value;
        const digest18 = decode91(multihash);
        return _CID.create(version5, code18, digest18);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version5, code18, digest18) {
      if (typeof code18 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest18.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version5) {
        case 0: {
          if (code18 !== DAG_PB_CODE17) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE17}) block encoding`);
          } else {
            return new _CID(version5, code18, digest18, digest18.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID17(version5, code18, digest18.bytes);
          return new _CID(version5, code18, digest18, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest18) {
      return _CID.create(0, DAG_PB_CODE17, digest18);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code18, digest18) {
      return _CID.create(1, code18, digest18);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes2) {
      const [cid, remainder] = _CID.decodeFirst(bytes2);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes2) {
      const specs = _CID.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce20(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest18 = new Digest18(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest18) : _CID.createV1(specs.codec, digest18);
      return [cid, bytes2.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length21] = decode90(initialBytes.subarray(offset));
        offset += length21;
        return i;
      };
      let version5 = next();
      let codec = DAG_PB_CODE17;
      if (version5 === 18) {
        version5 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version5 !== 0 && version5 !== 1) {
        throw new RangeError(`Invalid CID version ${version5}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version5, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base37) {
      const [prefix, bytes2] = parseCIDtoBytes17(source, base37);
      const cid = _CID.decode(bytes2);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache17(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes17(source, base37) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base37 ?? base58btc20;
        return [
          base58btc20.prefix,
          decoder.decode(`${base58btc20.prefix}${source}`)
        ];
      }
      case base58btc20.prefix: {
        const decoder = base37 ?? base58btc20;
        return [base58btc20.prefix, decoder.decode(source)];
      }
      case base3218.prefix: {
        const decoder = base37 ?? base3218;
        return [base3218.prefix, decoder.decode(source)];
      }
      case base3617.prefix: {
        const decoder = base37 ?? base3617;
        return [base3617.prefix, decoder.decode(source)];
      }
      default: {
        if (base37 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base37.decode(source)];
      }
    }
  }
  function toStringV017(bytes2, cache20, base37) {
    const { prefix } = base37;
    if (prefix !== base58btc20.prefix) {
      throw Error(`Cannot string encode V0 in ${base37.name} encoding`);
    }
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2).slice(1);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV117(bytes2, cache20, base37) {
    const { prefix } = base37;
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE17 = 112;
  var SHA_256_CODE17 = 18;
  function encodeCID17(version5, code18, multihash) {
    const codeOffset = encodingLength19(version5);
    const hashOffset = codeOffset + encodingLength19(code18);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo18(version5, bytes2, 0);
    encodeTo18(code18, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  }
  var cidSymbol17 = Symbol.for("@ipld/js-cid/CID");

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports31 = {};
  __export(identity_exports31, {
    identity: () => identity31
  });
  var code16 = 0;
  var name17 = "identity";
  var encode72 = coerce20;
  function digest16(input, options) {
    if (options?.truncate != null && options.truncate !== input.byteLength) {
      if (options.truncate < 0 || options.truncate > input.byteLength) {
        throw new Error(`Invalid truncate option, must be less than or equal to ${input.byteLength}`);
      }
      input = input.subarray(0, options.truncate);
    }
    return create17(code16, encode72(input));
  }
  var identity31 = { code: code16, name: name17, encode: encode72, digest: digest16 };

  // ../node_modules/@waku/enr/node_modules/uint8arrays/dist/src/equals.js
  function equals46(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports16 = {};
  __export(base10_exports16, {
    base10: () => base1016
  });
  var base1016 = baseX20({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports16 = {};
  __export(base16_exports16, {
    base16: () => base1616,
    base16upper: () => base16upper16
  });
  var base1616 = rfc464819({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper16 = rfc464819({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports16 = {};
  __export(base2_exports16, {
    base2: () => base216
  });
  var base216 = rfc464819({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports16 = {};
  __export(base256emoji_exports16, {
    base256emoji: () => base256emoji16
  });
  var alphabet16 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars16 = alphabet16.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes16 = alphabet16.reduce((p, c, i) => {
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
  }, []);
  function encode73(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars16[c];
      return p;
    }, "");
  }
  function decode92(str) {
    const byts = [];
    for (const char of str) {
      const codePoint = char.codePointAt(0);
      if (codePoint == null) {
        throw new Error(`Invalid character: ${char}`);
      }
      const byt = alphabetCharsToBytes16[codePoint];
      if (byt == null) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji16 = from35({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode73,
    decode: decode92
  });

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports16 = {};
  __export(base64_exports16, {
    base64: () => base6418,
    base64pad: () => base64pad18,
    base64url: () => base64url18,
    base64urlpad: () => base64urlpad18
  });
  var base6418 = rfc464819({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad18 = rfc464819({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url18 = rfc464819({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad18 = rfc464819({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports16 = {};
  __export(base8_exports16, {
    base8: () => base816
  });
  var base816 = rfc464819({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports32 = {};
  __export(identity_exports32, {
    identity: () => identity32
  });
  var identity32 = from35({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString26(buf),
    decode: (str) => fromString30(str)
  });

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/codecs/json.js
  var textEncoder16 = new TextEncoder();
  var textDecoder16 = new TextDecoder();

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports16 = {};
  __export(sha2_browser_exports16, {
    sha256: () => sha25619,
    sha512: () => sha51218
  });

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/hashes/hasher.js
  var DEFAULT_MIN_DIGEST_LENGTH2 = 20;
  function from36({ name: name19, code: code18, encode: encode79, minDigestLength, maxDigestLength }) {
    return new Hasher16(name19, code18, encode79, minDigestLength, maxDigestLength);
  }
  var Hasher16 = class {
    name;
    code;
    encode;
    minDigestLength;
    maxDigestLength;
    constructor(name19, code18, encode79, minDigestLength, maxDigestLength) {
      this.name = name19;
      this.code = code18;
      this.encode = encode79;
      this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH2;
      this.maxDigestLength = maxDigestLength;
    }
    digest(input, options) {
      if (options?.truncate != null) {
        if (options.truncate < this.minDigestLength) {
          throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);
        }
        if (this.maxDigestLength != null && options.truncate > this.maxDigestLength) {
          throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`);
        }
      }
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        if (result instanceof Uint8Array) {
          return createDigest2(result, this.code, options?.truncate);
        }
        return result.then((digest18) => createDigest2(digest18, this.code, options?.truncate));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  function createDigest2(digest18, code18, truncate) {
    if (truncate != null && truncate !== digest18.byteLength) {
      if (truncate > digest18.byteLength) {
        throw new Error(`Invalid truncate option, must be less than or equal to ${digest18.byteLength}`);
      }
      digest18 = digest18.subarray(0, truncate);
    }
    return create17(code18, digest18);
  }

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  function sha16(name19) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name19, data));
  }
  var sha25619 = from36({
    name: "sha2-256",
    code: 18,
    encode: sha16("SHA-256")
  });
  var sha51218 = from36({
    name: "sha2-512",
    code: 19,
    encode: sha16("SHA-512")
  });

  // ../node_modules/@waku/enr/node_modules/multiformats/dist/src/basics.js
  var bases16 = { ...identity_exports32, ...base2_exports16, ...base8_exports16, ...base10_exports16, ...base16_exports16, ...base32_exports16, ...base36_exports16, ...base58_exports16, ...base64_exports16, ...base256emoji_exports16 };
  var hashes16 = { ...sha2_browser_exports16, ...identity_exports31 };

  // ../node_modules/@waku/enr/node_modules/uint8arrays/dist/src/alloc.js
  function allocUnsafe20(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/@waku/enr/node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec17(name19, prefix, encode79, decode99) {
    return {
      name: name19,
      prefix,
      encoder: {
        name: name19,
        prefix,
        encode: encode79
      },
      decoder: {
        decode: decode99
      }
    };
  }
  var string17 = createCodec17("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder3 = new TextEncoder();
    return encoder3.encode(str.substring(1));
  });
  var ascii16 = createCodec17("ascii", "a", (buf) => {
    let string19 = "a";
    for (let i = 0; i < buf.length; i++) {
      string19 += String.fromCharCode(buf[i]);
    }
    return string19;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe20(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  var BASES16 = {
    utf8: string17,
    "utf-8": string17,
    hex: bases16.base16,
    latin1: ascii16,
    ascii: ascii16,
    binary: ascii16,
    ...bases16
  };
  var bases_default16 = BASES16;

  // ../node_modules/@waku/enr/node_modules/uint8arrays/dist/src/from-string.js
  function fromString31(string19, encoding = "utf8") {
    const base37 = bases_default16[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.decoder.decode(`${base37.prefix}${string19}`);
  }

  // ../node_modules/@waku/enr/node_modules/uint8arrays/dist/src/to-string.js
  function toString27(array, encoding = "utf8") {
    const base37 = bases_default16[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.encoder.encode(array).substring(1);
  }

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/rsa/der.js
  var TAG_MASK2 = parseInt("11111", 2);
  var LONG_LENGTH_MASK2 = parseInt("10000000", 2);
  var LONG_LENGTH_BYTES_MASK2 = parseInt("01111111", 2);
  var decoders3 = {
    0: readSequence2,
    1: readSequence2,
    2: readInteger2,
    3: readBitString2,
    4: readOctetString2,
    5: readNull2,
    6: readObjectIdentifier2,
    16: readSequence2,
    22: readSequence2,
    48: readSequence2
  };
  function decodeDer2(buf, context = { offset: 0 }) {
    const tag = buf[context.offset] & TAG_MASK2;
    context.offset++;
    if (decoders3[tag] != null) {
      return decoders3[tag](buf, context);
    }
    throw new Error("No decoder for tag " + tag);
  }
  function readLength2(buf, context) {
    let length21 = 0;
    if ((buf[context.offset] & LONG_LENGTH_MASK2) === LONG_LENGTH_MASK2) {
      const count = buf[context.offset] & LONG_LENGTH_BYTES_MASK2;
      let str = "0x";
      context.offset++;
      for (let i = 0; i < count; i++, context.offset++) {
        str += buf[context.offset].toString(16).padStart(2, "0");
      }
      length21 = parseInt(str, 16);
    } else {
      length21 = buf[context.offset];
      context.offset++;
    }
    return length21;
  }
  function readSequence2(buf, context) {
    readLength2(buf, context);
    const entries = [];
    while (true) {
      if (context.offset >= buf.byteLength) {
        break;
      }
      const result = decodeDer2(buf, context);
      if (result === null) {
        break;
      }
      entries.push(result);
    }
    return entries;
  }
  function readInteger2(buf, context) {
    const length21 = readLength2(buf, context);
    const start2 = context.offset;
    const end = context.offset + length21;
    const vals = [];
    for (let i = start2; i < end; i++) {
      if (i === start2 && buf[i] === 0) {
        continue;
      }
      vals.push(buf[i]);
    }
    context.offset += length21;
    return Uint8Array.from(vals);
  }
  function readObjectIdentifier2(buf, context) {
    const count = readLength2(buf, context);
    const finalOffset = context.offset + count;
    const byte = buf[context.offset];
    context.offset++;
    let val1 = 0;
    let val2 = 0;
    if (byte < 40) {
      val1 = 0;
      val2 = byte;
    } else if (byte < 80) {
      val1 = 1;
      val2 = byte - 40;
    } else {
      val1 = 2;
      val2 = byte - 80;
    }
    let oid = `${val1}.${val2}`;
    let num = [];
    while (context.offset < finalOffset) {
      const byte2 = buf[context.offset];
      context.offset++;
      num.push(byte2 & 127);
      if (byte2 < 128) {
        num.reverse();
        let val = 0;
        for (let i = 0; i < num.length; i++) {
          val += num[i] << i * 7;
        }
        oid += `.${val}`;
        num = [];
      }
    }
    return oid;
  }
  function readNull2(buf, context) {
    context.offset++;
    return null;
  }
  function readBitString2(buf, context) {
    const length21 = readLength2(buf, context);
    const unusedBits = buf[context.offset];
    context.offset++;
    const bytes2 = buf.subarray(context.offset, context.offset + length21 - 1);
    context.offset += length21;
    if (unusedBits !== 0) {
      throw new Error("Unused bits in bit string is unimplemented");
    }
    return bytes2;
  }
  function readOctetString2(buf, context) {
    const length21 = readLength2(buf, context);
    const bytes2 = buf.subarray(context.offset, context.offset + length21);
    context.offset += length21;
    return bytes2;
  }
  function encodeNumber2(value) {
    let number3 = value.toString(16);
    if (number3.length % 2 === 1) {
      number3 = "0" + number3;
    }
    const array = new Uint8ArrayList();
    for (let i = 0; i < number3.length; i += 2) {
      array.append(Uint8Array.from([parseInt(`${number3[i]}${number3[i + 1]}`, 16)]));
    }
    return array;
  }
  function encodeLength2(bytes2) {
    if (bytes2.byteLength < 128) {
      return Uint8Array.from([bytes2.byteLength]);
    }
    const length21 = encodeNumber2(bytes2.byteLength);
    return new Uint8ArrayList(Uint8Array.from([
      length21.byteLength | LONG_LENGTH_MASK2
    ]), length21);
  }
  function encodeInteger2(value) {
    const contents = new Uint8ArrayList();
    const mask = 128;
    const positive2 = (value.subarray()[0] & mask) === mask;
    if (positive2) {
      contents.append(Uint8Array.from([0]));
    }
    contents.append(value);
    return new Uint8ArrayList(Uint8Array.from([2]), encodeLength2(contents), contents);
  }
  function encodeBitString2(value) {
    const unusedBits = Uint8Array.from([0]);
    const contents = new Uint8ArrayList(unusedBits, value);
    return new Uint8ArrayList(Uint8Array.from([3]), encodeLength2(contents), contents);
  }
  function encodeSequence2(values, tag = 48) {
    const output2 = new Uint8ArrayList();
    for (const buf of values) {
      output2.append(buf);
    }
    return new Uint8ArrayList(Uint8Array.from([tag]), encodeLength2(output2), output2);
  }

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/ecdsa/index.js
  var ECDSA_P_256_OID = "1.2.840.10045.3.1.7";
  var ECDSA_P_384_OID = "1.3.132.0.34";
  var ECDSA_P_521_OID = "1.3.132.0.35";
  async function hashAndVerify5(key, sig, msg, options) {
    const publicKey = await crypto.subtle.importKey("jwk", key, {
      name: "ECDSA",
      namedCurve: key.crv ?? "P-256"
    }, false, ["verify"]);
    options?.signal?.throwIfAborted();
    const result = await crypto.subtle.verify({
      name: "ECDSA",
      hash: {
        name: "SHA-256"
      }
    }, publicKey, sig, msg.subarray());
    options?.signal?.throwIfAborted();
    return result;
  }

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/ecdsa/utils.js
  var OID_2562 = Uint8Array.from([6, 8, 42, 134, 72, 206, 61, 3, 1, 7]);
  var OID_3842 = Uint8Array.from([6, 5, 43, 129, 4, 0, 34]);
  var OID_5212 = Uint8Array.from([6, 5, 43, 129, 4, 0, 35]);
  var P_256_KEY_JWK2 = {
    ext: true,
    kty: "EC",
    crv: "P-256"
  };
  var P_384_KEY_JWK2 = {
    ext: true,
    kty: "EC",
    crv: "P-384"
  };
  var P_521_KEY_JWK2 = {
    ext: true,
    kty: "EC",
    crv: "P-521"
  };
  var P_256_KEY_LENGTH2 = 32;
  var P_384_KEY_LENGTH2 = 48;
  var P_521_KEY_LENGTH2 = 66;
  function pkiMessageToECDSAPublicKey2(message2) {
    const coordinates = message2[1][1][0];
    const offset = 1;
    let x;
    let y2;
    if (coordinates.byteLength === P_256_KEY_LENGTH2 * 2 + 1) {
      x = toString27(coordinates.subarray(offset, offset + P_256_KEY_LENGTH2), "base64url");
      y2 = toString27(coordinates.subarray(offset + P_256_KEY_LENGTH2), "base64url");
      return new ECDSAPublicKey2({
        ...P_256_KEY_JWK2,
        key_ops: ["verify"],
        x,
        y: y2
      });
    }
    if (coordinates.byteLength === P_384_KEY_LENGTH2 * 2 + 1) {
      x = toString27(coordinates.subarray(offset, offset + P_384_KEY_LENGTH2), "base64url");
      y2 = toString27(coordinates.subarray(offset + P_384_KEY_LENGTH2), "base64url");
      return new ECDSAPublicKey2({
        ...P_384_KEY_JWK2,
        key_ops: ["verify"],
        x,
        y: y2
      });
    }
    if (coordinates.byteLength === P_521_KEY_LENGTH2 * 2 + 1) {
      x = toString27(coordinates.subarray(offset, offset + P_521_KEY_LENGTH2), "base64url");
      y2 = toString27(coordinates.subarray(offset + P_521_KEY_LENGTH2), "base64url");
      return new ECDSAPublicKey2({
        ...P_521_KEY_JWK2,
        key_ops: ["verify"],
        x,
        y: y2
      });
    }
    throw new InvalidParametersError(`coordinates were wrong length, got ${coordinates.byteLength}, expected 65, 97 or 133`);
  }
  function publicKeyToPKIMessage2(publicKey) {
    return encodeSequence2([
      encodeInteger2(Uint8Array.from([1])),
      // header
      encodeSequence2([
        getOID2(publicKey.crv)
      ], 160),
      encodeSequence2([
        encodeBitString2(new Uint8ArrayList(Uint8Array.from([4]), fromString31(publicKey.x ?? "", "base64url"), fromString31(publicKey.y ?? "", "base64url")))
      ], 161)
    ]).subarray();
  }
  function getOID2(curve) {
    if (curve === "P-256") {
      return OID_2562;
    }
    if (curve === "P-384") {
      return OID_3842;
    }
    if (curve === "P-521") {
      return OID_5212;
    }
    throw new InvalidParametersError(`Invalid curve ${curve}`);
  }

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/ecdsa/ecdsa.js
  var ECDSAPublicKey2 = class {
    type = "ECDSA";
    jwk;
    _raw;
    constructor(jwk) {
      this.jwk = jwk;
    }
    get raw() {
      if (this._raw == null) {
        this._raw = publicKeyToPKIMessage2(this.jwk);
      }
      return this._raw;
    }
    toMultihash() {
      return identity31.digest(publicKeyToProtobuf2(this));
    }
    toCID() {
      return CID17.createV1(114, this.toMultihash());
    }
    toString() {
      return base58btc20.encode(this.toMultihash().bytes).substring(1);
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals46(this.raw, key.raw);
    }
    async verify(data, sig, options) {
      return hashAndVerify5(this.jwk, sig, data, options);
    }
  };

  // ../node_modules/@waku/enr/node_modules/@noble/hashes/esm/crypto.js
  var crypto5 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

  // ../node_modules/@waku/enr/node_modules/@noble/hashes/esm/utils.js
  function isBytes3(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function anumber3(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error("positive integer expected, got " + n);
  }
  function abytes3(b, ...lengths) {
    if (!isBytes3(b))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
  }
  function ahash2(h2) {
    if (typeof h2 !== "function" || typeof h2.create !== "function")
      throw new Error("Hash should be wrapped by utils.createHasher");
    anumber3(h2.outputLen);
    anumber3(h2.blockLen);
  }
  function aexists3(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput3(out, instance) {
    abytes3(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least " + min);
    }
  }
  function clean3(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
      arrays[i].fill(0);
    }
  }
  function createView4(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function rotr3(word, shift) {
    return word << 32 - shift | word >>> shift;
  }
  var hasHexBuiltin2 = /* @__PURE__ */ (() => (
    // @ts-ignore
    typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
  ))();
  var hexes4 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex5(bytes2) {
    abytes3(bytes2);
    if (hasHexBuiltin2)
      return bytes2.toHex();
    let hex = "";
    for (let i = 0; i < bytes2.length; i++) {
      hex += hexes4[bytes2[i]];
    }
    return hex;
  }
  var asciis2 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function asciiToBase162(ch) {
    if (ch >= asciis2._0 && ch <= asciis2._9)
      return ch - asciis2._0;
    if (ch >= asciis2.A && ch <= asciis2.F)
      return ch - (asciis2.A - 10);
    if (ch >= asciis2.a && ch <= asciis2.f)
      return ch - (asciis2.a - 10);
    return;
  }
  function hexToBytes5(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    if (hasHexBuiltin2)
      return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase162(hex.charCodeAt(hi));
      const n2 = asciiToBase162(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  }
  function utf8ToBytes5(str) {
    if (typeof str !== "string")
      throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes4(data) {
    if (typeof data === "string")
      data = utf8ToBytes5(data);
    abytes3(data);
    return data;
  }
  function concatBytes5(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      abytes3(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  }
  var Hash4 = class {
  };
  function createHasher2(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes4(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function randomBytes4(bytesLength = 32) {
    if (crypto5 && typeof crypto5.getRandomValues === "function") {
      return crypto5.getRandomValues(new Uint8Array(bytesLength));
    }
    if (crypto5 && typeof crypto5.randomBytes === "function") {
      return Uint8Array.from(crypto5.randomBytes(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }

  // ../node_modules/@waku/enr/node_modules/@noble/hashes/esm/_md.js
  function setBigUint644(view, byteOffset, value, isLE3) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE3);
    const _32n4 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n4 & _u32_max);
    const wl = Number(value & _u32_max);
    const h2 = isLE3 ? 4 : 0;
    const l = isLE3 ? 0 : 4;
    view.setUint32(byteOffset + h2, wh, isLE3);
    view.setUint32(byteOffset + l, wl, isLE3);
  }
  function Chi3(a, b, c) {
    return a & b ^ ~a & c;
  }
  function Maj3(a, b, c) {
    return a & b ^ a & c ^ b & c;
  }
  var HashMD2 = class extends Hash4 {
    constructor(blockLen, outputLen, padOffset, isLE3) {
      super();
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE3;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView4(this.buffer);
    }
    update(data) {
      aexists3(this);
      data = toBytes4(data);
      abytes3(data);
      const { view, buffer, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take2 = Math.min(blockLen - this.pos, len - pos);
        if (take2 === blockLen) {
          const dataView = createView4(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take2), this.pos);
        this.pos += take2;
        pos += take2;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      aexists3(this);
      aoutput3(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE3 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      clean3(this.buffer.subarray(pos));
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint644(view, blockLen - 8, BigInt(this.length * 8), isLE3);
      this.process(view, 0);
      const oview = createView4(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE3);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length: length21, finished, destroyed, pos } = this;
      to.destroyed = destroyed;
      to.finished = finished;
      to.length = length21;
      to.pos = pos;
      if (length21 % blockLen)
        to.buffer.set(buffer);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  };
  var SHA256_IV2 = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA512_IV2 = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]);

  // ../node_modules/@waku/enr/node_modules/@noble/hashes/esm/_u64.js
  var U32_MASK643 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n3 = /* @__PURE__ */ BigInt(32);
  function fromBig3(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK643), l: Number(n >> _32n3 & U32_MASK643) };
    return { h: Number(n >> _32n3 & U32_MASK643) | 0, l: Number(n & U32_MASK643) | 0 };
  }
  function split3(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
      const { h: h2, l } = fromBig3(lst[i], le);
      [Ah[i], Al[i]] = [h2, l];
    }
    return [Ah, Al];
  }
  var shrSH3 = (h2, _l, s2) => h2 >>> s2;
  var shrSL3 = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
  var rotrSH3 = (h2, l, s2) => h2 >>> s2 | l << 32 - s2;
  var rotrSL3 = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
  var rotrBH3 = (h2, l, s2) => h2 << 64 - s2 | l >>> s2 - 32;
  var rotrBL3 = (h2, l, s2) => h2 >>> s2 - 32 | l << 64 - s2;
  function add3(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  var add3L3 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  var add3H3 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  var add4L3 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  var add4H3 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  var add5L3 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  var add5H3 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

  // ../node_modules/@waku/enr/node_modules/@noble/hashes/esm/sha2.js
  var SHA256_K3 = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var SHA256_W3 = /* @__PURE__ */ new Uint32Array(64);
  var SHA2563 = class extends HashMD2 {
    constructor(outputLen = 32) {
      super(64, outputLen, 8, false);
      this.A = SHA256_IV2[0] | 0;
      this.B = SHA256_IV2[1] | 0;
      this.C = SHA256_IV2[2] | 0;
      this.D = SHA256_IV2[3] | 0;
      this.E = SHA256_IV2[4] | 0;
      this.F = SHA256_IV2[5] | 0;
      this.G = SHA256_IV2[6] | 0;
      this.H = SHA256_IV2[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        SHA256_W3[i] = view.getUint32(offset, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W3[i - 15];
        const W2 = SHA256_W3[i - 2];
        const s0 = rotr3(W15, 7) ^ rotr3(W15, 18) ^ W15 >>> 3;
        const s1 = rotr3(W2, 17) ^ rotr3(W2, 19) ^ W2 >>> 10;
        SHA256_W3[i] = s1 + SHA256_W3[i - 7] + s0 + SHA256_W3[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = rotr3(E, 6) ^ rotr3(E, 11) ^ rotr3(E, 25);
        const T1 = H + sigma1 + Chi3(E, F, G) + SHA256_K3[i] + SHA256_W3[i] | 0;
        const sigma0 = rotr3(A, 2) ^ rotr3(A, 13) ^ rotr3(A, 22);
        const T2 = sigma0 + Maj3(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      clean3(SHA256_W3);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      clean3(this.buffer);
    }
  };
  var K5122 = /* @__PURE__ */ (() => split3([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n) => BigInt(n))))();
  var SHA512_Kh3 = /* @__PURE__ */ (() => K5122[0])();
  var SHA512_Kl3 = /* @__PURE__ */ (() => K5122[1])();
  var SHA512_W_H3 = /* @__PURE__ */ new Uint32Array(80);
  var SHA512_W_L3 = /* @__PURE__ */ new Uint32Array(80);
  var SHA5123 = class extends HashMD2 {
    constructor(outputLen = 64) {
      super(128, outputLen, 16, false);
      this.Ah = SHA512_IV2[0] | 0;
      this.Al = SHA512_IV2[1] | 0;
      this.Bh = SHA512_IV2[2] | 0;
      this.Bl = SHA512_IV2[3] | 0;
      this.Ch = SHA512_IV2[4] | 0;
      this.Cl = SHA512_IV2[5] | 0;
      this.Dh = SHA512_IV2[6] | 0;
      this.Dl = SHA512_IV2[7] | 0;
      this.Eh = SHA512_IV2[8] | 0;
      this.El = SHA512_IV2[9] | 0;
      this.Fh = SHA512_IV2[10] | 0;
      this.Fl = SHA512_IV2[11] | 0;
      this.Gh = SHA512_IV2[12] | 0;
      this.Gl = SHA512_IV2[13] | 0;
      this.Hh = SHA512_IV2[14] | 0;
      this.Hl = SHA512_IV2[15] | 0;
    }
    // prettier-ignore
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4) {
        SHA512_W_H3[i] = view.getUint32(offset);
        SHA512_W_L3[i] = view.getUint32(offset += 4);
      }
      for (let i = 16; i < 80; i++) {
        const W15h = SHA512_W_H3[i - 15] | 0;
        const W15l = SHA512_W_L3[i - 15] | 0;
        const s0h = rotrSH3(W15h, W15l, 1) ^ rotrSH3(W15h, W15l, 8) ^ shrSH3(W15h, W15l, 7);
        const s0l = rotrSL3(W15h, W15l, 1) ^ rotrSL3(W15h, W15l, 8) ^ shrSL3(W15h, W15l, 7);
        const W2h = SHA512_W_H3[i - 2] | 0;
        const W2l = SHA512_W_L3[i - 2] | 0;
        const s1h = rotrSH3(W2h, W2l, 19) ^ rotrBH3(W2h, W2l, 61) ^ shrSH3(W2h, W2l, 6);
        const s1l = rotrSL3(W2h, W2l, 19) ^ rotrBL3(W2h, W2l, 61) ^ shrSL3(W2h, W2l, 6);
        const SUMl = add4L3(s0l, s1l, SHA512_W_L3[i - 7], SHA512_W_L3[i - 16]);
        const SUMh = add4H3(SUMl, s0h, s1h, SHA512_W_H3[i - 7], SHA512_W_H3[i - 16]);
        SHA512_W_H3[i] = SUMh | 0;
        SHA512_W_L3[i] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i = 0; i < 80; i++) {
        const sigma1h = rotrSH3(Eh, El, 14) ^ rotrSH3(Eh, El, 18) ^ rotrBH3(Eh, El, 41);
        const sigma1l = rotrSL3(Eh, El, 14) ^ rotrSL3(Eh, El, 18) ^ rotrBL3(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = add5L3(Hl, sigma1l, CHIl, SHA512_Kl3[i], SHA512_W_L3[i]);
        const T1h = add5H3(T1ll, Hh, sigma1h, CHIh, SHA512_Kh3[i], SHA512_W_H3[i]);
        const T1l = T1ll | 0;
        const sigma0h = rotrSH3(Ah, Al, 28) ^ rotrBH3(Ah, Al, 34) ^ rotrBH3(Ah, Al, 39);
        const sigma0l = rotrSL3(Ah, Al, 28) ^ rotrBL3(Ah, Al, 34) ^ rotrBL3(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = add3(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = add3L3(T1l, sigma0l, MAJl);
        Ah = add3H3(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = add3(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = add3(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = add3(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = add3(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = add3(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = add3(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = add3(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = add3(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      clean3(SHA512_W_H3, SHA512_W_L3);
    }
    destroy() {
      clean3(this.buffer);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  var sha25620 = /* @__PURE__ */ createHasher2(() => new SHA2563());
  var sha51219 = /* @__PURE__ */ createHasher2(() => new SHA5123());

  // ../node_modules/@waku/enr/node_modules/@noble/curves/esm/utils.js
  var _0n14 = /* @__PURE__ */ BigInt(0);
  var _1n14 = /* @__PURE__ */ BigInt(1);
  function _abool22(value, title = "") {
    if (typeof value !== "boolean") {
      const prefix = title && `"${title}"`;
      throw new Error(prefix + "expected boolean, got type=" + typeof value);
    }
    return value;
  }
  function _abytes22(value, length21, title = "") {
    const bytes2 = isBytes3(value);
    const len = value?.length;
    const needsLen = length21 !== void 0;
    if (!bytes2 || needsLen && len !== length21) {
      const prefix = title && `"${title}" `;
      const ofLen = needsLen ? ` of length ${length21}` : "";
      const got = bytes2 ? `length=${len}` : `type=${typeof value}`;
      throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
    }
    return value;
  }
  function numberToHexUnpadded3(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? "0" + hex : hex;
  }
  function hexToNumber4(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return hex === "" ? _0n14 : BigInt("0x" + hex);
  }
  function bytesToNumberBE3(bytes2) {
    return hexToNumber4(bytesToHex5(bytes2));
  }
  function bytesToNumberLE3(bytes2) {
    abytes3(bytes2);
    return hexToNumber4(bytesToHex5(Uint8Array.from(bytes2).reverse()));
  }
  function numberToBytesBE3(n, len) {
    return hexToBytes5(n.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE3(n, len) {
    return numberToBytesBE3(n, len).reverse();
  }
  function ensureBytes4(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes5(hex);
      } catch (e) {
        throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
      }
    } else if (isBytes3(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(title + " must be hex string or Uint8Array");
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(title + " of length " + expectedLength + " expected, got " + len);
    return res;
  }
  function equalBytes3(a, b) {
    if (a.length !== b.length)
      return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
      diff |= a[i] ^ b[i];
    return diff === 0;
  }
  function copyBytes3(bytes2) {
    return Uint8Array.from(bytes2);
  }
  var isPosBig2 = (n) => typeof n === "bigint" && _0n14 <= n;
  function inRange2(n, min, max) {
    return isPosBig2(n) && isPosBig2(min) && isPosBig2(max) && min <= n && n < max;
  }
  function aInRange2(title, n, min, max) {
    if (!inRange2(n, min, max))
      throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
  }
  function bitLen2(n) {
    let len;
    for (len = 0; n > _0n14; n >>= _1n14, len += 1)
      ;
    return len;
  }
  var bitMask3 = (n) => (_1n14 << BigInt(n)) - _1n14;
  function createHmacDrbg2(hashLen2, qByteLen, hmacFn) {
    if (typeof hashLen2 !== "number" || hashLen2 < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    const u8n = (len) => new Uint8Array(len);
    const u8of = (byte) => Uint8Array.of(byte);
    let v = u8n(hashLen2);
    let k = u8n(hashLen2);
    let i = 0;
    const reset = () => {
      v.fill(1);
      k.fill(0);
      i = 0;
    };
    const h2 = (...b) => hmacFn(k, v, ...b);
    const reseed = (seed = u8n(0)) => {
      k = h2(u8of(0), seed);
      v = h2();
      if (seed.length === 0)
        return;
      k = h2(u8of(1), seed);
      v = h2();
    };
    const gen = () => {
      if (i++ >= 1e3)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v = h2();
        const sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return concatBytes5(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  function _validateObject2(object, fields, optFields = {}) {
    if (!object || typeof object !== "object")
      throw new Error("expected valid options object");
    function checkField(fieldName, expectedType, isOpt) {
      const val = object[fieldName];
      if (isOpt && val === void 0)
        return;
      const current = typeof val;
      if (current !== expectedType || val === null)
        throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
  }
  var notImplemented2 = () => {
    throw new Error("not implemented");
  };
  function memoized2(fn) {
    const map2 = /* @__PURE__ */ new WeakMap();
    return (arg, ...args) => {
      const val = map2.get(arg);
      if (val !== void 0)
        return val;
      const computed = fn(arg, ...args);
      map2.set(arg, computed);
      return computed;
    };
  }

  // ../node_modules/@waku/enr/node_modules/@noble/curves/esm/abstract/modular.js
  var _0n15 = BigInt(0);
  var _1n15 = BigInt(1);
  var _2n11 = /* @__PURE__ */ BigInt(2);
  var _3n6 = /* @__PURE__ */ BigInt(3);
  var _4n4 = /* @__PURE__ */ BigInt(4);
  var _5n5 = /* @__PURE__ */ BigInt(5);
  var _7n2 = /* @__PURE__ */ BigInt(7);
  var _8n7 = /* @__PURE__ */ BigInt(8);
  var _9n3 = /* @__PURE__ */ BigInt(9);
  var _16n3 = /* @__PURE__ */ BigInt(16);
  function mod5(a, b) {
    const result = a % b;
    return result >= _0n15 ? result : b + result;
  }
  function pow24(x, power, modulo) {
    let res = x;
    while (power-- > _0n15) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert4(number3, modulo) {
    if (number3 === _0n15)
      throw new Error("invert: expected non-zero number");
    if (modulo <= _0n15)
      throw new Error("invert: expected positive modulus, got " + modulo);
    let a = mod5(number3, modulo);
    let b = modulo;
    let x = _0n15, y2 = _1n15, u = _1n15, v = _0n15;
    while (a !== _0n15) {
      const q = b / a;
      const r = b % a;
      const m2 = x - u * q;
      const n = y2 - v * q;
      b = a, a = r, x = u, y2 = v, u = m2, v = n;
    }
    const gcd = b;
    if (gcd !== _1n15)
      throw new Error("invert: does not exist");
    return mod5(x, modulo);
  }
  function assertIsSquare2(Fp4, root, n) {
    if (!Fp4.eql(Fp4.sqr(root), n))
      throw new Error("Cannot find square root");
  }
  function sqrt3mod42(Fp4, n) {
    const p1div4 = (Fp4.ORDER + _1n15) / _4n4;
    const root = Fp4.pow(n, p1div4);
    assertIsSquare2(Fp4, root, n);
    return root;
  }
  function sqrt5mod82(Fp4, n) {
    const p5div8 = (Fp4.ORDER - _5n5) / _8n7;
    const n2 = Fp4.mul(n, _2n11);
    const v = Fp4.pow(n2, p5div8);
    const nv = Fp4.mul(n, v);
    const i = Fp4.mul(Fp4.mul(nv, _2n11), v);
    const root = Fp4.mul(nv, Fp4.sub(i, Fp4.ONE));
    assertIsSquare2(Fp4, root, n);
    return root;
  }
  function sqrt9mod162(P) {
    const Fp_ = Field3(P);
    const tn = tonelliShanks3(P);
    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
    const c2 = tn(Fp_, c1);
    const c3 = tn(Fp_, Fp_.neg(c1));
    const c4 = (P + _7n2) / _16n3;
    return (Fp4, n) => {
      let tv1 = Fp4.pow(n, c4);
      let tv2 = Fp4.mul(tv1, c1);
      const tv3 = Fp4.mul(tv1, c2);
      const tv4 = Fp4.mul(tv1, c3);
      const e1 = Fp4.eql(Fp4.sqr(tv2), n);
      const e2 = Fp4.eql(Fp4.sqr(tv3), n);
      tv1 = Fp4.cmov(tv1, tv2, e1);
      tv2 = Fp4.cmov(tv4, tv3, e2);
      const e3 = Fp4.eql(Fp4.sqr(tv2), n);
      const root = Fp4.cmov(tv1, tv2, e3);
      assertIsSquare2(Fp4, root, n);
      return root;
    };
  }
  function tonelliShanks3(P) {
    if (P < _3n6)
      throw new Error("sqrt is not defined for small field");
    let Q = P - _1n15;
    let S = 0;
    while (Q % _2n11 === _0n15) {
      Q /= _2n11;
      S++;
    }
    let Z = _2n11;
    const _Fp = Field3(P);
    while (FpLegendre2(_Fp, Z) === 1) {
      if (Z++ > 1e3)
        throw new Error("Cannot find square root: probably non-prime P");
    }
    if (S === 1)
      return sqrt3mod42;
    let cc = _Fp.pow(Z, Q);
    const Q1div2 = (Q + _1n15) / _2n11;
    return function tonelliSlow(Fp4, n) {
      if (Fp4.is0(n))
        return n;
      if (FpLegendre2(Fp4, n) !== 1)
        throw new Error("Cannot find square root");
      let M = S;
      let c = Fp4.mul(Fp4.ONE, cc);
      let t = Fp4.pow(n, Q);
      let R = Fp4.pow(n, Q1div2);
      while (!Fp4.eql(t, Fp4.ONE)) {
        if (Fp4.is0(t))
          return Fp4.ZERO;
        let i = 1;
        let t_tmp = Fp4.sqr(t);
        while (!Fp4.eql(t_tmp, Fp4.ONE)) {
          i++;
          t_tmp = Fp4.sqr(t_tmp);
          if (i === M)
            throw new Error("Cannot find square root");
        }
        const exponent = _1n15 << BigInt(M - i - 1);
        const b = Fp4.pow(c, exponent);
        M = i;
        c = Fp4.sqr(b);
        t = Fp4.mul(t, c);
        R = Fp4.mul(R, b);
      }
      return R;
    };
  }
  function FpSqrt3(P) {
    if (P % _4n4 === _3n6)
      return sqrt3mod42;
    if (P % _8n7 === _5n5)
      return sqrt5mod82;
    if (P % _16n3 === _9n3)
      return sqrt9mod162(P);
    return tonelliShanks3(P);
  }
  var isNegativeLE3 = (num, modulo) => (mod5(num, modulo) & _1n15) === _1n15;
  var FIELD_FIELDS3 = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField3(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "number",
      BITS: "number"
    };
    const opts = FIELD_FIELDS3.reduce((map2, val) => {
      map2[val] = "function";
      return map2;
    }, initial);
    _validateObject2(field, opts);
    return field;
  }
  function FpPow3(Fp4, num, power) {
    if (power < _0n15)
      throw new Error("invalid exponent, negatives unsupported");
    if (power === _0n15)
      return Fp4.ONE;
    if (power === _1n15)
      return num;
    let p = Fp4.ONE;
    let d2 = num;
    while (power > _0n15) {
      if (power & _1n15)
        p = Fp4.mul(p, d2);
      d2 = Fp4.sqr(d2);
      power >>= _1n15;
    }
    return p;
  }
  function FpInvertBatch3(Fp4, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp4.ZERO : void 0);
    const multipliedAcc = nums.reduce((acc, num, i) => {
      if (Fp4.is0(num))
        return acc;
      inverted[i] = acc;
      return Fp4.mul(acc, num);
    }, Fp4.ONE);
    const invertedAcc = Fp4.inv(multipliedAcc);
    nums.reduceRight((acc, num, i) => {
      if (Fp4.is0(num))
        return acc;
      inverted[i] = Fp4.mul(acc, inverted[i]);
      return Fp4.mul(acc, num);
    }, invertedAcc);
    return inverted;
  }
  function FpLegendre2(Fp4, n) {
    const p1mod2 = (Fp4.ORDER - _1n15) / _2n11;
    const powered = Fp4.pow(n, p1mod2);
    const yes = Fp4.eql(powered, Fp4.ONE);
    const zero2 = Fp4.eql(powered, Fp4.ZERO);
    const no = Fp4.eql(powered, Fp4.neg(Fp4.ONE));
    if (!yes && !zero2 && !no)
      throw new Error("invalid Legendre symbol result");
    return yes ? 1 : zero2 ? 0 : -1;
  }
  function nLength3(n, nBitLength) {
    if (nBitLength !== void 0)
      anumber3(nBitLength);
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field3(ORDER, bitLenOrOpts, isLE3 = false, opts = {}) {
    if (ORDER <= _0n15)
      throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
    let _nbitLength = void 0;
    let _sqrt = void 0;
    let modFromBytes = false;
    let allowedLengths = void 0;
    if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
      if (opts.sqrt || isLE3)
        throw new Error("cannot specify opts in two arguments");
      const _opts = bitLenOrOpts;
      if (_opts.BITS)
        _nbitLength = _opts.BITS;
      if (_opts.sqrt)
        _sqrt = _opts.sqrt;
      if (typeof _opts.isLE === "boolean")
        isLE3 = _opts.isLE;
      if (typeof _opts.modFromBytes === "boolean")
        modFromBytes = _opts.modFromBytes;
      allowedLengths = _opts.allowedLengths;
    } else {
      if (typeof bitLenOrOpts === "number")
        _nbitLength = bitLenOrOpts;
      if (opts.sqrt)
        _sqrt = opts.sqrt;
    }
    const { nBitLength: BITS, nByteLength: BYTES } = nLength3(ORDER, _nbitLength);
    if (BYTES > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let sqrtP;
    const f = Object.freeze({
      ORDER,
      isLE: isLE3,
      BITS,
      BYTES,
      MASK: bitMask3(BITS),
      ZERO: _0n15,
      ONE: _1n15,
      allowedLengths,
      create: (num) => mod5(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error("invalid field element: expected bigint, got " + typeof num);
        return _0n15 <= num && num < ORDER;
      },
      is0: (num) => num === _0n15,
      // is valid and invertible
      isValidNot0: (num) => !f.is0(num) && f.isValid(num),
      isOdd: (num) => (num & _1n15) === _1n15,
      neg: (num) => mod5(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod5(num * num, ORDER),
      add: (lhs, rhs) => mod5(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod5(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod5(lhs * rhs, ORDER),
      pow: (num, power) => FpPow3(f, num, power),
      div: (lhs, rhs) => mod5(lhs * invert4(rhs, ORDER), ORDER),
      // Same as above, but doesn't normalize
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert4(num, ORDER),
      sqrt: _sqrt || ((n) => {
        if (!sqrtP)
          sqrtP = FpSqrt3(ORDER);
        return sqrtP(f, n);
      }),
      toBytes: (num) => isLE3 ? numberToBytesLE3(num, BYTES) : numberToBytesBE3(num, BYTES),
      fromBytes: (bytes2, skipValidation = true) => {
        if (allowedLengths) {
          if (!allowedLengths.includes(bytes2.length) || bytes2.length > BYTES) {
            throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes2.length);
          }
          const padded = new Uint8Array(BYTES);
          padded.set(bytes2, isLE3 ? 0 : padded.length - bytes2.length);
          bytes2 = padded;
        }
        if (bytes2.length !== BYTES)
          throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes2.length);
        let scalar = isLE3 ? bytesToNumberLE3(bytes2) : bytesToNumberBE3(bytes2);
        if (modFromBytes)
          scalar = mod5(scalar, ORDER);
        if (!skipValidation) {
          if (!f.isValid(scalar))
            throw new Error("invalid field element: outside of range 0..ORDER");
        }
        return scalar;
      },
      // TODO: we don't need it here, move out to separate fn
      invertBatch: (lst) => FpInvertBatch3(f, lst),
      // We can't move this out because Fp6, Fp12 implement it
      // and it's unclear what to return in there.
      cmov: (a, b, c) => c ? b : a
    });
    return Object.freeze(f);
  }
  function getFieldBytesLength2(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  function getMinHashLength2(fieldOrder) {
    const length21 = getFieldBytesLength2(fieldOrder);
    return length21 + Math.ceil(length21 / 2);
  }
  function mapHashToField2(key, fieldOrder, isLE3 = false) {
    const len = key.length;
    const fieldLen2 = getFieldBytesLength2(fieldOrder);
    const minLen = getMinHashLength2(fieldOrder);
    if (len < 16 || len < minLen || len > 1024)
      throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
    const num = isLE3 ? bytesToNumberLE3(key) : bytesToNumberBE3(key);
    const reduced = mod5(num, fieldOrder - _1n15) + _1n15;
    return isLE3 ? numberToBytesLE3(reduced, fieldLen2) : numberToBytesBE3(reduced, fieldLen2);
  }

  // ../node_modules/@waku/enr/node_modules/@noble/curves/esm/abstract/curve.js
  var _0n16 = BigInt(0);
  var _1n16 = BigInt(1);
  function negateCt2(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
  }
  function normalizeZ2(c, points) {
    const invertedZs = FpInvertBatch3(c.Fp, points.map((p) => p.Z));
    return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
  }
  function validateW2(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
      throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
  }
  function calcWOpts2(W, scalarBits) {
    validateW2(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1;
    const windowSize = 2 ** (W - 1);
    const maxNumber = 2 ** W;
    const mask = bitMask3(W);
    const shiftBy = BigInt(W);
    return { windows, windowSize, mask, maxNumber, shiftBy };
  }
  function calcOffsets2(n, window2, wOpts) {
    const { windowSize, mask, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n & mask);
    let nextN = n >> shiftBy;
    if (wbits > windowSize) {
      wbits -= maxNumber;
      nextN += _1n16;
    }
    const offsetStart = window2 * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1;
    const isZero = wbits === 0;
    const isNeg = wbits < 0;
    const isNegF = window2 % 2 !== 0;
    const offsetF = offsetStart;
    return { nextN, offset, isZero, isNeg, isNegF, offsetF };
  }
  function validateMSMPoints2(points, c) {
    if (!Array.isArray(points))
      throw new Error("array expected");
    points.forEach((p, i) => {
      if (!(p instanceof c))
        throw new Error("invalid point at index " + i);
    });
  }
  function validateMSMScalars2(scalars, field) {
    if (!Array.isArray(scalars))
      throw new Error("array of scalars expected");
    scalars.forEach((s2, i) => {
      if (!field.isValid(s2))
        throw new Error("invalid scalar at index " + i);
    });
  }
  var pointPrecomputes3 = /* @__PURE__ */ new WeakMap();
  var pointWindowSizes2 = /* @__PURE__ */ new WeakMap();
  function getW2(P) {
    return pointWindowSizes2.get(P) || 1;
  }
  function assert02(n) {
    if (n !== _0n16)
      throw new Error("invalid wNAF");
  }
  var wNAF3 = class {
    // Parametrized with a given Point class (not individual point)
    constructor(Point2, bits) {
      this.BASE = Point2.BASE;
      this.ZERO = Point2.ZERO;
      this.Fn = Point2.Fn;
      this.bits = bits;
    }
    // non-const time multiplication ladder
    _unsafeLadder(elm, n, p = this.ZERO) {
      let d2 = elm;
      while (n > _0n16) {
        if (n & _1n16)
          p = p.add(d2);
        d2 = d2.double();
        n >>= _1n16;
      }
      return p;
    }
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param point Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(point, W) {
      const { windows, windowSize } = calcWOpts2(W, this.bits);
      const points = [];
      let p = point;
      let base37 = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base37 = p;
        points.push(base37);
        for (let i = 1; i < windowSize; i++) {
          base37 = base37.add(p);
          points.push(base37);
        }
        p = base37.double();
      }
      return points;
    }
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * More compact implementation:
     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      if (!this.Fn.isValid(n))
        throw new Error("invalid scalar");
      let p = this.ZERO;
      let f = this.BASE;
      const wo = calcWOpts2(W, this.bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets2(n, window2, wo);
        n = nextN;
        if (isZero) {
          f = f.add(negateCt2(isNegF, precomputes[offsetF]));
        } else {
          p = p.add(negateCt2(isNeg, precomputes[offset]));
        }
      }
      assert02(n);
      return { p, f };
    }
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
      const wo = calcWOpts2(W, this.bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        if (n === _0n16)
          break;
        const { nextN, offset, isZero, isNeg } = calcOffsets2(n, window2, wo);
        n = nextN;
        if (isZero) {
          continue;
        } else {
          const item = precomputes[offset];
          acc = acc.add(isNeg ? item.negate() : item);
        }
      }
      assert02(n);
      return acc;
    }
    getPrecomputes(W, point, transform) {
      let comp = pointPrecomputes3.get(point);
      if (!comp) {
        comp = this.precomputeWindow(point, W);
        if (W !== 1) {
          if (typeof transform === "function")
            comp = transform(comp);
          pointPrecomputes3.set(point, comp);
        }
      }
      return comp;
    }
    cached(point, scalar, transform) {
      const W = getW2(point);
      return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
    }
    unsafe(point, scalar, transform, prev) {
      const W = getW2(point);
      if (W === 1)
        return this._unsafeLadder(point, scalar, prev);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
    }
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    createCache(P, W) {
      validateW2(W, this.bits);
      pointWindowSizes2.set(P, W);
      pointPrecomputes3.delete(P);
    }
    hasCache(elm) {
      return getW2(elm) !== 1;
    }
  };
  function mulEndoUnsafe2(Point2, point, k1, k2) {
    let acc = point;
    let p1 = Point2.ZERO;
    let p2 = Point2.ZERO;
    while (k1 > _0n16 || k2 > _0n16) {
      if (k1 & _1n16)
        p1 = p1.add(acc);
      if (k2 & _1n16)
        p2 = p2.add(acc);
      acc = acc.double();
      k1 >>= _1n16;
      k2 >>= _1n16;
    }
    return { p1, p2 };
  }
  function pippenger2(c, fieldN, points, scalars) {
    validateMSMPoints2(points, c);
    validateMSMScalars2(scalars, fieldN);
    const plength = points.length;
    const slength = scalars.length;
    if (plength !== slength)
      throw new Error("arrays of points and scalars must have equal length");
    const zero2 = c.ZERO;
    const wbits = bitLen2(BigInt(plength));
    let windowSize = 1;
    if (wbits > 12)
      windowSize = wbits - 3;
    else if (wbits > 4)
      windowSize = wbits - 2;
    else if (wbits > 0)
      windowSize = 2;
    const MASK = bitMask3(windowSize);
    const buckets = new Array(Number(MASK) + 1).fill(zero2);
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero2;
    for (let i = lastBits; i >= 0; i -= windowSize) {
      buckets.fill(zero2);
      for (let j = 0; j < slength; j++) {
        const scalar = scalars[j];
        const wbits2 = Number(scalar >> BigInt(i) & MASK);
        buckets[wbits2] = buckets[wbits2].add(points[j]);
      }
      let resI = zero2;
      for (let j = buckets.length - 1, sumI = zero2; j > 0; j--) {
        sumI = sumI.add(buckets[j]);
        resI = resI.add(sumI);
      }
      sum = sum.add(resI);
      if (i !== 0)
        for (let j = 0; j < windowSize; j++)
          sum = sum.double();
    }
    return sum;
  }
  function createField2(order, field, isLE3) {
    if (field) {
      if (field.ORDER !== order)
        throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
      validateField3(field);
      return field;
    } else {
      return Field3(order, { isLE: isLE3 });
    }
  }
  function _createCurveFields2(type, CURVE2, curveOpts = {}, FpFnLE) {
    if (FpFnLE === void 0)
      FpFnLE = type === "edwards";
    if (!CURVE2 || typeof CURVE2 !== "object")
      throw new Error(`expected valid ${type} CURVE object`);
    for (const p of ["p", "n", "h"]) {
      const val = CURVE2[p];
      if (!(typeof val === "bigint" && val > _0n16))
        throw new Error(`CURVE.${p} must be positive bigint`);
    }
    const Fp4 = createField2(CURVE2.p, curveOpts.Fp, FpFnLE);
    const Fn3 = createField2(CURVE2.n, curveOpts.Fn, FpFnLE);
    const _b = type === "weierstrass" ? "b" : "d";
    const params = ["Gx", "Gy", "a", _b];
    for (const p of params) {
      if (!Fp4.isValid(CURVE2[p]))
        throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
    }
    CURVE2 = Object.freeze(Object.assign({}, CURVE2));
    return { CURVE: CURVE2, Fp: Fp4, Fn: Fn3 };
  }

  // ../node_modules/@waku/enr/node_modules/@noble/curves/esm/abstract/edwards.js
  var _0n17 = BigInt(0);
  var _1n17 = BigInt(1);
  var _2n12 = BigInt(2);
  var _8n8 = BigInt(8);
  function isEdValidXY2(Fp4, CURVE2, x, y2) {
    const x2 = Fp4.sqr(x);
    const y22 = Fp4.sqr(y2);
    const left = Fp4.add(Fp4.mul(CURVE2.a, x2), y22);
    const right = Fp4.add(Fp4.ONE, Fp4.mul(CURVE2.d, Fp4.mul(x2, y22)));
    return Fp4.eql(left, right);
  }
  function edwards2(params, extraOpts = {}) {
    const validated = _createCurveFields2("edwards", params, extraOpts, extraOpts.FpFnLE);
    const { Fp: Fp4, Fn: Fn3 } = validated;
    let CURVE2 = validated.CURVE;
    const { h: cofactor } = CURVE2;
    _validateObject2(extraOpts, {}, { uvRatio: "function" });
    const MASK = _2n12 << BigInt(Fn3.BYTES * 8) - _1n17;
    const modP = (n) => Fp4.create(n);
    const uvRatio4 = extraOpts.uvRatio || ((u, v) => {
      try {
        return { isValid: true, value: Fp4.sqrt(Fp4.div(u, v)) };
      } catch (e) {
        return { isValid: false, value: _0n17 };
      }
    });
    if (!isEdValidXY2(Fp4, CURVE2, CURVE2.Gx, CURVE2.Gy))
      throw new Error("bad curve params: generator point");
    function acoord(title, n, banZero = false) {
      const min = banZero ? _1n17 : _0n17;
      aInRange2("coordinate " + title, n, min, MASK);
      return n;
    }
    function aextpoint(other) {
      if (!(other instanceof Point2))
        throw new Error("ExtendedPoint expected");
    }
    const toAffineMemo = memoized2((p, iz) => {
      const { X, Y, Z } = p;
      const is0 = p.is0();
      if (iz == null)
        iz = is0 ? _8n8 : Fp4.inv(Z);
      const x = modP(X * iz);
      const y2 = modP(Y * iz);
      const zz = Fp4.mul(Z, iz);
      if (is0)
        return { x: _0n17, y: _1n17 };
      if (zz !== _1n17)
        throw new Error("invZ was invalid");
      return { x, y: y2 };
    });
    const assertValidMemo = memoized2((p) => {
      const { a, d: d2 } = CURVE2;
      if (p.is0())
        throw new Error("bad point: ZERO");
      const { X, Y, Z, T } = p;
      const X2 = modP(X * X);
      const Y2 = modP(Y * Y);
      const Z2 = modP(Z * Z);
      const Z4 = modP(Z2 * Z2);
      const aX2 = modP(X2 * a);
      const left = modP(Z2 * modP(aX2 + Y2));
      const right = modP(Z4 + modP(d2 * modP(X2 * Y2)));
      if (left !== right)
        throw new Error("bad point: equation left != right (1)");
      const XY = modP(X * Y);
      const ZT = modP(Z * T);
      if (XY !== ZT)
        throw new Error("bad point: equation left != right (2)");
      return true;
    });
    class Point2 {
      constructor(X, Y, Z, T) {
        this.X = acoord("x", X);
        this.Y = acoord("y", Y);
        this.Z = acoord("z", Z, true);
        this.T = acoord("t", T);
        Object.freeze(this);
      }
      static CURVE() {
        return CURVE2;
      }
      static fromAffine(p) {
        if (p instanceof Point2)
          throw new Error("extended point not allowed");
        const { x, y: y2 } = p || {};
        acoord("x", x);
        acoord("y", y2);
        return new Point2(x, y2, _1n17, modP(x * y2));
      }
      // Uses algo from RFC8032 5.1.3.
      static fromBytes(bytes2, zip215 = false) {
        const len = Fp4.BYTES;
        const { a, d: d2 } = CURVE2;
        bytes2 = copyBytes3(_abytes22(bytes2, len, "point"));
        _abool22(zip215, "zip215");
        const normed = copyBytes3(bytes2);
        const lastByte = bytes2[len - 1];
        normed[len - 1] = lastByte & ~128;
        const y2 = bytesToNumberLE3(normed);
        const max = zip215 ? MASK : Fp4.ORDER;
        aInRange2("point.y", y2, _0n17, max);
        const y22 = modP(y2 * y2);
        const u = modP(y22 - _1n17);
        const v = modP(d2 * y22 - a);
        let { isValid, value: x } = uvRatio4(u, v);
        if (!isValid)
          throw new Error("bad point: invalid y coordinate");
        const isXOdd = (x & _1n17) === _1n17;
        const isLastByteOdd = (lastByte & 128) !== 0;
        if (!zip215 && x === _0n17 && isLastByteOdd)
          throw new Error("bad point: x=0 and x_0=1");
        if (isLastByteOdd !== isXOdd)
          x = modP(-x);
        return Point2.fromAffine({ x, y: y2 });
      }
      static fromHex(bytes2, zip215 = false) {
        return Point2.fromBytes(ensureBytes4("point", bytes2), zip215);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      precompute(windowSize = 8, isLazy = true) {
        wnaf.createCache(this, windowSize);
        if (!isLazy)
          this.multiply(_2n12);
        return this;
      }
      // Useful in fromAffine() - not for fromBytes(), which always created valid points.
      assertValidity() {
        assertValidMemo(this);
      }
      // Compare one point to another.
      equals(other) {
        aextpoint(other);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const { X: X2, Y: Y2, Z: Z2 } = other;
        const X1Z2 = modP(X1 * Z2);
        const X2Z1 = modP(X2 * Z1);
        const Y1Z2 = modP(Y1 * Z2);
        const Y2Z1 = modP(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      is0() {
        return this.equals(Point2.ZERO);
      }
      negate() {
        return new Point2(modP(-this.X), this.Y, this.Z, modP(-this.T));
      }
      // Fast algo for doubling Extended Point.
      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
      // Cost: 4M + 4S + 1*a + 6add + 1*2.
      double() {
        const { a } = CURVE2;
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const A = modP(X1 * X1);
        const B = modP(Y1 * Y1);
        const C = modP(_2n12 * modP(Z1 * Z1));
        const D = modP(a * A);
        const x1y1 = X1 + Y1;
        const E = modP(modP(x1y1 * x1y1) - A - B);
        const G = D + B;
        const F = G - C;
        const H = D - B;
        const X3 = modP(E * F);
        const Y3 = modP(G * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G);
        return new Point2(X3, Y3, Z3, T3);
      }
      // Fast algo for adding 2 Extended Points.
      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
      // Cost: 9M + 1*a + 1*d + 7add.
      add(other) {
        aextpoint(other);
        const { a, d: d2 } = CURVE2;
        const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
        const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
        const A = modP(X1 * X2);
        const B = modP(Y1 * Y2);
        const C = modP(T1 * d2 * T2);
        const D = modP(Z1 * Z2);
        const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
        const F = D - C;
        const G = D + C;
        const H = modP(B - a * A);
        const X3 = modP(E * F);
        const Y3 = modP(G * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G);
        return new Point2(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      // Constant-time multiplication.
      multiply(scalar) {
        if (!Fn3.isValidNot0(scalar))
          throw new Error("invalid scalar: expected 1 <= sc < curve.n");
        const { p, f } = wnaf.cached(this, scalar, (p2) => normalizeZ2(Point2, p2));
        return normalizeZ2(Point2, [p, f])[0];
      }
      // Non-constant-time multiplication. Uses double-and-add algorithm.
      // It's faster, but should only be used when you don't care about
      // an exposed private key e.g. sig verification.
      // Does NOT allow scalars higher than CURVE.n.
      // Accepts optional accumulator to merge with multiply (important for sparse scalars)
      multiplyUnsafe(scalar, acc = Point2.ZERO) {
        if (!Fn3.isValid(scalar))
          throw new Error("invalid scalar: expected 0 <= sc < curve.n");
        if (scalar === _0n17)
          return Point2.ZERO;
        if (this.is0() || scalar === _1n17)
          return this;
        return wnaf.unsafe(this, scalar, (p) => normalizeZ2(Point2, p), acc);
      }
      // Checks if point is of small order.
      // If you add something to small order point, you will have "dirty"
      // point with torsion component.
      // Multiplies point by cofactor and checks if the result is 0.
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      // Multiplies point by curve order and checks if the result is 0.
      // Returns `false` is the point is dirty.
      isTorsionFree() {
        return wnaf.unsafe(this, CURVE2.n).is0();
      }
      // Converts Extended point to default (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      toAffine(invertedZ) {
        return toAffineMemo(this, invertedZ);
      }
      clearCofactor() {
        if (cofactor === _1n17)
          return this;
        return this.multiplyUnsafe(cofactor);
      }
      toBytes() {
        const { x, y: y2 } = this.toAffine();
        const bytes2 = Fp4.toBytes(y2);
        bytes2[bytes2.length - 1] |= x & _1n17 ? 128 : 0;
        return bytes2;
      }
      toHex() {
        return bytesToHex5(this.toBytes());
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
      // TODO: remove
      get ex() {
        return this.X;
      }
      get ey() {
        return this.Y;
      }
      get ez() {
        return this.Z;
      }
      get et() {
        return this.T;
      }
      static normalizeZ(points) {
        return normalizeZ2(Point2, points);
      }
      static msm(points, scalars) {
        return pippenger2(Point2, Fn3, points, scalars);
      }
      _setWindowSize(windowSize) {
        this.precompute(windowSize);
      }
      toRawBytes() {
        return this.toBytes();
      }
    }
    Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy, _1n17, modP(CURVE2.Gx * CURVE2.Gy));
    Point2.ZERO = new Point2(_0n17, _1n17, _1n17, _0n17);
    Point2.Fp = Fp4;
    Point2.Fn = Fn3;
    const wnaf = new wNAF3(Point2, Fn3.BITS);
    Point2.BASE.precompute(8);
    return Point2;
  }
  var PrimeEdwardsPoint2 = class {
    constructor(ep) {
      this.ep = ep;
    }
    // Static methods that must be implemented by subclasses
    static fromBytes(_bytes) {
      notImplemented2();
    }
    static fromHex(_hex) {
      notImplemented2();
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    // Common implementations
    clearCofactor() {
      return this;
    }
    assertValidity() {
      this.ep.assertValidity();
    }
    toAffine(invertedZ) {
      return this.ep.toAffine(invertedZ);
    }
    toHex() {
      return bytesToHex5(this.toBytes());
    }
    toString() {
      return this.toHex();
    }
    isTorsionFree() {
      return true;
    }
    isSmallOrder() {
      return false;
    }
    add(other) {
      this.assertSame(other);
      return this.init(this.ep.add(other.ep));
    }
    subtract(other) {
      this.assertSame(other);
      return this.init(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
      return this.init(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
      return this.init(this.ep.multiplyUnsafe(scalar));
    }
    double() {
      return this.init(this.ep.double());
    }
    negate() {
      return this.init(this.ep.negate());
    }
    precompute(windowSize, isLazy) {
      return this.init(this.ep.precompute(windowSize, isLazy));
    }
    /** @deprecated use `toBytes` */
    toRawBytes() {
      return this.toBytes();
    }
  };
  function eddsa2(Point2, cHash, eddsaOpts = {}) {
    if (typeof cHash !== "function")
      throw new Error('"hash" function param is required');
    _validateObject2(eddsaOpts, {}, {
      adjustScalarBytes: "function",
      randomBytes: "function",
      domain: "function",
      prehash: "function",
      mapToCurve: "function"
    });
    const { prehash } = eddsaOpts;
    const { BASE, Fp: Fp4, Fn: Fn3 } = Point2;
    const randomBytes5 = eddsaOpts.randomBytes || randomBytes4;
    const adjustScalarBytes4 = eddsaOpts.adjustScalarBytes || ((bytes2) => bytes2);
    const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
      _abool22(phflag, "phflag");
      if (ctx.length || phflag)
        throw new Error("Contexts/pre-hash are not supported");
      return data;
    });
    function modN_LE(hash2) {
      return Fn3.create(bytesToNumberLE3(hash2));
    }
    function getPrivateScalar(key) {
      const len = lengths.secretKey;
      key = ensureBytes4("private key", key, len);
      const hashed = ensureBytes4("hashed private key", cHash(key), 2 * len);
      const head = adjustScalarBytes4(hashed.slice(0, len));
      const prefix = hashed.slice(len, 2 * len);
      const scalar = modN_LE(head);
      return { head, prefix, scalar };
    }
    function getExtendedPublicKey(secretKey) {
      const { head, prefix, scalar } = getPrivateScalar(secretKey);
      const point = BASE.multiply(scalar);
      const pointBytes = point.toBytes();
      return { head, prefix, scalar, point, pointBytes };
    }
    function getPublicKey(secretKey) {
      return getExtendedPublicKey(secretKey).pointBytes;
    }
    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
      const msg = concatBytes5(...msgs);
      return modN_LE(cHash(domain(msg, ensureBytes4("context", context), !!prehash)));
    }
    function sign3(msg, secretKey, options = {}) {
      msg = ensureBytes4("message", msg);
      if (prehash)
        msg = prehash(msg);
      const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
      const r = hashDomainToScalar(options.context, prefix, msg);
      const R = BASE.multiply(r).toBytes();
      const k = hashDomainToScalar(options.context, R, pointBytes, msg);
      const s2 = Fn3.create(r + k * scalar);
      if (!Fn3.isValid(s2))
        throw new Error("sign failed: invalid s");
      const rs = concatBytes5(R, Fn3.toBytes(s2));
      return _abytes22(rs, lengths.signature, "result");
    }
    const verifyOpts = { zip215: true };
    function verify2(sig, msg, publicKey, options = verifyOpts) {
      const { context, zip215 } = options;
      const len = lengths.signature;
      sig = ensureBytes4("signature", sig, len);
      msg = ensureBytes4("message", msg);
      publicKey = ensureBytes4("publicKey", publicKey, lengths.publicKey);
      if (zip215 !== void 0)
        _abool22(zip215, "zip215");
      if (prehash)
        msg = prehash(msg);
      const mid = len / 2;
      const r = sig.subarray(0, mid);
      const s2 = bytesToNumberLE3(sig.subarray(mid, len));
      let A, R, SB;
      try {
        A = Point2.fromBytes(publicKey, zip215);
        R = Point2.fromBytes(r, zip215);
        SB = BASE.multiplyUnsafe(s2);
      } catch (error) {
        return false;
      }
      if (!zip215 && A.isSmallOrder())
        return false;
      const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
      const RkA = R.add(A.multiplyUnsafe(k));
      return RkA.subtract(SB).clearCofactor().is0();
    }
    const _size = Fp4.BYTES;
    const lengths = {
      secretKey: _size,
      publicKey: _size,
      signature: 2 * _size,
      seed: _size
    };
    function randomSecretKey(seed = randomBytes5(lengths.seed)) {
      return _abytes22(seed, lengths.seed, "seed");
    }
    function keygen(seed) {
      const secretKey = utils2.randomSecretKey(seed);
      return { secretKey, publicKey: getPublicKey(secretKey) };
    }
    function isValidSecretKey(key) {
      return isBytes3(key) && key.length === Fn3.BYTES;
    }
    function isValidPublicKey(key, zip215) {
      try {
        return !!Point2.fromBytes(key, zip215);
      } catch (error) {
        return false;
      }
    }
    const utils2 = {
      getExtendedPublicKey,
      randomSecretKey,
      isValidSecretKey,
      isValidPublicKey,
      /**
       * Converts ed public key to x public key. Uses formula:
       * - ed25519:
       *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
       *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
       * - ed448:
       *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
       *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
       */
      toMontgomery(publicKey) {
        const { y: y2 } = Point2.fromBytes(publicKey);
        const size = lengths.publicKey;
        const is25519 = size === 32;
        if (!is25519 && size !== 57)
          throw new Error("only defined for 25519 and 448");
        const u = is25519 ? Fp4.div(_1n17 + y2, _1n17 - y2) : Fp4.div(y2 - _1n17, y2 + _1n17);
        return Fp4.toBytes(u);
      },
      toMontgomerySecret(secretKey) {
        const size = lengths.secretKey;
        _abytes22(secretKey, size);
        const hashed = cHash(secretKey.subarray(0, size));
        return adjustScalarBytes4(hashed).subarray(0, size);
      },
      /** @deprecated */
      randomPrivateKey: randomSecretKey,
      /** @deprecated */
      precompute(windowSize = 8, point = Point2.BASE) {
        return point.precompute(windowSize, false);
      }
    };
    return Object.freeze({
      keygen,
      getPublicKey,
      sign: sign3,
      verify: verify2,
      utils: utils2,
      Point: Point2,
      lengths
    });
  }
  function _eddsa_legacy_opts_to_new2(c) {
    const CURVE2 = {
      a: c.a,
      d: c.d,
      p: c.Fp.ORDER,
      n: c.n,
      h: c.h,
      Gx: c.Gx,
      Gy: c.Gy
    };
    const Fp4 = c.Fp;
    const Fn3 = Field3(CURVE2.n, c.nBitLength, true);
    const curveOpts = { Fp: Fp4, Fn: Fn3, uvRatio: c.uvRatio };
    const eddsaOpts = {
      randomBytes: c.randomBytes,
      adjustScalarBytes: c.adjustScalarBytes,
      domain: c.domain,
      prehash: c.prehash,
      mapToCurve: c.mapToCurve
    };
    return { CURVE: CURVE2, curveOpts, hash: c.hash, eddsaOpts };
  }
  function _eddsa_new_output_to_legacy2(c, eddsa3) {
    const Point2 = eddsa3.Point;
    const legacy = Object.assign({}, eddsa3, {
      ExtendedPoint: Point2,
      CURVE: c,
      nBitLength: Point2.Fn.BITS,
      nByteLength: Point2.Fn.BYTES
    });
    return legacy;
  }
  function twistedEdwards3(c) {
    const { CURVE: CURVE2, curveOpts, hash: hash2, eddsaOpts } = _eddsa_legacy_opts_to_new2(c);
    const Point2 = edwards2(CURVE2, curveOpts);
    const EDDSA = eddsa2(Point2, hash2, eddsaOpts);
    return _eddsa_new_output_to_legacy2(c, EDDSA);
  }

  // ../node_modules/@waku/enr/node_modules/@noble/curves/esm/ed25519.js
  var _0n18 = /* @__PURE__ */ BigInt(0);
  var _1n18 = BigInt(1);
  var _2n13 = BigInt(2);
  var _3n7 = BigInt(3);
  var _5n6 = BigInt(5);
  var _8n9 = BigInt(8);
  var ed25519_CURVE_p2 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
  var ed25519_CURVE2 = /* @__PURE__ */ (() => ({
    p: ed25519_CURVE_p2,
    n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
    h: _8n9,
    a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
    d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
    Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
    Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
  }))();
  function ed25519_pow_2_252_33(x) {
    const _10n2 = BigInt(10), _20n2 = BigInt(20), _40n2 = BigInt(40), _80n2 = BigInt(80);
    const P = ed25519_CURVE_p2;
    const x2 = x * x % P;
    const b2 = x2 * x % P;
    const b4 = pow24(b2, _2n13, P) * b2 % P;
    const b5 = pow24(b4, _1n18, P) * x % P;
    const b10 = pow24(b5, _5n6, P) * b5 % P;
    const b20 = pow24(b10, _10n2, P) * b10 % P;
    const b40 = pow24(b20, _20n2, P) * b20 % P;
    const b80 = pow24(b40, _40n2, P) * b40 % P;
    const b160 = pow24(b80, _80n2, P) * b80 % P;
    const b240 = pow24(b160, _80n2, P) * b80 % P;
    const b250 = pow24(b240, _10n2, P) * b10 % P;
    const pow_p_5_8 = pow24(b250, _2n13, P) * x % P;
    return { pow_p_5_8, b2 };
  }
  function adjustScalarBytes3(bytes2) {
    bytes2[0] &= 248;
    bytes2[31] &= 127;
    bytes2[31] |= 64;
    return bytes2;
  }
  var ED25519_SQRT_M13 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
  function uvRatio3(u, v) {
    const P = ed25519_CURVE_p2;
    const v3 = mod5(v * v * v, P);
    const v7 = mod5(v3 * v3 * v, P);
    const pow3 = ed25519_pow_2_252_33(u * v7).pow_p_5_8;
    let x = mod5(u * v3 * pow3, P);
    const vx2 = mod5(v * x * x, P);
    const root1 = x;
    const root2 = mod5(x * ED25519_SQRT_M13, P);
    const useRoot1 = vx2 === u;
    const useRoot2 = vx2 === mod5(-u, P);
    const noRoot = vx2 === mod5(-u * ED25519_SQRT_M13, P);
    if (useRoot1)
      x = root1;
    if (useRoot2 || noRoot)
      x = root2;
    if (isNegativeLE3(x, P))
      x = mod5(-x, P);
    return { isValid: useRoot1 || useRoot2, value: x };
  }
  var Fp3 = /* @__PURE__ */ (() => Field3(ed25519_CURVE2.p, { isLE: true }))();
  var Fn2 = /* @__PURE__ */ (() => Field3(ed25519_CURVE2.n, { isLE: true }))();
  var ed25519Defaults3 = /* @__PURE__ */ (() => ({
    ...ed25519_CURVE2,
    Fp: Fp3,
    hash: sha51219,
    adjustScalarBytes: adjustScalarBytes3,
    // dom2
    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
    // Constant-time, u/√v
    uvRatio: uvRatio3
  }))();
  var ed255192 = /* @__PURE__ */ (() => twistedEdwards3(ed25519Defaults3))();
  var SQRT_M12 = ED25519_SQRT_M13;
  var SQRT_AD_MINUS_ONE3 = /* @__PURE__ */ BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
  var INVSQRT_A_MINUS_D3 = /* @__PURE__ */ BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
  var ONE_MINUS_D_SQ3 = /* @__PURE__ */ BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
  var D_MINUS_ONE_SQ3 = /* @__PURE__ */ BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
  var invertSqrt2 = (number3) => uvRatio3(_1n18, number3);
  var MAX_255B3 = /* @__PURE__ */ BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  var bytes255ToNumberLE2 = (bytes2) => ed255192.Point.Fp.create(bytesToNumberLE3(bytes2) & MAX_255B3);
  function calcElligatorRistrettoMap2(r0) {
    const { d: d2 } = ed25519_CURVE2;
    const P = ed25519_CURVE_p2;
    const mod6 = (n) => Fp3.create(n);
    const r = mod6(SQRT_M12 * r0 * r0);
    const Ns = mod6((r + _1n18) * ONE_MINUS_D_SQ3);
    let c = BigInt(-1);
    const D = mod6((c - d2 * r) * mod6(r + d2));
    let { isValid: Ns_D_is_sq, value: s2 } = uvRatio3(Ns, D);
    let s_ = mod6(s2 * r0);
    if (!isNegativeLE3(s_, P))
      s_ = mod6(-s_);
    if (!Ns_D_is_sq)
      s2 = s_;
    if (!Ns_D_is_sq)
      c = r;
    const Nt = mod6(c * (r - _1n18) * D_MINUS_ONE_SQ3 - D);
    const s22 = s2 * s2;
    const W0 = mod6((s2 + s2) * D);
    const W1 = mod6(Nt * SQRT_AD_MINUS_ONE3);
    const W2 = mod6(_1n18 - s22);
    const W3 = mod6(_1n18 + s22);
    return new ed255192.Point(mod6(W0 * W3), mod6(W2 * W1), mod6(W1 * W3), mod6(W0 * W2));
  }
  function ristretto255_map2(bytes2) {
    abytes3(bytes2, 64);
    const r1 = bytes255ToNumberLE2(bytes2.subarray(0, 32));
    const R1 = calcElligatorRistrettoMap2(r1);
    const r2 = bytes255ToNumberLE2(bytes2.subarray(32, 64));
    const R2 = calcElligatorRistrettoMap2(r2);
    return new _RistrettoPoint2(R1.add(R2));
  }
  var _RistrettoPoint2 = class __RistrettoPoint extends PrimeEdwardsPoint2 {
    constructor(ep) {
      super(ep);
    }
    static fromAffine(ap) {
      return new __RistrettoPoint(ed255192.Point.fromAffine(ap));
    }
    assertSame(other) {
      if (!(other instanceof __RistrettoPoint))
        throw new Error("RistrettoPoint expected");
    }
    init(ep) {
      return new __RistrettoPoint(ep);
    }
    /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
    static hashToCurve(hex) {
      return ristretto255_map2(ensureBytes4("ristrettoHash", hex, 64));
    }
    static fromBytes(bytes2) {
      abytes3(bytes2, 32);
      const { a, d: d2 } = ed25519_CURVE2;
      const P = ed25519_CURVE_p2;
      const mod6 = (n) => Fp3.create(n);
      const s2 = bytes255ToNumberLE2(bytes2);
      if (!equalBytes3(Fp3.toBytes(s2), bytes2) || isNegativeLE3(s2, P))
        throw new Error("invalid ristretto255 encoding 1");
      const s22 = mod6(s2 * s2);
      const u1 = mod6(_1n18 + a * s22);
      const u2 = mod6(_1n18 - a * s22);
      const u1_2 = mod6(u1 * u1);
      const u2_2 = mod6(u2 * u2);
      const v = mod6(a * d2 * u1_2 - u2_2);
      const { isValid, value: I } = invertSqrt2(mod6(v * u2_2));
      const Dx = mod6(I * u2);
      const Dy = mod6(I * Dx * v);
      let x = mod6((s2 + s2) * Dx);
      if (isNegativeLE3(x, P))
        x = mod6(-x);
      const y2 = mod6(u1 * Dy);
      const t = mod6(x * y2);
      if (!isValid || isNegativeLE3(t, P) || y2 === _0n18)
        throw new Error("invalid ristretto255 encoding 2");
      return new __RistrettoPoint(new ed255192.Point(x, y2, _1n18, t));
    }
    /**
     * Converts ristretto-encoded string to ristretto point.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
     */
    static fromHex(hex) {
      return __RistrettoPoint.fromBytes(ensureBytes4("ristrettoHex", hex, 32));
    }
    static msm(points, scalars) {
      return pippenger2(__RistrettoPoint, ed255192.Point.Fn, points, scalars);
    }
    /**
     * Encodes ristretto point to Uint8Array.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
     */
    toBytes() {
      let { X, Y, Z, T } = this.ep;
      const P = ed25519_CURVE_p2;
      const mod6 = (n) => Fp3.create(n);
      const u1 = mod6(mod6(Z + Y) * mod6(Z - Y));
      const u2 = mod6(X * Y);
      const u2sq = mod6(u2 * u2);
      const { value: invsqrt } = invertSqrt2(mod6(u1 * u2sq));
      const D1 = mod6(invsqrt * u1);
      const D2 = mod6(invsqrt * u2);
      const zInv = mod6(D1 * D2 * T);
      let D;
      if (isNegativeLE3(T * zInv, P)) {
        let _x = mod6(Y * SQRT_M12);
        let _y = mod6(X * SQRT_M12);
        X = _x;
        Y = _y;
        D = mod6(D1 * INVSQRT_A_MINUS_D3);
      } else {
        D = D2;
      }
      if (isNegativeLE3(X * zInv, P))
        Y = mod6(-Y);
      let s2 = mod6((Z - Y) * D);
      if (isNegativeLE3(s2, P))
        s2 = mod6(-s2);
      return Fp3.toBytes(s2);
    }
    /**
     * Compares two Ristretto points.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
     */
    equals(other) {
      this.assertSame(other);
      const { X: X1, Y: Y1 } = this.ep;
      const { X: X2, Y: Y2 } = other.ep;
      const mod6 = (n) => Fp3.create(n);
      const one = mod6(X1 * Y2) === mod6(Y1 * X2);
      const two = mod6(Y1 * Y2) === mod6(X1 * X2);
      return one || two;
    }
    is0() {
      return this.equals(__RistrettoPoint.ZERO);
    }
  };
  _RistrettoPoint2.BASE = /* @__PURE__ */ (() => new _RistrettoPoint2(ed255192.Point.BASE))();
  _RistrettoPoint2.ZERO = /* @__PURE__ */ (() => new _RistrettoPoint2(ed255192.Point.ZERO))();
  _RistrettoPoint2.Fp = /* @__PURE__ */ (() => Fp3)();
  _RistrettoPoint2.Fn = /* @__PURE__ */ (() => Fn2)();

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/errors.js
  var VerificationError2 = class extends Error {
    constructor(message2 = "An error occurred while verifying a message") {
      super(message2);
      this.name = "VerificationError";
    }
  };
  var WebCryptoMissingError2 = class extends Error {
    constructor(message2 = "Missing Web Crypto API") {
      super(message2);
      this.name = "WebCryptoMissingError";
    }
  };

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/webcrypto/webcrypto.browser.js
  var webcrypto_browser_default2 = {
    get(win = globalThis) {
      const nativeCrypto = win.crypto;
      if (nativeCrypto?.subtle == null) {
        throw new WebCryptoMissingError2("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");
      }
      return nativeCrypto;
    }
  };

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/webcrypto/index.js
  var webcrypto_default2 = webcrypto_browser_default2;

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/ed25519/index.browser.js
  var PUBLIC_KEY_BYTE_LENGTH2 = 32;
  var ed25519Supported2;
  var webCryptoEd25519SupportedPromise2 = (async () => {
    try {
      await webcrypto_default2.get().subtle.generateKey({ name: "Ed25519" }, true, ["sign", "verify"]);
      return true;
    } catch {
      return false;
    }
  })();
  async function hashAndVerifyWebCrypto2(publicKey, sig, msg) {
    if (publicKey.buffer instanceof ArrayBuffer) {
      const key = await webcrypto_default2.get().subtle.importKey("raw", publicKey.buffer, { name: "Ed25519" }, false, ["verify"]);
      const isValid = await webcrypto_default2.get().subtle.verify({ name: "Ed25519" }, key, sig, msg instanceof Uint8Array ? msg : msg.subarray());
      return isValid;
    }
    throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys");
  }
  function hashAndVerifyNoble2(publicKey, sig, msg) {
    return ed255192.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey);
  }
  async function hashAndVerify6(publicKey, sig, msg) {
    if (ed25519Supported2 == null) {
      ed25519Supported2 = await webCryptoEd25519SupportedPromise2;
    }
    if (ed25519Supported2) {
      return hashAndVerifyWebCrypto2(publicKey, sig, msg);
    }
    return hashAndVerifyNoble2(publicKey, sig, msg);
  }

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/util.js
  function isPromise4(thing) {
    if (thing == null) {
      return false;
    }
    return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
  }

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/ed25519/ed25519.js
  var Ed25519PublicKey2 = class {
    type = "Ed25519";
    raw;
    constructor(key) {
      this.raw = ensureEd25519Key2(key, PUBLIC_KEY_BYTE_LENGTH2);
    }
    toMultihash() {
      return identity31.digest(publicKeyToProtobuf2(this));
    }
    toCID() {
      return CID17.createV1(114, this.toMultihash());
    }
    toString() {
      return base58btc20.encode(this.toMultihash().bytes).substring(1);
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals46(this.raw, key.raw);
    }
    verify(data, sig, options) {
      options?.signal?.throwIfAborted();
      const result = hashAndVerify6(this.raw, sig, data);
      if (isPromise4(result)) {
        return result.then((res) => {
          options?.signal?.throwIfAborted();
          return res;
        });
      }
      return result;
    }
  };

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/ed25519/utils.js
  function unmarshalEd25519PublicKey2(bytes2) {
    bytes2 = ensureEd25519Key2(bytes2, PUBLIC_KEY_BYTE_LENGTH2);
    return new Ed25519PublicKey2(bytes2);
  }
  function ensureEd25519Key2(key, length21) {
    key = Uint8Array.from(key ?? []);
    if (key.length !== length21) {
      throw new InvalidParametersError(`Key must be a Uint8Array of length ${length21}, got ${key.length}`);
    }
    return key;
  }

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/keys.js
  var KeyType2;
  (function(KeyType3) {
    KeyType3["RSA"] = "RSA";
    KeyType3["Ed25519"] = "Ed25519";
    KeyType3["secp256k1"] = "secp256k1";
    KeyType3["ECDSA"] = "ECDSA";
  })(KeyType2 || (KeyType2 = {}));
  var __KeyTypeValues2;
  (function(__KeyTypeValues3) {
    __KeyTypeValues3[__KeyTypeValues3["RSA"] = 0] = "RSA";
    __KeyTypeValues3[__KeyTypeValues3["Ed25519"] = 1] = "Ed25519";
    __KeyTypeValues3[__KeyTypeValues3["secp256k1"] = 2] = "secp256k1";
    __KeyTypeValues3[__KeyTypeValues3["ECDSA"] = 3] = "ECDSA";
  })(__KeyTypeValues2 || (__KeyTypeValues2 = {}));
  (function(KeyType3) {
    KeyType3.codec = () => {
      return enumeration(__KeyTypeValues2);
    };
  })(KeyType2 || (KeyType2 = {}));
  var PublicKey2;
  (function(PublicKey3) {
    let _codec;
    PublicKey3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.Type != null) {
            w2.uint32(8);
            KeyType2.codec().encode(obj.Type, w2);
          }
          if (obj.Data != null) {
            w2.uint32(18);
            w2.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {};
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.Type = KeyType2.codec().decode(reader);
                break;
              }
              case 2: {
                obj.Data = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PublicKey3.encode = (obj) => {
      return encodeMessage(obj, PublicKey3.codec());
    };
    PublicKey3.decode = (buf, opts) => {
      return decodeMessage(buf, PublicKey3.codec(), opts);
    };
  })(PublicKey2 || (PublicKey2 = {}));
  var PrivateKey2;
  (function(PrivateKey3) {
    let _codec;
    PrivateKey3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.Type != null) {
            w2.uint32(8);
            KeyType2.codec().encode(obj.Type, w2);
          }
          if (obj.Data != null) {
            w2.uint32(18);
            w2.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length21, opts = {}) => {
          const obj = {};
          const end = length21 == null ? reader.len : reader.pos + length21;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.Type = KeyType2.codec().decode(reader);
                break;
              }
              case 2: {
                obj.Data = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PrivateKey3.encode = (obj) => {
      return encodeMessage(obj, PrivateKey3.codec());
    };
    PrivateKey3.decode = (buf, opts) => {
      return decodeMessage(buf, PrivateKey3.codec(), opts);
    };
  })(PrivateKey2 || (PrivateKey2 = {}));

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js
  var utils_exports3 = {};
  __export(utils_exports3, {
    MAX_RSA_KEY_SIZE: () => MAX_RSA_KEY_SIZE2,
    generateRSAKeyPair: () => generateRSAKeyPair2,
    jwkToJWKKeyPair: () => jwkToJWKKeyPair2,
    jwkToPkcs1: () => jwkToPkcs12,
    jwkToPkix: () => jwkToPkix2,
    jwkToRSAPrivateKey: () => jwkToRSAPrivateKey2,
    pkcs1MessageToJwk: () => pkcs1MessageToJwk2,
    pkcs1MessageToRSAPrivateKey: () => pkcs1MessageToRSAPrivateKey2,
    pkcs1ToJwk: () => pkcs1ToJwk2,
    pkcs1ToRSAPrivateKey: () => pkcs1ToRSAPrivateKey2,
    pkixMessageToJwk: () => pkixMessageToJwk2,
    pkixMessageToRSAPublicKey: () => pkixMessageToRSAPublicKey2,
    pkixToJwk: () => pkixToJwk2,
    pkixToRSAPublicKey: () => pkixToRSAPublicKey2
  });

  // ../node_modules/@waku/enr/node_modules/@noble/hashes/esm/sha256.js
  var sha25621 = sha25620;

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/rsa/rsa.js
  var RSAPublicKey2 = class {
    type = "RSA";
    jwk;
    _raw;
    _multihash;
    constructor(jwk, digest18) {
      this.jwk = jwk;
      this._multihash = digest18;
    }
    get raw() {
      if (this._raw == null) {
        this._raw = utils_exports3.jwkToPkix(this.jwk);
      }
      return this._raw;
    }
    toMultihash() {
      return this._multihash;
    }
    toCID() {
      return CID17.createV1(114, this._multihash);
    }
    toString() {
      return base58btc20.encode(this.toMultihash().bytes).substring(1);
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals46(this.raw, key.raw);
    }
    verify(data, sig, options) {
      return hashAndVerify7(this.jwk, sig, data, options);
    }
  };
  var RSAPrivateKey2 = class {
    type = "RSA";
    jwk;
    _raw;
    publicKey;
    constructor(jwk, publicKey) {
      this.jwk = jwk;
      this.publicKey = publicKey;
    }
    get raw() {
      if (this._raw == null) {
        this._raw = utils_exports3.jwkToPkcs1(this.jwk);
      }
      return this._raw;
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals46(this.raw, key.raw);
    }
    sign(message2, options) {
      return hashAndSign7(this.jwk, message2, options);
    }
  };

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js
  var MAX_RSA_KEY_SIZE2 = 8192;
  var SHA2_256_CODE2 = 18;
  var MAX_RSA_JWK_SIZE2 = 1062;
  var RSA_ALGORITHM_IDENTIFIER2 = Uint8Array.from([
    48,
    13,
    6,
    9,
    42,
    134,
    72,
    134,
    247,
    13,
    1,
    1,
    1,
    5,
    0
  ]);
  function pkcs1ToJwk2(bytes2) {
    const message2 = decodeDer2(bytes2);
    return pkcs1MessageToJwk2(message2);
  }
  function pkcs1MessageToJwk2(message2) {
    return {
      n: toString27(message2[1], "base64url"),
      e: toString27(message2[2], "base64url"),
      d: toString27(message2[3], "base64url"),
      p: toString27(message2[4], "base64url"),
      q: toString27(message2[5], "base64url"),
      dp: toString27(message2[6], "base64url"),
      dq: toString27(message2[7], "base64url"),
      qi: toString27(message2[8], "base64url"),
      kty: "RSA"
    };
  }
  function jwkToPkcs12(jwk) {
    if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
      throw new InvalidParametersError("JWK was missing components");
    }
    return encodeSequence2([
      encodeInteger2(Uint8Array.from([0])),
      encodeInteger2(fromString31(jwk.n, "base64url")),
      encodeInteger2(fromString31(jwk.e, "base64url")),
      encodeInteger2(fromString31(jwk.d, "base64url")),
      encodeInteger2(fromString31(jwk.p, "base64url")),
      encodeInteger2(fromString31(jwk.q, "base64url")),
      encodeInteger2(fromString31(jwk.dp, "base64url")),
      encodeInteger2(fromString31(jwk.dq, "base64url")),
      encodeInteger2(fromString31(jwk.qi, "base64url"))
    ]).subarray();
  }
  function pkixToJwk2(bytes2) {
    const message2 = decodeDer2(bytes2, {
      offset: 0
    });
    return pkixMessageToJwk2(message2);
  }
  function pkixMessageToJwk2(message2) {
    const keys = decodeDer2(message2[1], {
      offset: 0
    });
    return {
      kty: "RSA",
      n: toString27(keys[0], "base64url"),
      e: toString27(keys[1], "base64url")
    };
  }
  function jwkToPkix2(jwk) {
    if (jwk.n == null || jwk.e == null) {
      throw new InvalidParametersError("JWK was missing components");
    }
    const subjectPublicKeyInfo = encodeSequence2([
      RSA_ALGORITHM_IDENTIFIER2,
      encodeBitString2(encodeSequence2([
        encodeInteger2(fromString31(jwk.n, "base64url")),
        encodeInteger2(fromString31(jwk.e, "base64url"))
      ]))
    ]);
    return subjectPublicKeyInfo.subarray();
  }
  function pkcs1ToRSAPrivateKey2(bytes2) {
    const message2 = decodeDer2(bytes2);
    return pkcs1MessageToRSAPrivateKey2(message2);
  }
  function pkcs1MessageToRSAPrivateKey2(message2) {
    const jwk = pkcs1MessageToJwk2(message2);
    return jwkToRSAPrivateKey2(jwk);
  }
  function pkixToRSAPublicKey2(bytes2, digest18) {
    if (bytes2.byteLength >= MAX_RSA_JWK_SIZE2) {
      throw new InvalidPublicKeyError("Key size is too large");
    }
    const message2 = decodeDer2(bytes2, {
      offset: 0
    });
    return pkixMessageToRSAPublicKey2(message2, bytes2, digest18);
  }
  function pkixMessageToRSAPublicKey2(message2, bytes2, digest18) {
    const jwk = pkixMessageToJwk2(message2);
    if (digest18 == null) {
      const hash2 = sha25621(PublicKey2.encode({
        Type: KeyType2.RSA,
        Data: bytes2
      }));
      digest18 = create17(SHA2_256_CODE2, hash2);
    }
    return new RSAPublicKey2(jwk, digest18);
  }
  function jwkToRSAPrivateKey2(jwk) {
    if (rsaKeySize2(jwk) > MAX_RSA_KEY_SIZE2) {
      throw new InvalidParametersError("Key size is too large");
    }
    const keys = jwkToJWKKeyPair2(jwk);
    const hash2 = sha25621(PublicKey2.encode({
      Type: KeyType2.RSA,
      Data: jwkToPkix2(keys.publicKey)
    }));
    const digest18 = create17(SHA2_256_CODE2, hash2);
    return new RSAPrivateKey2(keys.privateKey, new RSAPublicKey2(keys.publicKey, digest18));
  }
  async function generateRSAKeyPair2(bits) {
    if (bits > MAX_RSA_KEY_SIZE2) {
      throw new InvalidParametersError("Key size is too large");
    }
    const keys = await generateRSAKey2(bits);
    const hash2 = sha25621(PublicKey2.encode({
      Type: KeyType2.RSA,
      Data: jwkToPkix2(keys.publicKey)
    }));
    const digest18 = create17(SHA2_256_CODE2, hash2);
    return new RSAPrivateKey2(keys.privateKey, new RSAPublicKey2(keys.publicKey, digest18));
  }
  function jwkToJWKKeyPair2(key) {
    if (key == null) {
      throw new InvalidParametersError("Missing key parameter");
    }
    return {
      privateKey: key,
      publicKey: {
        kty: key.kty,
        n: key.n,
        e: key.e
      }
    };
  }

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/rsa/index.browser.js
  var RSAES_PKCS1_V1_5_OID = "1.2.840.113549.1.1.1";
  async function generateRSAKey2(bits, options) {
    const pair2 = await webcrypto_default2.get().subtle.generateKey({
      name: "RSASSA-PKCS1-v1_5",
      modulusLength: bits,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: { name: "SHA-256" }
    }, true, ["sign", "verify"]);
    options?.signal?.throwIfAborted();
    const keys = await exportKey2(pair2, options);
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  }
  async function hashAndSign7(key, msg, options) {
    const privateKey = await webcrypto_default2.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["sign"]);
    options?.signal?.throwIfAborted();
    const sig = await webcrypto_default2.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, msg instanceof Uint8Array ? msg : msg.subarray());
    options?.signal?.throwIfAborted();
    return new Uint8Array(sig, 0, sig.byteLength);
  }
  async function hashAndVerify7(key, sig, msg, options) {
    const publicKey = await webcrypto_default2.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["verify"]);
    options?.signal?.throwIfAborted();
    const result = await webcrypto_default2.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg instanceof Uint8Array ? msg : msg.subarray());
    options?.signal?.throwIfAborted();
    return result;
  }
  async function exportKey2(pair2, options) {
    if (pair2.privateKey == null || pair2.publicKey == null) {
      throw new InvalidParametersError("Private and public key are required");
    }
    const result = await Promise.all([
      webcrypto_default2.get().subtle.exportKey("jwk", pair2.privateKey),
      webcrypto_default2.get().subtle.exportKey("jwk", pair2.publicKey)
    ]);
    options?.signal?.throwIfAborted();
    return result;
  }
  function rsaKeySize2(jwk) {
    if (jwk.kty !== "RSA") {
      throw new InvalidParametersError("invalid key type");
    } else if (jwk.n == null) {
      throw new InvalidParametersError("invalid key modulus");
    }
    const bytes2 = fromString31(jwk.n, "base64url");
    return bytes2.length * 8;
  }

  // ../node_modules/@waku/enr/node_modules/@noble/hashes/esm/hmac.js
  var HMAC3 = class extends Hash4 {
    constructor(hash2, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      ahash2(hash2);
      const key = toBytes4(_key);
      this.iHash = hash2.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash2.create();
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54 ^ 92;
      this.oHash.update(pad);
      clean3(pad);
    }
    update(buf) {
      aexists3(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      aexists3(this);
      abytes3(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac3 = (hash2, key, message2) => new HMAC3(hash2, key).update(message2).digest();
  hmac3.create = (hash2, key) => new HMAC3(hash2, key);

  // ../node_modules/@waku/enr/node_modules/@noble/curves/esm/abstract/weierstrass.js
  var divNearest3 = (num, den) => (num + (num >= 0 ? den : -den) / _2n14) / den;
  function _splitEndoScalar2(k, basis, n) {
    const [[a1, b1], [a2, b2]] = basis;
    const c1 = divNearest3(b2 * k, n);
    const c2 = divNearest3(-b1 * k, n);
    let k1 = k - c1 * a1 - c2 * a2;
    let k2 = -c1 * b1 - c2 * b2;
    const k1neg = k1 < _0n19;
    const k2neg = k2 < _0n19;
    if (k1neg)
      k1 = -k1;
    if (k2neg)
      k2 = -k2;
    const MAX_NUM = bitMask3(Math.ceil(bitLen2(n) / 2)) + _1n19;
    if (k1 < _0n19 || k1 >= MAX_NUM || k2 < _0n19 || k2 >= MAX_NUM) {
      throw new Error("splitScalar (endomorphism): failed, k=" + k);
    }
    return { k1neg, k1, k2neg, k2 };
  }
  function validateSigFormat2(format19) {
    if (!["compact", "recovered", "der"].includes(format19))
      throw new Error('Signature format must be "compact", "recovered", or "der"');
    return format19;
  }
  function validateSigOpts2(opts, def) {
    const optsn = {};
    for (let optName of Object.keys(def)) {
      optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
    }
    _abool22(optsn.lowS, "lowS");
    _abool22(optsn.prehash, "prehash");
    if (optsn.format !== void 0)
      validateSigFormat2(optsn.format);
    return optsn;
  }
  var DERErr2 = class extends Error {
    constructor(m2 = "") {
      super(m2);
    }
  };
  var DER2 = {
    // asn.1 DER encoding utils
    Err: DERErr2,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
      encode: (tag, data) => {
        const { Err: E } = DER2;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length & 1)
          throw new E("tlv.encode: unpadded data");
        const dataLen = data.length / 2;
        const len = numberToHexUnpadded3(dataLen);
        if (len.length / 2 & 128)
          throw new E("tlv.encode: long form length too big");
        const lenLen = dataLen > 127 ? numberToHexUnpadded3(len.length / 2 | 128) : "";
        const t = numberToHexUnpadded3(tag);
        return t + lenLen + len + data;
      },
      // v - value, l - left bytes (unparsed)
      decode(tag, data) {
        const { Err: E } = DER2;
        let pos = 0;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length < 2 || data[pos++] !== tag)
          throw new E("tlv.decode: wrong tlv");
        const first = data[pos++];
        const isLong = !!(first & 128);
        let length21 = 0;
        if (!isLong)
          length21 = first;
        else {
          const lenLen = first & 127;
          if (!lenLen)
            throw new E("tlv.decode(long): indefinite length not supported");
          if (lenLen > 4)
            throw new E("tlv.decode(long): byte length is too big");
          const lengthBytes = data.subarray(pos, pos + lenLen);
          if (lengthBytes.length !== lenLen)
            throw new E("tlv.decode: length bytes not complete");
          if (lengthBytes[0] === 0)
            throw new E("tlv.decode(long): zero leftmost byte");
          for (const b of lengthBytes)
            length21 = length21 << 8 | b;
          pos += lenLen;
          if (length21 < 128)
            throw new E("tlv.decode(long): not minimal encoding");
        }
        const v = data.subarray(pos, pos + length21);
        if (v.length !== length21)
          throw new E("tlv.decode: wrong value length");
        return { v, l: data.subarray(pos + length21) };
      }
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
      encode(num) {
        const { Err: E } = DER2;
        if (num < _0n19)
          throw new E("integer: negative integers are not allowed");
        let hex = numberToHexUnpadded3(num);
        if (Number.parseInt(hex[0], 16) & 8)
          hex = "00" + hex;
        if (hex.length & 1)
          throw new E("unexpected DER parsing assertion: unpadded hex");
        return hex;
      },
      decode(data) {
        const { Err: E } = DER2;
        if (data[0] & 128)
          throw new E("invalid signature integer: negative");
        if (data[0] === 0 && !(data[1] & 128))
          throw new E("invalid signature integer: unnecessary leading zero");
        return bytesToNumberBE3(data);
      }
    },
    toSig(hex) {
      const { Err: E, _int: int, _tlv: tlv } = DER2;
      const data = ensureBytes4("signature", hex);
      const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
      if (seqLeftBytes.length)
        throw new E("invalid signature: left bytes after parsing");
      const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
      const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
      if (sLeftBytes.length)
        throw new E("invalid signature: left bytes after parsing");
      return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
      const { _tlv: tlv, _int: int } = DER2;
      const rs = tlv.encode(2, int.encode(sig.r));
      const ss = tlv.encode(2, int.encode(sig.s));
      const seq = rs + ss;
      return tlv.encode(48, seq);
    }
  };
  var _0n19 = BigInt(0);
  var _1n19 = BigInt(1);
  var _2n14 = BigInt(2);
  var _3n8 = BigInt(3);
  var _4n5 = BigInt(4);
  function _normFnElement2(Fn3, key) {
    const { BYTES: expected } = Fn3;
    let num;
    if (typeof key === "bigint") {
      num = key;
    } else {
      let bytes2 = ensureBytes4("private key", key);
      try {
        num = Fn3.fromBytes(bytes2);
      } catch (error) {
        throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
      }
    }
    if (!Fn3.isValidNot0(num))
      throw new Error("invalid private key: out of range [1..N-1]");
    return num;
  }
  function weierstrassN2(params, extraOpts = {}) {
    const validated = _createCurveFields2("weierstrass", params, extraOpts);
    const { Fp: Fp4, Fn: Fn3 } = validated;
    let CURVE2 = validated.CURVE;
    const { h: cofactor, n: CURVE_ORDER } = CURVE2;
    _validateObject2(extraOpts, {}, {
      allowInfinityPoint: "boolean",
      clearCofactor: "function",
      isTorsionFree: "function",
      fromBytes: "function",
      toBytes: "function",
      endo: "object",
      wrapPrivateKey: "boolean"
    });
    const { endo: endo2 } = extraOpts;
    if (endo2) {
      if (!Fp4.is0(CURVE2.a) || typeof endo2.beta !== "bigint" || !Array.isArray(endo2.basises)) {
        throw new Error('invalid endo: expected "beta": bigint and "basises": array');
      }
    }
    const lengths = getWLengths2(Fp4, Fn3);
    function assertCompressionIsSupported() {
      if (!Fp4.isOdd)
        throw new Error("compression is not supported: Field does not have .isOdd()");
    }
    function pointToBytes(_c, point, isCompressed) {
      const { x, y: y2 } = point.toAffine();
      const bx = Fp4.toBytes(x);
      _abool22(isCompressed, "isCompressed");
      if (isCompressed) {
        assertCompressionIsSupported();
        const hasEvenY = !Fp4.isOdd(y2);
        return concatBytes5(pprefix2(hasEvenY), bx);
      } else {
        return concatBytes5(Uint8Array.of(4), bx, Fp4.toBytes(y2));
      }
    }
    function pointFromBytes(bytes2) {
      _abytes22(bytes2, void 0, "Point");
      const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
      const length21 = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (length21 === comp && (head === 2 || head === 3)) {
        const x = Fp4.fromBytes(tail);
        if (!Fp4.isValid(x))
          throw new Error("bad point: is not on curve, wrong x");
        const y2 = weierstrassEquation(x);
        let y3;
        try {
          y3 = Fp4.sqrt(y2);
        } catch (sqrtError) {
          const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("bad point: is not on curve, sqrt error" + err);
        }
        assertCompressionIsSupported();
        const isYOdd = Fp4.isOdd(y3);
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp4.neg(y3);
        return { x, y: y3 };
      } else if (length21 === uncomp && head === 4) {
        const L = Fp4.BYTES;
        const x = Fp4.fromBytes(tail.subarray(0, L));
        const y2 = Fp4.fromBytes(tail.subarray(L, L * 2));
        if (!isValidXY(x, y2))
          throw new Error("bad point: is not on curve");
        return { x, y: y2 };
      } else {
        throw new Error(`bad point: got length ${length21}, expected compressed=${comp} or uncompressed=${uncomp}`);
      }
    }
    const encodePoint = extraOpts.toBytes || pointToBytes;
    const decodePoint = extraOpts.fromBytes || pointFromBytes;
    function weierstrassEquation(x) {
      const x2 = Fp4.sqr(x);
      const x3 = Fp4.mul(x2, x);
      return Fp4.add(Fp4.add(x3, Fp4.mul(x, CURVE2.a)), CURVE2.b);
    }
    function isValidXY(x, y2) {
      const left = Fp4.sqr(y2);
      const right = weierstrassEquation(x);
      return Fp4.eql(left, right);
    }
    if (!isValidXY(CURVE2.Gx, CURVE2.Gy))
      throw new Error("bad curve params: generator point");
    const _4a3 = Fp4.mul(Fp4.pow(CURVE2.a, _3n8), _4n5);
    const _27b2 = Fp4.mul(Fp4.sqr(CURVE2.b), BigInt(27));
    if (Fp4.is0(Fp4.add(_4a3, _27b2)))
      throw new Error("bad curve params: a or b");
    function acoord(title, n, banZero = false) {
      if (!Fp4.isValid(n) || banZero && Fp4.is0(n))
        throw new Error(`bad point coordinate ${title}`);
      return n;
    }
    function aprjpoint(other) {
      if (!(other instanceof Point2))
        throw new Error("ProjectivePoint expected");
    }
    function splitEndoScalarN(k) {
      if (!endo2 || !endo2.basises)
        throw new Error("no endo");
      return _splitEndoScalar2(k, endo2.basises, Fn3.ORDER);
    }
    const toAffineMemo = memoized2((p, iz) => {
      const { X, Y, Z } = p;
      if (Fp4.eql(Z, Fp4.ONE))
        return { x: X, y: Y };
      const is0 = p.is0();
      if (iz == null)
        iz = is0 ? Fp4.ONE : Fp4.inv(Z);
      const x = Fp4.mul(X, iz);
      const y2 = Fp4.mul(Y, iz);
      const zz = Fp4.mul(Z, iz);
      if (is0)
        return { x: Fp4.ZERO, y: Fp4.ZERO };
      if (!Fp4.eql(zz, Fp4.ONE))
        throw new Error("invZ was invalid");
      return { x, y: y2 };
    });
    const assertValidMemo = memoized2((p) => {
      if (p.is0()) {
        if (extraOpts.allowInfinityPoint && !Fp4.is0(p.Y))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y: y2 } = p.toAffine();
      if (!Fp4.isValid(x) || !Fp4.isValid(y2))
        throw new Error("bad point: x or y not field elements");
      if (!isValidXY(x, y2))
        throw new Error("bad point: equation left != right");
      if (!p.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
      return true;
    });
    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
      k2p = new Point2(Fp4.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
      k1p = negateCt2(k1neg, k1p);
      k2p = negateCt2(k2neg, k2p);
      return k1p.add(k2p);
    }
    class Point2 {
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      constructor(X, Y, Z) {
        this.X = acoord("x", X);
        this.Y = acoord("y", Y, true);
        this.Z = acoord("z", Z);
        Object.freeze(this);
      }
      static CURVE() {
        return CURVE2;
      }
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      static fromAffine(p) {
        const { x, y: y2 } = p || {};
        if (!p || !Fp4.isValid(x) || !Fp4.isValid(y2))
          throw new Error("invalid affine point");
        if (p instanceof Point2)
          throw new Error("projective point not allowed");
        if (Fp4.is0(x) && Fp4.is0(y2))
          return Point2.ZERO;
        return new Point2(x, y2, Fp4.ONE);
      }
      static fromBytes(bytes2) {
        const P = Point2.fromAffine(decodePoint(_abytes22(bytes2, void 0, "point")));
        P.assertValidity();
        return P;
      }
      static fromHex(hex) {
        return Point2.fromBytes(ensureBytes4("pointHex", hex));
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       *
       * @param windowSize
       * @param isLazy true will defer table computation until the first multiplication
       * @returns
       */
      precompute(windowSize = 8, isLazy = true) {
        wnaf.createCache(this, windowSize);
        if (!isLazy)
          this.multiply(_3n8);
        return this;
      }
      // TODO: return `this`
      /** A point on curve is valid if it conforms to equation. */
      assertValidity() {
        assertValidMemo(this);
      }
      hasEvenY() {
        const { y: y2 } = this.toAffine();
        if (!Fp4.isOdd)
          throw new Error("Field doesn't support isOdd");
        return !Fp4.isOdd(y2);
      }
      /** Compare one point to another. */
      equals(other) {
        aprjpoint(other);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const { X: X2, Y: Y2, Z: Z2 } = other;
        const U1 = Fp4.eql(Fp4.mul(X1, Z2), Fp4.mul(X2, Z1));
        const U2 = Fp4.eql(Fp4.mul(Y1, Z2), Fp4.mul(Y2, Z1));
        return U1 && U2;
      }
      /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
      negate() {
        return new Point2(this.X, Fp4.neg(this.Y), this.Z);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a, b } = CURVE2;
        const b3 = Fp4.mul(b, _3n8);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        let X3 = Fp4.ZERO, Y3 = Fp4.ZERO, Z3 = Fp4.ZERO;
        let t0 = Fp4.mul(X1, X1);
        let t1 = Fp4.mul(Y1, Y1);
        let t2 = Fp4.mul(Z1, Z1);
        let t3 = Fp4.mul(X1, Y1);
        t3 = Fp4.add(t3, t3);
        Z3 = Fp4.mul(X1, Z1);
        Z3 = Fp4.add(Z3, Z3);
        X3 = Fp4.mul(a, Z3);
        Y3 = Fp4.mul(b3, t2);
        Y3 = Fp4.add(X3, Y3);
        X3 = Fp4.sub(t1, Y3);
        Y3 = Fp4.add(t1, Y3);
        Y3 = Fp4.mul(X3, Y3);
        X3 = Fp4.mul(t3, X3);
        Z3 = Fp4.mul(b3, Z3);
        t2 = Fp4.mul(a, t2);
        t3 = Fp4.sub(t0, t2);
        t3 = Fp4.mul(a, t3);
        t3 = Fp4.add(t3, Z3);
        Z3 = Fp4.add(t0, t0);
        t0 = Fp4.add(Z3, t0);
        t0 = Fp4.add(t0, t2);
        t0 = Fp4.mul(t0, t3);
        Y3 = Fp4.add(Y3, t0);
        t2 = Fp4.mul(Y1, Z1);
        t2 = Fp4.add(t2, t2);
        t0 = Fp4.mul(t2, t3);
        X3 = Fp4.sub(X3, t0);
        Z3 = Fp4.mul(t2, t1);
        Z3 = Fp4.add(Z3, Z3);
        Z3 = Fp4.add(Z3, Z3);
        return new Point2(X3, Y3, Z3);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(other) {
        aprjpoint(other);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const { X: X2, Y: Y2, Z: Z2 } = other;
        let X3 = Fp4.ZERO, Y3 = Fp4.ZERO, Z3 = Fp4.ZERO;
        const a = CURVE2.a;
        const b3 = Fp4.mul(CURVE2.b, _3n8);
        let t0 = Fp4.mul(X1, X2);
        let t1 = Fp4.mul(Y1, Y2);
        let t2 = Fp4.mul(Z1, Z2);
        let t3 = Fp4.add(X1, Y1);
        let t4 = Fp4.add(X2, Y2);
        t3 = Fp4.mul(t3, t4);
        t4 = Fp4.add(t0, t1);
        t3 = Fp4.sub(t3, t4);
        t4 = Fp4.add(X1, Z1);
        let t5 = Fp4.add(X2, Z2);
        t4 = Fp4.mul(t4, t5);
        t5 = Fp4.add(t0, t2);
        t4 = Fp4.sub(t4, t5);
        t5 = Fp4.add(Y1, Z1);
        X3 = Fp4.add(Y2, Z2);
        t5 = Fp4.mul(t5, X3);
        X3 = Fp4.add(t1, t2);
        t5 = Fp4.sub(t5, X3);
        Z3 = Fp4.mul(a, t4);
        X3 = Fp4.mul(b3, t2);
        Z3 = Fp4.add(X3, Z3);
        X3 = Fp4.sub(t1, Z3);
        Z3 = Fp4.add(t1, Z3);
        Y3 = Fp4.mul(X3, Z3);
        t1 = Fp4.add(t0, t0);
        t1 = Fp4.add(t1, t0);
        t2 = Fp4.mul(a, t2);
        t4 = Fp4.mul(b3, t4);
        t1 = Fp4.add(t1, t2);
        t2 = Fp4.sub(t0, t2);
        t2 = Fp4.mul(a, t2);
        t4 = Fp4.add(t4, t2);
        t0 = Fp4.mul(t1, t4);
        Y3 = Fp4.add(Y3, t0);
        t0 = Fp4.mul(t5, t4);
        X3 = Fp4.mul(t3, X3);
        X3 = Fp4.sub(X3, t0);
        t0 = Fp4.mul(t3, t1);
        Z3 = Fp4.mul(t5, Z3);
        Z3 = Fp4.add(Z3, t0);
        return new Point2(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point2.ZERO);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(scalar) {
        const { endo: endo3 } = extraOpts;
        if (!Fn3.isValidNot0(scalar))
          throw new Error("invalid scalar: out of range");
        let point, fake;
        const mul = (n) => wnaf.cached(this, n, (p) => normalizeZ2(Point2, p));
        if (endo3) {
          const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
          const { p: k1p, f: k1f } = mul(k1);
          const { p: k2p, f: k2f } = mul(k2);
          fake = k1f.add(k2f);
          point = finishEndo(endo3.beta, k1p, k2p, k1neg, k2neg);
        } else {
          const { p, f } = mul(scalar);
          point = p;
          fake = f;
        }
        return normalizeZ2(Point2, [point, fake])[0];
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed secret key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(sc) {
        const { endo: endo3 } = extraOpts;
        const p = this;
        if (!Fn3.isValid(sc))
          throw new Error("invalid scalar: out of range");
        if (sc === _0n19 || p.is0())
          return Point2.ZERO;
        if (sc === _1n19)
          return p;
        if (wnaf.hasCache(this))
          return this.multiply(sc);
        if (endo3) {
          const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
          const { p1, p2 } = mulEndoUnsafe2(Point2, p, k1, k2);
          return finishEndo(endo3.beta, p1, p2, k1neg, k2neg);
        } else {
          return wnaf.unsafe(p, sc);
        }
      }
      multiplyAndAddUnsafe(Q, a, b) {
        const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
        return sum.is0() ? void 0 : sum;
      }
      /**
       * Converts Projective point to affine (x, y) coordinates.
       * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
       */
      toAffine(invertedZ) {
        return toAffineMemo(this, invertedZ);
      }
      /**
       * Checks whether Point is free of torsion elements (is in prime subgroup).
       * Always torsion-free for cofactor=1 curves.
       */
      isTorsionFree() {
        const { isTorsionFree } = extraOpts;
        if (cofactor === _1n19)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point2, this);
        return wnaf.unsafe(this, CURVE_ORDER).is0();
      }
      clearCofactor() {
        const { clearCofactor } = extraOpts;
        if (cofactor === _1n19)
          return this;
        if (clearCofactor)
          return clearCofactor(Point2, this);
        return this.multiplyUnsafe(cofactor);
      }
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      toBytes(isCompressed = true) {
        _abool22(isCompressed, "isCompressed");
        this.assertValidity();
        return encodePoint(Point2, this, isCompressed);
      }
      toHex(isCompressed = true) {
        return bytesToHex5(this.toBytes(isCompressed));
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
      // TODO: remove
      get px() {
        return this.X;
      }
      get py() {
        return this.X;
      }
      get pz() {
        return this.Z;
      }
      toRawBytes(isCompressed = true) {
        return this.toBytes(isCompressed);
      }
      _setWindowSize(windowSize) {
        this.precompute(windowSize);
      }
      static normalizeZ(points) {
        return normalizeZ2(Point2, points);
      }
      static msm(points, scalars) {
        return pippenger2(Point2, Fn3, points, scalars);
      }
      static fromPrivateKey(privateKey) {
        return Point2.BASE.multiply(_normFnElement2(Fn3, privateKey));
      }
    }
    Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy, Fp4.ONE);
    Point2.ZERO = new Point2(Fp4.ZERO, Fp4.ONE, Fp4.ZERO);
    Point2.Fp = Fp4;
    Point2.Fn = Fn3;
    const bits = Fn3.BITS;
    const wnaf = new wNAF3(Point2, extraOpts.endo ? Math.ceil(bits / 2) : bits);
    Point2.BASE.precompute(8);
    return Point2;
  }
  function pprefix2(hasEvenY) {
    return Uint8Array.of(hasEvenY ? 2 : 3);
  }
  function getWLengths2(Fp4, Fn3) {
    return {
      secretKey: Fn3.BYTES,
      publicKey: 1 + Fp4.BYTES,
      publicKeyUncompressed: 1 + 2 * Fp4.BYTES,
      publicKeyHasPrefix: true,
      signature: 2 * Fn3.BYTES
    };
  }
  function ecdh2(Point2, ecdhOpts = {}) {
    const { Fn: Fn3 } = Point2;
    const randomBytes_ = ecdhOpts.randomBytes || randomBytes4;
    const lengths = Object.assign(getWLengths2(Point2.Fp, Fn3), { seed: getMinHashLength2(Fn3.ORDER) });
    function isValidSecretKey(secretKey) {
      try {
        return !!_normFnElement2(Fn3, secretKey);
      } catch (error) {
        return false;
      }
    }
    function isValidPublicKey(publicKey, isCompressed) {
      const { publicKey: comp, publicKeyUncompressed } = lengths;
      try {
        const l = publicKey.length;
        if (isCompressed === true && l !== comp)
          return false;
        if (isCompressed === false && l !== publicKeyUncompressed)
          return false;
        return !!Point2.fromBytes(publicKey);
      } catch (error) {
        return false;
      }
    }
    function randomSecretKey(seed = randomBytes_(lengths.seed)) {
      return mapHashToField2(_abytes22(seed, lengths.seed, "seed"), Fn3.ORDER);
    }
    function getPublicKey(secretKey, isCompressed = true) {
      return Point2.BASE.multiply(_normFnElement2(Fn3, secretKey)).toBytes(isCompressed);
    }
    function keygen(seed) {
      const secretKey = randomSecretKey(seed);
      return { secretKey, publicKey: getPublicKey(secretKey) };
    }
    function isProbPub(item) {
      if (typeof item === "bigint")
        return false;
      if (item instanceof Point2)
        return true;
      const { secretKey, publicKey, publicKeyUncompressed } = lengths;
      if (Fn3.allowedLengths || secretKey === publicKey)
        return void 0;
      const l = ensureBytes4("key", item).length;
      return l === publicKey || l === publicKeyUncompressed;
    }
    function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
      if (isProbPub(secretKeyA) === true)
        throw new Error("first arg must be private key");
      if (isProbPub(publicKeyB) === false)
        throw new Error("second arg must be public key");
      const s2 = _normFnElement2(Fn3, secretKeyA);
      const b = Point2.fromHex(publicKeyB);
      return b.multiply(s2).toBytes(isCompressed);
    }
    const utils2 = {
      isValidSecretKey,
      isValidPublicKey,
      randomSecretKey,
      // TODO: remove
      isValidPrivateKey: isValidSecretKey,
      randomPrivateKey: randomSecretKey,
      normPrivateKeyToScalar: (key) => _normFnElement2(Fn3, key),
      precompute(windowSize = 8, point = Point2.BASE) {
        return point.precompute(windowSize, false);
      }
    };
    return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point: Point2, utils: utils2, lengths });
  }
  function ecdsa2(Point2, hash2, ecdsaOpts = {}) {
    ahash2(hash2);
    _validateObject2(ecdsaOpts, {}, {
      hmac: "function",
      lowS: "boolean",
      randomBytes: "function",
      bits2int: "function",
      bits2int_modN: "function"
    });
    const randomBytes5 = ecdsaOpts.randomBytes || randomBytes4;
    const hmac4 = ecdsaOpts.hmac || ((key, ...msgs) => hmac3(hash2, key, concatBytes5(...msgs)));
    const { Fp: Fp4, Fn: Fn3 } = Point2;
    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn3;
    const { keygen, getPublicKey, getSharedSecret, utils: utils2, lengths } = ecdh2(Point2, ecdsaOpts);
    const defaultSigOpts = {
      prehash: false,
      lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
      format: void 0,
      //'compact' as ECDSASigFormat,
      extraEntropy: false
    };
    const defaultSigOpts_format = "compact";
    function isBiggerThanHalfOrder(number3) {
      const HALF = CURVE_ORDER >> _1n19;
      return number3 > HALF;
    }
    function validateRS(title, num) {
      if (!Fn3.isValidNot0(num))
        throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
      return num;
    }
    function validateSigLength(bytes2, format19) {
      validateSigFormat2(format19);
      const size = lengths.signature;
      const sizer = format19 === "compact" ? size : format19 === "recovered" ? size + 1 : void 0;
      return _abytes22(bytes2, sizer, `${format19} signature`);
    }
    class Signature2 {
      constructor(r, s2, recovery) {
        this.r = validateRS("r", r);
        this.s = validateRS("s", s2);
        if (recovery != null)
          this.recovery = recovery;
        Object.freeze(this);
      }
      static fromBytes(bytes2, format19 = defaultSigOpts_format) {
        validateSigLength(bytes2, format19);
        let recid;
        if (format19 === "der") {
          const { r: r2, s: s3 } = DER2.toSig(_abytes22(bytes2));
          return new Signature2(r2, s3);
        }
        if (format19 === "recovered") {
          recid = bytes2[0];
          format19 = "compact";
          bytes2 = bytes2.subarray(1);
        }
        const L = Fn3.BYTES;
        const r = bytes2.subarray(0, L);
        const s2 = bytes2.subarray(L, L * 2);
        return new Signature2(Fn3.fromBytes(r), Fn3.fromBytes(s2), recid);
      }
      static fromHex(hex, format19) {
        return this.fromBytes(hexToBytes5(hex), format19);
      }
      addRecoveryBit(recovery) {
        return new Signature2(this.r, this.s, recovery);
      }
      recoverPublicKey(messageHash2) {
        const FIELD_ORDER = Fp4.ORDER;
        const { r, s: s2, recovery: rec } = this;
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const hasCofactor = CURVE_ORDER * _2n14 < FIELD_ORDER;
        if (hasCofactor && rec > 1)
          throw new Error("recovery id is ambiguous for h>1 curve");
        const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
        if (!Fp4.isValid(radj))
          throw new Error("recovery id 2 or 3 invalid");
        const x = Fp4.toBytes(radj);
        const R = Point2.fromBytes(concatBytes5(pprefix2((rec & 1) === 0), x));
        const ir = Fn3.inv(radj);
        const h2 = bits2int_modN(ensureBytes4("msgHash", messageHash2));
        const u1 = Fn3.create(-h2 * ir);
        const u2 = Fn3.create(s2 * ir);
        const Q = Point2.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
        if (Q.is0())
          throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      toBytes(format19 = defaultSigOpts_format) {
        validateSigFormat2(format19);
        if (format19 === "der")
          return hexToBytes5(DER2.hexFromSig(this));
        const r = Fn3.toBytes(this.r);
        const s2 = Fn3.toBytes(this.s);
        if (format19 === "recovered") {
          if (this.recovery == null)
            throw new Error("recovery bit must be present");
          return concatBytes5(Uint8Array.of(this.recovery), r, s2);
        }
        return concatBytes5(r, s2);
      }
      toHex(format19) {
        return bytesToHex5(this.toBytes(format19));
      }
      // TODO: remove
      assertValidity() {
      }
      static fromCompact(hex) {
        return Signature2.fromBytes(ensureBytes4("sig", hex), "compact");
      }
      static fromDER(hex) {
        return Signature2.fromBytes(ensureBytes4("sig", hex), "der");
      }
      normalizeS() {
        return this.hasHighS() ? new Signature2(this.r, Fn3.neg(this.s), this.recovery) : this;
      }
      toDERRawBytes() {
        return this.toBytes("der");
      }
      toDERHex() {
        return bytesToHex5(this.toBytes("der"));
      }
      toCompactRawBytes() {
        return this.toBytes("compact");
      }
      toCompactHex() {
        return bytesToHex5(this.toBytes("compact"));
      }
    }
    const bits2int2 = ecdsaOpts.bits2int || function bits2int_def(bytes2) {
      if (bytes2.length > 8192)
        throw new Error("input is too large");
      const num = bytesToNumberBE3(bytes2);
      const delta = bytes2.length * 8 - fnBits;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes2) {
      return Fn3.create(bits2int2(bytes2));
    };
    const ORDER_MASK = bitMask3(fnBits);
    function int2octets2(num) {
      aInRange2("num < 2^" + fnBits, num, _0n19, ORDER_MASK);
      return Fn3.toBytes(num);
    }
    function validateMsgAndHash(message2, prehash) {
      _abytes22(message2, void 0, "message");
      return prehash ? _abytes22(hash2(message2), void 0, "prehashed message") : message2;
    }
    function prepSig(message2, privateKey, opts) {
      if (["recovered", "canonical"].some((k) => k in opts))
        throw new Error("sign() legacy options not supported");
      const { lowS, prehash, extraEntropy } = validateSigOpts2(opts, defaultSigOpts);
      message2 = validateMsgAndHash(message2, prehash);
      const h1int = bits2int_modN(message2);
      const d2 = _normFnElement2(Fn3, privateKey);
      const seedArgs = [int2octets2(d2), int2octets2(h1int)];
      if (extraEntropy != null && extraEntropy !== false) {
        const e = extraEntropy === true ? randomBytes5(lengths.secretKey) : extraEntropy;
        seedArgs.push(ensureBytes4("extraEntropy", e));
      }
      const seed = concatBytes5(...seedArgs);
      const m2 = h1int;
      function k2sig(kBytes) {
        const k = bits2int2(kBytes);
        if (!Fn3.isValidNot0(k))
          return;
        const ik = Fn3.inv(k);
        const q = Point2.BASE.multiply(k).toAffine();
        const r = Fn3.create(q.x);
        if (r === _0n19)
          return;
        const s2 = Fn3.create(ik * Fn3.create(m2 + r * d2));
        if (s2 === _0n19)
          return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n19);
        let normS = s2;
        if (lowS && isBiggerThanHalfOrder(s2)) {
          normS = Fn3.neg(s2);
          recovery ^= 1;
        }
        return new Signature2(r, normS, recovery);
      }
      return { seed, k2sig };
    }
    function sign3(message2, secretKey, opts = {}) {
      message2 = ensureBytes4("message", message2);
      const { seed, k2sig } = prepSig(message2, secretKey, opts);
      const drbg = createHmacDrbg2(hash2.outputLen, Fn3.BYTES, hmac4);
      const sig = drbg(seed, k2sig);
      return sig;
    }
    function tryParsingSig(sg) {
      let sig = void 0;
      const isHex = typeof sg === "string" || isBytes3(sg);
      const isObj = !isHex && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
      if (!isHex && !isObj)
        throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
      if (isObj) {
        sig = new Signature2(sg.r, sg.s);
      } else if (isHex) {
        try {
          sig = Signature2.fromBytes(ensureBytes4("sig", sg), "der");
        } catch (derError) {
          if (!(derError instanceof DER2.Err))
            throw derError;
        }
        if (!sig) {
          try {
            sig = Signature2.fromBytes(ensureBytes4("sig", sg), "compact");
          } catch (error) {
            return false;
          }
        }
      }
      if (!sig)
        return false;
      return sig;
    }
    function verify2(signature, message2, publicKey, opts = {}) {
      const { lowS, prehash, format: format19 } = validateSigOpts2(opts, defaultSigOpts);
      publicKey = ensureBytes4("publicKey", publicKey);
      message2 = validateMsgAndHash(ensureBytes4("message", message2), prehash);
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      const sig = format19 === void 0 ? tryParsingSig(signature) : Signature2.fromBytes(ensureBytes4("sig", signature), format19);
      if (sig === false)
        return false;
      try {
        const P = Point2.fromBytes(publicKey);
        if (lowS && sig.hasHighS())
          return false;
        const { r, s: s2 } = sig;
        const h2 = bits2int_modN(message2);
        const is = Fn3.inv(s2);
        const u1 = Fn3.create(h2 * is);
        const u2 = Fn3.create(r * is);
        const R = Point2.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
        if (R.is0())
          return false;
        const v = Fn3.create(R.x);
        return v === r;
      } catch (e) {
        return false;
      }
    }
    function recoverPublicKey(signature, message2, opts = {}) {
      const { prehash } = validateSigOpts2(opts, defaultSigOpts);
      message2 = validateMsgAndHash(message2, prehash);
      return Signature2.fromBytes(signature, "recovered").recoverPublicKey(message2).toBytes();
    }
    return Object.freeze({
      keygen,
      getPublicKey,
      getSharedSecret,
      utils: utils2,
      lengths,
      Point: Point2,
      sign: sign3,
      verify: verify2,
      recoverPublicKey,
      Signature: Signature2,
      hash: hash2
    });
  }
  function _weierstrass_legacy_opts_to_new2(c) {
    const CURVE2 = {
      a: c.a,
      b: c.b,
      p: c.Fp.ORDER,
      n: c.n,
      h: c.h,
      Gx: c.Gx,
      Gy: c.Gy
    };
    const Fp4 = c.Fp;
    let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2)))) : void 0;
    const Fn3 = Field3(CURVE2.n, {
      BITS: c.nBitLength,
      allowedLengths,
      modFromBytes: c.wrapPrivateKey
    });
    const curveOpts = {
      Fp: Fp4,
      Fn: Fn3,
      allowInfinityPoint: c.allowInfinityPoint,
      endo: c.endo,
      isTorsionFree: c.isTorsionFree,
      clearCofactor: c.clearCofactor,
      fromBytes: c.fromBytes,
      toBytes: c.toBytes
    };
    return { CURVE: CURVE2, curveOpts };
  }
  function _ecdsa_legacy_opts_to_new2(c) {
    const { CURVE: CURVE2, curveOpts } = _weierstrass_legacy_opts_to_new2(c);
    const ecdsaOpts = {
      hmac: c.hmac,
      randomBytes: c.randomBytes,
      lowS: c.lowS,
      bits2int: c.bits2int,
      bits2int_modN: c.bits2int_modN
    };
    return { CURVE: CURVE2, curveOpts, hash: c.hash, ecdsaOpts };
  }
  function _ecdsa_new_output_to_legacy2(c, _ecdsa) {
    const Point2 = _ecdsa.Point;
    return Object.assign({}, _ecdsa, {
      ProjectivePoint: Point2,
      CURVE: Object.assign({}, c, nLength3(Point2.Fn.ORDER, Point2.Fn.BITS))
    });
  }
  function weierstrass3(c) {
    const { CURVE: CURVE2, curveOpts, hash: hash2, ecdsaOpts } = _ecdsa_legacy_opts_to_new2(c);
    const Point2 = weierstrassN2(CURVE2, curveOpts);
    const signs = ecdsa2(Point2, hash2, ecdsaOpts);
    return _ecdsa_new_output_to_legacy2(c, signs);
  }

  // ../node_modules/@waku/enr/node_modules/@noble/curves/esm/_shortw_utils.js
  function createCurve2(curveDef, defHash) {
    const create19 = (hash2) => weierstrass3({ ...curveDef, hash: hash2 });
    return { ...create19(defHash), create: create19 };
  }

  // ../node_modules/@waku/enr/node_modules/@noble/curves/esm/secp256k1.js
  var secp256k1_CURVE2 = {
    p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
    Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
  };
  var secp256k1_ENDO2 = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    basises: [
      [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
      [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
    ]
  };
  var _2n15 = /* @__PURE__ */ BigInt(2);
  function sqrtMod3(y2) {
    const P = secp256k1_CURVE2.p;
    const _3n9 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y2 * y2 * y2 % P;
    const b3 = b2 * b2 * y2 % P;
    const b6 = pow24(b3, _3n9, P) * b3 % P;
    const b9 = pow24(b6, _3n9, P) * b3 % P;
    const b11 = pow24(b9, _2n15, P) * b2 % P;
    const b22 = pow24(b11, _11n, P) * b11 % P;
    const b44 = pow24(b22, _22n, P) * b22 % P;
    const b88 = pow24(b44, _44n, P) * b44 % P;
    const b176 = pow24(b88, _88n, P) * b88 % P;
    const b220 = pow24(b176, _44n, P) * b44 % P;
    const b223 = pow24(b220, _3n9, P) * b3 % P;
    const t1 = pow24(b223, _23n, P) * b22 % P;
    const t2 = pow24(t1, _6n, P) * b2 % P;
    const root = pow24(t2, _2n15, P);
    if (!Fpk12.eql(Fpk12.sqr(root), y2))
      throw new Error("Cannot find square root");
    return root;
  }
  var Fpk12 = Field3(secp256k1_CURVE2.p, { sqrt: sqrtMod3 });
  var secp256k12 = createCurve2({ ...secp256k1_CURVE2, Fp: Fpk12, lowS: true, endo: secp256k1_ENDO2 }, sha25620);

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/secp256k1/index.browser.js
  var PUBLIC_KEY_BYTE_LENGTH3 = 33;
  function hashAndVerify8(key, sig, msg, options) {
    const p = sha25619.digest(msg instanceof Uint8Array ? msg : msg.subarray());
    if (isPromise4(p)) {
      return p.then(({ digest: digest18 }) => {
        options?.signal?.throwIfAborted();
        return secp256k12.verify(sig, digest18, key);
      }).catch((err) => {
        if (err.name === "AbortError") {
          throw err;
        }
        throw new VerificationError2(String(err));
      });
    }
    try {
      options?.signal?.throwIfAborted();
      return secp256k12.verify(sig, p.digest, key);
    } catch (err) {
      throw new VerificationError2(String(err));
    }
  }

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/secp256k1/secp256k1.js
  var Secp256k1PublicKey2 = class {
    type = "secp256k1";
    raw;
    _key;
    constructor(key) {
      this._key = validateSecp256k1PublicKey2(key);
      this.raw = compressSecp256k1PublicKey2(this._key);
    }
    toMultihash() {
      return identity31.digest(publicKeyToProtobuf2(this));
    }
    toCID() {
      return CID17.createV1(114, this.toMultihash());
    }
    toString() {
      return base58btc20.encode(this.toMultihash().bytes).substring(1);
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals46(this.raw, key.raw);
    }
    verify(data, sig, options) {
      return hashAndVerify8(this._key, sig, data, options);
    }
  };

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/secp256k1/utils.js
  function unmarshalSecp256k1PublicKey2(bytes2) {
    return new Secp256k1PublicKey2(bytes2);
  }
  function compressSecp256k1PublicKey2(key) {
    const point = secp256k12.ProjectivePoint.fromHex(key).toRawBytes(true);
    return point;
  }
  function validateSecp256k1PublicKey2(key) {
    try {
      secp256k12.ProjectivePoint.fromHex(key);
      return key;
    } catch (err) {
      throw new InvalidPublicKeyError(String(err));
    }
  }

  // ../node_modules/@waku/enr/node_modules/@libp2p/crypto/dist/src/keys/index.js
  function publicKeyFromRaw(buf) {
    if (buf.byteLength === PUBLIC_KEY_BYTE_LENGTH2) {
      return unmarshalEd25519PublicKey2(buf);
    } else if (buf.byteLength === PUBLIC_KEY_BYTE_LENGTH3) {
      return unmarshalSecp256k1PublicKey2(buf);
    }
    const message2 = decodeDer2(buf);
    const ecdsaOid = message2[1]?.[0];
    if (ecdsaOid === ECDSA_P_256_OID || ecdsaOid === ECDSA_P_384_OID || ecdsaOid === ECDSA_P_521_OID) {
      return pkiMessageToECDSAPublicKey2(message2);
    }
    if (message2[0]?.[0] === RSAES_PKCS1_V1_5_OID) {
      return pkixMessageToRSAPublicKey2(message2, buf);
    }
    throw new InvalidParametersError("Could not extract public key from raw bytes");
  }
  function publicKeyToProtobuf2(key) {
    return PublicKey2.encode({
      Type: KeyType2[key.type],
      Data: key.raw
    });
  }

  // ../node_modules/@waku/enr/node_modules/@libp2p/peer-id/dist/src/peer-id.js
  var inspect3 = Symbol.for("nodejs.util.inspect.custom");
  var LIBP2P_KEY_CODE3 = 114;
  var PeerIdImpl2 = class {
    type;
    multihash;
    publicKey;
    string;
    constructor(init) {
      this.type = init.type;
      this.multihash = init.multihash;
      Object.defineProperty(this, "string", {
        enumerable: false,
        writable: true
      });
    }
    get [Symbol.toStringTag]() {
      return `PeerId(${this.toString()})`;
    }
    [peerIdSymbol] = true;
    toString() {
      if (this.string == null) {
        this.string = base58btc20.encode(this.multihash.bytes).slice(1);
      }
      return this.string;
    }
    toMultihash() {
      return this.multihash;
    }
    // return self-describing String representation
    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
    toCID() {
      return CID17.createV1(LIBP2P_KEY_CODE3, this.multihash);
    }
    toJSON() {
      return this.toString();
    }
    /**
     * Checks the equality of `this` peer against a given PeerId
     */
    equals(id) {
      if (id == null) {
        return false;
      }
      if (id instanceof Uint8Array) {
        return equals46(this.multihash.bytes, id);
      } else if (typeof id === "string") {
        return this.toString() === id;
      } else if (id?.toMultihash()?.bytes != null) {
        return equals46(this.multihash.bytes, id.toMultihash().bytes);
      } else {
        throw new Error("not valid Id");
      }
    }
    /**
     * Returns PeerId as a human-readable string
     * https://nodejs.org/api/util.html#utilinspectcustom
     *
     * @example
     * ```TypeScript
     * import { peerIdFromString } from '@libp2p/peer-id'
     *
     * console.info(peerIdFromString('QmFoo'))
     * // 'PeerId(QmFoo)'
     * ```
     */
    [inspect3]() {
      return `PeerId(${this.toString()})`;
    }
  };
  var RSAPeerId2 = class extends PeerIdImpl2 {
    type = "RSA";
    publicKey;
    constructor(init) {
      super({ ...init, type: "RSA" });
      this.publicKey = init.publicKey;
    }
  };
  var Ed25519PeerId2 = class extends PeerIdImpl2 {
    type = "Ed25519";
    publicKey;
    constructor(init) {
      super({ ...init, type: "Ed25519" });
      this.publicKey = init.publicKey;
    }
  };
  var Secp256k1PeerId2 = class extends PeerIdImpl2 {
    type = "secp256k1";
    publicKey;
    constructor(init) {
      super({ ...init, type: "secp256k1" });
      this.publicKey = init.publicKey;
    }
  };
  var TRANSPORT_IPFS_GATEWAY_HTTP_CODE3 = 2336;
  var URLPeerId2 = class {
    type = "url";
    multihash;
    publicKey;
    url;
    constructor(url) {
      this.url = url.toString();
      this.multihash = identity31.digest(fromString31(this.url));
    }
    [inspect3]() {
      return `PeerId(${this.url})`;
    }
    [peerIdSymbol] = true;
    toString() {
      return this.toCID().toString();
    }
    toMultihash() {
      return this.multihash;
    }
    toCID() {
      return CID17.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE3, this.toMultihash());
    }
    toJSON() {
      return this.toString();
    }
    equals(other) {
      if (other == null) {
        return false;
      }
      if (other instanceof Uint8Array) {
        other = toString27(other);
      }
      return other.toString() === this.toString();
    }
  };

  // ../node_modules/@waku/enr/node_modules/@libp2p/peer-id/dist/src/index.js
  function peerIdFromPublicKey2(publicKey) {
    if (publicKey.type === "Ed25519") {
      return new Ed25519PeerId2({
        multihash: publicKey.toCID().multihash,
        publicKey
      });
    } else if (publicKey.type === "secp256k1") {
      return new Secp256k1PeerId2({
        multihash: publicKey.toCID().multihash,
        publicKey
      });
    } else if (publicKey.type === "RSA") {
      return new RSAPeerId2({
        multihash: publicKey.toCID().multihash,
        publicKey
      });
    }
    throw new UnsupportedKeyTypeError();
  }

  // ../node_modules/@waku/enr/dist/peer_id.js
  var ERR_TYPE_NOT_IMPLEMENTED = "Keypair type not implemented";
  function createPeerIdFromPublicKey(publicKey) {
    const pubKey = publicKeyFromRaw(publicKey);
    if (pubKey.type !== "secp256k1") {
      throw new Error(ERR_TYPE_NOT_IMPLEMENTED);
    }
    return peerIdFromPublicKey2(pubKey);
  }

  // ../node_modules/@waku/enr/dist/multiaddrs_codec.js
  function decodeMultiaddrs(bytes2) {
    const multiaddrs = [];
    let index = 0;
    while (index < bytes2.length) {
      const sizeDataView = new DataView(bytes2.buffer, index, MULTIADDR_LENGTH_SIZE);
      const size = sizeDataView.getUint16(0);
      index += MULTIADDR_LENGTH_SIZE;
      const multiaddrBytes = bytes2.slice(index, index + size);
      index += size;
      multiaddrs.push(multiaddr(multiaddrBytes));
    }
    return multiaddrs;
  }
  function encodeMultiaddrs(multiaddrs) {
    const totalLength = multiaddrs.reduce((acc, ma) => acc + MULTIADDR_LENGTH_SIZE + ma.bytes.length, 0);
    const bytes2 = new Uint8Array(totalLength);
    const dataView = new DataView(bytes2.buffer);
    let index = 0;
    multiaddrs.forEach((multiaddr2) => {
      if (multiaddr2.getPeerId())
        throw new Error("`multiaddr` field MUST not contain peer id");
      dataView.setUint16(index, multiaddr2.bytes.length);
      index += MULTIADDR_LENGTH_SIZE;
      bytes2.set(multiaddr2.bytes, index);
      index += multiaddr2.bytes.length;
    });
    return bytes2;
  }

  // ../node_modules/@waku/enr/dist/waku2_codec.js
  function encodeWaku2(protocols2) {
    let byte = 0;
    if (protocols2.lightPush)
      byte += 1;
    byte = byte << 1;
    if (protocols2.filter)
      byte += 1;
    byte = byte << 1;
    if (protocols2.store)
      byte += 1;
    byte = byte << 1;
    if (protocols2.relay)
      byte += 1;
    return byte;
  }
  function decodeWaku2(byte) {
    const waku2 = {
      relay: false,
      store: false,
      filter: false,
      lightPush: false
    };
    if (byte % 2)
      waku2.relay = true;
    byte = byte >> 1;
    if (byte % 2)
      waku2.store = true;
    byte = byte >> 1;
    if (byte % 2)
      waku2.filter = true;
    byte = byte >> 1;
    if (byte % 2)
      waku2.lightPush = true;
    return waku2;
  }

  // ../node_modules/@waku/enr/dist/raw_enr.js
  var RawEnr = class extends Map {
    seq;
    signature;
    constructor(kvs = {}, seq = BigInt(1), signature) {
      super(Object.entries(kvs));
      this.seq = seq;
      this.signature = signature;
    }
    set(k, v) {
      this.signature = void 0;
      this.seq++;
      return super.set(k, v);
    }
    get id() {
      const id = this.get("id");
      if (!id)
        throw new Error("id not found.");
      return bytesToUtf8(id);
    }
    get publicKey() {
      switch (this.id) {
        case "v4":
          return this.get("secp256k1");
        default:
          throw new Error(ERR_INVALID_ID);
      }
    }
    get rs() {
      const rs = this.get("rs");
      if (!rs)
        return void 0;
      return decodeRelayShard(rs);
    }
    get rsv() {
      const rsv = this.get("rsv");
      if (!rsv)
        return void 0;
      return decodeRelayShard(rsv);
    }
    get ip() {
      return getStringValue(this, "ip", "ip4");
    }
    set ip(ip) {
      setStringValue(this, "ip", "ip4", ip);
    }
    get tcp() {
      return getNumberAsStringValue(this, "tcp", "tcp");
    }
    set tcp(port) {
      setNumberAsStringValue(this, "tcp", "tcp", port);
    }
    get udp() {
      return getNumberAsStringValue(this, "udp", "udp");
    }
    set udp(port) {
      setNumberAsStringValue(this, "udp", "udp", port);
    }
    get ip6() {
      return getStringValue(this, "ip6", "ip6");
    }
    set ip6(ip) {
      setStringValue(this, "ip6", "ip6", ip);
    }
    get tcp6() {
      return getNumberAsStringValue(this, "tcp6", "tcp");
    }
    set tcp6(port) {
      setNumberAsStringValue(this, "tcp6", "tcp", port);
    }
    get udp6() {
      return getNumberAsStringValue(this, "udp6", "udp");
    }
    set udp6(port) {
      setNumberAsStringValue(this, "udp6", "udp", port);
    }
    /**
     * Get the `multiaddrs` field from ENR.
     *
     * This field is used to store multiaddresses that cannot be stored with the current ENR pre-defined keys.
     * These can be a multiaddresses that include encapsulation (e.g. wss) or do not use `ip4` nor `ip6` for the host
     * address (e.g. `dns4`, `dnsaddr`, etc)..
     *
     * If the peer information only contains information that can be represented with the ENR pre-defined keys
     * (ip, tcp, etc) then the usage of { @link ENR.getLocationMultiaddr } should be preferred.
     *
     * The multiaddresses stored in this field are expected to be location multiaddresses, ie, peer id less.
     */
    get multiaddrs() {
      const raw = this.get("multiaddrs");
      if (raw)
        return decodeMultiaddrs(raw);
      return;
    }
    /**
     * Set the `multiaddrs` field on the ENR.
     *
     * This field is used to store multiaddresses that cannot be stored with the current ENR pre-defined keys.
     * These can be a multiaddresses that include encapsulation (e.g. wss) or do not use `ip4` nor `ip6` for the host
     * address (e.g. `dns4`, `dnsaddr`, etc)..
     *
     * If the peer information only contains information that can be represented with the ENR pre-defined keys
     * (ip, tcp, etc) then the usage of { @link ENR.setLocationMultiaddr } should be preferred.
     * The multiaddresses stored in this field must be location multiaddresses,
     * ie, without a peer id.
     */
    set multiaddrs(multiaddrs) {
      deleteUndefined(this, "multiaddrs", multiaddrs, encodeMultiaddrs);
    }
    /**
     * Get the `waku2` field from ENR.
     */
    get waku2() {
      const raw = this.get("waku2");
      if (raw)
        return decodeWaku2(raw[0]);
      return;
    }
    /**
     * Set the `waku2` field on the ENR.
     */
    set waku2(waku2) {
      deleteUndefined(this, "waku2", waku2, (w2) => new Uint8Array([encodeWaku2(w2)]));
    }
  };
  function getStringValue(map2, key, proto) {
    const raw = map2.get(key);
    if (!raw)
      return;
    return convertToString(proto, raw);
  }
  function getNumberAsStringValue(map2, key, proto) {
    const raw = map2.get(key);
    if (!raw)
      return;
    return Number(convertToString(proto, raw));
  }
  function setStringValue(map2, key, proto, value) {
    deleteUndefined(map2, key, value, convertToBytes.bind({}, proto));
  }
  function setNumberAsStringValue(map2, key, proto, value) {
    setStringValue(map2, key, proto, value?.toString(10));
  }
  function deleteUndefined(map2, key, value, transform) {
    if (value !== void 0) {
      map2.set(key, transform(value));
    } else {
      map2.delete(key);
    }
  }

  // ../node_modules/@waku/enr/dist/v4.js
  async function sign2(privKey, msg) {
    return sign(keccak256(msg), privKey, {
      der: false
    });
  }
  function nodeId(pubKey) {
    const publicKey = Point.fromHex(pubKey);
    const uncompressedPubkey = publicKey.toRawBytes(false);
    return bytesToHex(keccak256(uncompressedPubkey.slice(1)));
  }

  // ../node_modules/@waku/enr/dist/enr.js
  var log22 = new Logger("enr");
  var TransportProtocol;
  (function(TransportProtocol2) {
    TransportProtocol2["TCP"] = "tcp";
    TransportProtocol2["UDP"] = "udp";
  })(TransportProtocol || (TransportProtocol = {}));
  var TransportProtocolPerIpVersion;
  (function(TransportProtocolPerIpVersion2) {
    TransportProtocolPerIpVersion2["TCP4"] = "tcp4";
    TransportProtocolPerIpVersion2["UDP4"] = "udp4";
    TransportProtocolPerIpVersion2["TCP6"] = "tcp6";
    TransportProtocolPerIpVersion2["UDP6"] = "udp6";
  })(TransportProtocolPerIpVersion || (TransportProtocolPerIpVersion = {}));
  var ENR = class _ENR extends RawEnr {
    static RECORD_PREFIX = "enr:";
    peerId;
    static create(kvs = {}, seq = BigInt(1), signature) {
      const enr = new _ENR(kvs, seq, signature);
      try {
        const publicKey = enr.publicKey;
        if (publicKey) {
          enr.peerId = createPeerIdFromPublicKey(publicKey);
        }
      } catch (e) {
        log22.error("Could not calculate peer id for ENR", e);
      }
      return enr;
    }
    get nodeId() {
      switch (this.id) {
        case "v4":
          return this.publicKey ? nodeId(this.publicKey) : void 0;
        default:
          throw new Error(ERR_INVALID_ID);
      }
    }
    getLocationMultiaddr = locationMultiaddrFromEnrFields.bind({}, this);
    get shardInfo() {
      if (this.rs && this.rsv) {
        log22.warn("ENR contains both `rs` and `rsv` fields.");
      }
      return this.rs || this.rsv;
    }
    setLocationMultiaddr(multiaddr2) {
      const protoNames = multiaddr2.protoNames();
      if (protoNames.length !== 2 && protoNames[1] !== "udp" && protoNames[1] !== "tcp") {
        throw new Error("Invalid multiaddr");
      }
      const tuples = multiaddr2.tuples();
      if (!tuples[0][1] || !tuples[1][1]) {
        throw new Error("Invalid multiaddr");
      }
      if (tuples[0][0] === 4) {
        this.set("ip", tuples[0][1]);
        this.set(protoNames[1], tuples[1][1]);
      } else {
        this.set("ip6", tuples[0][1]);
        this.set(protoNames[1] + "6", tuples[1][1]);
      }
    }
    getAllLocationMultiaddrs() {
      const multiaddrs = [];
      for (const protocol of Object.values(TransportProtocolPerIpVersion)) {
        const ma = this.getLocationMultiaddr(protocol);
        if (ma)
          multiaddrs.push(ma);
      }
      const _multiaddrs = this.multiaddrs ?? [];
      return multiaddrs.concat(_multiaddrs).map((ma) => {
        if (this.peerId) {
          return ma.encapsulate(`/p2p/${this.peerId.toString()}`);
        }
        return ma;
      });
    }
    get peerInfo() {
      const id = this.peerId;
      if (!id)
        return;
      return {
        id,
        multiaddrs: this.getAllLocationMultiaddrs()
      };
    }
    /**
     * Returns the full multiaddr from the ENR fields matching the provided
     * `protocol` parameter.
     * To return full multiaddrs from the `multiaddrs` ENR field,
     * use { @link ENR.getFullMultiaddrs }.
     *
     * @param protocol
     */
    getFullMultiaddr(protocol) {
      if (this.peerId) {
        const locationMultiaddr = this.getLocationMultiaddr(protocol);
        if (locationMultiaddr) {
          return locationMultiaddr.encapsulate(`/p2p/${this.peerId.toString()}`);
        }
      }
      return;
    }
    /**
     * Returns the full multiaddrs from the `multiaddrs` ENR field.
     */
    getFullMultiaddrs() {
      if (this.peerId && this.multiaddrs) {
        const peerId2 = this.peerId;
        return this.multiaddrs.map((ma) => {
          return ma.encapsulate(`/p2p/${peerId2.toString()}`);
        });
      }
      return [];
    }
    verify(data, signature) {
      if (!this.get("id") || this.id !== "v4") {
        throw new Error(ERR_INVALID_ID);
      }
      if (!this.publicKey) {
        throw new Error("Failed to verify ENR: No public key");
      }
      return verifySignature(signature, keccak256(data), this.publicKey);
    }
    async sign(data, privateKey) {
      switch (this.id) {
        case "v4":
          this.signature = await sign2(privateKey, data);
          break;
        default:
          throw new Error(ERR_INVALID_ID);
      }
      return this.signature;
    }
  };

  // ../node_modules/@ethersproject/logger/lib.esm/_version.js
  var version2 = "logger/5.8.0";

  // ../node_modules/@ethersproject/logger/lib.esm/index.js
  var _permanentCensorErrors = false;
  var _censorErrors = false;
  var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
  var _logLevel = LogLevels["default"];
  var _globalLogger = null;
  function _checkNormalize() {
    try {
      const missing = [];
      ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
        try {
          if ("test".normalize(form) !== "test") {
            throw new Error("bad normalize");
          }
          ;
        } catch (error) {
          missing.push(form);
        }
      });
      if (missing.length) {
        throw new Error("missing " + missing.join(", "));
      }
      if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
        throw new Error("broken implementation");
      }
    } catch (error) {
      return error.message;
    }
    return null;
  }
  var _normalizeError = _checkNormalize();
  var LogLevel;
  (function(LogLevel2) {
    LogLevel2["DEBUG"] = "DEBUG";
    LogLevel2["INFO"] = "INFO";
    LogLevel2["WARNING"] = "WARNING";
    LogLevel2["ERROR"] = "ERROR";
    LogLevel2["OFF"] = "OFF";
  })(LogLevel || (LogLevel = {}));
  var ErrorCode;
  (function(ErrorCode2) {
    ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
    ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
    ErrorCode2["TIMEOUT"] = "TIMEOUT";
    ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
    ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
    ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
  })(ErrorCode || (ErrorCode = {}));
  var HEX = "0123456789abcdef";
  var Logger2 = class _Logger {
    constructor(version5) {
      Object.defineProperty(this, "version", {
        enumerable: true,
        value: version5,
        writable: false
      });
    }
    _log(logLevel, args) {
      const level = logLevel.toLowerCase();
      if (LogLevels[level] == null) {
        this.throwArgumentError("invalid log level name", "logLevel", logLevel);
      }
      if (_logLevel > LogLevels[level]) {
        return;
      }
      console.log.apply(console, args);
    }
    debug(...args) {
      this._log(_Logger.levels.DEBUG, args);
    }
    info(...args) {
      this._log(_Logger.levels.INFO, args);
    }
    warn(...args) {
      this._log(_Logger.levels.WARNING, args);
    }
    makeError(message2, code18, params) {
      if (_censorErrors) {
        return this.makeError("censored error", code18, {});
      }
      if (!code18) {
        code18 = _Logger.errors.UNKNOWN_ERROR;
      }
      if (!params) {
        params = {};
      }
      const messageDetails = [];
      Object.keys(params).forEach((key) => {
        const value = params[key];
        try {
          if (value instanceof Uint8Array) {
            let hex = "";
            for (let i = 0; i < value.length; i++) {
              hex += HEX[value[i] >> 4];
              hex += HEX[value[i] & 15];
            }
            messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
          } else {
            messageDetails.push(key + "=" + JSON.stringify(value));
          }
        } catch (error2) {
          messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
        }
      });
      messageDetails.push(`code=${code18}`);
      messageDetails.push(`version=${this.version}`);
      const reason = message2;
      let url = "";
      switch (code18) {
        case ErrorCode.NUMERIC_FAULT: {
          url = "NUMERIC_FAULT";
          const fault = message2;
          switch (fault) {
            case "overflow":
            case "underflow":
            case "division-by-zero":
              url += "-" + fault;
              break;
            case "negative-power":
            case "negative-width":
              url += "-unsupported";
              break;
            case "unbound-bitwise-result":
              url += "-unbound-result";
              break;
          }
          break;
        }
        case ErrorCode.CALL_EXCEPTION:
        case ErrorCode.INSUFFICIENT_FUNDS:
        case ErrorCode.MISSING_NEW:
        case ErrorCode.NONCE_EXPIRED:
        case ErrorCode.REPLACEMENT_UNDERPRICED:
        case ErrorCode.TRANSACTION_REPLACED:
        case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
          url = code18;
          break;
      }
      if (url) {
        message2 += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
      }
      if (messageDetails.length) {
        message2 += " (" + messageDetails.join(", ") + ")";
      }
      const error = new Error(message2);
      error.reason = reason;
      error.code = code18;
      Object.keys(params).forEach(function(key) {
        error[key] = params[key];
      });
      return error;
    }
    throwError(message2, code18, params) {
      throw this.makeError(message2, code18, params);
    }
    throwArgumentError(message2, name19, value) {
      return this.throwError(message2, _Logger.errors.INVALID_ARGUMENT, {
        argument: name19,
        value
      });
    }
    assert(condition, message2, code18, params) {
      if (!!condition) {
        return;
      }
      this.throwError(message2, code18, params);
    }
    assertArgument(condition, message2, name19, value) {
      if (!!condition) {
        return;
      }
      this.throwArgumentError(message2, name19, value);
    }
    checkNormalize(message2) {
      if (message2 == null) {
        message2 = "platform missing String.prototype.normalize";
      }
      if (_normalizeError) {
        this.throwError("platform missing String.prototype.normalize", _Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "String.prototype.normalize",
          form: _normalizeError
        });
      }
    }
    checkSafeUint53(value, message2) {
      if (typeof value !== "number") {
        return;
      }
      if (message2 == null) {
        message2 = "value not safe";
      }
      if (value < 0 || value >= 9007199254740991) {
        this.throwError(message2, _Logger.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "out-of-safe-range",
          value
        });
      }
      if (value % 1) {
        this.throwError(message2, _Logger.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "non-integer",
          value
        });
      }
    }
    checkArgumentCount(count, expectedCount, message2) {
      if (message2) {
        message2 = ": " + message2;
      } else {
        message2 = "";
      }
      if (count < expectedCount) {
        this.throwError("missing argument" + message2, _Logger.errors.MISSING_ARGUMENT, {
          count,
          expectedCount
        });
      }
      if (count > expectedCount) {
        this.throwError("too many arguments" + message2, _Logger.errors.UNEXPECTED_ARGUMENT, {
          count,
          expectedCount
        });
      }
    }
    checkNew(target, kind) {
      if (target === Object || target == null) {
        this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
      }
    }
    checkAbstract(target, kind) {
      if (target === kind) {
        this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", _Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
      } else if (target === Object || target == null) {
        this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
      }
    }
    static globalLogger() {
      if (!_globalLogger) {
        _globalLogger = new _Logger(version2);
      }
      return _globalLogger;
    }
    static setCensorship(censorship, permanent) {
      if (!censorship && permanent) {
        this.globalLogger().throwError("cannot permanently disable censorship", _Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "setCensorship"
        });
      }
      if (_permanentCensorErrors) {
        if (!censorship) {
          return;
        }
        this.globalLogger().throwError("error censorship permanent", _Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "setCensorship"
        });
      }
      _censorErrors = !!censorship;
      _permanentCensorErrors = !!permanent;
    }
    static setLogLevel(logLevel) {
      const level = LogLevels[logLevel.toLowerCase()];
      if (level == null) {
        _Logger.globalLogger().warn("invalid log level - " + logLevel);
        return;
      }
      _logLevel = level;
    }
    static from(version5) {
      return new _Logger(version5);
    }
  };
  Logger2.errors = ErrorCode;
  Logger2.levels = LogLevel;

  // ../node_modules/@ethersproject/bytes/lib.esm/_version.js
  var version3 = "bytes/5.8.0";

  // ../node_modules/@ethersproject/bytes/lib.esm/index.js
  var logger2 = new Logger2(version3);
  function isHexable(value) {
    return !!value.toHexString;
  }
  function addSlice(array) {
    if (array.slice) {
      return array;
    }
    array.slice = function() {
      const args = Array.prototype.slice.call(arguments);
      return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
  }
  function isBytesLike(value) {
    return isHexString(value) && !(value.length % 2) || isBytes4(value);
  }
  function isInteger(value) {
    return typeof value === "number" && value == value && value % 1 === 0;
  }
  function isBytes4(value) {
    if (value == null) {
      return false;
    }
    if (value.constructor === Uint8Array) {
      return true;
    }
    if (typeof value === "string") {
      return false;
    }
    if (!isInteger(value.length) || value.length < 0) {
      return false;
    }
    for (let i = 0; i < value.length; i++) {
      const v = value[i];
      if (!isInteger(v) || v < 0 || v >= 256) {
        return false;
      }
    }
    return true;
  }
  function arrayify(value, options) {
    if (!options) {
      options = {};
    }
    if (typeof value === "number") {
      logger2.checkSafeUint53(value, "invalid arrayify value");
      const result = [];
      while (value) {
        result.unshift(value & 255);
        value = parseInt(String(value / 256));
      }
      if (result.length === 0) {
        result.push(0);
      }
      return addSlice(new Uint8Array(result));
    }
    if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
      value = "0x" + value;
    }
    if (isHexable(value)) {
      value = value.toHexString();
    }
    if (isHexString(value)) {
      let hex = value.substring(2);
      if (hex.length % 2) {
        if (options.hexPad === "left") {
          hex = "0" + hex;
        } else if (options.hexPad === "right") {
          hex += "0";
        } else {
          logger2.throwArgumentError("hex data is odd-length", "value", value);
        }
      }
      const result = [];
      for (let i = 0; i < hex.length; i += 2) {
        result.push(parseInt(hex.substring(i, i + 2), 16));
      }
      return addSlice(new Uint8Array(result));
    }
    if (isBytes4(value)) {
      return addSlice(new Uint8Array(value));
    }
    return logger2.throwArgumentError("invalid arrayify value", "value", value);
  }
  function isHexString(value, length21) {
    if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
      return false;
    }
    if (length21 && value.length !== 2 + 2 * length21) {
      return false;
    }
    return true;
  }
  var HexCharacters = "0123456789abcdef";
  function hexlify(value, options) {
    if (!options) {
      options = {};
    }
    if (typeof value === "number") {
      logger2.checkSafeUint53(value, "invalid hexlify value");
      let hex = "";
      while (value) {
        hex = HexCharacters[value & 15] + hex;
        value = Math.floor(value / 16);
      }
      if (hex.length) {
        if (hex.length % 2) {
          hex = "0" + hex;
        }
        return "0x" + hex;
      }
      return "0x00";
    }
    if (typeof value === "bigint") {
      value = value.toString(16);
      if (value.length % 2) {
        return "0x0" + value;
      }
      return "0x" + value;
    }
    if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
      value = "0x" + value;
    }
    if (isHexable(value)) {
      return value.toHexString();
    }
    if (isHexString(value)) {
      if (value.length % 2) {
        if (options.hexPad === "left") {
          value = "0x0" + value.substring(2);
        } else if (options.hexPad === "right") {
          value += "0";
        } else {
          logger2.throwArgumentError("hex data is odd-length", "value", value);
        }
      }
      return value.toLowerCase();
    }
    if (isBytes4(value)) {
      let result = "0x";
      for (let i = 0; i < value.length; i++) {
        let v = value[i];
        result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
      }
      return result;
    }
    return logger2.throwArgumentError("invalid hexlify value", "value", value);
  }

  // ../node_modules/@ethersproject/rlp/lib.esm/_version.js
  var version4 = "rlp/5.8.0";

  // ../node_modules/@ethersproject/rlp/lib.esm/index.js
  var logger3 = new Logger2(version4);
  function arrayifyInteger(value) {
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value >>= 8;
    }
    return result;
  }
  function unarrayifyInteger(data, offset, length21) {
    let result = 0;
    for (let i = 0; i < length21; i++) {
      result = result * 256 + data[offset + i];
    }
    return result;
  }
  function _encode(object) {
    if (Array.isArray(object)) {
      let payload = [];
      object.forEach(function(child) {
        payload = payload.concat(_encode(child));
      });
      if (payload.length <= 55) {
        payload.unshift(192 + payload.length);
        return payload;
      }
      const length22 = arrayifyInteger(payload.length);
      length22.unshift(247 + length22.length);
      return length22.concat(payload);
    }
    if (!isBytesLike(object)) {
      logger3.throwArgumentError("RLP object must be BytesLike", "object", object);
    }
    const data = Array.prototype.slice.call(arrayify(object));
    if (data.length === 1 && data[0] <= 127) {
      return data;
    } else if (data.length <= 55) {
      data.unshift(128 + data.length);
      return data;
    }
    const length21 = arrayifyInteger(data.length);
    length21.unshift(183 + length21.length);
    return length21.concat(data);
  }
  function encode74(object) {
    return hexlify(_encode(object));
  }
  function _decodeChildren(data, offset, childOffset, length21) {
    const result = [];
    while (childOffset < offset + 1 + length21) {
      const decoded = _decode(data, childOffset);
      result.push(decoded.result);
      childOffset += decoded.consumed;
      if (childOffset > offset + 1 + length21) {
        logger3.throwError("child data too short", Logger2.errors.BUFFER_OVERRUN, {});
      }
    }
    return { consumed: 1 + length21, result };
  }
  function _decode(data, offset) {
    if (data.length === 0) {
      logger3.throwError("data too short", Logger2.errors.BUFFER_OVERRUN, {});
    }
    if (data[offset] >= 248) {
      const lengthLength = data[offset] - 247;
      if (offset + 1 + lengthLength > data.length) {
        logger3.throwError("data short segment too short", Logger2.errors.BUFFER_OVERRUN, {});
      }
      const length21 = unarrayifyInteger(data, offset + 1, lengthLength);
      if (offset + 1 + lengthLength + length21 > data.length) {
        logger3.throwError("data long segment too short", Logger2.errors.BUFFER_OVERRUN, {});
      }
      return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length21);
    } else if (data[offset] >= 192) {
      const length21 = data[offset] - 192;
      if (offset + 1 + length21 > data.length) {
        logger3.throwError("data array too short", Logger2.errors.BUFFER_OVERRUN, {});
      }
      return _decodeChildren(data, offset, offset + 1, length21);
    } else if (data[offset] >= 184) {
      const lengthLength = data[offset] - 183;
      if (offset + 1 + lengthLength > data.length) {
        logger3.throwError("data array too short", Logger2.errors.BUFFER_OVERRUN, {});
      }
      const length21 = unarrayifyInteger(data, offset + 1, lengthLength);
      if (offset + 1 + lengthLength + length21 > data.length) {
        logger3.throwError("data array too short", Logger2.errors.BUFFER_OVERRUN, {});
      }
      const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length21));
      return { consumed: 1 + lengthLength + length21, result };
    } else if (data[offset] >= 128) {
      const length21 = data[offset] - 128;
      if (offset + 1 + length21 > data.length) {
        logger3.throwError("data too short", Logger2.errors.BUFFER_OVERRUN, {});
      }
      const result = hexlify(data.slice(offset + 1, offset + 1 + length21));
      return { consumed: 1 + length21, result };
    }
    return { consumed: 1, result: hexlify(data[offset]) };
  }
  function decode93(data) {
    const bytes2 = arrayify(data);
    const decoded = _decode(bytes2, 0);
    if (decoded.consumed !== bytes2.length) {
      logger3.throwArgumentError("invalid rlp data", "data", data);
    }
    return decoded.result;
  }

  // ../node_modules/@waku/enr/dist/decoder.js
  var log23 = new Logger("enr:decoder");
  var EnrDecoder = class _EnrDecoder {
    static fromString(encoded) {
      if (!encoded.startsWith(ENR.RECORD_PREFIX)) {
        throw new Error(`"string encoded ENR must start with '${ENR.RECORD_PREFIX}'`);
      }
      return _EnrDecoder.fromRLP(fromString31(encoded.slice(4), "base64url"));
    }
    static fromRLP(encoded) {
      const decoded = decode93(encoded).map(hexToBytes);
      return fromValues(decoded);
    }
  };
  async function fromValues(values) {
    const { signature, seq, kvs } = checkValues(values);
    const obj = {};
    for (let i = 0; i < kvs.length; i += 2) {
      try {
        obj[bytesToUtf8(kvs[i])] = kvs[i + 1];
      } catch (e) {
        log23.error("Failed to decode ENR key to UTF-8, skipping it", kvs[i], e);
      }
    }
    const _seq = decodeSeq(seq);
    const enr = ENR.create(obj, _seq, signature);
    checkSignature(seq, kvs, enr, signature);
    return enr;
  }
  function decodeSeq(seq) {
    if (!seq.length)
      return BigInt(0);
    return BigInt("0x" + bytesToHex(seq));
  }
  function checkValues(values) {
    if (!Array.isArray(values)) {
      throw new Error("Decoded ENR must be an array");
    }
    if (values.length % 2 !== 0) {
      throw new Error("Decoded ENR must have an even number of elements");
    }
    const [signature, seq, ...kvs] = values;
    if (!signature || Array.isArray(signature)) {
      throw new Error("Decoded ENR invalid signature: must be a byte array");
    }
    if (!seq || Array.isArray(seq)) {
      throw new Error("Decoded ENR invalid sequence number: must be a byte array");
    }
    return { signature, seq, kvs };
  }
  function checkSignature(seq, kvs, enr, signature) {
    const rlpEncodedBytes = hexToBytes(encode74([seq, ...kvs]));
    if (!enr.verify(rlpEncodedBytes, signature)) {
      throw new Error("Unable to verify ENR signature");
    }
  }

  // ../node_modules/dns-over-http-resolver/node_modules/quick-lru/index.js
  var QuickLRU = class extends Map {
    #size = 0;
    #cache = /* @__PURE__ */ new Map();
    #oldCache = /* @__PURE__ */ new Map();
    #maxSize;
    #maxAge;
    #onEviction;
    constructor(options = {}) {
      super();
      if (!(options.maxSize && options.maxSize > 0)) {
        throw new TypeError("`maxSize` must be a number greater than 0");
      }
      if (typeof options.maxAge === "number" && options.maxAge === 0) {
        throw new TypeError("`maxAge` must be a number greater than 0");
      }
      this.#maxSize = options.maxSize;
      this.#maxAge = options.maxAge || Number.POSITIVE_INFINITY;
      this.#onEviction = options.onEviction;
    }
    // For tests.
    get __oldCache() {
      return this.#oldCache;
    }
    #emitEvictions(cache20) {
      if (typeof this.#onEviction !== "function") {
        return;
      }
      for (const [key, item] of cache20) {
        this.#onEviction(key, item.value);
      }
    }
    #deleteIfExpired(key, item) {
      if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
        if (typeof this.#onEviction === "function") {
          this.#onEviction(key, item.value);
        }
        return this.delete(key);
      }
      return false;
    }
    #getOrDeleteIfExpired(key, item) {
      const deleted = this.#deleteIfExpired(key, item);
      if (deleted === false) {
        return item.value;
      }
    }
    #getItemValue(key, item) {
      return item.expiry ? this.#getOrDeleteIfExpired(key, item) : item.value;
    }
    #peek(key, cache20) {
      const item = cache20.get(key);
      return this.#getItemValue(key, item);
    }
    #set(key, value) {
      this.#cache.set(key, value);
      this.#size++;
      if (this.#size >= this.#maxSize) {
        this.#size = 0;
        this.#emitEvictions(this.#oldCache);
        this.#oldCache = this.#cache;
        this.#cache = /* @__PURE__ */ new Map();
      }
    }
    #moveToRecent(key, item) {
      this.#oldCache.delete(key);
      this.#set(key, item);
    }
    *#entriesAscending() {
      for (const item of this.#oldCache) {
        const [key, value] = item;
        if (!this.#cache.has(key)) {
          const deleted = this.#deleteIfExpired(key, value);
          if (deleted === false) {
            yield item;
          }
        }
      }
      for (const item of this.#cache) {
        const [key, value] = item;
        const deleted = this.#deleteIfExpired(key, value);
        if (deleted === false) {
          yield item;
        }
      }
    }
    get(key) {
      if (this.#cache.has(key)) {
        const item = this.#cache.get(key);
        return this.#getItemValue(key, item);
      }
      if (this.#oldCache.has(key)) {
        const item = this.#oldCache.get(key);
        if (this.#deleteIfExpired(key, item) === false) {
          this.#moveToRecent(key, item);
          return item.value;
        }
      }
    }
    set(key, value, { maxAge = this.#maxAge } = {}) {
      const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
      if (this.#cache.has(key)) {
        this.#cache.set(key, {
          value,
          expiry
        });
      } else {
        this.#set(key, { value, expiry });
      }
      return this;
    }
    has(key) {
      if (this.#cache.has(key)) {
        return !this.#deleteIfExpired(key, this.#cache.get(key));
      }
      if (this.#oldCache.has(key)) {
        return !this.#deleteIfExpired(key, this.#oldCache.get(key));
      }
      return false;
    }
    peek(key) {
      if (this.#cache.has(key)) {
        return this.#peek(key, this.#cache);
      }
      if (this.#oldCache.has(key)) {
        return this.#peek(key, this.#oldCache);
      }
    }
    delete(key) {
      const deleted = this.#cache.delete(key);
      if (deleted) {
        this.#size--;
      }
      return this.#oldCache.delete(key) || deleted;
    }
    clear() {
      this.#cache.clear();
      this.#oldCache.clear();
      this.#size = 0;
    }
    resize(newSize) {
      if (!(newSize && newSize > 0)) {
        throw new TypeError("`maxSize` must be a number greater than 0");
      }
      const items = [...this.#entriesAscending()];
      const removeCount = items.length - newSize;
      if (removeCount < 0) {
        this.#cache = new Map(items);
        this.#oldCache = /* @__PURE__ */ new Map();
        this.#size = items.length;
      } else {
        if (removeCount > 0) {
          this.#emitEvictions(items.slice(0, removeCount));
        }
        this.#oldCache = new Map(items.slice(removeCount));
        this.#cache = /* @__PURE__ */ new Map();
        this.#size = 0;
      }
      this.#maxSize = newSize;
    }
    *keys() {
      for (const [key] of this) {
        yield key;
      }
    }
    *values() {
      for (const [, value] of this) {
        yield value;
      }
    }
    *[Symbol.iterator]() {
      for (const item of this.#cache) {
        const [key, value] = item;
        const deleted = this.#deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
      for (const item of this.#oldCache) {
        const [key, value] = item;
        if (!this.#cache.has(key)) {
          const deleted = this.#deleteIfExpired(key, value);
          if (deleted === false) {
            yield [key, value.value];
          }
        }
      }
    }
    *entriesDescending() {
      let items = [...this.#cache];
      for (let i = items.length - 1; i >= 0; --i) {
        const item = items[i];
        const [key, value] = item;
        const deleted = this.#deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
      items = [...this.#oldCache];
      for (let i = items.length - 1; i >= 0; --i) {
        const item = items[i];
        const [key, value] = item;
        if (!this.#cache.has(key)) {
          const deleted = this.#deleteIfExpired(key, value);
          if (deleted === false) {
            yield [key, value.value];
          }
        }
      }
    }
    *entriesAscending() {
      for (const [key, value] of this.#entriesAscending()) {
        yield [key, value.value];
      }
    }
    get size() {
      if (!this.#size) {
        return this.#oldCache.size;
      }
      let oldCacheSize = 0;
      for (const key of this.#oldCache.keys()) {
        if (!this.#cache.has(key)) {
          oldCacheSize++;
        }
      }
      return Math.min(this.#size + oldCacheSize, this.#maxSize);
    }
    get maxSize() {
      return this.#maxSize;
    }
    entries() {
      return this.entriesAscending();
    }
    forEach(callbackFunction, thisArgument = this) {
      for (const [key, value] of this.entriesAscending()) {
        callbackFunction.call(thisArgument, value, key, this);
      }
    }
    get [Symbol.toStringTag]() {
      return "QuickLRU";
    }
    toString() {
      return `QuickLRU(${this.size}/${this.maxSize})`;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.toString();
    }
  };

  // ../node_modules/dns-over-http-resolver/dist/src/utils.js
  function buildResource(serverResolver, hostname, recordType) {
    return `${serverResolver}?name=${hostname}&type=${recordType}`;
  }
  async function request(resource, signal) {
    const req = await fetch(resource, {
      headers: new Headers({
        accept: "application/dns-json"
      }),
      signal
    });
    const res = await req.json();
    return res;
  }
  function getCacheKey(hostname, recordType) {
    return `${recordType}_${hostname}`;
  }

  // ../node_modules/dns-over-http-resolver/dist/src/index.js
  var log24 = Object.assign(src_default4("dns-over-http-resolver"), {
    error: src_default4("dns-over-http-resolver:error")
  });
  var Resolver = class {
    _cache;
    _TXTcache;
    _servers;
    _request;
    _abortControllers;
    /**
     * @class
     * @param {object} [options]
     * @param {number} [options.maxCache = 100] - maximum number of cached dns records
     * @param {Request} [options.request] - function to return DNSJSON
     */
    constructor(options = {}) {
      this._cache = new QuickLRU({ maxSize: options?.maxCache ?? 100 });
      this._TXTcache = new QuickLRU({ maxSize: options?.maxCache ?? 100 });
      this._servers = [
        "https://cloudflare-dns.com/dns-query",
        "https://dns.google/resolve"
      ];
      this._request = options.request ?? request;
      this._abortControllers = [];
    }
    /**
     * Cancel all outstanding DNS queries made by this resolver. Any outstanding
     * requests will be aborted and promises rejected.
     */
    cancel() {
      this._abortControllers.forEach((controller) => {
        controller.abort();
      });
    }
    /**
     * Get an array of the IP addresses currently configured for DNS resolution.
     * These addresses are formatted according to RFC 5952. It can include a custom port.
     */
    getServers() {
      return this._servers;
    }
    /**
     * Get a shuffled array of the IP addresses currently configured for DNS resolution.
     * These addresses are formatted according to RFC 5952. It can include a custom port.
     */
    _getShuffledServers() {
      const newServers = [...this._servers];
      for (let i = newServers.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * i);
        const temp = newServers[i];
        newServers[i] = newServers[j];
        newServers[j] = temp;
      }
      return newServers;
    }
    /**
     * Sets the IP address and port of servers to be used when performing DNS resolution.
     *
     * @param {string[]} servers - array of RFC 5952 formatted addresses.
     */
    setServers(servers) {
      this._servers = servers;
    }
    async resolve(hostname, rrType = "A") {
      switch (rrType) {
        case "A":
          return this.resolve4(hostname);
        case "AAAA":
          return this.resolve6(hostname);
        case "TXT":
          return this.resolveTxt(hostname);
        default:
          throw new Error(`${rrType} is not supported`);
      }
    }
    /**
     * Uses the DNS protocol to resolve the given host name into IPv4 addresses
     *
     * @param {string} hostname - host name to resolve
     */
    async resolve4(hostname) {
      const recordType = "A";
      const cached = this._cache.get(getCacheKey(hostname, recordType));
      if (cached != null) {
        return cached;
      }
      let aborted = false;
      for (const server of this._getShuffledServers()) {
        const controller = new AbortController();
        this._abortControllers.push(controller);
        try {
          const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
          const data = response.Answer.map((a) => a.data);
          const ttl = Math.min(...response.Answer.map((a) => a.TTL));
          this._cache.set(getCacheKey(hostname, recordType), data, { maxAge: ttl });
          return data;
        } catch (err) {
          if (controller.signal.aborted) {
            aborted = true;
          }
          log24.error(`${server} could not resolve ${hostname} record ${recordType}`);
        } finally {
          this._abortControllers = this._abortControllers.filter((c) => c !== controller);
        }
      }
      if (aborted) {
        throw Object.assign(new Error("queryA ECANCELLED"), {
          code: "ECANCELLED"
        });
      }
      throw new Error(`Could not resolve ${hostname} record ${recordType}`);
    }
    /**
     * Uses the DNS protocol to resolve the given host name into IPv6 addresses
     *
     * @param {string} hostname - host name to resolve
     */
    async resolve6(hostname) {
      const recordType = "AAAA";
      const cached = this._cache.get(getCacheKey(hostname, recordType));
      if (cached != null) {
        return cached;
      }
      let aborted = false;
      for (const server of this._getShuffledServers()) {
        const controller = new AbortController();
        this._abortControllers.push(controller);
        try {
          const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
          const data = response.Answer.map((a) => a.data);
          const ttl = Math.min(...response.Answer.map((a) => a.TTL));
          this._cache.set(getCacheKey(hostname, recordType), data, { maxAge: ttl });
          return data;
        } catch (err) {
          if (controller.signal.aborted) {
            aborted = true;
          }
          log24.error(`${server} could not resolve ${hostname} record ${recordType}`);
        } finally {
          this._abortControllers = this._abortControllers.filter((c) => c !== controller);
        }
      }
      if (aborted) {
        throw Object.assign(new Error("queryAaaa ECANCELLED"), {
          code: "ECANCELLED"
        });
      }
      throw new Error(`Could not resolve ${hostname} record ${recordType}`);
    }
    /**
     * Uses the DNS protocol to resolve the given host name into a Text record
     *
     * @param {string} hostname - host name to resolve
     */
    async resolveTxt(hostname) {
      const recordType = "TXT";
      const cached = this._TXTcache.get(getCacheKey(hostname, recordType));
      if (cached != null) {
        return cached;
      }
      let aborted = false;
      for (const server of this._getShuffledServers()) {
        const controller = new AbortController();
        this._abortControllers.push(controller);
        try {
          const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
          const data = response.Answer.map((a) => [a.data.replace(/['"]+/g, "")]);
          const ttl = Math.min(...response.Answer.map((a) => a.TTL));
          this._TXTcache.set(getCacheKey(hostname, recordType), data, { maxAge: ttl });
          return data;
        } catch (err) {
          if (controller.signal.aborted) {
            aborted = true;
          }
          log24.error(`${server} could not resolve ${hostname} record ${recordType}`);
        } finally {
          this._abortControllers = this._abortControllers.filter((c) => c !== controller);
        }
      }
      if (aborted) {
        throw Object.assign(new Error("queryTxt ECANCELLED"), {
          code: "ECANCELLED"
        });
      }
      throw new Error(`Could not resolve ${hostname} record ${recordType}`);
    }
    clearCache() {
      this._cache.clear();
      this._TXTcache.clear();
    }
  };
  var src_default9 = Resolver;

  // ../node_modules/@waku/discovery/dist/dns/dns_over_https.js
  var log25 = new Logger("dns-over-https");
  var DnsOverHttps = class _DnsOverHttps {
    resolver;
    /**
     * Create new Dns-Over-Http DNS client.
     *
     * @throws {code: string} If DNS query fails.
     */
    static async create() {
      return new _DnsOverHttps();
    }
    constructor(resolver = new src_default9()) {
      this.resolver = resolver;
    }
    /**
     * Resolves a TXT record
     *
     * @param domain The domain name
     *
     * @throws if the query fails
     */
    async resolveTXT(domain) {
      let answers;
      try {
        answers = await this.resolver.resolveTxt(domain);
      } catch (error) {
        log25.error("query failed: ", error);
        throw new Error("DNS query failed");
      }
      if (!answers)
        throw new Error(`Could not resolve ${domain}`);
      const result = [];
      answers.forEach((d2) => {
        if (typeof d2 === "string") {
          result.push(d2);
        } else if (Array.isArray(d2)) {
          d2.forEach((sd) => {
            if (typeof sd === "string") {
              result.push(sd);
            } else {
              result.push(bytesToUtf8(sd));
            }
          });
        } else {
          result.push(bytesToUtf8(d2));
        }
      });
      return result;
    }
  };

  // ../node_modules/@waku/discovery/dist/dns/enrtree.js
  var import_hi_base32 = __toESM(require_base32(), 1);

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports17 = {};
  __export(base10_exports17, {
    base10: () => base1017
  });

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/bytes.js
  var empty21 = new Uint8Array(0);
  function equals47(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce21(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function fromString32(str) {
    return new TextEncoder().encode(str);
  }
  function toString28(b) {
    return new TextDecoder().decode(b);
  }

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/vendor/base-x.js
  function base35(ALPHABET, name19) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode79(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length21 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length21) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        pbegin++;
      }
      var it2 = size - length21;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length21 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length21) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length21 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length21;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode99(string19) {
      var buffer = decodeUnsafe(string19);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name19} character`);
    }
    return {
      encode: encode79,
      decodeUnsafe,
      decode: decode99
    };
  }
  var src21 = base35;
  var _brrp__multiformats_scope_baseX21 = src21;
  var base_x_default21 = _brrp__multiformats_scope_baseX21;

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/bases/base.js
  var Encoder23 = class {
    name;
    prefix;
    baseEncode;
    constructor(name19, prefix, baseEncode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder23 = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name19, prefix, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or23(this, decoder);
    }
  };
  var ComposedDecoder21 = class {
    decoders;
    constructor(decoders4) {
      this.decoders = decoders4;
    }
    or(decoder) {
      return or23(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or23(left, right) {
    return new ComposedDecoder21({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec21 = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name19, prefix, baseEncode, baseDecode) {
      this.name = name19;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder23(name19, prefix, baseEncode);
      this.decoder = new Decoder23(name19, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from37({ name: name19, prefix, encode: encode79, decode: decode99 }) {
    return new Codec21(name19, prefix, encode79, decode99);
  }
  function baseX21({ name: name19, prefix, alphabet: alphabet18 }) {
    const { encode: encode79, decode: decode99 } = base_x_default21(alphabet18, name19);
    return from37({
      prefix,
      name: name19,
      encode: encode79,
      decode: (text) => coerce21(decode99(text))
    });
  }
  function decode94(string19, alphabetIdx, bitsPerChar, name19) {
    let end = string19.length;
    while (string19[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string19[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name19} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode75(data, alphabet18, bitsPerChar) {
    const pad = alphabet18[alphabet18.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet18[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet18[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx20(alphabet18) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet18.length; ++i) {
      alphabetIdx[alphabet18[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc464820({ name: name19, prefix, bitsPerChar, alphabet: alphabet18 }) {
    const alphabetIdx = createAlphabetIdx20(alphabet18);
    return from37({
      prefix,
      name: name19,
      encode(input) {
        return encode75(input, alphabet18, bitsPerChar);
      },
      decode(input) {
        return decode94(input, alphabetIdx, bitsPerChar, name19);
      }
    });
  }

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/bases/base10.js
  var base1017 = baseX21({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports17 = {};
  __export(base16_exports17, {
    base16: () => base1617,
    base16upper: () => base16upper17
  });
  var base1617 = rfc464820({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper17 = rfc464820({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports17 = {};
  __export(base2_exports17, {
    base2: () => base217
  });
  var base217 = rfc464820({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports17 = {};
  __export(base256emoji_exports17, {
    base256emoji: () => base256emoji17
  });
  var alphabet17 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars17 = alphabet17.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes17 = alphabet17.reduce((p, c, i) => {
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
  }, []);
  function encode76(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars17[c];
      return p;
    }, "");
  }
  function decode95(str) {
    const byts = [];
    for (const char of str) {
      const codePoint = char.codePointAt(0);
      if (codePoint == null) {
        throw new Error(`Invalid character: ${char}`);
      }
      const byt = alphabetCharsToBytes17[codePoint];
      if (byt == null) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji17 = from37({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode76,
    decode: decode95
  });

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports17 = {};
  __export(base32_exports17, {
    base32: () => base3219,
    base32hex: () => base32hex19,
    base32hexpad: () => base32hexpad19,
    base32hexpadupper: () => base32hexpadupper19,
    base32hexupper: () => base32hexupper19,
    base32pad: () => base32pad19,
    base32padupper: () => base32padupper19,
    base32upper: () => base32upper19,
    base32z: () => base32z19
  });
  var base3219 = rfc464820({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper19 = rfc464820({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad19 = rfc464820({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper19 = rfc464820({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex19 = rfc464820({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper19 = rfc464820({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad19 = rfc464820({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper19 = rfc464820({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z19 = rfc464820({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports17 = {};
  __export(base36_exports17, {
    base36: () => base3618,
    base36upper: () => base36upper18
  });
  var base3618 = baseX21({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper18 = baseX21({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports17 = {};
  __export(base58_exports17, {
    base58btc: () => base58btc21,
    base58flickr: () => base58flickr21
  });
  var base58btc21 = baseX21({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr21 = baseX21({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports17 = {};
  __export(base64_exports17, {
    base64: () => base6419,
    base64pad: () => base64pad19,
    base64url: () => base64url19,
    base64urlpad: () => base64urlpad19
  });
  var base6419 = rfc464820({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad19 = rfc464820({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url19 = rfc464820({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad19 = rfc464820({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports17 = {};
  __export(base8_exports17, {
    base8: () => base817
  });
  var base817 = rfc464820({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports33 = {};
  __export(identity_exports33, {
    identity: () => identity33
  });
  var identity33 = from37({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString28(buf),
    decode: (str) => fromString32(str)
  });

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/codecs/json.js
  var textEncoder17 = new TextEncoder();
  var textDecoder17 = new TextDecoder();

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports34 = {};
  __export(identity_exports34, {
    identity: () => identity34
  });

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_119 = encode77;
  var MSB21 = 128;
  var REST21 = 127;
  var MSBALL19 = ~REST21;
  var INT19 = Math.pow(2, 31);
  function encode77(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT19) {
      out[offset++] = num & 255 | MSB21;
      num /= 128;
    }
    while (num & MSBALL19) {
      out[offset++] = num & 255 | MSB21;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode77.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode96 = read21;
  var MSB$119 = 128;
  var REST$119 = 127;
  function read21(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read21.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$119) << shift : (b & REST$119) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$119);
    read21.bytes = counter - offset;
    return res;
  }
  var N120 = Math.pow(2, 7);
  var N220 = Math.pow(2, 14);
  var N320 = Math.pow(2, 21);
  var N420 = Math.pow(2, 28);
  var N520 = Math.pow(2, 35);
  var N620 = Math.pow(2, 42);
  var N720 = Math.pow(2, 49);
  var N819 = Math.pow(2, 56);
  var N919 = Math.pow(2, 63);
  var length20 = function(value) {
    return value < N120 ? 1 : value < N220 ? 2 : value < N320 ? 3 : value < N420 ? 4 : value < N520 ? 5 : value < N620 ? 6 : value < N720 ? 7 : value < N819 ? 8 : value < N919 ? 9 : 10;
  };
  var varint19 = {
    encode: encode_119,
    decode: decode96,
    encodingLength: length20
  };
  var _brrp_varint19 = varint19;
  var varint_default19 = _brrp_varint19;

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/varint.js
  function decode97(data, offset = 0) {
    const code18 = varint_default19.decode(data, offset);
    return [code18, varint_default19.decode.bytes];
  }
  function encodeTo19(int, target, offset = 0) {
    varint_default19.encode(int, target, offset);
    return target;
  }
  function encodingLength20(int) {
    return varint_default19.encodingLength(int);
  }

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/hashes/digest.js
  function create18(code18, digest18) {
    const size = digest18.byteLength;
    const sizeOffset = encodingLength20(code18);
    const digestOffset = sizeOffset + encodingLength20(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo19(code18, bytes2, 0);
    encodeTo19(size, bytes2, sizeOffset);
    bytes2.set(digest18, digestOffset);
    return new Digest19(code18, size, digest18, bytes2);
  }
  function decode98(multihash) {
    const bytes2 = coerce21(multihash);
    const [code18, sizeOffset] = decode97(bytes2);
    const [size, digestOffset] = decode97(bytes2.subarray(sizeOffset));
    const digest18 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest18.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest19(code18, size, digest18, bytes2);
  }
  function equals48(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals47(a.bytes, data.bytes);
    }
  }
  var Digest19 = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code18, size, digest18, bytes2) {
      this.code = code18;
      this.size = size;
      this.digest = digest18;
      this.bytes = bytes2;
    }
  };

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/hashes/identity.js
  var code17 = 0;
  var name18 = "identity";
  var encode78 = coerce21;
  function digest17(input, options) {
    if (options?.truncate != null && options.truncate !== input.byteLength) {
      if (options.truncate < 0 || options.truncate > input.byteLength) {
        throw new Error(`Invalid truncate option, must be less than or equal to ${input.byteLength}`);
      }
      input = input.subarray(0, options.truncate);
    }
    return create18(code17, encode78(input));
  }
  var identity34 = { code: code17, name: name18, encode: encode78, digest: digest17 };

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports17 = {};
  __export(sha2_browser_exports17, {
    sha256: () => sha25622,
    sha512: () => sha51220
  });

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/hashes/hasher.js
  var DEFAULT_MIN_DIGEST_LENGTH3 = 20;
  function from38({ name: name19, code: code18, encode: encode79, minDigestLength, maxDigestLength }) {
    return new Hasher17(name19, code18, encode79, minDigestLength, maxDigestLength);
  }
  var Hasher17 = class {
    name;
    code;
    encode;
    minDigestLength;
    maxDigestLength;
    constructor(name19, code18, encode79, minDigestLength, maxDigestLength) {
      this.name = name19;
      this.code = code18;
      this.encode = encode79;
      this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH3;
      this.maxDigestLength = maxDigestLength;
    }
    digest(input, options) {
      if (options?.truncate != null) {
        if (options.truncate < this.minDigestLength) {
          throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);
        }
        if (this.maxDigestLength != null && options.truncate > this.maxDigestLength) {
          throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`);
        }
      }
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        if (result instanceof Uint8Array) {
          return createDigest3(result, this.code, options?.truncate);
        }
        return result.then((digest18) => createDigest3(digest18, this.code, options?.truncate));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  function createDigest3(digest18, code18, truncate) {
    if (truncate != null && truncate !== digest18.byteLength) {
      if (truncate > digest18.byteLength) {
        throw new Error(`Invalid truncate option, must be less than or equal to ${digest18.byteLength}`);
      }
      digest18 = digest18.subarray(0, truncate);
    }
    return create18(code18, digest18);
  }

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/hashes/sha2-browser.js
  function sha17(name19) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name19, data));
  }
  var sha25622 = from38({
    name: "sha2-256",
    code: 18,
    encode: sha17("SHA-256")
  });
  var sha51220 = from38({
    name: "sha2-512",
    code: 19,
    encode: sha17("SHA-512")
  });

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/cid.js
  function format18(link, base37) {
    const { bytes: bytes2, version: version5 } = link;
    switch (version5) {
      case 0:
        return toStringV018(bytes2, baseCache18(link), base37 ?? base58btc21.encoder);
      default:
        return toStringV118(bytes2, baseCache18(link), base37 ?? base3219.encoder);
    }
  }
  var cache19 = /* @__PURE__ */ new WeakMap();
  function baseCache18(cid) {
    const baseCache19 = cache19.get(cid);
    if (baseCache19 == null) {
      const baseCache20 = /* @__PURE__ */ new Map();
      cache19.set(cid, baseCache20);
      return baseCache20;
    }
    return baseCache19;
  }
  var CID18 = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version5, code18, multihash, bytes2) {
      this.code = code18;
      this.version = version5;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code18, multihash } = this;
          if (code18 !== DAG_PB_CODE18) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE18) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code18, digest: digest18 } = this.multihash;
          const multihash = create18(code18, digest18);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals48(self2.multihash, unknown.multihash);
    }
    toString(base37) {
      return format18(this, base37);
    }
    toJSON() {
      return { "/": format18(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version5, code: code18, multihash, bytes: bytes2 } = value;
        return new _CID(version5, code18, multihash, bytes2 ?? encodeCID18(version5, code18, multihash.bytes));
      } else if (value[cidSymbol18] === true) {
        const { version: version5, multihash, code: code18 } = value;
        const digest18 = decode98(multihash);
        return _CID.create(version5, code18, digest18);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version5, code18, digest18) {
      if (typeof code18 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest18.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version5) {
        case 0: {
          if (code18 !== DAG_PB_CODE18) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE18}) block encoding`);
          } else {
            return new _CID(version5, code18, digest18, digest18.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID18(version5, code18, digest18.bytes);
          return new _CID(version5, code18, digest18, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest18) {
      return _CID.create(0, DAG_PB_CODE18, digest18);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code18, digest18) {
      return _CID.create(1, code18, digest18);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes2) {
      const [cid, remainder] = _CID.decodeFirst(bytes2);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes2) {
      const specs = _CID.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce21(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest18 = new Digest19(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest18) : _CID.createV1(specs.codec, digest18);
      return [cid, bytes2.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length21] = decode97(initialBytes.subarray(offset));
        offset += length21;
        return i;
      };
      let version5 = next();
      let codec = DAG_PB_CODE18;
      if (version5 === 18) {
        version5 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version5 !== 0 && version5 !== 1) {
        throw new RangeError(`Invalid CID version ${version5}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version5, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base37) {
      const [prefix, bytes2] = parseCIDtoBytes18(source, base37);
      const cid = _CID.decode(bytes2);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache18(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes18(source, base37) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base37 ?? base58btc21;
        return [
          base58btc21.prefix,
          decoder.decode(`${base58btc21.prefix}${source}`)
        ];
      }
      case base58btc21.prefix: {
        const decoder = base37 ?? base58btc21;
        return [base58btc21.prefix, decoder.decode(source)];
      }
      case base3219.prefix: {
        const decoder = base37 ?? base3219;
        return [base3219.prefix, decoder.decode(source)];
      }
      case base3618.prefix: {
        const decoder = base37 ?? base3618;
        return [base3618.prefix, decoder.decode(source)];
      }
      default: {
        if (base37 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base37.decode(source)];
      }
    }
  }
  function toStringV018(bytes2, cache20, base37) {
    const { prefix } = base37;
    if (prefix !== base58btc21.prefix) {
      throw Error(`Cannot string encode V0 in ${base37.name} encoding`);
    }
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2).slice(1);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV118(bytes2, cache20, base37) {
    const { prefix } = base37;
    const cid = cache20.get(prefix);
    if (cid == null) {
      const cid2 = base37.encode(bytes2);
      cache20.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE18 = 112;
  var SHA_256_CODE18 = 18;
  function encodeCID18(version5, code18, multihash) {
    const codeOffset = encodingLength20(version5);
    const hashOffset = codeOffset + encodingLength20(code18);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo19(version5, bytes2, 0);
    encodeTo19(code18, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  }
  var cidSymbol18 = Symbol.for("@ipld/js-cid/CID");

  // ../node_modules/@waku/discovery/node_modules/multiformats/dist/src/basics.js
  var bases17 = { ...identity_exports33, ...base2_exports17, ...base8_exports17, ...base10_exports17, ...base16_exports17, ...base32_exports17, ...base36_exports17, ...base58_exports17, ...base64_exports17, ...base256emoji_exports17 };
  var hashes17 = { ...sha2_browser_exports17, ...identity_exports34 };

  // ../node_modules/@waku/discovery/node_modules/uint8arrays/dist/src/alloc.js
  function allocUnsafe21(size = 0) {
    return new Uint8Array(size);
  }

  // ../node_modules/@waku/discovery/node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec18(name19, prefix, encode79, decode99) {
    return {
      name: name19,
      prefix,
      encoder: {
        name: name19,
        prefix,
        encode: encode79
      },
      decoder: {
        decode: decode99
      }
    };
  }
  var string18 = createCodec18("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder3 = new TextEncoder();
    return encoder3.encode(str.substring(1));
  });
  var ascii17 = createCodec18("ascii", "a", (buf) => {
    let string19 = "a";
    for (let i = 0; i < buf.length; i++) {
      string19 += String.fromCharCode(buf[i]);
    }
    return string19;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe21(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  var BASES17 = {
    utf8: string18,
    "utf-8": string18,
    hex: bases17.base16,
    latin1: ascii17,
    ascii: ascii17,
    binary: ascii17,
    ...bases17
  };
  var bases_default17 = BASES17;

  // ../node_modules/@waku/discovery/node_modules/uint8arrays/dist/src/from-string.js
  function fromString33(string19, encoding = "utf8") {
    const base37 = bases_default17[encoding];
    if (base37 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base37.decoder.decode(`${base37.prefix}${string19}`);
  }

  // ../node_modules/@waku/discovery/dist/dns/enrtree.js
  var ENRTree = class _ENRTree {
    static RECORD_PREFIX = ENR.RECORD_PREFIX;
    static TREE_PREFIX = "enrtree:";
    static BRANCH_PREFIX = "enrtree-branch:";
    static ROOT_PREFIX = "enrtree-root:";
    /**
     * Extracts the branch subdomain referenced by a DNS tree root string after verifying
     * the root record signature with its base32 compressed public key.
     */
    static parseAndVerifyRoot(root, publicKey) {
      if (!root.startsWith(this.ROOT_PREFIX))
        throw new Error(`ENRTree root entry must start with '${this.ROOT_PREFIX}'`);
      const rootValues = _ENRTree.parseRootValues(root);
      const decodedPublicKey = import_hi_base32.default.decode.asBytes(publicKey);
      const signedComponent = root.split(" sig")[0];
      const signedComponentBuffer = utf8ToBytes2(signedComponent);
      const signatureBuffer = fromString33(rootValues.signature, "base64url").slice(0, 64);
      const isVerified = verifySignature(signatureBuffer, keccak256(signedComponentBuffer), new Uint8Array(decodedPublicKey));
      if (!isVerified)
        throw new Error("Unable to verify ENRTree root signature");
      return rootValues.eRoot;
    }
    static parseRootValues(txt) {
      const matches = txt.match(/^enrtree-root:v1 e=([^ ]+) l=([^ ]+) seq=(\d+) sig=([^ ]+)$/);
      if (!Array.isArray(matches))
        throw new Error("Could not parse ENRTree root entry");
      matches.shift();
      const [eRoot, lRoot, seq, signature] = matches;
      if (!eRoot)
        throw new Error("Could not parse 'e' value from ENRTree root entry");
      if (!lRoot)
        throw new Error("Could not parse 'l' value from ENRTree root entry");
      if (!seq)
        throw new Error("Could not parse 'seq' value from ENRTree root entry");
      if (!signature)
        throw new Error("Could not parse 'sig' value from ENRTree root entry");
      return { eRoot, lRoot, seq: Number(seq), signature };
    }
    /**
     * Returns the public key and top level domain of an ENR tree entry.
     * The domain is the starting point for traversing a set of linked DNS TXT records
     * and the public key is used to verify the root entry record
     */
    static parseTree(tree) {
      if (!tree.startsWith(this.TREE_PREFIX))
        throw new Error(`ENRTree tree entry must start with '${this.TREE_PREFIX}'`);
      const matches = tree.match(/^enrtree:\/\/([^@]+)@(.+)$/);
      if (!Array.isArray(matches))
        throw new Error("Could not parse ENRTree tree entry");
      matches.shift();
      const [publicKey, domain] = matches;
      if (!publicKey)
        throw new Error("Could not parse public key from ENRTree tree entry");
      if (!domain)
        throw new Error("Could not parse domain from ENRTree tree entry");
      return { publicKey, domain };
    }
    /**
     * Returns subdomains listed in an ENR branch entry. These in turn lead to
     * either further branch entries or ENR records.
     */
    static parseBranch(branch) {
      if (!branch.startsWith(this.BRANCH_PREFIX))
        throw new Error(`ENRTree branch entry must start with '${this.BRANCH_PREFIX}'`);
      return branch.split(this.BRANCH_PREFIX)[1].split(",");
    }
  };

  // ../node_modules/@waku/discovery/dist/dns/fetch_nodes.js
  var log26 = new Logger("discovery:fetch_nodes");
  async function* fetchNodes(getNode, maxGet = 10, maxErrors = 3) {
    const peerNodeIds = /* @__PURE__ */ new Set();
    let totalSearches = 0;
    let erroneousSearches = 0;
    while (totalSearches < maxGet && erroneousSearches < maxErrors) {
      totalSearches++;
      const peer = await getNode();
      if (!peer || !peer.nodeId) {
        erroneousSearches++;
        continue;
      }
      if (!peerNodeIds.has(peer.nodeId)) {
        peerNodeIds.add(peer.nodeId);
        if (peer.waku2) {
          yield peer;
        }
        log26.info(`got new peer candidate from DNS address=${peer.nodeId}@${peer.ip}`);
      }
    }
  }

  // ../node_modules/@waku/discovery/dist/dns/dns.js
  var log27 = new Logger("discovery:dns");
  var DnsNodeDiscovery = class _DnsNodeDiscovery {
    dns;
    _DNSTreeCache;
    static async dnsOverHttp(dnsClient) {
      if (!dnsClient) {
        dnsClient = await DnsOverHttps.create();
      }
      return new _DnsNodeDiscovery(dnsClient);
    }
    constructor(dns2) {
      this._DNSTreeCache = {};
      this.dns = dns2;
    }
    /**
     * Retrieve the next peers from the passed [[enrTreeUrls]],
     */
    async *getNextPeer(enrTreeUrls) {
      for (const enrTreeUrl of shuffle(enrTreeUrls)) {
        const { publicKey, domain } = ENRTree.parseTree(enrTreeUrl);
        const context = {
          domain,
          publicKey,
          visits: {}
        };
        for await (const peer of fetchNodes(() => this._search(domain, context))) {
          yield peer;
        }
      }
    }
    /**
     * Runs a recursive, randomized descent of the DNS tree to retrieve a single
     * ENR record as an ENR. Returns null if parsing or DNS resolution fails.
     */
    async _search(subdomain, context) {
      try {
        const entry = await this._getTXTRecord(subdomain, context);
        context.visits[subdomain] = true;
        let next;
        let branches;
        const entryType = getEntryType(entry);
        try {
          switch (entryType) {
            case ENRTree.ROOT_PREFIX:
              next = ENRTree.parseAndVerifyRoot(entry, context.publicKey);
              return await this._search(next, context);
            case ENRTree.BRANCH_PREFIX:
              branches = ENRTree.parseBranch(entry);
              next = selectRandomPath(branches, context);
              return await this._search(next, context);
            case ENRTree.RECORD_PREFIX:
              return EnrDecoder.fromString(entry);
            default:
              return null;
          }
        } catch (error) {
          log27.error(`Failed to search DNS tree ${entryType} at subdomain ${subdomain}: ${error}`);
          return null;
        }
      } catch (error) {
        log27.error(`Failed to retrieve TXT record at subdomain ${subdomain}: ${error}`);
        return null;
      }
    }
    /**
     * Retrieves the TXT record stored at a location from either
     * this DNS tree cache or via DNS query.
     *
     * @throws if the TXT Record contains non-UTF-8 values.
     */
    async _getTXTRecord(subdomain, context) {
      if (this._DNSTreeCache[subdomain]) {
        return this._DNSTreeCache[subdomain];
      }
      const location = subdomain !== context.domain ? `${subdomain}.${context.domain}` : context.domain;
      const response = await this.dns.resolveTXT(location);
      if (!response.length)
        throw new Error("Received empty result array while fetching TXT record");
      if (!response[0].length)
        throw new Error("Received empty TXT record");
      const result = response.join("");
      this._DNSTreeCache[subdomain] = result;
      return result;
    }
  };
  function getEntryType(entry) {
    if (entry.startsWith(ENRTree.ROOT_PREFIX))
      return ENRTree.ROOT_PREFIX;
    if (entry.startsWith(ENRTree.BRANCH_PREFIX))
      return ENRTree.BRANCH_PREFIX;
    if (entry.startsWith(ENRTree.RECORD_PREFIX))
      return ENRTree.RECORD_PREFIX;
    return "";
  }
  function selectRandomPath(branches, context) {
    const circularRefs = {};
    for (const [idx, subdomain] of branches.entries()) {
      if (context.visits[subdomain]) {
        circularRefs[idx] = true;
      }
    }
    if (Object.keys(circularRefs).length === branches.length) {
      throw new Error("Unresolvable circular path detected");
    }
    let index;
    do {
      index = Math.floor(Math.random() * branches.length);
    } while (circularRefs[index]);
    return branches[index];
  }

  // ../node_modules/@waku/discovery/dist/dns/dns_discovery.js
  var log28 = new Logger("peer-discovery-dns");
  var PeerDiscoveryDns = class extends TypedEventEmitter {
    nextPeer;
    _started;
    _components;
    _options;
    constructor(components, options) {
      super();
      this._started = false;
      this._components = components;
      this._options = options;
      const { enrUrls } = options;
      log28.info("Use following EIP-1459 ENR Tree URLs: ", enrUrls);
    }
    /**
     * Start discovery process
     */
    async start() {
      log28.info("Starting peer discovery via dns");
      this._started = true;
      await this.findPeers();
    }
    async findPeers() {
      if (!this.nextPeer) {
        let { enrUrls } = this._options;
        if (!Array.isArray(enrUrls))
          enrUrls = [enrUrls];
        const dns2 = await DnsNodeDiscovery.dnsOverHttp();
        this.nextPeer = dns2.getNextPeer.bind(dns2, enrUrls);
      }
      for await (const peerEnr of this.nextPeer()) {
        if (!this._started) {
          return;
        }
        const { peerInfo, shardInfo } = peerEnr;
        if (!peerInfo) {
          continue;
        }
        const tagsToUpdate = {
          [DEFAULT_BOOTSTRAP_TAG_NAME2]: {
            value: this._options.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE2,
            ttl: this._options.tagTTL ?? DEFAULT_BOOTSTRAP_TAG_TTL
          }
        };
        let isPeerChanged = false;
        const isPeerAlreadyInPeerStore = await this._components.peerStore.has(peerInfo.id);
        if (isPeerAlreadyInPeerStore) {
          const peer = await this._components.peerStore.get(peerInfo.id);
          const hasBootstrapTag = peer.tags.has(DEFAULT_BOOTSTRAP_TAG_NAME2);
          if (!hasBootstrapTag) {
            isPeerChanged = true;
            await this._components.peerStore.merge(peerInfo.id, {
              tags: tagsToUpdate
            });
          }
        } else {
          isPeerChanged = true;
          await this._components.peerStore.save(peerInfo.id, {
            tags: tagsToUpdate,
            ...shardInfo && {
              metadata: {
                shardInfo: encodeRelayShard(shardInfo)
              }
            }
          });
        }
        if (isPeerChanged) {
          this.dispatchEvent(new CustomEvent("peer", { detail: peerInfo }));
        }
      }
    }
    /**
     * Stop emitting events
     */
    stop() {
      this._started = false;
    }
    get [peerDiscoverySymbol]() {
      return true;
    }
    get [Symbol.toStringTag]() {
      return DNS_DISCOVERY_TAG;
    }
  };
  function wakuDnsDiscovery(enrUrls) {
    return (components) => new PeerDiscoveryDns(components, { enrUrls });
  }

  // ../node_modules/@waku/discovery/dist/peer-exchange/constants.js
  var DEFAULT_PEER_EXCHANGE_REQUEST_NODES = 60;
  var DEFAULT_PEER_EXCHANGE_TAG_NAME = Tags.PEER_EXCHANGE;
  var DEFAULT_PEER_EXCHANGE_TAG_VALUE = 50;
  var DEFAULT_PEER_EXCHANGE_TAG_TTL = 3e4;
  var PeerExchangeCodec = "/vac/waku/peer-exchange/2.0.0-alpha1";

  // ../node_modules/@waku/discovery/dist/peer-exchange/rpc.js
  var PeerExchangeRPC2 = class _PeerExchangeRPC {
    proto;
    constructor(proto) {
      this.proto = proto;
    }
    static createRequest(params) {
      const { numPeers } = params;
      return new _PeerExchangeRPC({
        query: {
          numPeers
        },
        response: void 0
      });
    }
    /**
     * Encode the current PeerExchangeRPC request to bytes
     * @returns Uint8Array
     */
    encode() {
      return peer_exchange_exports.PeerExchangeRPC.encode(this.proto);
    }
    /**
     * Decode the current PeerExchangeRPC request to bytes
     * @returns Uint8Array
     */
    static decode(bytes2) {
      const res = peer_exchange_exports.PeerExchangeRPC.decode(bytes2);
      return new _PeerExchangeRPC(res);
    }
    get query() {
      return this.proto.query;
    }
    get response() {
      return this.proto.response;
    }
  };

  // ../node_modules/@waku/discovery/dist/peer-exchange/peer_exchange.js
  var log29 = new Logger("peer-exchange");
  var PeerExchange = class {
    components;
    streamManager;
    /**
     * @param components - libp2p components
     */
    constructor(components) {
      this.components = components;
      this.streamManager = new StreamManager(PeerExchangeCodec, components);
    }
    /**
     * Make a peer exchange query to a peer
     */
    async query(params) {
      const { numPeers, peerId: peerId2 } = params;
      const rpcQuery = PeerExchangeRPC2.createRequest({
        numPeers: BigInt(numPeers)
      });
      const hasPeer = await this.components.peerStore.has(peerId2);
      if (!hasPeer) {
        return {
          peerInfos: null,
          error: ProtocolError.NO_PEER_AVAILABLE
        };
      }
      const stream = await this.streamManager.getStream(peerId2);
      if (!stream) {
        log29.error(`Failed to get a stream for remote peer:${peerId2?.toString?.()}`);
        return {
          peerInfos: null,
          error: ProtocolError.NO_STREAM_AVAILABLE
        };
      }
      const res = await pipe([rpcQuery.encode()], encode23, stream, decode28, async (source) => await src_default(source));
      try {
        const bytes2 = new Uint8ArrayList();
        res.forEach((chunk) => {
          bytes2.append(chunk);
        });
        const { response } = PeerExchangeRPC2.decode(bytes2);
        if (!response) {
          log29.error("PeerExchangeRPC message did not contains a `response` field");
          return {
            peerInfos: null,
            error: ProtocolError.EMPTY_PAYLOAD
          };
        }
        const peerInfos = await Promise.all(response.peerInfos.map((peerInfo) => peerInfo.enr).filter(isDefined).map(async (enr) => {
          return { ENR: await EnrDecoder.fromRLP(enr) };
        }));
        return {
          peerInfos,
          error: null
        };
      } catch (err) {
        log29.error("Failed to decode push reply", err);
        return {
          peerInfos: null,
          error: ProtocolError.DECODE_FAILED
        };
      }
    }
  };

  // ../node_modules/@waku/discovery/dist/peer-exchange/peer_exchange_discovery.js
  var log30 = new Logger("peer-exchange-discovery");
  var PeerExchangeDiscovery = class extends TypedEventEmitter {
    components;
    peerExchange;
    options;
    isStarted = false;
    queryingPeers = /* @__PURE__ */ new Set();
    peerExpirationRecords = /* @__PURE__ */ new Map();
    continuousDiscoveryInterval = null;
    constructor(components, options = {}) {
      super();
      this.components = components;
      this.peerExchange = new PeerExchange(components);
      this.options = {
        ...options,
        TTL: options.TTL ?? DEFAULT_PEER_EXCHANGE_TAG_TTL
      };
      this.handleDiscoveredPeer = this.handleDiscoveredPeer.bind(this);
    }
    /**
     * Start Peer Exchange.
     * Subscribe to "peer:identify" events and handle them.
     */
    start() {
      if (this.isStarted) {
        return;
      }
      log30.info("Starting peer exchange node discovery, discovering peers");
      this.isStarted = true;
      this.components.events.addEventListener("peer:identify", this.handleDiscoveredPeer);
      this.continuousDiscoveryInterval = setInterval(() => {
        void this.handlePeriodicDiscovery();
      }, this.options.TTL);
    }
    /**
     * Stop Peer Exchange.
     * Unsubscribe from "peer:identify" events.
     */
    stop() {
      if (!this.isStarted) {
        return;
      }
      log30.info("Stopping peer exchange node discovery");
      this.isStarted = false;
      this.queryingPeers.clear();
      this.peerExpirationRecords.clear();
      if (this.continuousDiscoveryInterval) {
        clearInterval(this.continuousDiscoveryInterval);
      }
      this.components.events.removeEventListener("peer:identify", this.handleDiscoveredPeer);
    }
    get [peerDiscoverySymbol]() {
      return true;
    }
    get [Symbol.toStringTag]() {
      return "@waku/peer-exchange";
    }
    async handleDiscoveredPeer(event) {
      void this.runQuery(event.detail.peerId, event.detail.protocols);
    }
    async handlePeriodicDiscovery() {
      const connections = this.components.connectionManager.getConnections();
      await Promise.all(connections.map(async (connection) => {
        try {
          const peerIdStr = connection.remotePeer.toString();
          const shouldQuery = this.peerExpirationRecords.has(peerIdStr) ? this.peerExpirationRecords.get(peerIdStr) <= Date.now() : true;
          if (!shouldQuery) {
            return null;
          }
          const peer = await this.components.peerStore.get(connection.remotePeer);
          return this.runQuery(connection.remotePeer, peer.protocols);
        } catch (error) {
          log30.warn("Error getting peer info", error);
          return null;
        }
      }));
    }
    async runQuery(peerId2, protocols2) {
      if (!protocols2.includes(PeerExchangeCodec) || this.queryingPeers.has(peerId2.toString())) {
        log30.info(`Skipping peer ${peerId2} as it is already querying or does not support peer exchange`);
        return;
      }
      try {
        this.queryingPeers.add(peerId2.toString());
        await this.query(peerId2);
      } catch (error) {
        log30.error("Error querying peer", error);
      }
      this.peerExpirationRecords.set(peerId2.toString(), Date.now() + this.options.TTL);
      this.queryingPeers.delete(peerId2.toString());
    }
    async query(peerId2) {
      const peerIdStr = peerId2.toString();
      log30.info(`Querying peer exchange for ${peerIdStr}`);
      const { error, peerInfos } = await this.peerExchange.query({
        numPeers: DEFAULT_PEER_EXCHANGE_REQUEST_NODES,
        peerId: peerId2
      });
      if (error) {
        log30.error(`Peer exchange query to ${peerIdStr} failed`, error);
        return;
      }
      for (const { ENR: ENR2 } of peerInfos) {
        if (!ENR2) {
          log30.warn(`No ENR in peerInfo object from ${peerIdStr}, skipping`);
          continue;
        }
        const { peerInfo, shardInfo } = ENR2;
        if (!peerInfo) {
          log30.warn(`No peerInfo in ENR from ${peerIdStr}, skipping`);
          continue;
        }
        const hasPrevShardInfo = await this.hasShardInfo(peerInfo.id);
        const metadata = !hasPrevShardInfo && shardInfo ? { metadata: { shardInfo: encodeRelayShard(shardInfo) } } : void 0;
        await this.components.peerStore.merge(peerInfo.id, {
          tags: {
            [DEFAULT_PEER_EXCHANGE_TAG_NAME]: {
              value: DEFAULT_PEER_EXCHANGE_TAG_VALUE
            }
          },
          ...metadata,
          ...peerInfo.multiaddrs && {
            multiaddrs: peerInfo.multiaddrs
          }
        });
        log30.info(`Discovered peer: ${peerInfo.id.toString()}`);
        this.dispatchEvent(new CustomEvent("peer", {
          detail: {
            id: peerInfo.id,
            multiaddrs: peerInfo.multiaddrs
          }
        }));
      }
    }
    async hasShardInfo(peerId2) {
      try {
        const peer = await this.components.peerStore.get(peerId2);
        if (!peer) {
          return false;
        }
        return peer.metadata.has("shardInfo");
      } catch (err) {
        log30.warn(`Error getting shard info for ${peerId2.toString()}`, err);
      }
      return false;
    }
  };
  function wakuPeerExchangeDiscovery(options = {}) {
    return (components) => new PeerExchangeDiscovery(components, options);
  }

  // ../node_modules/@waku/discovery/dist/peer-cache/constants.js
  var DEFAULT_PEER_CACHE_TAG_NAME = Tags.PEER_CACHE;
  var DEFAULT_PEER_CACHE_TAG_VALUE = 50;

  // ../node_modules/@waku/discovery/dist/peer-cache/utils.js
  var isValidStoredPeer = (peer) => {
    return !!peer && typeof peer === "object" && "id" in peer && typeof peer.id === "string" && "multiaddrs" in peer && Array.isArray(peer.multiaddrs);
  };
  var NoopCache = class {
    get() {
      return [];
    }
    set(_value) {
      return;
    }
    remove() {
      return;
    }
  };
  var LocalStorageCache = class {
    get() {
      try {
        const cachedPeers = localStorage.getItem("waku:peers");
        const peers = cachedPeers ? JSON.parse(cachedPeers) : [];
        return peers.filter(isValidStoredPeer);
      } catch (e) {
        return [];
      }
    }
    set(_value) {
      try {
        localStorage.setItem("waku:peers", JSON.stringify(_value));
      } catch (e) {
      }
    }
    remove() {
      try {
        localStorage.removeItem("waku:peers");
      } catch (e) {
      }
    }
  };
  var defaultCache = () => {
    try {
      if (typeof localStorage !== "undefined") {
        return new LocalStorageCache();
      }
    } catch (_e) {
    }
    return new NoopCache();
  };

  // ../node_modules/@waku/discovery/dist/peer-cache/peer_cache.js
  var log31 = new Logger("peer-cache");
  var PeerCacheDiscovery = class extends TypedEventEmitter {
    components;
    isStarted = false;
    cache;
    constructor(components, options) {
      super();
      this.components = components;
      this.cache = options?.cache ?? defaultCache();
    }
    get [Symbol.toStringTag]() {
      return `@waku/${DEFAULT_PEER_CACHE_TAG_NAME}`;
    }
    async start() {
      if (this.isStarted) {
        return;
      }
      log31.info("Starting Peer Cache Discovery");
      this.components.events.addEventListener("peer:identify", this.handleDiscoveredPeer);
      await this.discoverPeers();
      this.isStarted = true;
    }
    stop() {
      if (!this.isStarted) {
        return;
      }
      log31.info("Stopping Peer Cache Discovery");
      this.components.events.removeEventListener("peer:identify", this.handleDiscoveredPeer);
      this.isStarted = false;
    }
    handleDiscoveredPeer = (event) => {
      const { peerId: peerId2, listenAddrs } = event.detail;
      const multiaddrs = listenAddrs.map((addr) => addr.toString());
      const peerIdStr = peerId2.toString();
      const knownPeers = this.readPeerInfoFromCache();
      const peerIndex = knownPeers.findIndex((p) => p.id === peerIdStr);
      if (peerIndex !== -1) {
        knownPeers[peerIndex].multiaddrs = multiaddrs;
      } else {
        knownPeers.push({
          id: peerIdStr,
          multiaddrs
        });
      }
      this.writePeerInfoToCache(knownPeers);
    };
    async discoverPeers() {
      const knownPeers = this.readPeerInfoFromCache();
      for (const peer of knownPeers) {
        const peerId2 = peerIdFromString(peer.id);
        const multiaddrs = peer.multiaddrs.map((addr) => multiaddr(addr));
        if (await this.components.peerStore.has(peerId2)) {
          continue;
        }
        await this.components.peerStore.save(peerId2, {
          multiaddrs,
          tags: {
            [DEFAULT_PEER_CACHE_TAG_NAME]: {
              value: DEFAULT_PEER_CACHE_TAG_VALUE
            }
          }
        });
        this.dispatchEvent(new CustomEvent("peer", {
          detail: {
            id: peerId2,
            multiaddrs
          }
        }));
      }
    }
    readPeerInfoFromCache() {
      try {
        return this.cache.get();
      } catch (error) {
        log31.error("Error parsing peers from cache:", error);
        return [];
      }
    }
    writePeerInfoToCache(peers) {
      try {
        this.cache.set(peers);
      } catch (error) {
        log31.error("Error saving peers to cache:", error);
      }
    }
  };
  function wakuPeerCacheDiscovery(options = {}) {
    return (components) => new PeerCacheDiscovery(components, options);
  }

  // ../node_modules/@waku/sdk/dist/create/discovery.js
  function getPeerDiscoveries(enabled, peerCache) {
    const dnsEnrTrees = [enrTree["SANDBOX"], enrTree["TEST"]];
    const discoveries = [];
    if (enabled?.dns) {
      discoveries.push(wakuDnsDiscovery(dnsEnrTrees));
    }
    if (enabled?.peerCache || peerCache) {
      discoveries.push(wakuPeerCacheDiscovery({ cache: peerCache }));
    }
    if (enabled?.peerExchange) {
      discoveries.push(wakuPeerExchangeDiscovery());
    }
    return discoveries;
  }

  // ../node_modules/@waku/sdk/dist/create/libp2p.js
  var log32 = new Logger("sdk:create");
  var DefaultUserAgent = "js-waku";
  var DefaultPingMaxInboundStreams = 10;
  async function defaultLibp2p(clusterId, options, userAgent2) {
    if (!options?.hideWebSocketInfo && !isTestEnvironment()) {
      console.info("%cIgnore WebSocket connection failures", "background: gray; color: white; font-size: x-large");
      console.info("%cWaku tries to discover peers and some of them are expected to fail", "background: gray; color: white; font-size: x-large");
    }
    const filter2 = options?.filterMultiaddrs === false || isTestEnvironment() ? all2 : wss;
    return createLibp2p({
      transports: [webSockets({ filter: filter2 })],
      streamMuxers: [mplex()],
      connectionEncrypters: [noise()],
      ...options,
      services: {
        identify: identify({
          agentVersion: userAgent2 ?? DefaultUserAgent
        }),
        ping: ping({
          maxInboundStreams: options?.pingMaxInboundStreams ?? DefaultPingMaxInboundStreams
        }),
        metadata: wakuMetadata(clusterId),
        ...options?.services
      }
    });
  }
  async function createLibp2pAndUpdateOptions(options) {
    const networkConfig = options.networkConfig ?? DefaultNetworkConfig;
    const clusterId = networkConfig.clusterId ?? DEFAULT_CLUSTER_ID;
    log32.info("Creating Waku node with cluster id: ", clusterId);
    const libp2pOptions = options?.libp2p ?? {};
    const peerDiscovery = libp2pOptions.peerDiscovery ?? [];
    if (options?.defaultBootstrap) {
      peerDiscovery.push(...getPeerDiscoveries({
        dns: true,
        peerExchange: true,
        peerCache: true,
        ...options.discovery
      }, options.peerCache));
    } else {
      peerDiscovery.push(...getPeerDiscoveries(options.discovery, options.peerCache));
    }
    const bootstrapPeers = [
      ...options.bootstrapPeers || [],
      ...options.store?.peers || []
    ];
    if (bootstrapPeers.length) {
      peerDiscovery.push(bootstrap({ list: bootstrapPeers }));
    }
    libp2pOptions.peerDiscovery = peerDiscovery;
    return defaultLibp2p(clusterId, libp2pOptions, options?.userAgent);
  }

  // ../node_modules/@waku/sdk/dist/create/create.js
  async function createLightNode(options = {}) {
    const libp2p = await createLibp2pAndUpdateOptions(options);
    const node2 = new WakuNode(options, libp2p, {
      store: true,
      lightpush: true,
      filter: true
    });
    if (options?.autoStart !== false) {
      await node2.start();
    }
    return node2;
  }

  // src/waku/safe.ts
  var import_protobufjs = __toESM(require_protobufjs(), 1);
  var SafeHarbourTopicTransactionsV1 = "/safe/harbour/v1/txs";
  var SafeTransactionPacket = new import_protobufjs.default.Type("SafeTransaction").add(new import_protobufjs.default.Field("chainId", 0, "string")).add(new import_protobufjs.default.Field("safe", 1, "string")).add(new import_protobufjs.default.Field("to", 2, "string")).add(new import_protobufjs.default.Field("value", 3, "string")).add(new import_protobufjs.default.Field("data", 4, "string")).add(new import_protobufjs.default.Field("operation", 5, "uint32")).add(new import_protobufjs.default.Field("safeTxGas", 6, "string")).add(new import_protobufjs.default.Field("baseGas", 7, "string")).add(new import_protobufjs.default.Field("gasPrice", 8, "string")).add(new import_protobufjs.default.Field("gasToken", 9, "string")).add(new import_protobufjs.default.Field("refundReceiver", 10, "string")).add(new import_protobufjs.default.Field("nonce", 12, "string")).add(new import_protobufjs.default.Field("signature", 13, "string"));

  // src/mobile.ts
  var logger4 = console;
  var node;
  var encoder2;
  function setLogger(_logger) {
    logger4 = _logger;
  }
  function connectedPeers(callback) {
    const _node = node;
    if (_node === void 0) {
      callback(0);
      return;
    }
    _node.getConnectedPeers().then((peers) => {
      callback(peers.length);
    }).catch(() => {
      callback(0);
    });
  }
  async function setup2() {
    const _node = await createLightNode({ defaultBootstrap: true });
    logger4.log("Waku node configured. configuring encoder");
    node = _node;
    encoder2 = node.createEncoder({
      contentTopic: SafeHarbourTopicTransactionsV1,
      ephemeral: true
    });
    logger4.log("Encoder configured; starting node");
    await _node.start();
    logger4.log("Waku node started, waiting for peers...");
    await _node.waitForPeers();
    logger4.log("Waku peers found.");
    logger4.log("\u2705 Worker initialized and ready for sending messages.");
  }
  function isAvailable() {
    const _node = node;
    return _node !== void 0 && _node.isConnected() && _node.isStarted();
  }
  async function send(transaction, signature) {
    const _node = node;
    const _encoder = encoder2;
    if (_node === void 0 || _encoder === void 0 || !isAvailable()) {
      console.error("Waku is not available");
      return false;
    }
    logger4.log({ transaction, signature });
    const protoMessage = SafeTransactionPacket.create({
      ...transaction,
      safe: transaction.safe,
      chainId: transaction.chainId.toString(),
      signature
    });
    logger4.log({ protoMessage });
    const serialisedMessage = SafeTransactionPacket.encode(protoMessage).finish();
    logger4.log("Send Message");
    const response = await _node.lightPush.send(_encoder, {
      payload: serialisedMessage
    });
    logger4.log(
      `Done: ${response.successes.length > 0 ? `Transmitted to ${response.successes.length} peers` : "Could not send message"}`
    );
    return response.successes.length > 0;
  }
  return __toCommonJS(mobile_exports);
})();
/*! Bundled license information:

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.9.3
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2023
   * @license MIT
   *)

hi-base32/src/base32.js:
  (*
   * [hi-base32]{@link https://github.com/emn178/hi-base32}
   *
   * @version 0.5.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)

@noble/hashes/esm/utils.js:
@noble/hashes/esm/utils.js:
@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/edwards.js:
@noble/curves/esm/ed25519.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
@noble/curves/esm/abstract/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/edwards.js:
@noble/curves/esm/abstract/montgomery.js:
@noble/curves/esm/ed25519.js:
@noble/curves/esm/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/edwards.js:
@noble/curves/esm/ed25519.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/ciphers/esm/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

@noble/secp256k1/lib/esm/index.js:
  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)
*/
