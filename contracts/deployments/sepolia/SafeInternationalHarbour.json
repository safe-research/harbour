{
  "address": "0x570e7926Ff2300680eb10a29db8Ab59b48C92319",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "entryPoint",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "maxPriorityFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "preVerificationGasPerByte",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "preVerificationBaseGas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "verificationGasPerByte",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "callGasPerByte",
              "type": "uint256"
            }
          ],
          "internalType": "struct ERC4337Mixin.ERC4337MixinConfig",
          "name": "_erc4337Mixinconfig",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "timeframeQuotaReset",
              "type": "uint64"
            },
            {
              "internalType": "uint16",
              "name": "requiredQuotaMultiplier",
              "type": "uint16"
            },
            {
              "internalType": "uint32",
              "name": "quotaPerDepositedFeeToken",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "maxFreeQuota",
              "type": "uint32"
            },
            {
              "internalType": "address",
              "name": "feeToken",
              "type": "address"
            },
            {
              "internalType": "uint8",
              "name": "feeTokenDecimals",
              "type": "uint8"
            }
          ],
          "internalType": "struct QuotaMixin.QuotaMixinConfig",
          "name": "_quotaMixinconfig",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "InvalidECDSASignatureLength",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "entryPoint",
          "type": "address"
        }
      ],
      "name": "InvalidEntryPoint",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSignature",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSignatureSValue",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "targetSelector",
          "type": "bytes4"
        }
      ],
      "name": "InvalidTarget",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidUserOpPaymasterAndData",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "SafeERC20FailedOperation",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "signer",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "safeTxHash",
          "type": "bytes32"
        }
      ],
      "name": "SignerAlreadySignedTransaction",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "expectedNonce",
          "type": "uint256"
        }
      ],
      "name": "UnexpectedNonce",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "expectedSafeTxHash",
          "type": "bytes32"
        }
      ],
      "name": "UnexpectedSafeTxHash",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "extractedR",
          "type": "bytes32"
        }
      ],
      "name": "UnexpectedSignatureR",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "extractedVS",
          "type": "bytes32"
        }
      ],
      "name": "UnexpectedSignatureVS",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "recoveredSigner",
          "type": "address"
        }
      ],
      "name": "UnexpectedSigner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ValueDoesNotFitInUint128",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "signer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Deposit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "safeTxHash",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "safe",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "operation",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "safeTxGas",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "baseGas",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "gasPrice",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "gasToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "refundReceiver",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "NewTransaction",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "signer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "safe",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "safeTxHash",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "listIndex",
          "type": "uint256"
        }
      ],
      "name": "SignatureStored",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "signer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Withdraw",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "CALL_GAS_PER_BYTE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "FEE_TOKEN",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "FEE_TOKEN_DECIMALS",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "FREE_QUOTA_PER_DEPOSITED_FEE_TOKEN",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_FREE_QUOTA",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_PRIORITY_FEE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PRE_VERIFICATION_BASE_GAS",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PRE_VERIFICATION_GAS_PER_BYTE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "REQUIRED_QUOTA_MULTIPLIER",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SUPPORTED_ENTRYPOINT",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "TIMEFRAME_QUOTA_RESET",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "VERIFICATION_GAS_PER_BYTE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "signer",
          "type": "address"
        }
      ],
      "name": "availableFreeQuotaForSigner",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "availableFreeQuota",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "usedSignerQuota",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "nextSignerQuotaReset",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "signer",
          "type": "address"
        },
        {
          "internalType": "uint128",
          "name": "amount",
          "type": "uint128"
        }
      ],
      "name": "depositTokensForSigner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "safeAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "uint8",
          "name": "operation",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "safeTxGas",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "baseGas",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "gasPrice",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "gasToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "refundReceiver",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "enqueueTransaction",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "listIndex",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "signer",
          "type": "address"
        }
      ],
      "name": "getNonce",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "quotaStatsForSigner",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "tokenBalance",
          "type": "uint128"
        },
        {
          "internalType": "uint64",
          "name": "usedQuota",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "nextQuotaReset",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "signerAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "safeAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "start",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "count",
          "type": "uint256"
        }
      ],
      "name": "retrieveSignatures",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "vs",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "txHash",
              "type": "bytes32"
            }
          ],
          "internalType": "struct SignatureDataWithTxHashIndex[]",
          "name": "page",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "totalCount",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "signerAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "safeAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        }
      ],
      "name": "retrieveSignaturesCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "count",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "safeTxHash",
          "type": "bytes32"
        }
      ],
      "name": "retrieveTransaction",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bool",
              "name": "stored",
              "type": "bool"
            },
            {
              "internalType": "uint8",
              "name": "operation",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint128",
              "name": "value",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "safeTxGas",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "baseGas",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "gasPrice",
              "type": "uint128"
            },
            {
              "internalType": "address",
              "name": "gasToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "refundReceiver",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct SafeTransaction",
          "name": "txParams",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "safeTxHash",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "safeAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "uint8",
          "name": "operation",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "safeTxGas",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "baseGas",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "gasPrice",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "gasToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "refundReceiver",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "signer",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "r",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "vs",
          "type": "bytes32"
        }
      ],
      "name": "storeTransaction",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "listIndex",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "initCode",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            },
            {
              "internalType": "bytes32",
              "name": "accountGasLimits",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "preVerificationGas",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "gasFees",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "paymasterAndData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct PackedUserOperation",
          "name": "userOp",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "validateUserOp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "validationData",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        },
        {
          "internalType": "uint128",
          "name": "amount",
          "type": "uint128"
        },
        {
          "internalType": "address",
          "name": "beneficiary",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        }
      ],
      "name": "widthdrawTokensForSigner",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "withdrawsForSigner",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "args": [
    {
      "entryPoint": "0x4337084d9e255ff0702461cf8895ce9e3b5ff108",
      "maxPriorityFee": "2000000000",
      "preVerificationGasPerByte": 25,
      "preVerificationBaseGas": 40000,
      "verificationGasPerByte": 200,
      "callGasPerByte": 1000
    },
    {
      "timeframeQuotaReset": 86400,
      "requiredQuotaMultiplier": 1,
      "quotaPerDepositedFeeToken": 1000000,
      "maxFreeQuota": 5000,
      "feeToken": "0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14",
      "feeTokenDecimals": 18
    }
  ],
  "numDeployments": 6,
  "solcInputHash": "16b53e9dd32acdd99a485b9d75058e40",
  "metadata": "{\"compiler\":{\"version\":\"0.8.29+commit.ab55807c\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"entryPoint\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGasPerByte\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationBaseGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasPerByte\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"callGasPerByte\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC4337Mixin.ERC4337MixinConfig\",\"name\":\"_erc4337Mixinconfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"timeframeQuotaReset\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"requiredQuotaMultiplier\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"quotaPerDepositedFeeToken\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxFreeQuota\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"feeTokenDecimals\",\"type\":\"uint8\"}],\"internalType\":\"struct QuotaMixin.QuotaMixinConfig\",\"name\":\"_quotaMixinconfig\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidECDSASignatureLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"entryPoint\",\"type\":\"address\"}],\"name\":\"InvalidEntryPoint\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignatureSValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"targetSelector\",\"type\":\"bytes4\"}],\"name\":\"InvalidTarget\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidUserOpPaymasterAndData\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"safeTxHash\",\"type\":\"bytes32\"}],\"name\":\"SignerAlreadySignedTransaction\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expectedNonce\",\"type\":\"uint256\"}],\"name\":\"UnexpectedNonce\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"expectedSafeTxHash\",\"type\":\"bytes32\"}],\"name\":\"UnexpectedSafeTxHash\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"extractedR\",\"type\":\"bytes32\"}],\"name\":\"UnexpectedSignatureR\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"extractedVS\",\"type\":\"bytes32\"}],\"name\":\"UnexpectedSignatureVS\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recoveredSigner\",\"type\":\"address\"}],\"name\":\"UnexpectedSigner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ValueDoesNotFitInUint128\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"safeTxHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"operation\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"safeTxGas\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseGas\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gasToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refundReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"NewTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"safeTxHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listIndex\",\"type\":\"uint256\"}],\"name\":\"SignatureStored\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CALL_GAS_PER_BYTE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_TOKEN_DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FREE_QUOTA_PER_DEPOSITED_FEE_TOKEN\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FREE_QUOTA\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PRIORITY_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRE_VERIFICATION_BASE_GAS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRE_VERIFICATION_GAS_PER_BYTE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REQUIRED_QUOTA_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPPORTED_ENTRYPOINT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIMEFRAME_QUOTA_RESET\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERIFICATION_GAS_PER_BYTE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"availableFreeQuotaForSigner\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"availableFreeQuota\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"usedSignerQuota\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nextSignerQuotaReset\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"depositTokensForSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"safeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"safeTxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"gasToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refundReceiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"enqueueTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"listIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"quotaStatsForSigner\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"tokenBalance\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"usedQuota\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nextQuotaReset\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"safeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"retrieveSignatures\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vs\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct SignatureDataWithTxHashIndex[]\",\"name\":\"page\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"totalCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"safeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"retrieveSignaturesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"safeTxHash\",\"type\":\"bytes32\"}],\"name\":\"retrieveTransaction\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"stored\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"value\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"safeTxGas\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"baseGas\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"gasPrice\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"gasToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refundReceiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct SafeTransaction\",\"name\":\"txParams\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"safeTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"safeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"safeTxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"gasToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refundReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vs\",\"type\":\"bytes32\"}],\"name\":\"storeTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"listIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"accountGasLimits\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"gasFees\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct PackedUserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validateUserOp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"validationData\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"widthdrawTokensForSigner\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"withdrawsForSigner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"The {SignatureStored} event is the only hook required by indexers; however, the contract is      fully functional without any off\\u2011chain infrastructure.\",\"errors\":{\"SafeERC20FailedOperation(address)\":[{\"details\":\"An operation with an ERC-20 token failed.\"}],\"SignerAlreadySignedTransaction(address,bytes32)\":[{\"params\":{\"safeTxHash\":\"The EIP-712 hash of the Safe transaction.\",\"signer\":\"Signer address.\"}}]},\"events\":{\"NewTransaction(bytes32,address,uint256,uint256,address,uint256,uint8,uint256,uint256,uint256,address,address,bytes)\":{\"params\":{\"baseGas\":\"Fixed overhead reimbursed to the submitting signer.\",\"chainId\":\"Intended execution chain.\",\"data\":\"Calldata executed by the Safe.\",\"gasPrice\":\"Gas price used for reimbursement.\",\"gasToken\":\"ERC-20 token address for refunds.\",\"nonce\":\"Safe nonce.\",\"operation\":\"0 = CALL, 1 = DELEGATECALL.\",\"refundReceiver\":\"Address receiving the gas refund.\",\"safe\":\"Safe Smart-Account the transaction targets.\",\"safeTxGas\":\"Gas forwarded to the inner call.\",\"safeTxHash\":\"EIP-712 hash identifying the SafeTx.\",\"to\":\"Destination of the inner call/delegatecall.\",\"value\":\"ETH value forwarded by the Safe.\"}},\"SignatureStored(address,address,bytes32,uint256,uint256,uint256)\":{\"params\":{\"chainId\":\"Intended execution chain.\",\"listIndex\":\"Position of the signature in the signer\\u2011specific array.\",\"nonce\":\"Safe nonce.\",\"safe\":\"Safe Smart\\u2011Account the transaction targets.\",\"safeTxHash\":\"EIP\\u2011712 hash identifying the SafeTx.\",\"signer\":\"Address recovered from the provided signature.\"}}},\"kind\":\"dev\",\"methods\":{\"enqueueTransaction(address,uint256,uint256,address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes)\":{\"custom:events\":\"Emits {SignatureStored}.\",\"details\":\"If `safeTxHash` has been seen before, its parameters are *not* validated nor overwritten \\u2013      the call simply appends the `(r,s)` pair for `signer`.\",\"params\":{\"baseGas\":\"Fixed overhead reimbursed to the submitting signer.\",\"chainId\":\"Chain id the transaction is meant for.\",\"data\":\"Calldata executed by the Safe.\",\"gasPrice\":\"Gas price used for reimbursement.\",\"gasToken\":\"ERC\\u201120 token address for refunds (`address(0)` = ETH).\",\"nonce\":\"Safe nonce.\",\"operation\":\"0 = CALL, 1 = DELEGATECALL.\",\"refundReceiver\":\"Address receiving the gas refund.\",\"safeAddress\":\"Target Safe Smart\\u2011Account.\",\"safeTxGas\":\"Gas forwarded to the inner call.\",\"signature\":\"**Single** 65\\u2011byte ECDSA signature.\",\"to\":\"Destination of the inner call/delegatecall.\",\"value\":\"ETH value forwarded by the Safe.\"},\"returns\":{\"listIndex\":\"    Index of the stored signature in the signer\\u2011specific list.\"}},\"retrieveSignatures(address,address,uint256,uint256,uint256,uint256)\":{\"params\":{\"chainId\":\"Target chain id.\",\"count\":\"Maximum number of entries to return.\",\"nonce\":\"Safe nonce.\",\"safeAddress\":\"Safe Smart\\u2011Account.\",\"signerAddress\":\"Address that created the signatures.\",\"start\":\"Zero\\u2011based start index of the slice.\"},\"returns\":{\"page\":\"      Array slice `[start \\u2026 start+count)` (may be shorter).\",\"totalCount\":\"Total number of signatures stored for the tuple.\"}},\"retrieveSignaturesCount(address,address,uint256,uint256)\":{\"params\":{\"chainId\":\"Target chain id.\",\"nonce\":\"Safe nonce.\",\"safeAddress\":\"Safe Smart\\u2011Account.\",\"signerAddress\":\"Signer address.\"},\"returns\":{\"count\":\"Length of the signature list.\"}},\"retrieveTransaction(bytes32)\":{\"params\":{\"safeTxHash\":\"EIP\\u2011712 digest of the transaction.\"},\"returns\":{\"txParams\":\"Struct with all SafeTx parameters (zero\\u2011initialised if unknown).\"}}},\"stateVariables\":{\"_hasSignerSignedTx\":{\"details\":\"Tracks if a signer has already submitted *any* signature for a specific safeTxHash,      preventing duplicate signatures for the *exact same* transaction digest.      This complements `_sigData` by ensuring uniqueness per (safeTxHash, signer) pair. Mapping `safeTxHash \\u2192 signer \\u2192 bool`\"}},\"title\":\"SafeInternationalHarbour\",\"version\":1},\"userdoc\":{\"errors\":{\"InvalidECDSASignatureLength()\":[{\"notice\":\"Thrown when a signature blob is not exactly 65 bytes.\"}],\"InvalidSignature()\":[{\"notice\":\"Thrown if `ecrecover` yields `address(0)`.\"}],\"InvalidSignatureSValue()\":[{\"notice\":\"Thrown if the S value of the signature is not from the lower half of the curve.\"}],\"SignerAlreadySignedTransaction(address,bytes32)\":[{\"notice\":\"Thrown when attempting to store a signature for a transaction (safeTxHash) that the signer has already provided a signature for.\"}],\"ValueDoesNotFitInUint128()\":[{\"notice\":\"Thrown when a value doesn't fit in a uint128.\"}]},\"events\":{\"NewTransaction(bytes32,address,uint256,uint256,address,uint256,uint8,uint256,uint256,uint256,address,address,bytes)\":{\"notice\":\"Emitted when a transaction is first stored.\"},\"SignatureStored(address,address,bytes32,uint256,uint256,uint256)\":{\"notice\":\"Emitted whenever a new signature is stored (and possibly the parameters on first sight).\"}},\"kind\":\"user\",\"methods\":{\"SUPPORTED_ENTRYPOINT()\":{\"notice\":\"The address of the EntryPoint contract supported by this module.\"},\"enqueueTransaction(address,uint256,uint256,address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes)\":{\"notice\":\"Publish a Safe transaction and/or append a signature to it.\"},\"getNonce(address)\":{\"notice\":\"Return the account nonce. This method returns the next sequential nonce. For a nonce of a specific key, use `entrypoint.getNonce(account, key)`\"},\"retrieveSignatures(address,address,uint256,uint256,uint256,uint256)\":{\"notice\":\"Paginated getter for signature entries.\"},\"retrieveSignaturesCount(address,address,uint256,uint256)\":{\"notice\":\"Convenience getter returning the **number** of signatures stored for the key tuple.\"},\"retrieveTransaction(bytes32)\":{\"notice\":\"Retrieve the full parameter set of a Safe transaction.\"}},\"notice\":\"Permissionless, append\\u2011only registry that lets **any EOA signer** publish Safe         transactions (\\\"SafeTx\\\") and their signatures. Clients without an off\\u2011chain indexer can reconstruct the full multisig payload with only:         1. the Safe address;         2. the target `chainId`;         3. the Safe `nonce`; and         4. the current Safe owners set. Each unique `safeTxHash` (EIP\\u2011712 digest of the SafeTx struct) is persisted **once** together with its parameters. Signatures are appended under the composite key `(signer, safe, chainId, nonce)`, enabling on\\u2011chain, gas\\u2011efficient look\\u2011ups. ### \\u26a0\\ufe0f Contract\\u2011based signers unsupported Only ECDSA signatures from externally\\u2011owned accounts (EOAs) are supported. Contract wallets that rely on ERC\\u20111271 or similar cannot be verified on\\u2011chain in a chain\\u2011agnostic way and are therefore **not supported**.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/SafeInternationalHarbour.sol\":\"SafeInternationalHarbour\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@account-abstraction/contracts/core/Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/* solhint-disable no-inline-assembly */\\n\\n\\n /*\\n  * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\\n  * must return this value in case of signature failure, instead of revert.\\n  */\\nuint256 constant SIG_VALIDATION_FAILED = 1;\\n\\n\\n/*\\n * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\\n * return this value on success.\\n */\\nuint256 constant SIG_VALIDATION_SUCCESS = 0;\\n\\n\\n/**\\n * Returned data from validateUserOp.\\n * validateUserOp returns a uint256, which is created by `_packedValidationData` and\\n * parsed by `_parseValidationData`.\\n * @param aggregator  - address(0) - The account validated the signature by itself.\\n *                      address(1) - The account failed to validate the signature.\\n *                      otherwise - This is an address of a signature aggregator that must\\n *                                  be used to validate the signature.\\n * @param validAfter  - This UserOp is valid only after this timestamp.\\n * @param validUntil - Last timestamp this operation is valid at, or 0 for \\\"indefinitely\\\".\\n */\\nstruct ValidationData {\\n    address aggregator;\\n    uint48 validAfter;\\n    uint48 validUntil;\\n}\\n\\n/**\\n * Extract aggregator/sigFailed, validAfter, validUntil.\\n * Also convert zero validUntil to type(uint48).max.\\n * @param validationData - The packed validation data.\\n * @return data - The unpacked in-memory validation data.\\n */\\nfunction _parseValidationData(\\n    uint256 validationData\\n) pure returns (ValidationData memory data) {\\n    address aggregator = address(uint160(validationData));\\n    uint48 validUntil = uint48(validationData >> 160);\\n    if (validUntil == 0) {\\n        validUntil = type(uint48).max;\\n    }\\n    uint48 validAfter = uint48(validationData >> (48 + 160));\\n    return ValidationData(aggregator, validAfter, validUntil);\\n}\\n\\n/**\\n * Helper to pack the return value for validateUserOp.\\n * @param data - The ValidationData to pack.\\n * @return the packed validation data.\\n */\\nfunction _packValidationData(\\n    ValidationData memory data\\n) pure returns (uint256) {\\n    return\\n        uint160(data.aggregator) |\\n        (uint256(data.validUntil) << 160) |\\n        (uint256(data.validAfter) << (160 + 48));\\n}\\n\\n/**\\n * Helper to pack the return value for validateUserOp, when not using an aggregator.\\n * @param sigFailed  - True for signature failure, false for success.\\n * @param validUntil - Last timestamp this operation is valid at, or 0 for \\\"indefinitely\\\".\\n * @param validAfter - First timestamp this UserOperation is valid.\\n * @return the packed validation data.\\n */\\nfunction _packValidationData(\\n    bool sigFailed,\\n    uint48 validUntil,\\n    uint48 validAfter\\n) pure returns (uint256) {\\n    return\\n        (sigFailed ?  SIG_VALIDATION_FAILED : SIG_VALIDATION_SUCCESS) |\\n        (uint256(validUntil) << 160) |\\n        (uint256(validAfter) << (160 + 48));\\n}\\n\\n/**\\n * keccak function over calldata.\\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\\n *\\n * @param data - the calldata bytes array to perform keccak on.\\n * @return ret - the keccak hash of the 'data' array.\\n */\\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\\n        assembly (\\\"memory-safe\\\") {\\n            let mem := mload(0x40)\\n            let len := data.length\\n            calldatacopy(mem, data.offset, len)\\n            ret := keccak256(mem, len)\\n        }\\n    }\\n\\n\\n/**\\n * The minimum of two numbers.\\n * @param a - First number.\\n * @param b - Second number.\\n * @return - the minimum value.\\n */\\n    function min(uint256 a, uint256 b) pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n/**\\n * standard solidity memory allocation finalization.\\n * copied from solidity generated code\\n * @param memPointer - The current memory pointer\\n * @param allocationSize - Bytes allocated from memPointer.\\n */\\n    function finalizeAllocation(uint256 memPointer, uint256 allocationSize) pure {\\n\\n        assembly (\\\"memory-safe\\\"){\\n            finalize_allocation(memPointer, allocationSize)\\n\\n            function finalize_allocation(memPtr, size) {\\n                let newFreePtr := add(memPtr, round_up_to_mul_of_32(size))\\n                mstore(64, newFreePtr)\\n            }\\n\\n            function round_up_to_mul_of_32(value) -> result {\\n                result := and(add(value, 31), not(31))\\n            }\\n        }\\n    }\\n\",\"keccak256\":\"0x42b948af5fa14a96149611595df1186800c7558b2de8762e4b45a7c45c16f65e\",\"license\":\"MIT\"},\"@account-abstraction/contracts/core/UserOperationLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/* solhint-disable no-inline-assembly */\\n\\nimport \\\"../interfaces/PackedUserOperation.sol\\\";\\nimport {calldataKeccak, min} from \\\"./Helpers.sol\\\";\\n\\n/**\\n * Utility functions helpful when working with UserOperation structs.\\n */\\nlibrary UserOperationLib {\\n\\n    uint256 public constant PAYMASTER_VALIDATION_GAS_OFFSET = 20;\\n    uint256 public constant PAYMASTER_POSTOP_GAS_OFFSET = 36;\\n    uint256 public constant PAYMASTER_DATA_OFFSET = 52;\\n\\n    /**\\n     * Relayer/block builder might submit the TX with higher priorityFee,\\n     * but the user should not pay above what he signed for.\\n     * @param userOp - The user operation data.\\n     */\\n    function gasPrice(\\n        PackedUserOperation calldata userOp\\n    ) internal view returns (uint256) {\\n        unchecked {\\n            (uint256 maxPriorityFeePerGas, uint256 maxFeePerGas) = unpackUints(userOp.gasFees);\\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n        }\\n    }\\n\\n    bytes32 internal constant PACKED_USEROP_TYPEHASH =\\n    keccak256(\\n        \\\"PackedUserOperation(address sender,uint256 nonce,bytes initCode,bytes callData,bytes32 accountGasLimits,uint256 preVerificationGas,bytes32 gasFees,bytes paymasterAndData)\\\"\\n    );\\n\\n    /**\\n     * Pack the user operation data into bytes for hashing.\\n     * @param userOp - The user operation data.\\n     * @param overrideInitCodeHash - If set, encode this instead of the initCode field in the userOp.\\n     */\\n    function encode(\\n        PackedUserOperation calldata userOp,\\n        bytes32 overrideInitCodeHash\\n    ) internal pure returns (bytes memory ret) {\\n        address sender = userOp.sender;\\n        uint256 nonce = userOp.nonce;\\n        bytes32 hashInitCode = overrideInitCodeHash != 0 ? overrideInitCodeHash : calldataKeccak(userOp.initCode);\\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\\n        bytes32 accountGasLimits = userOp.accountGasLimits;\\n        uint256 preVerificationGas = userOp.preVerificationGas;\\n        bytes32 gasFees = userOp.gasFees;\\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\\n\\n        return abi.encode(\\n            UserOperationLib.PACKED_USEROP_TYPEHASH,\\n            sender, nonce,\\n            hashInitCode, hashCallData,\\n            accountGasLimits, preVerificationGas, gasFees,\\n            hashPaymasterAndData\\n        );\\n    }\\n\\n    function unpackUints(\\n        bytes32 packed\\n    ) internal pure returns (uint256 high128, uint256 low128) {\\n        return (unpackHigh128(packed), unpackLow128(packed));\\n    }\\n\\n    // Unpack just the high 128-bits from a packed value\\n    function unpackHigh128(bytes32 packed) internal pure returns (uint256) {\\n        return uint256(packed) >> 128;\\n    }\\n\\n    // Unpack just the low 128-bits from a packed value\\n    function unpackLow128(bytes32 packed) internal pure returns (uint256) {\\n        return uint128(uint256(packed));\\n    }\\n\\n    function unpackMaxPriorityFeePerGas(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackHigh128(userOp.gasFees);\\n    }\\n\\n    function unpackMaxFeePerGas(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackLow128(userOp.gasFees);\\n    }\\n\\n    function unpackVerificationGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackHigh128(userOp.accountGasLimits);\\n    }\\n\\n    function unpackCallGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackLow128(userOp.accountGasLimits);\\n    }\\n\\n    function unpackPaymasterVerificationGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET]));\\n    }\\n\\n    function unpackPostOpGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]));\\n    }\\n\\n    function unpackPaymasterStaticFields(\\n        bytes calldata paymasterAndData\\n    ) internal pure returns (address paymaster, uint256 validationGasLimit, uint256 postOpGasLimit) {\\n        return (\\n            address(bytes20(paymasterAndData[: PAYMASTER_VALIDATION_GAS_OFFSET])),\\n            uint128(bytes16(paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET])),\\n            uint128(bytes16(paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]))\\n        );\\n    }\\n\\n    /**\\n     * Hash the user operation data.\\n     * @param userOp - The user operation data.\\n     * @param overrideInitCodeHash - If set, the initCode hash will be replaced with this value just for UserOp hashing.\\n     */\\n    function hash(\\n        PackedUserOperation calldata userOp,\\n        bytes32 overrideInitCodeHash\\n    ) internal pure returns (bytes32) {\\n        return keccak256(encode(userOp, overrideInitCodeHash));\\n    }\\n}\\n\",\"keccak256\":\"0x2d3450fa3906422b6fdbbe7f2a2a9e36d6f3751bfa9cd80af88befd6a5be78c1\",\"license\":\"MIT\"},\"@account-abstraction/contracts/interfaces/IAccount.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport \\\"./PackedUserOperation.sol\\\";\\n\\ninterface IAccount {\\n    /**\\n     * Validate user's signature and nonce\\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\\n     * This allows making a \\\"simulation call\\\" without a valid signature\\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\\n     *\\n     * @dev Must validate caller is the entryPoint.\\n     *      Must validate the signature and nonce\\n     * @param userOp              - The operation that is about to be executed.\\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for signature.\\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\\n     *                              This is the minimum amount to transfer to the sender(entryPoint) to be\\n     *                              able to make the call. The excess is left as a deposit in the entrypoint\\n     *                              for future calls. Can be withdrawn anytime using \\\"entryPoint.withdrawTo()\\\".\\n     *                              In case there is a paymaster in the request (or the current deposit is high\\n     *                              enough), this value will be zero.\\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData` and\\n     *                              `_unpackValidationData` to encode and decode.\\n     *                              <20-byte> aggregatorOrSigFail - 0 for valid signature, 1 to mark signature failure,\\n     *                                 otherwise, an address of an \\\"aggregator\\\" contract.\\n     *                              <6-byte> validUntil - Last timestamp this operation is valid at, or 0 for \\\"indefinitely\\\"\\n     *                              <6-byte> validAfter - First timestamp this operation is valid\\n     *                                                    If an account doesn't use time-range, it is enough to\\n     *                                                    return SIG_VALIDATION_FAILED value (1) for signature failure.\\n     *                              Note that the validation code cannot use block.timestamp (or block.number) directly.\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    ) external returns (uint256 validationData);\\n}\\n\",\"keccak256\":\"0x1030b464b49ce80da46b5b6c9af357c2d526f308de61391db6a4ec767d33b864\",\"license\":\"MIT\"},\"@account-abstraction/contracts/interfaces/IAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport \\\"./PackedUserOperation.sol\\\";\\n\\n/**\\n * Aggregated Signatures validator.\\n */\\ninterface IAggregator {\\n    /**\\n     * Validate an aggregated signature.\\n     * Reverts if the aggregated signature does not match the given list of operations.\\n     * @param userOps   - An array of UserOperations to validate the signature for.\\n     * @param signature - The aggregated signature.\\n     */\\n    function validateSignatures(\\n        PackedUserOperation[] calldata userOps,\\n        bytes calldata signature\\n    ) external;\\n\\n    /**\\n     * Validate the signature of a single userOp.\\n     * This method should be called by bundler after EntryPointSimulation.simulateValidation() returns\\n     * the aggregator this account uses.\\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\\n     * @param userOp        - The userOperation received from the user.\\n     * @return sigForUserOp - The value to put into the signature field of the userOp when calling handleOps.\\n     *                        (usually empty, unless account and aggregator support some kind of \\\"multisig\\\".\\n     */\\n    function validateUserOpSignature(\\n        PackedUserOperation calldata userOp\\n    ) external view returns (bytes memory sigForUserOp);\\n\\n    /**\\n     * Aggregate multiple signatures into a single value.\\n     * This method is called off-chain to calculate the signature to pass with handleOps()\\n     * bundler MAY use optimized custom code to perform this aggregation.\\n     * @param userOps              - An array of UserOperations to collect the signatures from.\\n     * @return aggregatedSignature - The aggregated signature.\\n     */\\n    function aggregateSignatures(\\n        PackedUserOperation[] calldata userOps\\n    ) external view returns (bytes memory aggregatedSignature);\\n}\\n\",\"keccak256\":\"0xdf580eafa015b81bde436d6a5468cc92b531ada84007cef885e923f6dfc5e8bf\",\"license\":\"MIT\"},\"@account-abstraction/contracts/interfaces/IEntryPoint.sol\":{\"content\":\"/**\\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\\n ** Only one instance required on each chain.\\n **/\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-inline-assembly */\\n/* solhint-disable reason-string */\\n\\nimport \\\"./PackedUserOperation.sol\\\";\\nimport \\\"./IStakeManager.sol\\\";\\nimport \\\"./IAggregator.sol\\\";\\nimport \\\"./INonceManager.sol\\\";\\nimport \\\"./ISenderCreator.sol\\\";\\n\\ninterface IEntryPoint is IStakeManager, INonceManager {\\n    /***\\n     * An event emitted after each successful request.\\n     * @param userOpHash    - Unique identifier for the request (hash its entire content, except signature).\\n     * @param sender        - The account that generates this request.\\n     * @param paymaster     - If non-null, the paymaster that pays for this request.\\n     * @param nonce         - The nonce value from the request.\\n     * @param success       - True if the sender transaction succeeded, false if reverted.\\n     * @param actualGasCost - Actual amount paid (by account or paymaster) for this UserOperation.\\n     * @param actualGasUsed - Total gas used by this UserOperation (including preVerification, creation,\\n     *                        validation and execution).\\n     */\\n    event UserOperationEvent(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        address indexed paymaster,\\n        uint256 nonce,\\n        bool success,\\n        uint256 actualGasCost,\\n        uint256 actualGasUsed\\n    );\\n\\n    /**\\n     * Account \\\"sender\\\" was deployed.\\n     * @param userOpHash - The userOp that deployed this account. UserOperationEvent will follow.\\n     * @param sender     - The account that is deployed\\n     * @param factory    - The factory used to deploy this account (in the initCode)\\n     * @param paymaster  - The paymaster used by this UserOp\\n     */\\n    event AccountDeployed(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        address factory,\\n        address paymaster\\n    );\\n\\n    /**\\n     * An event emitted if the UserOperation \\\"callData\\\" reverted with non-zero length.\\n     * @param userOpHash   - The request unique identifier.\\n     * @param sender       - The sender of this request.\\n     * @param nonce        - The nonce used in the request.\\n     * @param revertReason - The return bytes from the reverted \\\"callData\\\" call.\\n     */\\n    event UserOperationRevertReason(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        uint256 nonce,\\n        bytes revertReason\\n    );\\n\\n    /**\\n     * An event emitted if the UserOperation Paymaster's \\\"postOp\\\" call reverted with non-zero length.\\n     * @param userOpHash   - The request unique identifier.\\n     * @param sender       - The sender of this request.\\n     * @param nonce        - The nonce used in the request.\\n     * @param revertReason - The return bytes from the reverted call to \\\"postOp\\\".\\n     */\\n    event PostOpRevertReason(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        uint256 nonce,\\n        bytes revertReason\\n    );\\n\\n    /**\\n     * UserOp consumed more than prefund. The UserOperation is reverted, and no refund is made.\\n     * @param userOpHash   - The request unique identifier.\\n     * @param sender       - The sender of this request.\\n     * @param nonce        - The nonce used in the request.\\n     */\\n    event UserOperationPrefundTooLow(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        uint256 nonce\\n    );\\n\\n    /**\\n     * An event emitted by handleOps() and handleAggregatedOps(), before starting the execution loop.\\n     * Any event emitted before this event, is part of the validation.\\n     */\\n    event BeforeExecution();\\n\\n    /**\\n     * Signature aggregator used by the following UserOperationEvents within this bundle.\\n     * @param aggregator - The aggregator used for the following UserOperationEvents.\\n     */\\n    event SignatureAggregatorChanged(address indexed aggregator);\\n\\n    /**\\n     * A custom revert error of handleOps andhandleAggregatedOps, to identify the offending op.\\n     * Should be caught in off-chain handleOps/handleAggregatedOps simulation and not happen on-chain.\\n     * Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\\n     * NOTE: If simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\\n     * @param reason  - Revert reason. The string starts with a unique code \\\"AAmn\\\",\\n     *                  where \\\"m\\\" is \\\"1\\\" for factory, \\\"2\\\" for account and \\\"3\\\" for paymaster issues,\\n     *                  so a failure can be attributed to the correct entity.\\n     */\\n    error FailedOp(uint256 opIndex, string reason);\\n\\n    /**\\n     * A custom revert error of handleOps and handleAggregatedOps, to report a revert by account or paymaster.\\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\\n     * @param reason  - Revert reason. see FailedOp(uint256,string), above\\n     * @param inner   - data from inner cought revert reason\\n     * @dev note that inner is truncated to 2048 bytes\\n     */\\n    error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner);\\n\\n    error PostOpReverted(bytes returnData);\\n\\n    /**\\n     * Error case when a signature aggregator fails to verify the aggregated signature it had created.\\n     * @param aggregator The aggregator that failed to verify the signature\\n     */\\n    error SignatureValidationFailed(address aggregator);\\n\\n    // Return value of getSenderAddress.\\n    error SenderAddressResult(address sender);\\n\\n    // UserOps handled, per aggregator.\\n    struct UserOpsPerAggregator {\\n        PackedUserOperation[] userOps;\\n        // Aggregator address\\n        IAggregator aggregator;\\n        // Aggregated signature\\n        bytes signature;\\n    }\\n\\n    /**\\n     * Execute a batch of UserOperations.\\n     * No signature aggregator is used.\\n     * If any account requires an aggregator (that is, it returned an aggregator when\\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\\n     * @param ops         - The operations to execute.\\n     * @param beneficiary - The address to receive the fees.\\n     */\\n    function handleOps(\\n        PackedUserOperation[] calldata ops,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * Execute a batch of UserOperation with Aggregators\\n     * @param opsPerAggregator - The operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts).\\n     * @param beneficiary      - The address to receive the fees.\\n     */\\n    function handleAggregatedOps(\\n        UserOpsPerAggregator[] calldata opsPerAggregator,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * Generate a request Id - unique identifier for this request.\\n     * The request ID is a hash over the content of the userOp (except the signature), entrypoint address, chainId and (optionally) 7702 delegate address\\n     * @param userOp - The user operation to generate the request ID for.\\n     * @return hash the hash of this UserOperation\\n     */\\n    function getUserOpHash(\\n        PackedUserOperation calldata userOp\\n    ) external view returns (bytes32);\\n\\n    /**\\n     * Gas and return values during simulation.\\n     * @param preOpGas         - The gas used for validation (including preValidationGas)\\n     * @param prefund          - The required prefund for this operation\\n     * @param accountValidationData   - returned validationData from account.\\n     * @param paymasterValidationData - return validationData from paymaster.\\n     * @param paymasterContext - Returned by validatePaymasterUserOp (to be passed into postOp)\\n     */\\n    struct ReturnInfo {\\n        uint256 preOpGas;\\n        uint256 prefund;\\n        uint256 accountValidationData;\\n        uint256 paymasterValidationData;\\n        bytes paymasterContext;\\n    }\\n\\n    /**\\n     * Get counterfactual sender address.\\n     * Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\\n     * This method always revert, and returns the address in SenderAddressResult error.\\n     * @notice this method cannot be used for EIP-7702 derived contracts.\\n     *\\n     * @param initCode - The constructor code to be passed into the UserOperation.\\n     */\\n    function getSenderAddress(bytes memory initCode) external;\\n\\n    error DelegateAndRevert(bool success, bytes ret);\\n\\n    /**\\n     * Helper method for dry-run testing.\\n     * @dev calling this method, the EntryPoint will make a delegatecall to the given data, and report (via revert) the result.\\n     *  The method always revert, so is only useful off-chain for dry run calls, in cases where state-override to replace\\n     *  actual EntryPoint code is less convenient.\\n     * @param target a target contract to make a delegatecall from entrypoint\\n     * @param data data to pass to target in a delegatecall\\n     */\\n    function delegateAndRevert(address target, bytes calldata data) external;\\n\\n    /**\\n     * @notice Retrieves the immutable SenderCreator contract which is responsible for deployment of sender contracts.\\n     */\\n    function senderCreator() external view returns (ISenderCreator);\\n}\\n\",\"keccak256\":\"0x3b0423737e810dd886183ed32cfed9b45edd315f5fb3e1076fc19f86791adc64\",\"license\":\"MIT\"},\"@account-abstraction/contracts/interfaces/INonceManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\ninterface INonceManager {\\n\\n    /**\\n     * Return the next nonce for this sender.\\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\\n     * But UserOp with different keys can come with arbitrary order.\\n     *\\n     * @param sender the account address\\n     * @param key the high 192 bit of the nonce\\n     * @return nonce a full nonce to pass for next UserOp with this sender.\\n     */\\n    function getNonce(address sender, uint192 key)\\n    external view returns (uint256 nonce);\\n\\n    /**\\n     * Manually increment the nonce of the sender.\\n     * This method is exposed just for completeness..\\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\\n     * as the EntryPoint will update the nonce regardless.\\n     * Possible use-case is call it with various keys to \\\"initialize\\\" their nonces to one, so that future\\n     * UserOperations will not pay extra for the first transaction with a given key.\\n     *\\n     * @param key - the \\\"nonce key\\\" to increment the \\\"nonce sequence\\\" for.\\n     */\\n    function incrementNonce(uint192 key) external;\\n}\\n\",\"keccak256\":\"0xee493ae200b8c675bdc0da66f7ac6bb883ecea33672d7d0a95526b9eecdedf87\",\"license\":\"MIT\"},\"@account-abstraction/contracts/interfaces/ISenderCreator.sol\":{\"content\":\"\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\ninterface ISenderCreator {\\n    /**\\n     * @dev Creates a new sender contract.\\n     * @return sender Address of the newly created sender contract.\\n     */\\n    function createSender(bytes calldata initCode) external returns (address sender);\\n\\n    /**\\n     * Use initCallData to initialize an EIP-7702 account.\\n     * The caller is the EntryPoint contract and it is already verified to be an EIP-7702 account.\\n     * Note: Can be called multiple times as long as an appropriate initCode is supplied\\n     *\\n     * @param sender - the 'sender' EIP-7702 account to be initialized.\\n     * @param initCallData - the call data to be passed to the sender account call.\\n     */\\n    function initEip7702Sender(address sender, bytes calldata initCallData) external;\\n}\\n\",\"keccak256\":\"0x677f651d733162b80d1af7901e4f36469e362737a8353d1d0cc7bb94489e4ba4\",\"license\":\"MIT\"},\"@account-abstraction/contracts/interfaces/IStakeManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/**\\n * Manage deposits and stakes.\\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\\n * Stake is value locked for at least \\\"unstakeDelay\\\" by the staked entity.\\n */\\ninterface IStakeManager {\\n    event Deposited(address indexed account, uint256 totalDeposit);\\n\\n    event Withdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    // Emitted when stake or unstake delay are modified.\\n    event StakeLocked(\\n        address indexed account,\\n        uint256 totalStaked,\\n        uint256 unstakeDelaySec\\n    );\\n\\n    // Emitted once a stake is scheduled for withdrawal.\\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\\n\\n    event StakeWithdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @param deposit         - The entity's deposit.\\n     * @param staked          - True if this entity is staked.\\n     * @param stake           - Actual amount of ether staked for this entity.\\n     * @param unstakeDelaySec - Minimum delay to withdraw the stake.\\n     * @param withdrawTime    - First block timestamp where 'withdrawStake' will be callable, or zero if already locked.\\n     * @dev Sizes were chosen so that deposit fits into one cell (used during handleOp)\\n     *      and the rest fit into a 2nd cell (used during stake/unstake)\\n     *      - 112 bit allows for 10^15 eth\\n     *      - 48 bit for full timestamp\\n     *      - 32 bit allows 150 years for unstake delay\\n     */\\n    struct DepositInfo {\\n        uint256 deposit;\\n        bool staked;\\n        uint112 stake;\\n        uint32 unstakeDelaySec;\\n        uint48 withdrawTime;\\n    }\\n\\n    // API struct used by getStakeInfo and simulateValidation.\\n    struct StakeInfo {\\n        uint256 stake;\\n        uint256 unstakeDelaySec;\\n    }\\n\\n    /**\\n     * Get deposit info.\\n     * @param account - The account to query.\\n     * @return info   - Full deposit information of given account.\\n     */\\n    function getDepositInfo(\\n        address account\\n    ) external view returns (DepositInfo memory info);\\n\\n    /**\\n     * Get account balance.\\n     * @param account - The account to query.\\n     * @return        - The deposit (for gas payment) of the account.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * Add to the deposit of the given account.\\n     * @param account - The account to add to.\\n     */\\n    function depositTo(address account) external payable;\\n\\n    /**\\n     * Add to the account's stake - amount and delay\\n     * any pending unstake is first cancelled.\\n     * @param unstakeDelaySec - The new lock duration before the deposit can be withdrawn.\\n     */\\n    function addStake(uint32 unstakeDelaySec) external payable;\\n\\n    /**\\n     * Attempt to unlock the stake.\\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\\n     */\\n    function unlockStake() external;\\n\\n    /**\\n     * Withdraw from the (unlocked) stake.\\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\\n     * @param withdrawAddress - The address to send withdrawn value.\\n     */\\n    function withdrawStake(address payable withdrawAddress) external;\\n\\n    /**\\n     * Withdraw from the deposit.\\n     * @param withdrawAddress - The address to send withdrawn value.\\n     * @param withdrawAmount  - The amount to withdraw.\\n     */\\n    function withdrawTo(\\n        address payable withdrawAddress,\\n        uint256 withdrawAmount\\n    ) external;\\n}\\n\",\"keccak256\":\"0xe48e904fcac02295aad07fbfa1c1d449a74bf44c04e432afef6f34d1ef726ae0\",\"license\":\"MIT\"},\"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/**\\n * User Operation struct\\n * @param sender                - The sender account of this request.\\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\\n * @param initCode              - If set, the account contract will be created by this constructor\\n * @param callData              - The method call to execute on this account.\\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\\n *                                Covers batch overhead.\\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\\n *                                The paymaster will pay for the transaction instead of the sender.\\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n */\\nstruct PackedUserOperation {\\n    address sender;\\n    uint256 nonce;\\n    bytes initCode;\\n    bytes callData;\\n    bytes32 accountGasLimits;\\n    uint256 preVerificationGas;\\n    bytes32 gasFees;\\n    bytes paymasterAndData;\\n    bytes signature;\\n}\\n\",\"keccak256\":\"0xb15188e25e45fe73097e279675b6c0beccbd4133ead2260f8f0c4ba840046800\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC1363.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @title IERC1363\\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\\n *\\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\\n */\\ninterface IERC1363 is IERC20, IERC165 {\\n    /*\\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\\n     * 0xb0202a11 ===\\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\\n     */\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @param data Additional data with no specified format, sent in call to `spender`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9b6b3e7803bc5f2f8cd7ad57db8ac1def61a9930a5a3107df4882e028a9605d7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../utils/introspection/IERC165.sol\\\";\\n\",\"keccak256\":\"0xde7e9fd9aee8d4f40772f96bb3b58836cbc6dfc0227014a061947f8821ea9724\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\n\",\"keccak256\":\"0xce41876e78d1badc0512229b4d14e4daf83bc1003d7f83978d18e0e56f965b9c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xe06a3f08a987af6ad2e1c1e774405d4fe08f1694b67517438b467cecf0da0ef7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC1363} from \\\"../../../interfaces/IERC1363.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    /**\\n     * @dev An operation with an ERC-20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     *\\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\\n     * only sets the \\\"standard\\\" allowance. Any temporary allowance will remain active, in addition to the value being\\n     * set here.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            safeTransfer(token, to, value);\\n        } else if (!token.transferAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferFromAndCallRelaxed(\\n        IERC1363 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransferFrom(token, from, to, value);\\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\\n     * once without retrying, and relies on the returned value to be true.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            forceApprove(token, to, value);\\n        } else if (!token.approveAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            // bubble errors\\n            if iszero(success) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n\\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\\n    }\\n}\\n\",\"keccak256\":\"0x982c5cb790ab941d1e04f807120a71709d4c313ba0bfc16006447ffbd27fbbd5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8\",\"license\":\"MIT\"},\"@safe-global/safe-contracts/contracts/handler/HandlerContext.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/**\\n * @title Handler Context - Allows the fallback handler to extract addition context from the calldata\\n * @dev The fallback manager appends the following context to the calldata:\\n *      1. Fallback manager caller address (non-padded)\\n * based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/f8cc8b844a9f92f63dc55aa581f7d643a1bc5ac1/contracts/metatx/ERC2771Context.sol\\n * @author Richard Meissner - @rmeissner\\n */\\nabstract contract HandlerContext {\\n    /**\\n     * @notice Allows fetching the original caller address.\\n     * @dev This is only reliable in combination with a FallbackManager that supports this (e.g. Safe contract >=1.3.0).\\n     *      When using this functionality make sure that the linked _manager (aka msg.sender) supports this.\\n     *      This function does not rely on a trusted forwarder. Use the returned value only to\\n     *      check information against the calling manager.\\n     * @return sender Original caller address.\\n     */\\n    function _msgSender() internal pure returns (address sender) {\\n        // The assembly code is more direct than the Solidity version using `abi.decode`.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the FallbackManager address\\n     * @return Fallback manager address\\n     */\\n    function _manager() internal view returns (address) {\\n        return msg.sender;\\n    }\\n}\\n\",\"keccak256\":\"0xce6da4c47f8691a4fcf07d20266b1a23ea757e49eedbfcf929f535f3f6e8072d\",\"license\":\"LGPL-3.0-only\"},\"src/SafeInternationalHarbour.sol\":{\"content\":\"// // SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\nimport \\\"./interfaces/Constants.sol\\\";\\nimport \\\"./interfaces/Errors.sol\\\";\\nimport \\\"./interfaces/Types.sol\\\";\\nimport \\\"./interfaces/Events.sol\\\";\\nimport \\\"./libs/CoreLib.sol\\\";\\nimport \\\"./mixins/ERC4337Mixin.sol\\\";\\nimport \\\"./mixins/QuotaMixin.sol\\\";\\n\\n/**\\n * @title SafeInternationalHarbour\\n * @notice Permissionless, append\\u2011only registry that lets **any EOA signer** publish Safe\\n *         transactions (\\\"SafeTx\\\") and their signatures. Clients without an off\\u2011chain indexer can reconstruct the full multisig payload with only:\\n *         1. the Safe address;\\n *         2. the target `chainId`;\\n *         3. the Safe `nonce`; and\\n *         4. the current Safe owners set.\\n *\\n * Each unique `safeTxHash` (EIP\\u2011712 digest of the SafeTx struct) is persisted **once** together with\\n * its parameters. Signatures are appended under the composite key\\n * `(signer, safe, chainId, nonce)`, enabling on\\u2011chain, gas\\u2011efficient look\\u2011ups.\\n *\\n * ### \\u26a0\\ufe0f Contract\\u2011based signers unsupported\\n * Only ECDSA signatures from externally\\u2011owned accounts (EOAs) are supported. Contract wallets that\\n * rely on ERC\\u20111271 or similar cannot be verified on\\u2011chain in a chain\\u2011agnostic way and are therefore\\n * **not supported**.\\n *\\n * @dev The {SignatureStored} event is the only hook required by indexers; however, the contract is\\n *      fully functional without any off\\u2011chain infrastructure.\\n */\\ncontract SafeInternationalHarbour is ERC4337Mixin, QuotaMixin {\\n    // ------------------------------------------------------------------\\n    // Storage\\n    // ------------------------------------------------------------------\\n\\n    /// Mapping `safeTxHash \\u2192 SafeTransaction` parameters\\n    mapping(bytes32 => SafeTransaction) private _txDetails;\\n\\n    /// Mapping `signer \\u2192 safe \\u2192 chainId \\u2192 nonce \\u2192 SignatureDataWithTxHashIndex[]`\\n    /// Stores the list of signatures provided by a signer for a given Safe context.\\n    /// Note: A single list entry here could contain signatures for *different* `safeTxHash` values\\n    /// if those transactions share the same (safe, chainId, nonce). Use `_hasSignerSignedTx`\\n    /// to ensure a signer only signs a specific `safeTxHash` once.\\n    mapping(address signer => mapping(address safe => mapping(uint256 chainId => mapping(uint256 nonce => SignatureDataWithTxHashIndex[]))))\\n        private _sigData;\\n\\n    /// @dev Tracks if a signer has already submitted *any* signature for a specific safeTxHash,\\n    ///      preventing duplicate signatures for the *exact same* transaction digest.\\n    ///      This complements `_sigData` by ensuring uniqueness per (safeTxHash, signer) pair.\\n    /// Mapping `safeTxHash \\u2192 signer \\u2192 bool`\\n    mapping(bytes32 safeTxHash => mapping(address signer => bool))\\n        private _hasSignerSignedTx;\\n\\n    constructor(\\n        ERC4337MixinConfig memory _erc4337Mixinconfig,\\n        QuotaMixinConfig memory _quotaMixinconfig\\n    ) ERC4337Mixin(_erc4337Mixinconfig) QuotaMixin(_quotaMixinconfig) {}\\n\\n    // ------------------------------------------------------------------\\n    // External & public write functions\\n    // ------------------------------------------------------------------\\n\\n    /**\\n     * @notice Publish a Safe transaction and/or append a signature to it.\\n     *\\n     * @dev If `safeTxHash` has been seen before, its parameters are *not* validated nor overwritten \\u2013\\n     *      the call simply appends the `(r,s)` pair for `signer`.\\n     *\\n     * @param safeAddress    Target Safe Smart\\u2011Account.\\n     * @param chainId        Chain id the transaction is meant for.\\n     * @param nonce          Safe nonce.\\n     * @param to             Destination of the inner call/delegatecall.\\n     * @param value          ETH value forwarded by the Safe.\\n     * @param data           Calldata executed by the Safe.\\n     * @param operation      0 = CALL, 1 = DELEGATECALL.\\n     * @param safeTxGas      Gas forwarded to the inner call.\\n     * @param baseGas        Fixed overhead reimbursed to the submitting signer.\\n     * @param gasPrice       Gas price used for reimbursement.\\n     * @param gasToken       ERC\\u201120 token address for refunds (`address(0)` = ETH).\\n     * @param refundReceiver Address receiving the gas refund.\\n     * @param signature      **Single** 65\\u2011byte ECDSA signature.\\n     *\\n     * @return listIndex     Index of the stored signature in the signer\\u2011specific list.\\n     *\\n     * @custom:events Emits {SignatureStored}.\\n     */\\n    function enqueueTransaction(\\n        address safeAddress,\\n        uint256 chainId,\\n        uint256 nonce,\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        uint8 operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address refundReceiver,\\n        bytes calldata signature\\n    ) external returns (uint256 listIndex) {\\n        require(signature.length == 65, InvalidECDSASignatureLength());\\n\\n        // ------------------------------------------------------------------\\n        // Build the EIP\\u2011712 digest that uniquely identifies the SafeTx\\n        // ------------------------------------------------------------------\\n        bytes32 safeTxHash = CoreLib.computeSafeTxHash(\\n            safeAddress,\\n            chainId,\\n            nonce,\\n            to,\\n            value,\\n            data,\\n            operation,\\n            safeTxGas,\\n            baseGas,\\n            gasPrice,\\n            gasToken,\\n            refundReceiver\\n        );\\n\\n        (address signer, bytes32 r, bytes32 vs) = CoreLib.recoverSigner(\\n            safeTxHash,\\n            signature\\n        );\\n\\n        _storeTransaction(\\n            safeTxHash,\\n            safeAddress,\\n            chainId,\\n            nonce,\\n            to,\\n            value,\\n            data,\\n            operation,\\n            safeTxGas,\\n            baseGas,\\n            gasPrice,\\n            gasToken,\\n            refundReceiver\\n        );\\n\\n        // --- DUPLICATE TRANSACTION SIGNATURE CHECK ---\\n        // Revert if this signer has already submitted *any* signature for this *exact* safeTxHash\\n        require(\\n            !_signerSignedTx(safeTxHash, signer),\\n            SignerAlreadySignedTransaction(signer, safeTxHash)\\n        );\\n        return\\n            _storeSignature(\\n                signer,\\n                safeAddress,\\n                chainId,\\n                nonce,\\n                safeTxHash,\\n                r,\\n                vs\\n            );\\n    }\\n\\n    // ------------------------------------------------------------------\\n    // External & public read functions\\n    // ------------------------------------------------------------------\\n\\n    /**\\n     * @notice Retrieve the full parameter set of a Safe transaction.\\n     *\\n     * @param safeTxHash EIP\\u2011712 digest of the transaction.\\n     *\\n     * @return txParams Struct with all SafeTx parameters (zero\\u2011initialised if unknown).\\n     */\\n    function retrieveTransaction(\\n        bytes32 safeTxHash\\n    ) external view returns (SafeTransaction memory txParams) {\\n        txParams = _txDetails[safeTxHash];\\n    }\\n\\n    /**\\n     * @notice Paginated getter for signature entries.\\n     *\\n     * @param signerAddress Address that created the signatures.\\n     * @param safeAddress   Safe Smart\\u2011Account.\\n     * @param chainId       Target chain id.\\n     * @param nonce         Safe nonce.\\n     * @param start         Zero\\u2011based start index of the slice.\\n     * @param count         Maximum number of entries to return.\\n     *\\n     * @return page       Array slice `[start \\u2026 start+count)` (may be shorter).\\n     * @return totalCount Total number of signatures stored for the tuple.\\n     */\\n    function retrieveSignatures(\\n        address signerAddress,\\n        address safeAddress,\\n        uint256 chainId,\\n        uint256 nonce,\\n        uint256 start,\\n        uint256 count\\n    )\\n        external\\n        view\\n        returns (SignatureDataWithTxHashIndex[] memory page, uint256 totalCount)\\n    {\\n        SignatureDataWithTxHashIndex[] storage all = _sigData[signerAddress][\\n            safeAddress\\n        ][chainId][nonce];\\n        totalCount = all.length;\\n        if (start >= totalCount)\\n            return (new SignatureDataWithTxHashIndex[](0), totalCount);\\n\\n        uint256 end = start + count;\\n        if (end > totalCount) end = totalCount;\\n        uint256 len = end - start;\\n\\n        page = new SignatureDataWithTxHashIndex[](len);\\n        for (uint256 i; i < len; ++i) {\\n            page[i] = all[start + i];\\n        }\\n    }\\n\\n    /**\\n     * @notice Convenience getter returning the **number** of signatures stored for the key tuple.\\n     *\\n     * @param signerAddress Signer address.\\n     * @param safeAddress   Safe Smart\\u2011Account.\\n     * @param chainId       Target chain id.\\n     * @param nonce         Safe nonce.\\n     *\\n     * @return count Length of the signature list.\\n     */\\n    function retrieveSignaturesCount(\\n        address signerAddress,\\n        address safeAddress,\\n        uint256 chainId,\\n        uint256 nonce\\n    ) external view returns (uint256 count) {\\n        count = _sigData[signerAddress][safeAddress][chainId][nonce].length;\\n    }\\n\\n    // ------------------------------------------------------------------\\n    // Internal functions\\n    // ------------------------------------------------------------------\\n\\n    /**\\n     * @dev Internal function to store the transaction data and signature after validation.\\n     *\\n     * @param safeTxHash    EIP-712 digest of the transaction.\\n     * @param signer        Signer address to be checked.\\n     */\\n    function _signerSignedTx(\\n        bytes32 safeTxHash,\\n        address signer\\n    ) internal view override returns (bool signed) {\\n        signed = _hasSignerSignedTx[safeTxHash][signer];\\n    }\\n\\n    /**\\n     * @dev Internal function to store the transaction data and signature after validation.\\n     *\\n     * @param safeTxHash     EIP-712 digest of the transaction.\\n     * @param safeAddress    Target Safe Smart\\u2011Account.\\n     * @param chainId        Chain id the transaction is meant for.\\n     * @param nonce          Safe nonce.\\n     * @param to             Destination of the inner call/delegatecall.\\n     * @param value          ETH value forwarded by the Safe.\\n     * @param data           Calldata executed by the Safe.\\n     * @param operation      0 = CALL, 1 = DELEGATECALL.\\n     * @param safeTxGas      Gas forwarded to the inner call.\\n     * @param baseGas        Fixed overhead reimbursed to the submitting signer.\\n     * @param gasPrice       Gas price used for reimbursement.\\n     * @param gasToken       ERC\\u201120 token address for refunds (`address(0)` = ETH).\\n     * @param refundReceiver Address receiving the gas refund.\\n     */\\n    function _storeTransaction(\\n        bytes32 safeTxHash,\\n        address safeAddress,\\n        uint256 chainId,\\n        uint256 nonce,\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        uint8 operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address refundReceiver\\n    ) internal override {\\n        // Store parameters only once (idempotent write)\\n        SafeTransaction storage slot = _txDetails[safeTxHash];\\n        if (!slot.stored) {\\n            // first encounter \\u2192 persist full parameter set\\n            slot.stored = true;\\n            slot.to = to;\\n            slot.operation = operation;\\n\\n            // Writing to storage is expensive, so we only write if the value is non-zero\\n            if (value > 0) {\\n                slot.value = CoreLib.safeCastUint256ToUint128(value);\\n            }\\n            if (safeTxGas > 0) {\\n                slot.safeTxGas = CoreLib.safeCastUint256ToUint128(safeTxGas);\\n            }\\n            if (baseGas > 0) {\\n                slot.baseGas = CoreLib.safeCastUint256ToUint128(baseGas);\\n            }\\n            if (gasPrice > 0) {\\n                slot.gasPrice = CoreLib.safeCastUint256ToUint128(gasPrice);\\n            }\\n            if (gasToken != address(0)) {\\n                slot.gasToken = gasToken;\\n            }\\n            if (refundReceiver != address(0)) {\\n                slot.refundReceiver = refundReceiver;\\n            }\\n            if (data.length > 0) {\\n                slot.data = data;\\n            }\\n\\n            emit NewTransaction(\\n                safeTxHash,\\n                safeAddress,\\n                chainId,\\n                nonce,\\n                to,\\n                value,\\n                operation,\\n                safeTxGas,\\n                baseGas,\\n                gasPrice,\\n                gasToken,\\n                refundReceiver,\\n                data\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to store a signature after validation.\\n     *\\n     * @param signer        Address that signed the transaction.\\n     * @param safeAddress   Target Safe Smart-Account.\\n     * @param chainId       Chain id the transaction is meant for.\\n     * @param nonce         Safe nonce.\\n     * @param safeTxHash    EIP-712 digest of the transaction.\\n     * @param r             First 32 bytes of the signature.\\n     * @param vs            Compact representation of s and v from EIP-2098.\\n     *\\n     * @return listIndex    Index of the stored signature in the signer-specific list.\\n     */\\n    function _storeSignature(\\n        address signer,\\n        address safeAddress,\\n        uint256 chainId,\\n        uint256 nonce,\\n        bytes32 safeTxHash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal override returns (uint256 listIndex) {\\n        _hasSignerSignedTx[safeTxHash][signer] = true;\\n\\n        SignatureDataWithTxHashIndex[] storage list = _sigData[signer][\\n            safeAddress\\n        ][chainId][nonce];\\n        listIndex = list.length;\\n\\n        list.push(\\n            SignatureDataWithTxHashIndex({r: r, vs: vs, txHash: safeTxHash})\\n        );\\n\\n        emit SignatureStored(\\n            signer,\\n            safeAddress,\\n            safeTxHash,\\n            chainId,\\n            nonce,\\n            listIndex\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x50b84c557721ff76b8cc892ebcbd1a2f3131ad260e1d675d18cfe6e75c8d26ef\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/Constants.sol\":{\"content\":\"// // SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\n// ------------------------------------------------------------------\\n// Constants\\n// ------------------------------------------------------------------\\n\\n// The hashes must be the same as the ones in the Safe contract:\\n// https://github.com/safe-global/safe-smart-account/blob/b115c4c5fe23dca6aefeeccc73d312ddd23322c2/contracts/Safe.sol#L54-L63\\n// These should cover Safe versions 1.3.0 and 1.4.1\\n// keccak256(\\\"EIP712Domain(uint256 chainId,address verifyingContract)\\\")\\nbytes32 constant DOMAIN_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\\n\\n// keccak256(\\\"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\\\")\\nbytes32 constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\\n\\n// The lower bound of the S value for a valid secp256k1 signature.\\n// https://github.com/safe-global/safe-smart-account/blob/b115c4c5fe23dca6aefeeccc73d312ddd23322c2/contracts/Safe.sol#L100\\nbytes32 constant SECP256K1_LOW_S_BOUND = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\\n\",\"keccak256\":\"0x8ef29c796b00159d6991fff6e587712411e216e585510d18c18a72a091b46289\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/Errors.sol\":{\"content\":\"// // SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\n// ------------------------------------------------------------------\\n// Errors\\n// ------------------------------------------------------------------\\n\\n/// Thrown when a signature blob is not exactly 65 bytes.\\nerror InvalidECDSASignatureLength();\\n\\n/// Thrown if `ecrecover` yields `address(0)`.\\nerror InvalidSignature();\\n\\n/// Thrown if the S value of the signature is not from the lower half of the curve.\\nerror InvalidSignatureSValue();\\n\\n/// Thrown when a value doesn't fit in a uint128.\\nerror ValueDoesNotFitInUint128();\\n\\n/// @notice Thrown when attempting to store a signature for a transaction (safeTxHash)\\n/// that the signer has already provided a signature for.\\n/// @param signer Signer address.\\n/// @param safeTxHash The EIP-712 hash of the Safe transaction.\\nerror SignerAlreadySignedTransaction(address signer, bytes32 safeTxHash);\\nerror InvalidTarget(bytes4 targetSelector);\\nerror InvalidEntryPoint(address entryPoint);\\nerror InvalidUserOpPaymasterAndData();\\nerror UnexpectedSafeTxHash(bytes32 expectedSafeTxHash);\\nerror UnexpectedSigner(address recoveredSigner);\\nerror UnexpectedSignatureR(bytes32 extractedR);\\nerror UnexpectedSignatureVS(bytes32 extractedVS);\\nerror UnexpectedNonce(uint256 expectedNonce);\\n\",\"keccak256\":\"0x3a8771c51838773205f82d750462db6383a511106780a4ed2ceb8d9de5bb335c\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/Events.sol\":{\"content\":\"// // SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\n// ------------------------------------------------------------------\\n// Events\\n// ------------------------------------------------------------------\\n\\n/**\\n * @notice Emitted whenever a new signature is stored (and possibly the parameters on first sight).\\n *\\n * @param signer     Address recovered from the provided signature.\\n * @param safe       Safe Smart\\u2011Account the transaction targets.\\n * @param safeTxHash EIP\\u2011712 hash identifying the SafeTx.\\n * @param chainId    Intended execution chain.\\n * @param nonce      Safe nonce.\\n * @param listIndex  Position of the signature in the signer\\u2011specific array.\\n */\\nevent SignatureStored(\\n    address indexed signer,\\n    address indexed safe,\\n    bytes32 indexed safeTxHash,\\n    uint256 chainId,\\n    uint256 nonce,\\n    uint256 listIndex\\n);\\n\\n/**\\n * @notice Emitted when a transaction is first stored.\\n * @param safeTxHash EIP-712 hash identifying the SafeTx.\\n * @param safe       Safe Smart-Account the transaction targets.\\n * @param chainId    Intended execution chain.\\n * @param nonce      Safe nonce.\\n * @param to         Destination of the inner call/delegatecall.\\n * @param value      ETH value forwarded by the Safe.\\n * @param operation  0 = CALL, 1 = DELEGATECALL.\\n * @param safeTxGas  Gas forwarded to the inner call.\\n * @param baseGas    Fixed overhead reimbursed to the submitting signer.\\n * @param gasPrice   Gas price used for reimbursement.\\n * @param gasToken   ERC-20 token address for refunds.\\n * @param refundReceiver Address receiving the gas refund.\\n * @param data       Calldata executed by the Safe.\\n */\\nevent NewTransaction(\\n    bytes32 indexed safeTxHash,\\n    address indexed safe,\\n    uint256 indexed chainId,\\n    uint256 nonce,\\n    address to,\\n    uint256 value,\\n    uint8 operation,\\n    uint256 safeTxGas,\\n    uint256 baseGas,\\n    uint256 gasPrice,\\n    address gasToken,\\n    address refundReceiver,\\n    bytes data\\n);\\n\",\"keccak256\":\"0xf112b2c24c05b2b273be09ba30237c0d5b9f5f2e11450f174cb7ac093941aea2\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/HarbourStore.sol\":{\"content\":\"// // SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\nabstract contract IHarbourStore {\\n    /**\\n     * @dev Internal function to store the transaction data and signature after validation.\\n     *\\n     * @param safeTxHash    EIP-712 digest of the transaction.\\n     * @param signer        Signer address to be checked.\\n     */\\n    function _signerSignedTx(\\n        bytes32 safeTxHash,\\n        address signer\\n    ) internal view virtual returns (bool signed);\\n\\n    /**\\n     * @dev Internal function to store a signature after validation.\\n     *\\n     * @param signer        Address that signed the transaction.\\n     * @param safeAddress   Target Safe Smart-Account.\\n     * @param chainId       Chain id the transaction is meant for.\\n     * @param nonce         Safe nonce.\\n     * @param safeTxHash    EIP-712 digest of the transaction.\\n     * @param r             First 32 bytes of the signature.\\n     * @param vs            Compact representation of s and v from EIP-2098.\\n     *\\n     * @return listIndex    Index of the stored signature in the signer-specific list.\\n     */\\n    function _storeSignature(\\n        address signer,\\n        address safeAddress,\\n        uint256 chainId,\\n        uint256 nonce,\\n        bytes32 safeTxHash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal virtual returns (uint256 listIndex);\\n\\n    /**\\n     * @dev Internal function to store the transaction data and signature after validation.\\n     *\\n     * @param safeTxHash     EIP-712 digest of the transaction.\\n     * @param safeAddress    Target Safe Smart\\u2011Account.\\n     * @param chainId        Chain id the transaction is meant for.\\n     * @param nonce          Safe nonce.\\n     * @param to             Destination of the inner call/delegatecall.\\n     * @param value          ETH value forwarded by the Safe.\\n     * @param data           Calldata executed by the Safe.\\n     * @param operation      0 = CALL, 1 = DELEGATECALL.\\n     * @param safeTxGas      Gas forwarded to the inner call.\\n     * @param baseGas        Fixed overhead reimbursed to the submitting signer.\\n     * @param gasPrice       Gas price used for reimbursement.\\n     * @param gasToken       ERC\\u201120 token address for refunds (`address(0)` = ETH).\\n     * @param refundReceiver Address receiving the gas refund.\\n     */\\n    function _storeTransaction(\\n        bytes32 safeTxHash,\\n        address safeAddress,\\n        uint256 chainId,\\n        uint256 nonce,\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        uint8 operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address refundReceiver\\n    ) internal virtual;\\n}\\n\",\"keccak256\":\"0x8b5220db76af351dee1fb783fe30f7c36d9f2d73c81582396bf0cf1b4da93bf3\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/QuotaManager.sol\":{\"content\":\"// // SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\nabstract contract IQuotaManager {\\n    function _checkAndUpdateQuota(\\n        address signer,\\n        uint256 requiredQuota\\n    ) internal virtual returns (bool);\\n}\\n\",\"keccak256\":\"0xf1d8620e73f18772172db809d33b5d8ce007277f8ff1d243c289ca8d78b1db88\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/Types.sol\":{\"content\":\"// // SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\n// ------------------------------------------------------------------\\n// Data structures\\n// ------------------------------------------------------------------\\n\\n/**\\n * @dev Storage optimised mirror of the SafeTx struct used by Safe contracts.\\n *      Non-optimised version uses uint256 for:\\n *      - value\\n *      - safeTxGas\\n *      - baseGas\\n *      - gasPrice\\n */\\nstruct SafeTransaction {\\n    // stored, operation and to will be packed into the same storage slot\\n    bool stored;\\n    uint8 operation;\\n    address to;\\n    uint128 value;\\n    uint128 safeTxGas;\\n    uint128 baseGas;\\n    uint128 gasPrice;\\n    address gasToken;\\n    address refundReceiver;\\n    bytes data;\\n}\\n\\n/**\\n * @dev Minimal, storage\\u2011optimised representation of an ECDSA signature.\\n */\\nstruct SignatureDataWithTxHashIndex {\\n    bytes32 r;\\n    // vs is the compact representation of s and v coming from\\n    // EIP-2098: https://eips.ethereum.org/EIPS/eip-2098\\n    bytes32 vs;\\n    bytes32 txHash; // EIP\\u2011712 digest this signature belongs to\\n}\\n\",\"keccak256\":\"0x91d6cff0d7c1bacd7c4c4cb6c6ea3f64c58a2e6461e8e77f4a9c222953d44830\",\"license\":\"GPL-3.0-only\"},\"src/libs/CoreLib.sol\":{\"content\":\"// // SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\nimport \\\"../interfaces/Constants.sol\\\";\\nimport \\\"../interfaces/Types.sol\\\";\\nimport \\\"../interfaces/Errors.sol\\\";\\nimport \\\"../interfaces/Events.sol\\\";\\n\\nlibrary CoreLib {\\n    // ------------------------------------------------------------------\\n    // Internal functions\\n    // ------------------------------------------------------------------\\n\\n    /**\\n     * @notice Computes the unique EIP-712 digest for a SafeTx using the provided parameters and domain.\\n     * @param safeAddress Address of the target Safe Smart Account.\\n     * @param chainId Chain ID included in the domain separator.\\n     * @param nonce Safe transaction nonce.\\n     * @param to Target address the Safe will call.\\n     * @param value ETH value to be sent with the call.\\n     * @param data Call data executed by the Safe.\\n     * @param operation Operation type: 0 = CALL, 1 = DELEGATECALL.\\n     * @param safeTxGas Gas limit for the Safe's internal execution.\\n     * @param baseGas Base gas overhead for reimbursement.\\n     * @param gasPrice Gas price used for reimbursement calculation.\\n     * @param gasToken Token address for refunds (0x0 for ETH).\\n     * @param refundReceiver Address to receive gas refunds.\\n     * @return safeTxHash Keccak256 digest of the EIP-712 encoded SafeTx.\\n     */\\n    function computeSafeTxHash(\\n        address safeAddress,\\n        uint256 chainId,\\n        uint256 nonce,\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        uint8 operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address refundReceiver\\n    ) internal pure returns (bytes32 safeTxHash) {\\n        bytes32 domainSeparator = keccak256(\\n            abi.encode(DOMAIN_TYPEHASH, chainId, safeAddress)\\n        );\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                SAFE_TX_TYPEHASH,\\n                to,\\n                value,\\n                keccak256(data),\\n                operation,\\n                safeTxGas,\\n                baseGas,\\n                gasPrice,\\n                gasToken,\\n                refundReceiver,\\n                nonce\\n            )\\n        );\\n        safeTxHash = keccak256(\\n            abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash)\\n        );\\n    }\\n\\n    /**\\n     * @notice Splits a 65-byte ECDSA signature into its components and recovers the signer address.\\n     * @param digest The message or data hash to verify (EIP-712 digest or eth_sign prefixed).\\n     * @param sig Concatenated 65-byte ECDSA signature (r || s || v).\\n     * @return signer The address that produced the signature (EOA).\\n     * @return r First 32 bytes of the ECDSA signature.\\n     * @return vs Compact representation of s and v coming from EIP-2098.\\n     * @dev Supports both EIP-712 and eth_sign flows by detecting v > 30 and applying the Ethereum Signed Message prefix.\\n     */\\n    function recoverSigner(\\n        bytes32 digest,\\n        bytes calldata sig\\n    ) internal pure returns (address signer, bytes32 r, bytes32 vs) {\\n        uint8 v;\\n        bytes32 s;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            r := calldataload(sig.offset)\\n            s := calldataload(add(sig.offset, 0x20))\\n            v := byte(0, calldataload(add(sig.offset, 0x40)))\\n        }\\n        require(s <= SECP256K1_LOW_S_BOUND, InvalidSignatureSValue());\\n\\n        signer = ecrecover(digest, v, r, s);\\n        require(signer != address(0), InvalidSignature());\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            // Equivalent to:\\n            // vs = bytes32(uint256(v - 27)  << 255 | uint256(s));\\n            // Which should avoid conversion between uint256 and bytes32\\n            vs := or(shl(255, sub(v, 27)), s)\\n        }\\n    }\\n\\n    function safeCastUint256ToUint128(\\n        uint256 value\\n    ) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, ValueDoesNotFitInUint128());\\n        return uint128(value);\\n    }\\n}\\n\",\"keccak256\":\"0xa9d1e95de49f1688b74d5f1a53d80eeb70299d163187b6835d8f68d75ad02d45\",\"license\":\"GPL-3.0-only\"},\"src/mixins/ERC4337Mixin.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\nimport {\\n    HandlerContext\\n} from \\\"@safe-global/safe-contracts/contracts/handler/HandlerContext.sol\\\";\\nimport {IAccount} from \\\"@account-abstraction/contracts/interfaces/IAccount.sol\\\";\\nimport {\\n    IEntryPoint\\n} from \\\"@account-abstraction/contracts/interfaces/IEntryPoint.sol\\\";\\nimport {\\n    PackedUserOperation\\n} from \\\"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\\\";\\nimport {\\n    _packValidationData\\n} from \\\"@account-abstraction/contracts/core/Helpers.sol\\\";\\nimport {\\n    UserOperationLib\\n} from \\\"@account-abstraction/contracts/core/UserOperationLib.sol\\\";\\nimport \\\"../interfaces/Errors.sol\\\";\\nimport \\\"../interfaces/HarbourStore.sol\\\";\\nimport \\\"../interfaces/QuotaManager.sol\\\";\\nimport \\\"../libs/CoreLib.sol\\\";\\n\\nabstract contract ERC4337Mixin is IAccount, IHarbourStore, IQuotaManager {\\n    using UserOperationLib for PackedUserOperation;\\n\\n    struct ERC4337MixinConfig {\\n        address entryPoint;\\n        uint256 maxPriorityFee;\\n        uint256 preVerificationGasPerByte;\\n        uint256 preVerificationBaseGas;\\n        uint256 verificationGasPerByte;\\n        uint256 callGasPerByte;\\n    }\\n\\n    // ------------------------------------------------------------------\\n    // 4337 functions\\n    // ------------------------------------------------------------------\\n\\n    /**\\n     * @notice The address of the EntryPoint contract supported by this module.\\n     */\\n    address public immutable SUPPORTED_ENTRYPOINT;\\n    // TODO evaluate if this should be upgradable\\n    uint256 public immutable MAX_PRIORITY_FEE;\\n    uint256 public immutable PRE_VERIFICATION_GAS_PER_BYTE;\\n    uint256 public immutable PRE_VERIFICATION_BASE_GAS;\\n    uint256 public immutable VERIFICATION_GAS_PER_BYTE;\\n    uint256 public immutable CALL_GAS_PER_BYTE;\\n\\n    constructor(ERC4337MixinConfig memory _config) {\\n        SUPPORTED_ENTRYPOINT = _config.entryPoint;\\n        MAX_PRIORITY_FEE = _config.maxPriorityFee;\\n        PRE_VERIFICATION_GAS_PER_BYTE = _config.preVerificationGasPerByte;\\n        PRE_VERIFICATION_BASE_GAS = _config.preVerificationBaseGas;\\n        VERIFICATION_GAS_PER_BYTE = _config.verificationGasPerByte;\\n        CALL_GAS_PER_BYTE = _config.callGasPerByte;\\n    }\\n\\n    /**\\n     * Return the account nonce.\\n     * This method returns the next sequential nonce.\\n     * For a nonce of a specific key, use `entrypoint.getNonce(account, key)`\\n     */\\n    function getNonce(address signer) public view virtual returns (uint256) {\\n        return\\n            IEntryPoint(SUPPORTED_ENTRYPOINT).getNonce(\\n                address(this),\\n                uint192(uint160(signer))\\n            );\\n    }\\n\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32,\\n        uint256\\n    ) external override returns (uint256 validationData) {\\n        // Assumption:\\n        //   - UserOp signature is SafeTx signature\\n        // Requirements:\\n        //   - [x] Check entrypoint\\n        //   - [x] No paymaster support\\n        // Steps:\\n        //   - [x] decode callData\\n        //   - [x] recover signer from SafeTx signature\\n        //   - [x] check that signer has not submitted signature\\n        //   - [x] check that nonce key is signer address\\n        //   - [x] check limits on fee params\\n        //   - [ ] usage checks\\n\\n        require(\\n            msg.sender == SUPPORTED_ENTRYPOINT,\\n            InvalidEntryPoint(msg.sender)\\n        );\\n        require(\\n            userOp.paymasterAndData.length == 0,\\n            InvalidUserOpPaymasterAndData()\\n        );\\n        require(userOp.signature.length == 65, InvalidECDSASignatureLength());\\n\\n        require(\\n            bytes4(userOp.callData) == this.storeTransaction.selector,\\n            InvalidTarget(bytes4(userOp.callData))\\n        );\\n        (\\n            bytes32 safeTxHash,\\n            address signer,\\n            bytes32 r,\\n            bytes32 vs,\\n            uint256 computedDataLength\\n        ) = _verifySafeTxData(userOp.callData[4:]);\\n\\n        // --- DUPLICATE TRANSACTION SIGNATURE CHECK ---\\n        // Revert if this signer has already submitted *any* signature for this *exact* safeTxHash\\n        require(\\n            !_signerSignedTx(safeTxHash, signer),\\n            SignerAlreadySignedTransaction(signer, safeTxHash)\\n        );\\n\\n        _verifySignature(safeTxHash, userOp.signature, signer, r, vs);\\n\\n        uint256 nonce = getNonce(signer);\\n        require(userOp.nonce == nonce, UnexpectedNonce(nonce));\\n\\n        // We skip the check that missingAccountFunds should be == 0, as this is the job of the entry point\\n\\n        // `computedDataLength` is used for validations, as userOp.callData can be extended to manipulate the fees\\n        bool validationFailed = !_validGasFees(userOp) ||\\n            !_validGasLimits(userOp, computedDataLength) ||\\n            !_checkAndUpdateQuota(signer, computedDataLength);\\n        return _packValidationData(validationFailed, 0, 0);\\n    }\\n\\n    function _validGasFees(\\n        PackedUserOperation calldata userOp\\n    ) private view returns (bool) {\\n        uint256 maxPriorityFeePerGas = userOp.unpackMaxPriorityFeePerGas();\\n        return maxPriorityFeePerGas <= MAX_PRIORITY_FEE;\\n    }\\n\\n    function _validGasLimits(\\n        PackedUserOperation calldata userOp,\\n        uint256 computedDataLength\\n    ) private view returns (bool) {\\n        // Base calculations of gas limits on calldata size, this is a simple workaround for now\\n        //      -> an alernative for verificationGas could be to do internal gas metering\\n        // Employ a maximum gas limit based on locked tokens\\n        if (\\n            userOp.preVerificationGas >\\n            computedDataLength *\\n                PRE_VERIFICATION_GAS_PER_BYTE +\\n                PRE_VERIFICATION_BASE_GAS\\n        ) return false;\\n        uint256 verificationGasLimit = userOp.unpackVerificationGasLimit();\\n        if (\\n            verificationGasLimit >\\n            computedDataLength * VERIFICATION_GAS_PER_BYTE\\n        ) return false;\\n        uint256 callGasLimit = userOp.unpackCallGasLimit();\\n        if (callGasLimit > computedDataLength * CALL_GAS_PER_BYTE) return false;\\n        return true;\\n    }\\n\\n    function _verifySafeTxData(\\n        bytes calldata callData\\n    ) private pure returns (bytes32, address, bytes32, bytes32, uint256) {\\n        (\\n            bytes32 safeTxHash,\\n            address safeAddress,\\n            uint256 chainId,\\n            uint256 nonce,\\n            address to,\\n            uint256 value,\\n            bytes memory data,\\n            uint8 operation,\\n            uint256 safeTxGas,\\n            uint256 baseGas,\\n            uint256 gasPrice,\\n            address gasToken,\\n            address refundReceiver,\\n            address signer,\\n            bytes32 r,\\n            bytes32 vs\\n        ) = abi.decode(\\n                callData,\\n                (\\n                    bytes32,\\n                    address,\\n                    uint256,\\n                    uint256,\\n                    address,\\n                    uint256,\\n                    bytes,\\n                    uint8,\\n                    uint256,\\n                    uint256,\\n                    uint256,\\n                    address,\\n                    address,\\n                    address,\\n                    bytes32,\\n                    bytes32\\n                )\\n            );\\n        bytes32 computedSafeTxHash = CoreLib.computeSafeTxHash(\\n            safeAddress,\\n            chainId,\\n            nonce,\\n            to,\\n            value,\\n            data,\\n            operation,\\n            safeTxGas,\\n            baseGas,\\n            gasPrice,\\n            gasToken,\\n            refundReceiver\\n        );\\n\\n        require(\\n            computedSafeTxHash == safeTxHash,\\n            UnexpectedSafeTxHash(computedSafeTxHash)\\n        );\\n        // The computed length when properly encoded is based on the data length and the number of params\\n        // 4 bytes selector + 15 params each 32 bytes + 32 bytes offset of data + 32 bytes length of data + data length + 32 bytes buffer for padding\\n        return (safeTxHash, signer, r, vs, data.length + 18 * 32 + 4);\\n    }\\n\\n    function _verifySignature(\\n        bytes32 safeTxHash,\\n        bytes calldata signature,\\n        address signer,\\n        bytes32 r,\\n        bytes32 vs\\n    ) private pure {\\n        (\\n            address recoveredSigner,\\n            bytes32 extractedR,\\n            bytes32 extractedVS\\n        ) = CoreLib.recoverSigner(safeTxHash, signature);\\n        require(signer == recoveredSigner, UnexpectedSigner(signer));\\n        require(r == extractedR, UnexpectedSignatureR(r));\\n        require(vs == extractedVS, UnexpectedSignatureVS(vs));\\n    }\\n\\n    function storeTransaction(\\n        bytes32 safeTxHash,\\n        address safeAddress,\\n        uint256 chainId,\\n        uint256 nonce,\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        uint8 operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address refundReceiver,\\n        address signer,\\n        bytes32 r,\\n        bytes32 vs\\n    ) external returns (uint256 listIndex) {\\n        require(\\n            msg.sender == SUPPORTED_ENTRYPOINT,\\n            InvalidEntryPoint(msg.sender)\\n        );\\n        _storeTransaction(\\n            safeTxHash,\\n            safeAddress,\\n            chainId,\\n            nonce,\\n            to,\\n            value,\\n            data,\\n            operation,\\n            safeTxGas,\\n            baseGas,\\n            gasPrice,\\n            gasToken,\\n            refundReceiver\\n        );\\n        return\\n            _storeSignature(\\n                signer,\\n                safeAddress,\\n                chainId,\\n                nonce,\\n                safeTxHash,\\n                r,\\n                vs\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x291a391085b500c8926f7f861520e7611bee892bf6a90301535adc663a6b2000\",\"license\":\"GPL-3.0-only\"},\"src/mixins/QuotaMixin.sol\":{\"content\":\"// // SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\nimport {\\n    SafeERC20\\n} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../interfaces/QuotaManager.sol\\\";\\nimport \\\"../libs/CoreLib.sol\\\";\\n\\nstruct QuotaStats {\\n    uint128 tokenBalance; // uint96 might also be enough, as this would be more tokens than most project have in circulation\\n    uint64 usedQuota; // Quota is limited to 64 bits (current Quota == Bytes of data, so that should be ok)\\n    uint64 nextQuotaReset; // timestamps are Safe to limit to 64 bits\\n}\\n\\nabstract contract QuotaMixin is IQuotaManager {\\n    using SafeERC20 for IERC20;\\n\\n    event Withdraw(address indexed signer, uint256 indexed amount);\\n    event Deposit(address indexed signer, uint256 indexed amount);\\n\\n    struct QuotaMixinConfig {\\n        uint64 timeframeQuotaReset;\\n        uint16 requiredQuotaMultiplier;\\n        uint32 quotaPerDepositedFeeToken;\\n        uint32 maxFreeQuota;\\n        address feeToken;\\n        uint8 feeTokenDecimals;\\n    }\\n\\n    mapping(address => QuotaStats) public quotaStatsForSigner;\\n    mapping(address => mapping(bytes32 => uint256)) public withdrawsForSigner;\\n\\n    uint64 public immutable TIMEFRAME_QUOTA_RESET;\\n    uint32 public immutable FREE_QUOTA_PER_DEPOSITED_FEE_TOKEN;\\n    uint16 public immutable REQUIRED_QUOTA_MULTIPLIER;\\n    uint32 public immutable MAX_FREE_QUOTA;\\n    address public immutable FEE_TOKEN;\\n    uint8 public immutable FEE_TOKEN_DECIMALS;\\n\\n    constructor(QuotaMixinConfig memory _config) {\\n        TIMEFRAME_QUOTA_RESET = _config.timeframeQuotaReset;\\n        FREE_QUOTA_PER_DEPOSITED_FEE_TOKEN = _config\\n            .quotaPerDepositedFeeToken;\\n        REQUIRED_QUOTA_MULTIPLIER = _config.requiredQuotaMultiplier;\\n        MAX_FREE_QUOTA = _config.maxFreeQuota;\\n        FEE_TOKEN = _config.feeToken;\\n        FEE_TOKEN_DECIMALS = _config.feeTokenDecimals;\\n    }\\n\\n    function depositTokensForSigner(\\n        address signer,\\n        uint128 amount\\n    ) public {\\n        // We don't update the nextQuotaReset this way depositing more tokens does not negatively affect the reset schedule\\n        // The reset schedule always starts from 0, therefore is always a multiple of the reset timeframe (unless the timeframe is changed)\\n        quotaStatsForSigner[signer].tokenBalance += amount;\\n        IERC20(FEE_TOKEN).safeTransferFrom(msg.sender, address(this), amount);\\n        emit Deposit(signer, amount);\\n    }\\n\\n    function computeWithdrawHash(\\n        uint256 amount,\\n        address beneficiary,\\n        uint256 nonce\\n    ) internal view returns (bytes32 withdrawHash) {\\n        bytes32 domainSeparator = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"WithdrawRequest(uint256 amount,address beneficiary,uint256 nonce)\\\"\\n                ),\\n                amount,\\n                beneficiary,\\n                nonce\\n            )\\n        );\\n        withdrawHash = keccak256(\\n            abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash)\\n        );\\n    }\\n\\n    function widthdrawTokensForSigner(\\n        bytes calldata signature,\\n        uint128 amount,\\n        address beneficiary,\\n        uint256 nonce\\n    ) public payable {\\n        bytes32 withdrawHash = computeWithdrawHash(amount, beneficiary, nonce);\\n        (address signer,,) = CoreLib.recoverSigner(\\n            withdrawHash,\\n            signature\\n        );\\n        // Check that withdrawal was not executed yet\\n        require(withdrawsForSigner[signer][withdrawHash] == 0, \\\"Withdrawal was already performed\\\");\\n        withdrawsForSigner[signer][withdrawHash] = block.timestamp;\\n\\n        QuotaStats storage stats = quotaStatsForSigner[signer];\\n        require(stats.tokenBalance >= amount, \\\"Insufficient Tokens\\\");\\n        // We use the quota reset timeframe as a unlock timeframe\\n        // -> currently the signer is not allowed to sign any Safe transaction during this timeframe\\n        // TODO: have dedicated unlock logic (also to avoid some fee exploit flows)\\n        require(\\n            stats.nextQuotaReset < block.timestamp,\\n            \\\"Tokens have been used during this timeframe\\\"\\n        );\\n\\n        stats.tokenBalance -= amount;\\n\\n        IERC20(FEE_TOKEN).safeTransfer(beneficiary, amount);\\n        emit Withdraw(signer, amount);\\n    }\\n\\n    function availableFreeQuotaForSigner(\\n        address signer\\n    )\\n        public\\n        view\\n        returns (\\n            uint64 availableFreeQuota,\\n            uint64 usedSignerQuota,\\n            uint64 nextSignerQuotaReset\\n        )\\n    {\\n        QuotaStats memory stats = quotaStatsForSigner[signer];\\n        nextSignerQuotaReset = stats.nextQuotaReset;\\n        if (nextSignerQuotaReset > block.timestamp) {\\n            usedSignerQuota = stats.usedQuota;\\n        } else {\\n            // Signer quota should be reset (therefore be 0)\\n            usedSignerQuota = 0;\\n            // The reset time should always be aligned with the timeframe (be a multiple)\\n            // First the time difference since the last reset is calculated (last reset - block time)\\n            // Then the elablesed time in the current timeframe (modulo with timeframe duration)\\n            // Then substract this from the current blocktime to get the start of the current timeframe\\n            // And lastly add the timeframe duration to get the starting point of the next timeframe\\n            uint64 blocktime = uint64(block.timestamp);\\n            nextSignerQuotaReset = blocktime -\\n                ((blocktime - nextSignerQuotaReset) % TIMEFRAME_QUOTA_RESET) +\\n                TIMEFRAME_QUOTA_RESET;\\n        }\\n        // We cast tokenBalance to uint256 to use more bits for the arithmetics\\n        uint256 maxSignerQuota = (uint256(stats.tokenBalance) *\\n            FREE_QUOTA_PER_DEPOSITED_FEE_TOKEN) / 10 ** FEE_TOKEN_DECIMALS;\\n\\n        require(\\n            maxSignerQuota <= type(uint64).max,\\n            \\\"Max signer quota too high\\\"\\n        );\\n\\n        uint64 freeSignerQuota = uint64(maxSignerQuota);\\n        if (freeSignerQuota > MAX_FREE_QUOTA) {\\n            freeSignerQuota = MAX_FREE_QUOTA;\\n        }\\n        if (usedSignerQuota <= freeSignerQuota) {\\n            availableFreeQuota = freeSignerQuota - usedSignerQuota;\\n        } else {\\n            availableFreeQuota = 0;\\n        }\\n    }\\n\\n    function _updateQuotaParams(\\n        address signer,\\n        uint64 newSignerQuota,\\n        uint64 nextSignerQuotaReset\\n    ) internal {\\n        QuotaStats storage stats = quotaStatsForSigner[signer];\\n        if (nextSignerQuotaReset != stats.nextQuotaReset) {\\n            stats.nextQuotaReset = nextSignerQuotaReset;\\n        }\\n        stats.usedQuota = newSignerQuota;\\n    }\\n\\n    function _checkAndUpdateQuota(\\n        address signer,\\n        uint256 requiredSignerQuota\\n    ) internal override returns (bool) {\\n        if (REQUIRED_QUOTA_MULTIPLIER == 0) return true;\\n        (\\n            uint64 availableFreeSignerQuota,\\n            uint64 usedSignerQuota,\\n            uint64 nextSignerQuotaReset\\n        ) = availableFreeQuotaForSigner(signer);\\n        uint256 adjustedRequiredSignerQuota = REQUIRED_QUOTA_MULTIPLIER *\\n            requiredSignerQuota;\\n        if (adjustedRequiredSignerQuota > availableFreeSignerQuota)\\n            return false;\\n        // Casting to uint64 is safe, as availableFreeSignerQuota is at most a uint64 and we compare it against that\\n        _updateQuotaParams(\\n            signer,\\n            usedSignerQuota + uint64(adjustedRequiredSignerQuota),\\n            nextSignerQuotaReset\\n        );\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0xea706fe9235554456750c83864ed21bac76475c91740b92c5f2adb9ae5705584\",\"license\":\"GPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x6102006040523461028e5760405161337b38819003601f8101601f191683016001600160401b038111848210176102925783928291604052833981010390610180821261028e5760c0821261028e576100566102a6565b90610060816102c5565b82526020810151926020830193845260408201519060408401918252606083015194606085019586526080840151946080810195865260c060a08601519360a0830194855260bf19011261028e576100b66102a6565b60c08601519091906001600160401b038116810361028e57825260e08601519161ffff8316830361028e57602081019283526100f561010088016102d9565b906040810191825261010a61012089016102d9565b95606082019687526101606101226101408b016102c5565b99608084019a8b5201519960ff8b168b0361028e5760a08381019b8c5294516001600160a01b039081166080529651909452965160c052985160e05290516101005293516101205295516001600160401b031661014052915163ffffffff90811661016052945161ffff1661018052519093166101a052519091166101c0525160ff166101e05260405161309090816102eb823960805181818161022b0152818161145101528181611b960152612105015260a05181818161057201526117a6015260c0518181816112a8015261251c015260e051818181610c55015261254301526101005181818161112c015261257c0152610120518181816105ca01526125c101526101405181818161118d01526123d4015261016051818181610bfc0152612256015261018051818181610625015261260101526101a0518181816111eb01526122d301526101c05181818161097a01526110d301526101e051818181610caf01526122800152f35b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b6040519060c082016001600160401b0381118382101761029257604052565b51906001600160a01b038216820361028e57565b519063ffffffff8216820361028e5756fe60a0806040526004361015610012575f80fd5b5f3560e01c908163137e051e14611b4e575080631573a55d14611aaa5780631846652a1461196c57806319822f7c146113c35780632220debb1461130c5780632d0335ab146112cb57806339ba5c8a14611273578063519e98151461120f57806353f74a10146111b15780636f9bb7bd1461114f578063700e4ca9146110f757806373717b081461108957806375f398fe14610d425780637eec7d6814610cd357806388ee6cf414610c785780639229f4cf14610c205780639f9b5ef414610bc2578063a3be4d7b14610b32578063b930d9ad14610649578063c0f06efd146105ed578063c7efacb114610595578063c90e34461461053d578063dd030c67146102885763e1ea48fc14610124575f80fd5b34610284576102007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845760043561015f611bdd565b60443590606435916084359373ffffffffffffffffffffffffffffffffffffffff851685036102845760c43567ffffffffffffffff8111610284576101a8903690600401611c43565b94909260e43560ff81168103610284576101c0611c00565b610184359073ffffffffffffffffffffffffffffffffffffffff82168203610284576101a4359673ffffffffffffffffffffffffffffffffffffffff881688036102845760209a8961026d9561027c9c6102523373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163314611c71565b61014435948b61012435958c8c610104359760a435946128c2565b6101e435946101c43594612e0b565b604051908152f35b5f80fd5b34610284576101a07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610284576102c0611bba565b60643573ffffffffffffffffffffffffffffffffffffffff811681036102845760a43567ffffffffffffffff811161028457610300903690600401611c43565b909260c435919060ff8316830361028457610144359073ffffffffffffffffffffffffffffffffffffffff821682036102845761033b611c00565b93610184359467ffffffffffffffff8611610284576103606041963690600401611c43565b96909603610515576103998185610124358b89878d610388610104359460e43594369161248f565b90608435906044356024358e612746565b937f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a06020880135116104ed5760205f608060405188815260408b0135831a848201528a356040820152838b0135606082015282805260015afa156104e2575f519573ffffffffffffffffffffffffffffffffffffffff8716156104ba5760209961027c99610440956101243593610104359360e43593608435906044356024358d8f6128c2565b815f526004865260405f2073ffffffffffffffffffffffffffffffffffffffff84165f528652610479828460ff60405f20541615611d72565b858401357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe560408601355f1a0160ff1b179335926044359160243591612e0b565b7f8baa579f000000000000000000000000000000000000000000000000000000005f5260045ffd5b6040513d5f823e3d90fd5b7f617cf474000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f85e6258e000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457602060405161ffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b60807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845760043567ffffffffffffffff811161028457610693903690600401611c43565b5061069c611c24565b906044359173ffffffffffffffffffffffffffffffffffffffff8316809303610284576fffffffffffffffffffffffffffffffff169160405160208101907f47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218825246604082015230606082015260608152610718608082611e26565b5190206107b46107e060405160208101907ff004bebf3ce3a32f609e24232a25277f97bc1a0843e36f180d0e414dd5a65b7a825287604082015285606082015260643560808201526080815261076f60a082611e26565b51902060405192839160208301958690916042927f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201520190565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101835282611e26565b519020916020810135907f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a082116104ed5760805f91602093604051918783526040810135851a86840152356040830152606082015282805260015afa156104e25773ffffffffffffffffffffffffffffffffffffffff5f51169182156104ba57825f52600160205260405f20815f5260205260405f2054610ad457825f52600160205260405f20905f526020524260405f2055815f525f60205260405f209081546fffffffffffffffffffffffffffffffff811690858210610a7657429060c01c10156109f257849003916fffffffffffffffffffffffffffffffff83116109c5576fffffffffffffffffffffffffffffffff61099f93167fffffffffffffffffffffffffffffffff00000000000000000000000000000000825416179055604051907fa9059cbb000000000000000000000000000000000000000000000000000000006020830152602482015283604482015260448152610963606482611e26565b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016612f7f565b7f884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a94243645f80a3005b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f546f6b656e732068617665206265656e207573656420647572696e672074686960448201527f732074696d656672616d650000000000000000000000000000000000000000006064820152fd5b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f496e73756666696369656e7420546f6b656e73000000000000000000000000006044820152fd5b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602060248201527f5769746864726177616c2077617320616c726561647920706572666f726d65646044820152fd5b346102845760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845773ffffffffffffffffffffffffffffffffffffffff610b7e611bba565b165f525f602052606060405f2054604051906fffffffffffffffffffffffffffffffff8116825267ffffffffffffffff8160801c16602083015260c01c6040820152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457602060405160ff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b346102845760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845773ffffffffffffffffffffffffffffffffffffffff610d1f611bba565b165f52600160205260405f206024355f52602052602060405f2054604051908152f35b346102845760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610284576060610120604051610d8281611dc0565b5f81525f60208201525f60408201525f838201525f60808201525f60a08201525f60c08201525f60e08201525f61010082015201526004355f52600260205260405f20604051610dd181611dc0565b815460ff811615158252602082019260ff8260081c16845273ffffffffffffffffffffffffffffffffffffffff604084019260101c168252600181015460608401906fffffffffffffffffffffffffffffffff81168252608085019060801c815260028301549060a08601906fffffffffffffffffffffffffffffffff8316825260c087019260801c835273ffffffffffffffffffffffffffffffffffffffff6003860154169360e08801948552600573ffffffffffffffffffffffffffffffffffffffff600488015416966101008a01978852019660405180985f90805490610eba8261243e565b808552916001811690811561104c5750600114611010575b505003610edf9089611e26565b6101208901978852604051998a9960208b5251151560208b01525160ff1660408a01525173ffffffffffffffffffffffffffffffffffffffff166060890152516fffffffffffffffffffffffffffffffff166080880152516fffffffffffffffffffffffffffffffff1660a0870152516fffffffffffffffffffffffffffffffff1660c0860152516fffffffffffffffffffffffffffffffff1660e08501525173ffffffffffffffffffffffffffffffffffffffff166101008401525173ffffffffffffffffffffffffffffffffffffffff166101208301525161014082016101409052805180918161016085015260200161018084015e808201610180015f9052601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168101036101800190f35b5f908152602081209092505b81831061103157505081016020018c80610ed2565b80602092948385600194549201015201910190918a9261101c565b9050602093507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0091501682840152151560051b8201018c80610ed2565b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457602060405167ffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b346102845760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457606067ffffffffffffffff8061125a611255611bba565b6121be565b9193908160405195168552166020840152166040820152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346102845760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457602061027c611307611bba565b6120a0565b346102845760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457611364611346611bba565b61134e611bdd565b9060a43591608435916064359160443591611ee6565b9060405190604082019260408352815180945260206060840192015f945b80861061139757505082935060208301520390f35b909260206060600192604087518051835284810151858401520151604082015201940195019490611382565b346102845760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845760043567ffffffffffffffff81116102845780600401906101207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8236030112610284576114783373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163314611c71565b61148560e4820183611cbb565b905061194457610104810190604161149d8385611cbb565b90500361051557606481017fe1ea48fc000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000006114fd6114f78488611cbb565b90611d0c565b161461150c6114f78387611cbb565b90156118f6575061151d9084611cbb565b80600493929311610284578201916102007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc82850301126102845760048101359061156a602482016124f3565b91611577608483016124f3565b9460c483013567ffffffffffffffff811161028457830190806023830112156102845781602460046115ac940135910161248f565b60e483013560ff811681036102845761166d906115cc61016486016124f3565b906115da61018487016124f3565b986115e86101a488016124f3565b976101c48801359773ffffffffffffffffffffffffffffffffffffffff80806101e48401359c169d169516938761014483013594610124840135946101048501359473ffffffffffffffffffffffffffffffffffffffff60a482013593169173ffffffffffffffffffffffffffffffffffffffff604460648401359301359116612746565b8281036118cb575051956102408701968781116109c557610244018097116109c5576116d490825f52600460205260405f2073ffffffffffffffffffffffffffffffffffffffff88165f526020526116ce838860ff60405f20541615611d72565b88611cbb565b50918235604060208501359401355f1a927f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a085116104ed575f6080602092604051908152868482015284604082015287606082015282805260015afa156104e25773ffffffffffffffffffffffffffffffffffffffff5f511680156104ba57870361189f57810361187457507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe50160ff1b1781036118495750611796826120a0565b8060248301350361181e575060c47f000000000000000000000000000000000000000000000000000000000000000091013560801c11928315611809575b5082156117f7575b5050156117ef5760206001604051908152f35b60205f61027c565b61180192506125fc565b1581806117dc565b6118169193508290612514565b1591836117d4565b7fec6e82cd000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7f5ac4a43b000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7f42f4d17e000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b867fa150e3da000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7fef8711f5000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7fffffffff00000000000000000000000000000000000000000000000000000000907f839d9ad2000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b7fea42a443000000000000000000000000000000000000000000000000000000005f5260045ffd5b346102845760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610284576119a3611bba565b73ffffffffffffffffffffffffffffffffffffffff6119c0611c24565b9116805f525f60205260405f206fffffffffffffffffffffffffffffffff8082541693168093016fffffffffffffffffffffffffffffffff81116109c5576fffffffffffffffffffffffffffffffff167fffffffffffffffffffffffffffffffff00000000000000000000000000000000825416179055611a846040517f23b872dd00000000000000000000000000000000000000000000000000000000602082015233602482015230604482015283606482015260648152610963608482611e26565b7fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c5f80a3005b346102845760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457611ae1611bba565b73ffffffffffffffffffffffffffffffffffffffff611afe611bdd565b91165f52600360205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f206044355f5260205260405f206064355f52602052602060405f2054604051908152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845760209073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361028457565b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361028457565b610164359073ffffffffffffffffffffffffffffffffffffffff8216820361028457565b602435906fffffffffffffffffffffffffffffffff8216820361028457565b9181601f840112156102845782359167ffffffffffffffff8311610284576020838186019501011161028457565b15611c795750565b73ffffffffffffffffffffffffffffffffffffffff907f1d6ddbf4000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe181360301821215610284570180359067ffffffffffffffff82116102845760200191813603831361028457565b919091357fffffffff0000000000000000000000000000000000000000000000000000000081169260048110611d40575050565b7fffffffff00000000000000000000000000000000000000000000000000000000929350829060040360031b1b161690565b15611d7b575050565b73ffffffffffffffffffffffffffffffffffffffff907f41e3e888000000000000000000000000000000000000000000000000000000005f521660045260245260445ffd5b610140810190811067ffffffffffffffff821117611ddd57604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6060810190811067ffffffffffffffff821117611ddd57604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117611ddd57604052565b67ffffffffffffffff8111611ddd5760051b60200190565b919082018092116109c557565b8054821015611ea5575f52600360205f20910201905f90565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b8051821015611ea55760209160051b010190565b73ffffffffffffffffffffffffffffffffffffffff90969496165f52600360205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f5260205260405f20905f5260205260405f208054928385101561205057611f549085611e7f565b90838211612048575b8482039182116109c557611f7082611e67565b90611f7e6040519283611e26565b8282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0611fab84611e67565b015f5b81811061201f57505081955f5b848110611fc9575050505050565b80611fdf611fd960019385611e7f565b85611e8c565b50600260405191611fef83611e0a565b805483528481015460208401520154604082015261200d8287611ed2565b526120188186611ed2565b5001611fbb565b60209060405161202e81611e0a565b5f81525f838201525f604082015282828701015201611fae565b839150611f5d565b509192509050604051612064602082611e26565b5f81525f805b8181106120775750509190565b60209060405161208681611e0a565b5f81525f838201525f60408201528282860101520161206a565b73ffffffffffffffffffffffffffffffffffffffff604051917f35567e1a00000000000000000000000000000000000000000000000000000000835230600484015216602482015260208160448173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165afa9081156104e2575f91612138575090565b90506020813d60201161215f575b8161215360209383611e26565b81010312610284575190565b3d9150612146565b9067ffffffffffffffff8091169116039067ffffffffffffffff82116109c557565b9067ffffffffffffffff8091169116019067ffffffffffffffff82116109c557565b818102929181159184041417156109c557565b73ffffffffffffffffffffffffffffffffffffffff165f525f60205260405f20604051906121eb82611e0a565b546fffffffffffffffffffffffffffffffff81168252602082019067ffffffffffffffff8160801c16825260c01c90816040840152814281115f146123b657506fffffffffffffffffffffffffffffffff67ffffffffffffffff61227c925116935b511663ffffffff7f000000000000000000000000000000000000000000000000000000000000000016906121ab565b60ff7f000000000000000000000000000000000000000000000000000000000000000016604d81116109c557600a0a908115612389570467ffffffffffffffff811161232b5767ffffffffffffffff1663ffffffff7f000000000000000000000000000000000000000000000000000000000000000016808211612323575b508267ffffffffffffffff8281169082161161231d5761231a91612167565b92565b50505f92565b90505f6122fb565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f4d6178207369676e65722071756f746120746f6f2068696768000000000000006044820152fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b929150505f916123d167ffffffffffffffff42169182612167565b907f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff8116908115612389576124336fffffffffffffffffffffffffffffffff936124389367ffffffffffffffff61227c97160690612167565b612189565b9261224d565b90600182811c92168015612485575b602083101461245857565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b91607f169161244d565b92919267ffffffffffffffff8211611ddd57604051916124d760207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8401160184611e26565b829481845281830111610284578281602093845f960137010152565b359073ffffffffffffffffffffffffffffffffffffffff8216820361028457565b6125686125417f0000000000000000000000000000000000000000000000000000000000000000846121ab565b7f000000000000000000000000000000000000000000000000000000000000000090611e7f565b60a0820135116125f65760800135906125a17f0000000000000000000000000000000000000000000000000000000000000000826121ab565b8260801c116125f6576125e66fffffffffffffffffffffffffffffffff917f0000000000000000000000000000000000000000000000000000000000000000906121ab565b9116116125f257600190565b5f90565b50505f90565b61ffff7f000000000000000000000000000000000000000000000000000000000000000016801561273e576126479267ffffffffffffffff61263d846121be565b96919390946121ab565b911681116127365773ffffffffffffffffffffffffffffffffffffffff9167ffffffffffffffff612679921690612189565b91165f525f60205260405f20918254908160c01c67ffffffffffffffff8216036126eb575b50507fffffffffffffffff0000000000000000ffffffffffffffffffffffffffffffff77ffffffffffffffff0000000000000000000000000000000083549260801b169116179055600190565b7fffffffffffffffff00000000000000000000000000000000000000000000000077ffffffffffffffffffffffffffffffffffffffffffffffff9160c01b1691161782555f8061269e565b505050505f90565b505050600190565b9a9692999591979398949a6040519060208201927f47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a794692188452604083015273ffffffffffffffffffffffffffffffffffffffff166060820152606081526127ac608082611e26565b51902099805190602001206040519860208a019a7fbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d88c5273ffffffffffffffffffffffffffffffffffffffff1660408b015260608a0152608089015260ff1660a088015260c087015260e086015261010085015273ffffffffffffffffffffffffffffffffffffffff1661012084015273ffffffffffffffffffffffffffffffffffffffff16610140830152610160820152610160815261286f61018082611e26565b5190206040517f19010000000000000000000000000000000000000000000000000000000000006020820190815260228201939093526042808201929092529081526128bc606282611e26565b51902090565b9a959893909994919c97929b966080528a5f52600260205260405f209687549060ff8216156128fd575b505050505050505050505050505050565b73ffffffffffffffffffffffffffffffffffffffff9160017fffffffffffffffffffff0000000000000000000000000000000000000000000061ff008860081b1692161775ffffffffffffffffffffffffffffffffffffffff00008560101b161717895583612dbf575b85612d69575b86612d1d575b87612cc7575b169687612c96575b73ffffffffffffffffffffffffffffffffffffffff8916612c4f575b608051612aab575b506040519b8c5273ffffffffffffffffffffffffffffffffffffffff1660208c015260408b015260ff1660608a0152608089015260a088015260c087015260e086015273ffffffffffffffffffffffffffffffffffffffff1661010085015261012084016101409052608051610140850152608051906101608501376080518301610160015f905273ffffffffffffffffffffffffffffffffffffffff169180608051601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810103610160017f3fcaf82260999b0a1a77f3006e142f8a15153ca131932b8b3b42ba67f44e02a391a45f80808080808080808080808080806128ec565b67ffffffffffffffff60805111611ddd57612ac9600582015461243e565b601f8111612c03575b505f601f60805111600114612b36576005905f90608051612b2b575b5060805160011b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60805160031b1c1916179101555b5f6129a5565b90508b01355f612aee565b600582015f5260205f20905f5b8c7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0608051168210612beb5750506080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0811610612bb1575b505060056001608051811b01910155612b25565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f860805160031b161c19908c01351690555f80612b9d565b60018394602093948493013581550193019101612b43565b600582015f5260205f20601f6080510160051c810191602060805110612c45575b601f0160051c01905b818110612c3a5750612ad2565b5f8155600101612c2d565b9091508190612c24565b6004810173ffffffffffffffffffffffffffffffffffffffff8a167fffffffffffffffffffffffff000000000000000000000000000000000000000082541617905561299d565b60038101887fffffffffffffffffffffffff0000000000000000000000000000000000000000825416179055612981565b612d18612cd389613006565b60028b01906fffffffffffffffffffffffffffffffff7fffffffffffffffffffffffffffffffff0000000000000000000000000000000083549260801b169116179055565b612979565b612d2687613006565b6fffffffffffffffffffffffffffffffff60028b0191167fffffffffffffffffffffffffffffffff00000000000000000000000000000000825416179055612973565b612dba612d7587613006565b60018b01906fffffffffffffffffffffffffffffffff7fffffffffffffffffffffffffffffffff0000000000000000000000000000000083549260801b169116179055565b61296d565b612dc884613006565b6fffffffffffffffffffffffffffffffff60018b0191167fffffffffffffffffffffffffffffffff00000000000000000000000000000000825416179055612967565b73ffffffffffffffffffffffffffffffffffffffff909796939795929495865f52600460205260405f208282165f5260205260405f2060017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff008254161790551692835f52600360205260405f2073ffffffffffffffffffffffffffffffffffffffff83165f5260205260405f20855f5260205260405f20885f5260205260405f209182549860405194612ebd86611e0a565b8552602085019283526040850193888552680100000000000000008b1015611ddd578a612eef91600182018155611e8c565b612f5357600260609573ffffffffffffffffffffffffffffffffffffffff957f8ca934463363b9653ec99615768595e2f35a0b21bab215117cf38b4038882c41985184555160018401555191015560405196875260208701528860408701521693a4565b7f4e487b71000000000000000000000000000000000000000000000000000000005f525f60045260245ffd5b905f602091828151910182855af1156104e2575f513d612ffd575073ffffffffffffffffffffffffffffffffffffffff81163b155b612fbb5750565b73ffffffffffffffffffffffffffffffffffffffff907f5274afe7000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b60011415612fb4565b6fffffffffffffffffffffffffffffffff8111613032576fffffffffffffffffffffffffffffffff1690565b7f5e978e24000000000000000000000000000000000000000000000000000000005f5260045ffdfea2646970667358221220ecdac52acb96f66b88a3712051d38356d5748124bbfa5dac8d3b4312a350021164736f6c634300081d0033",
  "deployedBytecode": "0x60a0806040526004361015610012575f80fd5b5f3560e01c908163137e051e14611b4e575080631573a55d14611aaa5780631846652a1461196c57806319822f7c146113c35780632220debb1461130c5780632d0335ab146112cb57806339ba5c8a14611273578063519e98151461120f57806353f74a10146111b15780636f9bb7bd1461114f578063700e4ca9146110f757806373717b081461108957806375f398fe14610d425780637eec7d6814610cd357806388ee6cf414610c785780639229f4cf14610c205780639f9b5ef414610bc2578063a3be4d7b14610b32578063b930d9ad14610649578063c0f06efd146105ed578063c7efacb114610595578063c90e34461461053d578063dd030c67146102885763e1ea48fc14610124575f80fd5b34610284576102007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845760043561015f611bdd565b60443590606435916084359373ffffffffffffffffffffffffffffffffffffffff851685036102845760c43567ffffffffffffffff8111610284576101a8903690600401611c43565b94909260e43560ff81168103610284576101c0611c00565b610184359073ffffffffffffffffffffffffffffffffffffffff82168203610284576101a4359673ffffffffffffffffffffffffffffffffffffffff881688036102845760209a8961026d9561027c9c6102523373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163314611c71565b61014435948b61012435958c8c610104359760a435946128c2565b6101e435946101c43594612e0b565b604051908152f35b5f80fd5b34610284576101a07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610284576102c0611bba565b60643573ffffffffffffffffffffffffffffffffffffffff811681036102845760a43567ffffffffffffffff811161028457610300903690600401611c43565b909260c435919060ff8316830361028457610144359073ffffffffffffffffffffffffffffffffffffffff821682036102845761033b611c00565b93610184359467ffffffffffffffff8611610284576103606041963690600401611c43565b96909603610515576103998185610124358b89878d610388610104359460e43594369161248f565b90608435906044356024358e612746565b937f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a06020880135116104ed5760205f608060405188815260408b0135831a848201528a356040820152838b0135606082015282805260015afa156104e2575f519573ffffffffffffffffffffffffffffffffffffffff8716156104ba5760209961027c99610440956101243593610104359360e43593608435906044356024358d8f6128c2565b815f526004865260405f2073ffffffffffffffffffffffffffffffffffffffff84165f528652610479828460ff60405f20541615611d72565b858401357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe560408601355f1a0160ff1b179335926044359160243591612e0b565b7f8baa579f000000000000000000000000000000000000000000000000000000005f5260045ffd5b6040513d5f823e3d90fd5b7f617cf474000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f85e6258e000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457602060405161ffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b60807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845760043567ffffffffffffffff811161028457610693903690600401611c43565b5061069c611c24565b906044359173ffffffffffffffffffffffffffffffffffffffff8316809303610284576fffffffffffffffffffffffffffffffff169160405160208101907f47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218825246604082015230606082015260608152610718608082611e26565b5190206107b46107e060405160208101907ff004bebf3ce3a32f609e24232a25277f97bc1a0843e36f180d0e414dd5a65b7a825287604082015285606082015260643560808201526080815261076f60a082611e26565b51902060405192839160208301958690916042927f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201520190565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101835282611e26565b519020916020810135907f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a082116104ed5760805f91602093604051918783526040810135851a86840152356040830152606082015282805260015afa156104e25773ffffffffffffffffffffffffffffffffffffffff5f51169182156104ba57825f52600160205260405f20815f5260205260405f2054610ad457825f52600160205260405f20905f526020524260405f2055815f525f60205260405f209081546fffffffffffffffffffffffffffffffff811690858210610a7657429060c01c10156109f257849003916fffffffffffffffffffffffffffffffff83116109c5576fffffffffffffffffffffffffffffffff61099f93167fffffffffffffffffffffffffffffffff00000000000000000000000000000000825416179055604051907fa9059cbb000000000000000000000000000000000000000000000000000000006020830152602482015283604482015260448152610963606482611e26565b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016612f7f565b7f884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a94243645f80a3005b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f546f6b656e732068617665206265656e207573656420647572696e672074686960448201527f732074696d656672616d650000000000000000000000000000000000000000006064820152fd5b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f496e73756666696369656e7420546f6b656e73000000000000000000000000006044820152fd5b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602060248201527f5769746864726177616c2077617320616c726561647920706572666f726d65646044820152fd5b346102845760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845773ffffffffffffffffffffffffffffffffffffffff610b7e611bba565b165f525f602052606060405f2054604051906fffffffffffffffffffffffffffffffff8116825267ffffffffffffffff8160801c16602083015260c01c6040820152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457602060405160ff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b346102845760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845773ffffffffffffffffffffffffffffffffffffffff610d1f611bba565b165f52600160205260405f206024355f52602052602060405f2054604051908152f35b346102845760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610284576060610120604051610d8281611dc0565b5f81525f60208201525f60408201525f838201525f60808201525f60a08201525f60c08201525f60e08201525f61010082015201526004355f52600260205260405f20604051610dd181611dc0565b815460ff811615158252602082019260ff8260081c16845273ffffffffffffffffffffffffffffffffffffffff604084019260101c168252600181015460608401906fffffffffffffffffffffffffffffffff81168252608085019060801c815260028301549060a08601906fffffffffffffffffffffffffffffffff8316825260c087019260801c835273ffffffffffffffffffffffffffffffffffffffff6003860154169360e08801948552600573ffffffffffffffffffffffffffffffffffffffff600488015416966101008a01978852019660405180985f90805490610eba8261243e565b808552916001811690811561104c5750600114611010575b505003610edf9089611e26565b6101208901978852604051998a9960208b5251151560208b01525160ff1660408a01525173ffffffffffffffffffffffffffffffffffffffff166060890152516fffffffffffffffffffffffffffffffff166080880152516fffffffffffffffffffffffffffffffff1660a0870152516fffffffffffffffffffffffffffffffff1660c0860152516fffffffffffffffffffffffffffffffff1660e08501525173ffffffffffffffffffffffffffffffffffffffff166101008401525173ffffffffffffffffffffffffffffffffffffffff166101208301525161014082016101409052805180918161016085015260200161018084015e808201610180015f9052601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168101036101800190f35b5f908152602081209092505b81831061103157505081016020018c80610ed2565b80602092948385600194549201015201910190918a9261101c565b9050602093507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0091501682840152151560051b8201018c80610ed2565b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457602060405167ffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b346102845760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457606067ffffffffffffffff8061125a611255611bba565b6121be565b9193908160405195168552166020840152166040820152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346102845760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457602061027c611307611bba565b6120a0565b346102845760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457611364611346611bba565b61134e611bdd565b9060a43591608435916064359160443591611ee6565b9060405190604082019260408352815180945260206060840192015f945b80861061139757505082935060208301520390f35b909260206060600192604087518051835284810151858401520151604082015201940195019490611382565b346102845760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845760043567ffffffffffffffff81116102845780600401906101207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8236030112610284576114783373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163314611c71565b61148560e4820183611cbb565b905061194457610104810190604161149d8385611cbb565b90500361051557606481017fe1ea48fc000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000006114fd6114f78488611cbb565b90611d0c565b161461150c6114f78387611cbb565b90156118f6575061151d9084611cbb565b80600493929311610284578201916102007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc82850301126102845760048101359061156a602482016124f3565b91611577608483016124f3565b9460c483013567ffffffffffffffff811161028457830190806023830112156102845781602460046115ac940135910161248f565b60e483013560ff811681036102845761166d906115cc61016486016124f3565b906115da61018487016124f3565b986115e86101a488016124f3565b976101c48801359773ffffffffffffffffffffffffffffffffffffffff80806101e48401359c169d169516938761014483013594610124840135946101048501359473ffffffffffffffffffffffffffffffffffffffff60a482013593169173ffffffffffffffffffffffffffffffffffffffff604460648401359301359116612746565b8281036118cb575051956102408701968781116109c557610244018097116109c5576116d490825f52600460205260405f2073ffffffffffffffffffffffffffffffffffffffff88165f526020526116ce838860ff60405f20541615611d72565b88611cbb565b50918235604060208501359401355f1a927f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a085116104ed575f6080602092604051908152868482015284604082015287606082015282805260015afa156104e25773ffffffffffffffffffffffffffffffffffffffff5f511680156104ba57870361189f57810361187457507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe50160ff1b1781036118495750611796826120a0565b8060248301350361181e575060c47f000000000000000000000000000000000000000000000000000000000000000091013560801c11928315611809575b5082156117f7575b5050156117ef5760206001604051908152f35b60205f61027c565b61180192506125fc565b1581806117dc565b6118169193508290612514565b1591836117d4565b7fec6e82cd000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7f5ac4a43b000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7f42f4d17e000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b867fa150e3da000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7fef8711f5000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7fffffffff00000000000000000000000000000000000000000000000000000000907f839d9ad2000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b7fea42a443000000000000000000000000000000000000000000000000000000005f5260045ffd5b346102845760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610284576119a3611bba565b73ffffffffffffffffffffffffffffffffffffffff6119c0611c24565b9116805f525f60205260405f206fffffffffffffffffffffffffffffffff8082541693168093016fffffffffffffffffffffffffffffffff81116109c5576fffffffffffffffffffffffffffffffff167fffffffffffffffffffffffffffffffff00000000000000000000000000000000825416179055611a846040517f23b872dd00000000000000000000000000000000000000000000000000000000602082015233602482015230604482015283606482015260648152610963608482611e26565b7fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c5f80a3005b346102845760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261028457611ae1611bba565b73ffffffffffffffffffffffffffffffffffffffff611afe611bdd565b91165f52600360205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f206044355f5260205260405f206064355f52602052602060405f2054604051908152f35b34610284575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102845760209073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361028457565b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361028457565b610164359073ffffffffffffffffffffffffffffffffffffffff8216820361028457565b602435906fffffffffffffffffffffffffffffffff8216820361028457565b9181601f840112156102845782359167ffffffffffffffff8311610284576020838186019501011161028457565b15611c795750565b73ffffffffffffffffffffffffffffffffffffffff907f1d6ddbf4000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe181360301821215610284570180359067ffffffffffffffff82116102845760200191813603831361028457565b919091357fffffffff0000000000000000000000000000000000000000000000000000000081169260048110611d40575050565b7fffffffff00000000000000000000000000000000000000000000000000000000929350829060040360031b1b161690565b15611d7b575050565b73ffffffffffffffffffffffffffffffffffffffff907f41e3e888000000000000000000000000000000000000000000000000000000005f521660045260245260445ffd5b610140810190811067ffffffffffffffff821117611ddd57604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6060810190811067ffffffffffffffff821117611ddd57604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117611ddd57604052565b67ffffffffffffffff8111611ddd5760051b60200190565b919082018092116109c557565b8054821015611ea5575f52600360205f20910201905f90565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b8051821015611ea55760209160051b010190565b73ffffffffffffffffffffffffffffffffffffffff90969496165f52600360205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f20905f5260205260405f20905f5260205260405f208054928385101561205057611f549085611e7f565b90838211612048575b8482039182116109c557611f7082611e67565b90611f7e6040519283611e26565b8282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0611fab84611e67565b015f5b81811061201f57505081955f5b848110611fc9575050505050565b80611fdf611fd960019385611e7f565b85611e8c565b50600260405191611fef83611e0a565b805483528481015460208401520154604082015261200d8287611ed2565b526120188186611ed2565b5001611fbb565b60209060405161202e81611e0a565b5f81525f838201525f604082015282828701015201611fae565b839150611f5d565b509192509050604051612064602082611e26565b5f81525f805b8181106120775750509190565b60209060405161208681611e0a565b5f81525f838201525f60408201528282860101520161206a565b73ffffffffffffffffffffffffffffffffffffffff604051917f35567e1a00000000000000000000000000000000000000000000000000000000835230600484015216602482015260208160448173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165afa9081156104e2575f91612138575090565b90506020813d60201161215f575b8161215360209383611e26565b81010312610284575190565b3d9150612146565b9067ffffffffffffffff8091169116039067ffffffffffffffff82116109c557565b9067ffffffffffffffff8091169116019067ffffffffffffffff82116109c557565b818102929181159184041417156109c557565b73ffffffffffffffffffffffffffffffffffffffff165f525f60205260405f20604051906121eb82611e0a565b546fffffffffffffffffffffffffffffffff81168252602082019067ffffffffffffffff8160801c16825260c01c90816040840152814281115f146123b657506fffffffffffffffffffffffffffffffff67ffffffffffffffff61227c925116935b511663ffffffff7f000000000000000000000000000000000000000000000000000000000000000016906121ab565b60ff7f000000000000000000000000000000000000000000000000000000000000000016604d81116109c557600a0a908115612389570467ffffffffffffffff811161232b5767ffffffffffffffff1663ffffffff7f000000000000000000000000000000000000000000000000000000000000000016808211612323575b508267ffffffffffffffff8281169082161161231d5761231a91612167565b92565b50505f92565b90505f6122fb565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f4d6178207369676e65722071756f746120746f6f2068696768000000000000006044820152fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b929150505f916123d167ffffffffffffffff42169182612167565b907f000000000000000000000000000000000000000000000000000000000000000067ffffffffffffffff8116908115612389576124336fffffffffffffffffffffffffffffffff936124389367ffffffffffffffff61227c97160690612167565b612189565b9261224d565b90600182811c92168015612485575b602083101461245857565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b91607f169161244d565b92919267ffffffffffffffff8211611ddd57604051916124d760207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8401160184611e26565b829481845281830111610284578281602093845f960137010152565b359073ffffffffffffffffffffffffffffffffffffffff8216820361028457565b6125686125417f0000000000000000000000000000000000000000000000000000000000000000846121ab565b7f000000000000000000000000000000000000000000000000000000000000000090611e7f565b60a0820135116125f65760800135906125a17f0000000000000000000000000000000000000000000000000000000000000000826121ab565b8260801c116125f6576125e66fffffffffffffffffffffffffffffffff917f0000000000000000000000000000000000000000000000000000000000000000906121ab565b9116116125f257600190565b5f90565b50505f90565b61ffff7f000000000000000000000000000000000000000000000000000000000000000016801561273e576126479267ffffffffffffffff61263d846121be565b96919390946121ab565b911681116127365773ffffffffffffffffffffffffffffffffffffffff9167ffffffffffffffff612679921690612189565b91165f525f60205260405f20918254908160c01c67ffffffffffffffff8216036126eb575b50507fffffffffffffffff0000000000000000ffffffffffffffffffffffffffffffff77ffffffffffffffff0000000000000000000000000000000083549260801b169116179055600190565b7fffffffffffffffff00000000000000000000000000000000000000000000000077ffffffffffffffffffffffffffffffffffffffffffffffff9160c01b1691161782555f8061269e565b505050505f90565b505050600190565b9a9692999591979398949a6040519060208201927f47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a794692188452604083015273ffffffffffffffffffffffffffffffffffffffff166060820152606081526127ac608082611e26565b51902099805190602001206040519860208a019a7fbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d88c5273ffffffffffffffffffffffffffffffffffffffff1660408b015260608a0152608089015260ff1660a088015260c087015260e086015261010085015273ffffffffffffffffffffffffffffffffffffffff1661012084015273ffffffffffffffffffffffffffffffffffffffff16610140830152610160820152610160815261286f61018082611e26565b5190206040517f19010000000000000000000000000000000000000000000000000000000000006020820190815260228201939093526042808201929092529081526128bc606282611e26565b51902090565b9a959893909994919c97929b966080528a5f52600260205260405f209687549060ff8216156128fd575b505050505050505050505050505050565b73ffffffffffffffffffffffffffffffffffffffff9160017fffffffffffffffffffff0000000000000000000000000000000000000000000061ff008860081b1692161775ffffffffffffffffffffffffffffffffffffffff00008560101b161717895583612dbf575b85612d69575b86612d1d575b87612cc7575b169687612c96575b73ffffffffffffffffffffffffffffffffffffffff8916612c4f575b608051612aab575b506040519b8c5273ffffffffffffffffffffffffffffffffffffffff1660208c015260408b015260ff1660608a0152608089015260a088015260c087015260e086015273ffffffffffffffffffffffffffffffffffffffff1661010085015261012084016101409052608051610140850152608051906101608501376080518301610160015f905273ffffffffffffffffffffffffffffffffffffffff169180608051601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810103610160017f3fcaf82260999b0a1a77f3006e142f8a15153ca131932b8b3b42ba67f44e02a391a45f80808080808080808080808080806128ec565b67ffffffffffffffff60805111611ddd57612ac9600582015461243e565b601f8111612c03575b505f601f60805111600114612b36576005905f90608051612b2b575b5060805160011b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60805160031b1c1916179101555b5f6129a5565b90508b01355f612aee565b600582015f5260205f20905f5b8c7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0608051168210612beb5750506080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0811610612bb1575b505060056001608051811b01910155612b25565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f860805160031b161c19908c01351690555f80612b9d565b60018394602093948493013581550193019101612b43565b600582015f5260205f20601f6080510160051c810191602060805110612c45575b601f0160051c01905b818110612c3a5750612ad2565b5f8155600101612c2d565b9091508190612c24565b6004810173ffffffffffffffffffffffffffffffffffffffff8a167fffffffffffffffffffffffff000000000000000000000000000000000000000082541617905561299d565b60038101887fffffffffffffffffffffffff0000000000000000000000000000000000000000825416179055612981565b612d18612cd389613006565b60028b01906fffffffffffffffffffffffffffffffff7fffffffffffffffffffffffffffffffff0000000000000000000000000000000083549260801b169116179055565b612979565b612d2687613006565b6fffffffffffffffffffffffffffffffff60028b0191167fffffffffffffffffffffffffffffffff00000000000000000000000000000000825416179055612973565b612dba612d7587613006565b60018b01906fffffffffffffffffffffffffffffffff7fffffffffffffffffffffffffffffffff0000000000000000000000000000000083549260801b169116179055565b61296d565b612dc884613006565b6fffffffffffffffffffffffffffffffff60018b0191167fffffffffffffffffffffffffffffffff00000000000000000000000000000000825416179055612967565b73ffffffffffffffffffffffffffffffffffffffff909796939795929495865f52600460205260405f208282165f5260205260405f2060017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff008254161790551692835f52600360205260405f2073ffffffffffffffffffffffffffffffffffffffff83165f5260205260405f20855f5260205260405f20885f5260205260405f209182549860405194612ebd86611e0a565b8552602085019283526040850193888552680100000000000000008b1015611ddd578a612eef91600182018155611e8c565b612f5357600260609573ffffffffffffffffffffffffffffffffffffffff957f8ca934463363b9653ec99615768595e2f35a0b21bab215117cf38b4038882c41985184555160018401555191015560405196875260208701528860408701521693a4565b7f4e487b71000000000000000000000000000000000000000000000000000000005f525f60045260245ffd5b905f602091828151910182855af1156104e2575f513d612ffd575073ffffffffffffffffffffffffffffffffffffffff81163b155b612fbb5750565b73ffffffffffffffffffffffffffffffffffffffff907f5274afe7000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b60011415612fb4565b6fffffffffffffffffffffffffffffffff8111613032576fffffffffffffffffffffffffffffffff1690565b7f5e978e24000000000000000000000000000000000000000000000000000000005f5260045ffdfea2646970667358221220ecdac52acb96f66b88a3712051d38356d5748124bbfa5dac8d3b4312a350021164736f6c634300081d0033",
  "devdoc": {
    "details": "The {SignatureStored} event is the only hook required by indexers; however, the contract is      fully functional without any off‑chain infrastructure.",
    "errors": {
      "SafeERC20FailedOperation(address)": [
        {
          "details": "An operation with an ERC-20 token failed."
        }
      ],
      "SignerAlreadySignedTransaction(address,bytes32)": [
        {
          "params": {
            "safeTxHash": "The EIP-712 hash of the Safe transaction.",
            "signer": "Signer address."
          }
        }
      ]
    },
    "events": {
      "NewTransaction(bytes32,address,uint256,uint256,address,uint256,uint8,uint256,uint256,uint256,address,address,bytes)": {
        "params": {
          "baseGas": "Fixed overhead reimbursed to the submitting signer.",
          "chainId": "Intended execution chain.",
          "data": "Calldata executed by the Safe.",
          "gasPrice": "Gas price used for reimbursement.",
          "gasToken": "ERC-20 token address for refunds.",
          "nonce": "Safe nonce.",
          "operation": "0 = CALL, 1 = DELEGATECALL.",
          "refundReceiver": "Address receiving the gas refund.",
          "safe": "Safe Smart-Account the transaction targets.",
          "safeTxGas": "Gas forwarded to the inner call.",
          "safeTxHash": "EIP-712 hash identifying the SafeTx.",
          "to": "Destination of the inner call/delegatecall.",
          "value": "ETH value forwarded by the Safe."
        }
      },
      "SignatureStored(address,address,bytes32,uint256,uint256,uint256)": {
        "params": {
          "chainId": "Intended execution chain.",
          "listIndex": "Position of the signature in the signer‑specific array.",
          "nonce": "Safe nonce.",
          "safe": "Safe Smart‑Account the transaction targets.",
          "safeTxHash": "EIP‑712 hash identifying the SafeTx.",
          "signer": "Address recovered from the provided signature."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "enqueueTransaction(address,uint256,uint256,address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes)": {
        "custom:events": "Emits {SignatureStored}.",
        "details": "If `safeTxHash` has been seen before, its parameters are *not* validated nor overwritten –      the call simply appends the `(r,s)` pair for `signer`.",
        "params": {
          "baseGas": "Fixed overhead reimbursed to the submitting signer.",
          "chainId": "Chain id the transaction is meant for.",
          "data": "Calldata executed by the Safe.",
          "gasPrice": "Gas price used for reimbursement.",
          "gasToken": "ERC‑20 token address for refunds (`address(0)` = ETH).",
          "nonce": "Safe nonce.",
          "operation": "0 = CALL, 1 = DELEGATECALL.",
          "refundReceiver": "Address receiving the gas refund.",
          "safeAddress": "Target Safe Smart‑Account.",
          "safeTxGas": "Gas forwarded to the inner call.",
          "signature": "**Single** 65‑byte ECDSA signature.",
          "to": "Destination of the inner call/delegatecall.",
          "value": "ETH value forwarded by the Safe."
        },
        "returns": {
          "listIndex": "    Index of the stored signature in the signer‑specific list."
        }
      },
      "retrieveSignatures(address,address,uint256,uint256,uint256,uint256)": {
        "params": {
          "chainId": "Target chain id.",
          "count": "Maximum number of entries to return.",
          "nonce": "Safe nonce.",
          "safeAddress": "Safe Smart‑Account.",
          "signerAddress": "Address that created the signatures.",
          "start": "Zero‑based start index of the slice."
        },
        "returns": {
          "page": "      Array slice `[start … start+count)` (may be shorter).",
          "totalCount": "Total number of signatures stored for the tuple."
        }
      },
      "retrieveSignaturesCount(address,address,uint256,uint256)": {
        "params": {
          "chainId": "Target chain id.",
          "nonce": "Safe nonce.",
          "safeAddress": "Safe Smart‑Account.",
          "signerAddress": "Signer address."
        },
        "returns": {
          "count": "Length of the signature list."
        }
      },
      "retrieveTransaction(bytes32)": {
        "params": {
          "safeTxHash": "EIP‑712 digest of the transaction."
        },
        "returns": {
          "txParams": "Struct with all SafeTx parameters (zero‑initialised if unknown)."
        }
      }
    },
    "stateVariables": {
      "_hasSignerSignedTx": {
        "details": "Tracks if a signer has already submitted *any* signature for a specific safeTxHash,      preventing duplicate signatures for the *exact same* transaction digest.      This complements `_sigData` by ensuring uniqueness per (safeTxHash, signer) pair. Mapping `safeTxHash → signer → bool`"
      }
    },
    "title": "SafeInternationalHarbour",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "InvalidECDSASignatureLength()": [
        {
          "notice": "Thrown when a signature blob is not exactly 65 bytes."
        }
      ],
      "InvalidSignature()": [
        {
          "notice": "Thrown if `ecrecover` yields `address(0)`."
        }
      ],
      "InvalidSignatureSValue()": [
        {
          "notice": "Thrown if the S value of the signature is not from the lower half of the curve."
        }
      ],
      "SignerAlreadySignedTransaction(address,bytes32)": [
        {
          "notice": "Thrown when attempting to store a signature for a transaction (safeTxHash) that the signer has already provided a signature for."
        }
      ],
      "ValueDoesNotFitInUint128()": [
        {
          "notice": "Thrown when a value doesn't fit in a uint128."
        }
      ]
    },
    "events": {
      "NewTransaction(bytes32,address,uint256,uint256,address,uint256,uint8,uint256,uint256,uint256,address,address,bytes)": {
        "notice": "Emitted when a transaction is first stored."
      },
      "SignatureStored(address,address,bytes32,uint256,uint256,uint256)": {
        "notice": "Emitted whenever a new signature is stored (and possibly the parameters on first sight)."
      }
    },
    "kind": "user",
    "methods": {
      "SUPPORTED_ENTRYPOINT()": {
        "notice": "The address of the EntryPoint contract supported by this module."
      },
      "enqueueTransaction(address,uint256,uint256,address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes)": {
        "notice": "Publish a Safe transaction and/or append a signature to it."
      },
      "getNonce(address)": {
        "notice": "Return the account nonce. This method returns the next sequential nonce. For a nonce of a specific key, use `entrypoint.getNonce(account, key)`"
      },
      "retrieveSignatures(address,address,uint256,uint256,uint256,uint256)": {
        "notice": "Paginated getter for signature entries."
      },
      "retrieveSignaturesCount(address,address,uint256,uint256)": {
        "notice": "Convenience getter returning the **number** of signatures stored for the key tuple."
      },
      "retrieveTransaction(bytes32)": {
        "notice": "Retrieve the full parameter set of a Safe transaction."
      }
    },
    "notice": "Permissionless, append‑only registry that lets **any EOA signer** publish Safe         transactions (\"SafeTx\") and their signatures. Clients without an off‑chain indexer can reconstruct the full multisig payload with only:         1. the Safe address;         2. the target `chainId`;         3. the Safe `nonce`; and         4. the current Safe owners set. Each unique `safeTxHash` (EIP‑712 digest of the SafeTx struct) is persisted **once** together with its parameters. Signatures are appended under the composite key `(signer, safe, chainId, nonce)`, enabling on‑chain, gas‑efficient look‑ups. ### ⚠️ Contract‑based signers unsupported Only ECDSA signatures from externally‑owned accounts (EOAs) are supported. Contract wallets that rely on ERC‑1271 or similar cannot be verified on‑chain in a chain‑agnostic way and are therefore **not supported**.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3888,
        "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
        "label": "quotaStatsForSigner",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_struct(QuotaStats)3852_storage)"
      },
      {
        "astId": 3894,
        "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
        "label": "withdrawsForSigner",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_mapping(t_bytes32,t_uint256))"
      },
      {
        "astId": 2318,
        "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
        "label": "_txDetails",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_bytes32,t_struct(SafeTransaction)3085_storage)"
      },
      {
        "astId": 2331,
        "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
        "label": "_sigData",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_mapping(t_address,t_mapping(t_uint256,t_mapping(t_uint256,t_array(t_struct(SignatureDataWithTxHashIndex)3093_storage)dyn_storage))))"
      },
      {
        "astId": 2338,
        "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
        "label": "_hasSignerSignedTx",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_bytes32,t_mapping(t_address,t_bool))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_struct(SignatureDataWithTxHashIndex)3093_storage)dyn_storage": {
        "base": "t_struct(SignatureDataWithTxHashIndex)3093_storage",
        "encoding": "dynamic_array",
        "label": "struct SignatureDataWithTxHashIndex[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_bytes_storage": {
        "encoding": "bytes",
        "label": "bytes",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_mapping(t_uint256,t_mapping(t_uint256,t_array(t_struct(SignatureDataWithTxHashIndex)3093_storage)dyn_storage))))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => mapping(uint256 => mapping(uint256 => struct SignatureDataWithTxHashIndex[]))))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_mapping(t_uint256,t_mapping(t_uint256,t_array(t_struct(SignatureDataWithTxHashIndex)3093_storage)dyn_storage)))"
      },
      "t_mapping(t_address,t_mapping(t_bytes32,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(bytes32 => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_uint256)"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_mapping(t_uint256,t_array(t_struct(SignatureDataWithTxHashIndex)3093_storage)dyn_storage)))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => mapping(uint256 => struct SignatureDataWithTxHashIndex[])))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_mapping(t_uint256,t_array(t_struct(SignatureDataWithTxHashIndex)3093_storage)dyn_storage))"
      },
      "t_mapping(t_address,t_struct(QuotaStats)3852_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct QuotaStats)",
        "numberOfBytes": "32",
        "value": "t_struct(QuotaStats)3852_storage"
      },
      "t_mapping(t_bytes32,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_bytes32,t_struct(SafeTransaction)3085_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct SafeTransaction)",
        "numberOfBytes": "32",
        "value": "t_struct(SafeTransaction)3085_storage"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_array(t_struct(SignatureDataWithTxHashIndex)3093_storage)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct SignatureDataWithTxHashIndex[])",
        "numberOfBytes": "32",
        "value": "t_array(t_struct(SignatureDataWithTxHashIndex)3093_storage)dyn_storage"
      },
      "t_mapping(t_uint256,t_mapping(t_uint256,t_array(t_struct(SignatureDataWithTxHashIndex)3093_storage)dyn_storage))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(uint256 => struct SignatureDataWithTxHashIndex[]))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_array(t_struct(SignatureDataWithTxHashIndex)3093_storage)dyn_storage)"
      },
      "t_struct(QuotaStats)3852_storage": {
        "encoding": "inplace",
        "label": "struct QuotaStats",
        "members": [
          {
            "astId": 3847,
            "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
            "label": "tokenBalance",
            "offset": 0,
            "slot": "0",
            "type": "t_uint128"
          },
          {
            "astId": 3849,
            "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
            "label": "usedQuota",
            "offset": 16,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 3851,
            "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
            "label": "nextQuotaReset",
            "offset": 24,
            "slot": "0",
            "type": "t_uint64"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(SafeTransaction)3085_storage": {
        "encoding": "inplace",
        "label": "struct SafeTransaction",
        "members": [
          {
            "astId": 3066,
            "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
            "label": "stored",
            "offset": 0,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 3068,
            "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
            "label": "operation",
            "offset": 1,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 3070,
            "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
            "label": "to",
            "offset": 2,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 3072,
            "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
            "label": "value",
            "offset": 0,
            "slot": "1",
            "type": "t_uint128"
          },
          {
            "astId": 3074,
            "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
            "label": "safeTxGas",
            "offset": 16,
            "slot": "1",
            "type": "t_uint128"
          },
          {
            "astId": 3076,
            "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
            "label": "baseGas",
            "offset": 0,
            "slot": "2",
            "type": "t_uint128"
          },
          {
            "astId": 3078,
            "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
            "label": "gasPrice",
            "offset": 16,
            "slot": "2",
            "type": "t_uint128"
          },
          {
            "astId": 3080,
            "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
            "label": "gasToken",
            "offset": 0,
            "slot": "3",
            "type": "t_address"
          },
          {
            "astId": 3082,
            "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
            "label": "refundReceiver",
            "offset": 0,
            "slot": "4",
            "type": "t_address"
          },
          {
            "astId": 3084,
            "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
            "label": "data",
            "offset": 0,
            "slot": "5",
            "type": "t_bytes_storage"
          }
        ],
        "numberOfBytes": "192"
      },
      "t_struct(SignatureDataWithTxHashIndex)3093_storage": {
        "encoding": "inplace",
        "label": "struct SignatureDataWithTxHashIndex",
        "members": [
          {
            "astId": 3088,
            "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
            "label": "r",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes32"
          },
          {
            "astId": 3090,
            "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
            "label": "vs",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          },
          {
            "astId": 3092,
            "contract": "src/SafeInternationalHarbour.sol:SafeInternationalHarbour",
            "label": "txHash",
            "offset": 0,
            "slot": "2",
            "type": "t_bytes32"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}