{
  "address": "0xfe46c93213FaE147C1ebc18bEefaa23a5BA2E5b3",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "manager",
          "type": "address"
        },
        {
          "internalType": "contract IEntryPoint",
          "name": "supportedEntrypoint",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "timeframeQuotaReset",
              "type": "uint32"
            },
            {
              "internalType": "uint16",
              "name": "requiredQuotaMultiplier",
              "type": "uint16"
            },
            {
              "internalType": "uint96",
              "name": "maxAvailableQuota",
              "type": "uint96"
            },
            {
              "internalType": "address",
              "name": "feeToken",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "quotaPerFeeToken",
              "type": "uint32"
            },
            {
              "internalType": "uint8",
              "name": "quotaPerFeeTokenScale",
              "type": "uint8"
            }
          ],
          "internalType": "struct QuotaMixinConfig",
          "name": "_quotaMixinconfig",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint48",
              "name": "enableCoditionsDelay",
              "type": "uint48"
            },
            {
              "internalType": "contract ISlashingCondition[]",
              "name": "initialConditions",
              "type": "address[]"
            }
          ],
          "internalType": "struct SlashingMixinConfig",
          "name": "_slashingMixinconfig",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "InvalidSignature",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSignatureSValue",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "targetSelector",
          "type": "bytes4"
        }
      ],
      "name": "InvalidTarget",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidUserOpPaymaster",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "OwnableInvalidOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "OwnableUnauthorizedAccount",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "SafeERC20FailedOperation",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "signer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Deposit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract ISlashingCondition",
          "name": "offendingCondition",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint48",
          "name": "enabledUntil",
          "type": "uint48"
        }
      ],
      "name": "DisableCondition",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract ISlashingCondition",
          "name": "offendingCondition",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint48",
          "name": "enabledFrom",
          "type": "uint48"
        }
      ],
      "name": "EnableCondition",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferStarted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract ISlashingCondition",
          "name": "offendingCondition",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "validator",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Slashed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "signer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Withdraw",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "ENABLE_CONDITIONS_DELAY",
      "outputs": [
        {
          "internalType": "uint48",
          "name": "",
          "type": "uint48"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "FEE_TOKEN",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_AVAILABLE_QUOTA",
      "outputs": [
        {
          "internalType": "uint96",
          "name": "",
          "type": "uint96"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "QUOTA_ENABLED",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "QUOTA_PER_FEE_TOKEN",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "QUOTA_PER_FEE_TOKEN_SCALE",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "TIMEFRAME_QUOTA_RESET",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "acceptOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "unstakeDelaySec",
          "type": "uint32"
        }
      ],
      "name": "addStake",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "signer",
          "type": "address"
        }
      ],
      "name": "availableFreeQuotaForSigner",
      "outputs": [
        {
          "internalType": "uint96",
          "name": "availableFreeQuota",
          "type": "uint96"
        },
        {
          "internalType": "uint96",
          "name": "usedSignerQuota",
          "type": "uint96"
        },
        {
          "internalType": "uint48",
          "name": "nextSignerQuotaReset",
          "type": "uint48"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "deposit",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "signer",
          "type": "address"
        },
        {
          "internalType": "uint96",
          "name": "amount",
          "type": "uint96"
        }
      ],
      "name": "depositTokensForSigner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ISlashingCondition",
          "name": "",
          "type": "address"
        }
      ],
      "name": "enabledConditions",
      "outputs": [
        {
          "internalType": "uint48",
          "name": "enabledAfter",
          "type": "uint48"
        },
        {
          "internalType": "uint48",
          "name": "enabledUntil",
          "type": "uint48"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "entryPoint",
      "outputs": [
        {
          "internalType": "contract IEntryPoint",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getDeposit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getSupportedEntrypoint",
      "outputs": [
        {
          "internalType": "contract IEntryPoint",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pendingOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum IPaymaster.PostOpMode",
          "name": "mode",
          "type": "uint8"
        },
        {
          "internalType": "bytes",
          "name": "context",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "actualGasCost",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "actualUserOpFeePerGas",
          "type": "uint256"
        }
      ],
      "name": "postOp",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "quotaStatsForSigner",
      "outputs": [
        {
          "internalType": "uint96",
          "name": "tokenBalance",
          "type": "uint96"
        },
        {
          "internalType": "uint96",
          "name": "usedQuota",
          "type": "uint96"
        },
        {
          "internalType": "uint48",
          "name": "nextQuotaReset",
          "type": "uint48"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ISlashingCondition",
          "name": "offendingCondition",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "initCode",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            },
            {
              "internalType": "bytes32",
              "name": "accountGasLimits",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "preVerificationGas",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "gasFees",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "paymasterAndData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct PackedUserOperation",
          "name": "userOp",
          "type": "tuple"
        }
      ],
      "name": "slashValidator",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "slashedTokens",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "slashedUserOps",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unlockStake",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "initCode",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            },
            {
              "internalType": "bytes32",
              "name": "accountGasLimits",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "preVerificationGas",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "gasFees",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "paymasterAndData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct PackedUserOperation",
          "name": "userOp",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "userOpHash",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "maxCost",
          "type": "uint256"
        }
      ],
      "name": "validatePaymasterUserOp",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "context",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "validationData",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        },
        {
          "internalType": "uint96",
          "name": "amount",
          "type": "uint96"
        },
        {
          "internalType": "address",
          "name": "beneficiary",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        }
      ],
      "name": "widthdrawTokensForSigner",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "withdrawAddress",
          "type": "address"
        }
      ],
      "name": "withdrawStake",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "withdrawAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "withdrawTo",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "withdrawsForSigner",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "args": [
    "0xF4f42442E2AE1d7Ea87087aF73B2Abb5536290C2",
    "0x4337084d9e255ff0702461cf8895ce9e3b5ff108",
    {
      "timeframeQuotaReset": 86400,
      "requiredQuotaMultiplier": 1,
      "maxAvailableQuota": 0,
      "feeToken": "0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14",
      "quotaPerFeeToken": 1000,
      "quotaPerFeeTokenScale": 0
    },
    {
      "enableCoditionsDelay": 172800,
      "initialConditions": []
    }
  ],
  "numDeployments": 12,
  "solcInputHash": "7e4ea39aac3aeda7fc17da81095340a1",
  "metadata": "{\"compiler\":{\"version\":\"0.8.29+commit.ab55807c\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"contract IEntryPoint\",\"name\":\"supportedEntrypoint\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"timeframeQuotaReset\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"requiredQuotaMultiplier\",\"type\":\"uint16\"},{\"internalType\":\"uint96\",\"name\":\"maxAvailableQuota\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"quotaPerFeeToken\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"quotaPerFeeTokenScale\",\"type\":\"uint8\"}],\"internalType\":\"struct QuotaMixinConfig\",\"name\":\"_quotaMixinconfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"enableCoditionsDelay\",\"type\":\"uint48\"},{\"internalType\":\"contract ISlashingCondition[]\",\"name\":\"initialConditions\",\"type\":\"address[]\"}],\"internalType\":\"struct SlashingMixinConfig\",\"name\":\"_slashingMixinconfig\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignatureSValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"targetSelector\",\"type\":\"bytes4\"}],\"name\":\"InvalidTarget\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidUserOpPaymaster\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ISlashingCondition\",\"name\":\"offendingCondition\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"enabledUntil\",\"type\":\"uint48\"}],\"name\":\"DisableCondition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ISlashingCondition\",\"name\":\"offendingCondition\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"enabledFrom\",\"type\":\"uint48\"}],\"name\":\"EnableCondition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ISlashingCondition\",\"name\":\"offendingCondition\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Slashed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ENABLE_CONDITIONS_DELAY\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_AVAILABLE_QUOTA\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"QUOTA_ENABLED\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"QUOTA_PER_FEE_TOKEN\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"QUOTA_PER_FEE_TOKEN_SCALE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIMEFRAME_QUOTA_RESET\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"unstakeDelaySec\",\"type\":\"uint32\"}],\"name\":\"addStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"availableFreeQuotaForSigner\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"availableFreeQuota\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"usedSignerQuota\",\"type\":\"uint96\"},{\"internalType\":\"uint48\",\"name\":\"nextSignerQuotaReset\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"depositTokensForSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISlashingCondition\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"enabledConditions\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"enabledAfter\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"enabledUntil\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryPoint\",\"outputs\":[{\"internalType\":\"contract IEntryPoint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSupportedEntrypoint\",\"outputs\":[{\"internalType\":\"contract IEntryPoint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPaymaster.PostOpMode\",\"name\":\"mode\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"actualGasCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actualUserOpFeePerGas\",\"type\":\"uint256\"}],\"name\":\"postOp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"quotaStatsForSigner\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"tokenBalance\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"usedQuota\",\"type\":\"uint96\"},{\"internalType\":\"uint48\",\"name\":\"nextQuotaReset\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISlashingCondition\",\"name\":\"offendingCondition\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"accountGasLimits\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"gasFees\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct PackedUserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"}],\"name\":\"slashValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slashedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"slashedUserOps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"accountGasLimits\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"gasFees\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct PackedUserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"userOpHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maxCost\",\"type\":\"uint256\"}],\"name\":\"validatePaymasterUserOp\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"validationData\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"widthdrawTokensForSigner\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"withdrawAddress\",\"type\":\"address\"}],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"withdrawAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"withdrawsForSigner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}],\"SafeERC20FailedOperation(address)\":[{\"details\":\"An operation with an ERC-20 token failed.\"}]},\"kind\":\"dev\",\"methods\":{\"acceptOwnership()\":{\"details\":\"The new owner accepts the ownership transfer.\"},\"addStake(uint32)\":{\"params\":{\"unstakeDelaySec\":\"- The unstake delay for this paymaster. Can only be increased.\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"pendingOwner()\":{\"details\":\"Returns the address of the pending owner.\"},\"postOp(uint8,bytes,uint256,uint256)\":{\"params\":{\"actualGasCost\":\"- Actual cost of gas used so far (without this postOp call).\",\"actualUserOpFeePerGas\":\"- the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas                        and maxPriorityFee (and basefee)                        It is not the same as tx.gasprice, which is what the bundler pays.\",\"context\":\"- The context value returned by validatePaymasterUserOp\",\"mode\":\"- Enum with the following options:                        opSucceeded - User operation succeeded.                        opReverted  - User op reverted. The paymaster still has to pay for gas.                        postOpReverted - never passed in a call to postOp().\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner. Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\"},\"validatePaymasterUserOp((address,uint256,bytes,bytes,bytes32,uint256,bytes32,bytes,bytes),bytes32,uint256)\":{\"params\":{\"maxCost\":\"- The maximum cost of this transaction (based on maximum gas and gas price from userOp).\",\"userOp\":\"- The user operation.\",\"userOpHash\":\"- Hash of the user's request data.\"},\"returns\":{\"context\":\"       - Value to send to a postOp. Zero length to signify postOp is not required.\",\"validationData\":\"- Signature and time-range of this operation, encoded the same as the return                          value of validateUserOperation.                          <20-byte> aggregatorOrSigFail - 0 for valid signature, 1 to mark signature failure,                                                    other values are invalid for paymaster.                          <6-byte> validUntil - Last timestamp this operation is valid at, or 0 for \\\"indefinitely\\\"                          <6-byte> validAfter - first timestamp this operation is valid                          Note that the validation code cannot use block.timestamp (or block.number) directly.\"}},\"withdrawStake(address)\":{\"params\":{\"withdrawAddress\":\"- The address to send withdrawn value.\"}},\"withdrawTo(address,uint256)\":{\"params\":{\"amount\":\"- Amount to withdraw.\",\"withdrawAddress\":\"- Target to send to.\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"InvalidSignature()\":[{\"notice\":\"Thrown if `ecrecover` yields `address(0)`.\"}],\"InvalidSignatureSValue()\":[{\"notice\":\"Thrown if the S value of the signature is not from the lower half of the curve.\"}]},\"kind\":\"user\",\"methods\":{\"addStake(uint32)\":{\"notice\":\"Add stake for this paymaster. This method can also carry eth value to add to the current stake.\"},\"deposit()\":{\"notice\":\"Add a deposit for this paymaster, used for paying for transaction fees.\"},\"getDeposit()\":{\"notice\":\"Return current paymaster's deposit on the entryPoint.\"},\"postOp(uint8,bytes,uint256,uint256)\":{\"notice\":\"Post-operation handler. Must verify sender is the entryPoint.\"},\"unlockStake()\":{\"notice\":\"Unlock the stake, in order to withdraw it. The paymaster can't serve requests once unlocked, until it calls addStake again\"},\"validatePaymasterUserOp((address,uint256,bytes,bytes,bytes32,uint256,bytes32,bytes,bytes),bytes32,uint256)\":{\"notice\":\"Payment validation: check if paymaster agrees to pay. Must verify sender is the entryPoint. Revert to reject this request. Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted). The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\"},\"withdrawStake(address)\":{\"notice\":\"Withdraw the entire paymaster's stake. stake must be unlocked first (and then wait for the unstakeDelay to be over)\"},\"withdrawTo(address,uint256)\":{\"notice\":\"Withdraw value from the deposit.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/SafeHarbourPaymaster.sol\":\"SafeHarbourPaymaster\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@account-abstraction/contracts/core/BasePaymaster.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/* solhint-disable reason-string */\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport \\\"../interfaces/IPaymaster.sol\\\";\\nimport \\\"../interfaces/IEntryPoint.sol\\\";\\nimport \\\"./UserOperationLib.sol\\\";\\n/**\\n * Helper class for creating a paymaster.\\n * provides helper methods for staking.\\n * Validates that the postOp is called only by the entryPoint.\\n */\\nabstract contract BasePaymaster is IPaymaster, Ownable2Step {\\n    IEntryPoint public immutable entryPoint;\\n\\n    uint256 internal constant PAYMASTER_VALIDATION_GAS_OFFSET = UserOperationLib.PAYMASTER_VALIDATION_GAS_OFFSET;\\n    uint256 internal constant PAYMASTER_POSTOP_GAS_OFFSET = UserOperationLib.PAYMASTER_POSTOP_GAS_OFFSET;\\n    uint256 internal constant PAYMASTER_DATA_OFFSET = UserOperationLib.PAYMASTER_DATA_OFFSET;\\n\\n    constructor(IEntryPoint _entryPoint) Ownable(msg.sender) {\\n        _validateEntryPointInterface(_entryPoint);\\n        entryPoint = _entryPoint;\\n    }\\n\\n    // Sanity check: make sure this EntryPoint was compiled against the same\\n    // IEntryPoint of this paymaster\\n    function _validateEntryPointInterface(IEntryPoint _entryPoint) internal virtual {\\n        require(IERC165(address(_entryPoint)).supportsInterface(type(IEntryPoint).interfaceId), \\\"IEntryPoint interface mismatch\\\");\\n    }\\n\\n    /// @inheritdoc IPaymaster\\n    function validatePaymasterUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 maxCost\\n    ) external override returns (bytes memory context, uint256 validationData) {\\n        _requireFromEntryPoint();\\n        return _validatePaymasterUserOp(userOp, userOpHash, maxCost);\\n    }\\n\\n    /**\\n     * Validate a user operation.\\n     * @param userOp     - The user operation.\\n     * @param userOpHash - The hash of the user operation.\\n     * @param maxCost    - The maximum cost of the user operation.\\n     */\\n    function _validatePaymasterUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 maxCost\\n    ) internal virtual returns (bytes memory context, uint256 validationData);\\n\\n    /// @inheritdoc IPaymaster\\n    function postOp(\\n        PostOpMode mode,\\n        bytes calldata context,\\n        uint256 actualGasCost,\\n        uint256 actualUserOpFeePerGas\\n    ) external override {\\n        _requireFromEntryPoint();\\n        _postOp(mode, context, actualGasCost, actualUserOpFeePerGas);\\n    }\\n\\n    /**\\n     * Post-operation handler.\\n     * (verified to be called only through the entryPoint)\\n     * @dev If subclass returns a non-empty context from validatePaymasterUserOp,\\n     *      it must also implement this method.\\n     * @param mode          - Enum with the following options:\\n     *                        opSucceeded - User operation succeeded.\\n     *                        opReverted  - User op reverted. The paymaster still has to pay for gas.\\n     *                        postOpReverted - never passed in a call to postOp().\\n     * @param context       - The context value returned by validatePaymasterUserOp\\n     * @param actualGasCost - Actual cost of gas used so far (without this postOp call).\\n     * @param actualUserOpFeePerGas - the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas\\n     *                        and maxPriorityFee (and basefee)\\n     *                        It is not the same as tx.gasprice, which is what the bundler pays.\\n     */\\n    function _postOp(\\n        PostOpMode mode,\\n        bytes calldata context,\\n        uint256 actualGasCost,\\n        uint256 actualUserOpFeePerGas\\n    ) internal virtual {\\n        (mode, context, actualGasCost, actualUserOpFeePerGas); // unused params\\n        // subclass must override this method if validatePaymasterUserOp returns a context\\n        revert(\\\"must override\\\");\\n    }\\n\\n    /**\\n     * Add a deposit for this paymaster, used for paying for transaction fees.\\n     */\\n    function deposit() public payable {\\n        entryPoint.depositTo{value: msg.value}(address(this));\\n    }\\n\\n    /**\\n     * Withdraw value from the deposit.\\n     * @param withdrawAddress - Target to send to.\\n     * @param amount          - Amount to withdraw.\\n     */\\n    function withdrawTo(\\n        address payable withdrawAddress,\\n        uint256 amount\\n    ) public onlyOwner {\\n        entryPoint.withdrawTo(withdrawAddress, amount);\\n    }\\n\\n    /**\\n     * Add stake for this paymaster.\\n     * This method can also carry eth value to add to the current stake.\\n     * @param unstakeDelaySec - The unstake delay for this paymaster. Can only be increased.\\n     */\\n    function addStake(uint32 unstakeDelaySec) external payable onlyOwner {\\n        entryPoint.addStake{value: msg.value}(unstakeDelaySec);\\n    }\\n\\n    /**\\n     * Return current paymaster's deposit on the entryPoint.\\n     */\\n    function getDeposit() public view returns (uint256) {\\n        return entryPoint.balanceOf(address(this));\\n    }\\n\\n    /**\\n     * Unlock the stake, in order to withdraw it.\\n     * The paymaster can't serve requests once unlocked, until it calls addStake again\\n     */\\n    function unlockStake() external onlyOwner {\\n        entryPoint.unlockStake();\\n    }\\n\\n    /**\\n     * Withdraw the entire paymaster's stake.\\n     * stake must be unlocked first (and then wait for the unstakeDelay to be over)\\n     * @param withdrawAddress - The address to send withdrawn value.\\n     */\\n    function withdrawStake(address payable withdrawAddress) external onlyOwner {\\n        entryPoint.withdrawStake(withdrawAddress);\\n    }\\n\\n    /**\\n     * Validate the call is made from a valid entrypoint\\n     */\\n    function _requireFromEntryPoint() internal virtual {\\n        require(msg.sender == address(entryPoint), \\\"Sender not EntryPoint\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x133b7392daa1fc943d834b7d7721c8dd76327df47ae93f53de5c3a0fa79d9741\",\"license\":\"MIT\"},\"@account-abstraction/contracts/core/Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/* solhint-disable no-inline-assembly */\\n\\n\\n /*\\n  * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\\n  * must return this value in case of signature failure, instead of revert.\\n  */\\nuint256 constant SIG_VALIDATION_FAILED = 1;\\n\\n\\n/*\\n * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\\n * return this value on success.\\n */\\nuint256 constant SIG_VALIDATION_SUCCESS = 0;\\n\\n\\n/**\\n * Returned data from validateUserOp.\\n * validateUserOp returns a uint256, which is created by `_packedValidationData` and\\n * parsed by `_parseValidationData`.\\n * @param aggregator  - address(0) - The account validated the signature by itself.\\n *                      address(1) - The account failed to validate the signature.\\n *                      otherwise - This is an address of a signature aggregator that must\\n *                                  be used to validate the signature.\\n * @param validAfter  - This UserOp is valid only after this timestamp.\\n * @param validUntil - Last timestamp this operation is valid at, or 0 for \\\"indefinitely\\\".\\n */\\nstruct ValidationData {\\n    address aggregator;\\n    uint48 validAfter;\\n    uint48 validUntil;\\n}\\n\\n/**\\n * Extract aggregator/sigFailed, validAfter, validUntil.\\n * Also convert zero validUntil to type(uint48).max.\\n * @param validationData - The packed validation data.\\n * @return data - The unpacked in-memory validation data.\\n */\\nfunction _parseValidationData(\\n    uint256 validationData\\n) pure returns (ValidationData memory data) {\\n    address aggregator = address(uint160(validationData));\\n    uint48 validUntil = uint48(validationData >> 160);\\n    if (validUntil == 0) {\\n        validUntil = type(uint48).max;\\n    }\\n    uint48 validAfter = uint48(validationData >> (48 + 160));\\n    return ValidationData(aggregator, validAfter, validUntil);\\n}\\n\\n/**\\n * Helper to pack the return value for validateUserOp.\\n * @param data - The ValidationData to pack.\\n * @return the packed validation data.\\n */\\nfunction _packValidationData(\\n    ValidationData memory data\\n) pure returns (uint256) {\\n    return\\n        uint160(data.aggregator) |\\n        (uint256(data.validUntil) << 160) |\\n        (uint256(data.validAfter) << (160 + 48));\\n}\\n\\n/**\\n * Helper to pack the return value for validateUserOp, when not using an aggregator.\\n * @param sigFailed  - True for signature failure, false for success.\\n * @param validUntil - Last timestamp this operation is valid at, or 0 for \\\"indefinitely\\\".\\n * @param validAfter - First timestamp this UserOperation is valid.\\n * @return the packed validation data.\\n */\\nfunction _packValidationData(\\n    bool sigFailed,\\n    uint48 validUntil,\\n    uint48 validAfter\\n) pure returns (uint256) {\\n    return\\n        (sigFailed ?  SIG_VALIDATION_FAILED : SIG_VALIDATION_SUCCESS) |\\n        (uint256(validUntil) << 160) |\\n        (uint256(validAfter) << (160 + 48));\\n}\\n\\n/**\\n * keccak function over calldata.\\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\\n *\\n * @param data - the calldata bytes array to perform keccak on.\\n * @return ret - the keccak hash of the 'data' array.\\n */\\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\\n        assembly (\\\"memory-safe\\\") {\\n            let mem := mload(0x40)\\n            let len := data.length\\n            calldatacopy(mem, data.offset, len)\\n            ret := keccak256(mem, len)\\n        }\\n    }\\n\\n\\n/**\\n * The minimum of two numbers.\\n * @param a - First number.\\n * @param b - Second number.\\n * @return - the minimum value.\\n */\\n    function min(uint256 a, uint256 b) pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n/**\\n * standard solidity memory allocation finalization.\\n * copied from solidity generated code\\n * @param memPointer - The current memory pointer\\n * @param allocationSize - Bytes allocated from memPointer.\\n */\\n    function finalizeAllocation(uint256 memPointer, uint256 allocationSize) pure {\\n\\n        assembly (\\\"memory-safe\\\"){\\n            finalize_allocation(memPointer, allocationSize)\\n\\n            function finalize_allocation(memPtr, size) {\\n                let newFreePtr := add(memPtr, round_up_to_mul_of_32(size))\\n                mstore(64, newFreePtr)\\n            }\\n\\n            function round_up_to_mul_of_32(value) -> result {\\n                result := and(add(value, 31), not(31))\\n            }\\n        }\\n    }\\n\",\"keccak256\":\"0x42b948af5fa14a96149611595df1186800c7558b2de8762e4b45a7c45c16f65e\",\"license\":\"MIT\"},\"@account-abstraction/contracts/core/UserOperationLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/* solhint-disable no-inline-assembly */\\n\\nimport \\\"../interfaces/PackedUserOperation.sol\\\";\\nimport {calldataKeccak, min} from \\\"./Helpers.sol\\\";\\n\\n/**\\n * Utility functions helpful when working with UserOperation structs.\\n */\\nlibrary UserOperationLib {\\n\\n    uint256 public constant PAYMASTER_VALIDATION_GAS_OFFSET = 20;\\n    uint256 public constant PAYMASTER_POSTOP_GAS_OFFSET = 36;\\n    uint256 public constant PAYMASTER_DATA_OFFSET = 52;\\n\\n    /**\\n     * Relayer/block builder might submit the TX with higher priorityFee,\\n     * but the user should not pay above what he signed for.\\n     * @param userOp - The user operation data.\\n     */\\n    function gasPrice(\\n        PackedUserOperation calldata userOp\\n    ) internal view returns (uint256) {\\n        unchecked {\\n            (uint256 maxPriorityFeePerGas, uint256 maxFeePerGas) = unpackUints(userOp.gasFees);\\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n        }\\n    }\\n\\n    bytes32 internal constant PACKED_USEROP_TYPEHASH =\\n    keccak256(\\n        \\\"PackedUserOperation(address sender,uint256 nonce,bytes initCode,bytes callData,bytes32 accountGasLimits,uint256 preVerificationGas,bytes32 gasFees,bytes paymasterAndData)\\\"\\n    );\\n\\n    /**\\n     * Pack the user operation data into bytes for hashing.\\n     * @param userOp - The user operation data.\\n     * @param overrideInitCodeHash - If set, encode this instead of the initCode field in the userOp.\\n     */\\n    function encode(\\n        PackedUserOperation calldata userOp,\\n        bytes32 overrideInitCodeHash\\n    ) internal pure returns (bytes memory ret) {\\n        address sender = userOp.sender;\\n        uint256 nonce = userOp.nonce;\\n        bytes32 hashInitCode = overrideInitCodeHash != 0 ? overrideInitCodeHash : calldataKeccak(userOp.initCode);\\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\\n        bytes32 accountGasLimits = userOp.accountGasLimits;\\n        uint256 preVerificationGas = userOp.preVerificationGas;\\n        bytes32 gasFees = userOp.gasFees;\\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\\n\\n        return abi.encode(\\n            UserOperationLib.PACKED_USEROP_TYPEHASH,\\n            sender, nonce,\\n            hashInitCode, hashCallData,\\n            accountGasLimits, preVerificationGas, gasFees,\\n            hashPaymasterAndData\\n        );\\n    }\\n\\n    function unpackUints(\\n        bytes32 packed\\n    ) internal pure returns (uint256 high128, uint256 low128) {\\n        return (unpackHigh128(packed), unpackLow128(packed));\\n    }\\n\\n    // Unpack just the high 128-bits from a packed value\\n    function unpackHigh128(bytes32 packed) internal pure returns (uint256) {\\n        return uint256(packed) >> 128;\\n    }\\n\\n    // Unpack just the low 128-bits from a packed value\\n    function unpackLow128(bytes32 packed) internal pure returns (uint256) {\\n        return uint128(uint256(packed));\\n    }\\n\\n    function unpackMaxPriorityFeePerGas(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackHigh128(userOp.gasFees);\\n    }\\n\\n    function unpackMaxFeePerGas(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackLow128(userOp.gasFees);\\n    }\\n\\n    function unpackVerificationGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackHigh128(userOp.accountGasLimits);\\n    }\\n\\n    function unpackCallGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackLow128(userOp.accountGasLimits);\\n    }\\n\\n    function unpackPaymasterVerificationGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET]));\\n    }\\n\\n    function unpackPostOpGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]));\\n    }\\n\\n    function unpackPaymasterStaticFields(\\n        bytes calldata paymasterAndData\\n    ) internal pure returns (address paymaster, uint256 validationGasLimit, uint256 postOpGasLimit) {\\n        return (\\n            address(bytes20(paymasterAndData[: PAYMASTER_VALIDATION_GAS_OFFSET])),\\n            uint128(bytes16(paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET])),\\n            uint128(bytes16(paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]))\\n        );\\n    }\\n\\n    /**\\n     * Hash the user operation data.\\n     * @param userOp - The user operation data.\\n     * @param overrideInitCodeHash - If set, the initCode hash will be replaced with this value just for UserOp hashing.\\n     */\\n    function hash(\\n        PackedUserOperation calldata userOp,\\n        bytes32 overrideInitCodeHash\\n    ) internal pure returns (bytes32) {\\n        return keccak256(encode(userOp, overrideInitCodeHash));\\n    }\\n}\\n\",\"keccak256\":\"0x2d3450fa3906422b6fdbbe7f2a2a9e36d6f3751bfa9cd80af88befd6a5be78c1\",\"license\":\"MIT\"},\"@account-abstraction/contracts/interfaces/IAccount.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport \\\"./PackedUserOperation.sol\\\";\\n\\ninterface IAccount {\\n    /**\\n     * Validate user's signature and nonce\\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\\n     * This allows making a \\\"simulation call\\\" without a valid signature\\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\\n     *\\n     * @dev Must validate caller is the entryPoint.\\n     *      Must validate the signature and nonce\\n     * @param userOp              - The operation that is about to be executed.\\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for signature.\\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\\n     *                              This is the minimum amount to transfer to the sender(entryPoint) to be\\n     *                              able to make the call. The excess is left as a deposit in the entrypoint\\n     *                              for future calls. Can be withdrawn anytime using \\\"entryPoint.withdrawTo()\\\".\\n     *                              In case there is a paymaster in the request (or the current deposit is high\\n     *                              enough), this value will be zero.\\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData` and\\n     *                              `_unpackValidationData` to encode and decode.\\n     *                              <20-byte> aggregatorOrSigFail - 0 for valid signature, 1 to mark signature failure,\\n     *                                 otherwise, an address of an \\\"aggregator\\\" contract.\\n     *                              <6-byte> validUntil - Last timestamp this operation is valid at, or 0 for \\\"indefinitely\\\"\\n     *                              <6-byte> validAfter - First timestamp this operation is valid\\n     *                                                    If an account doesn't use time-range, it is enough to\\n     *                                                    return SIG_VALIDATION_FAILED value (1) for signature failure.\\n     *                              Note that the validation code cannot use block.timestamp (or block.number) directly.\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    ) external returns (uint256 validationData);\\n}\\n\",\"keccak256\":\"0x1030b464b49ce80da46b5b6c9af357c2d526f308de61391db6a4ec767d33b864\",\"license\":\"MIT\"},\"@account-abstraction/contracts/interfaces/IAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport \\\"./PackedUserOperation.sol\\\";\\n\\n/**\\n * Aggregated Signatures validator.\\n */\\ninterface IAggregator {\\n    /**\\n     * Validate an aggregated signature.\\n     * Reverts if the aggregated signature does not match the given list of operations.\\n     * @param userOps   - An array of UserOperations to validate the signature for.\\n     * @param signature - The aggregated signature.\\n     */\\n    function validateSignatures(\\n        PackedUserOperation[] calldata userOps,\\n        bytes calldata signature\\n    ) external;\\n\\n    /**\\n     * Validate the signature of a single userOp.\\n     * This method should be called by bundler after EntryPointSimulation.simulateValidation() returns\\n     * the aggregator this account uses.\\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\\n     * @param userOp        - The userOperation received from the user.\\n     * @return sigForUserOp - The value to put into the signature field of the userOp when calling handleOps.\\n     *                        (usually empty, unless account and aggregator support some kind of \\\"multisig\\\".\\n     */\\n    function validateUserOpSignature(\\n        PackedUserOperation calldata userOp\\n    ) external view returns (bytes memory sigForUserOp);\\n\\n    /**\\n     * Aggregate multiple signatures into a single value.\\n     * This method is called off-chain to calculate the signature to pass with handleOps()\\n     * bundler MAY use optimized custom code to perform this aggregation.\\n     * @param userOps              - An array of UserOperations to collect the signatures from.\\n     * @return aggregatedSignature - The aggregated signature.\\n     */\\n    function aggregateSignatures(\\n        PackedUserOperation[] calldata userOps\\n    ) external view returns (bytes memory aggregatedSignature);\\n}\\n\",\"keccak256\":\"0xdf580eafa015b81bde436d6a5468cc92b531ada84007cef885e923f6dfc5e8bf\",\"license\":\"MIT\"},\"@account-abstraction/contracts/interfaces/IEntryPoint.sol\":{\"content\":\"/**\\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\\n ** Only one instance required on each chain.\\n **/\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-inline-assembly */\\n/* solhint-disable reason-string */\\n\\nimport \\\"./PackedUserOperation.sol\\\";\\nimport \\\"./IStakeManager.sol\\\";\\nimport \\\"./IAggregator.sol\\\";\\nimport \\\"./INonceManager.sol\\\";\\nimport \\\"./ISenderCreator.sol\\\";\\n\\ninterface IEntryPoint is IStakeManager, INonceManager {\\n    /***\\n     * An event emitted after each successful request.\\n     * @param userOpHash    - Unique identifier for the request (hash its entire content, except signature).\\n     * @param sender        - The account that generates this request.\\n     * @param paymaster     - If non-null, the paymaster that pays for this request.\\n     * @param nonce         - The nonce value from the request.\\n     * @param success       - True if the sender transaction succeeded, false if reverted.\\n     * @param actualGasCost - Actual amount paid (by account or paymaster) for this UserOperation.\\n     * @param actualGasUsed - Total gas used by this UserOperation (including preVerification, creation,\\n     *                        validation and execution).\\n     */\\n    event UserOperationEvent(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        address indexed paymaster,\\n        uint256 nonce,\\n        bool success,\\n        uint256 actualGasCost,\\n        uint256 actualGasUsed\\n    );\\n\\n    /**\\n     * Account \\\"sender\\\" was deployed.\\n     * @param userOpHash - The userOp that deployed this account. UserOperationEvent will follow.\\n     * @param sender     - The account that is deployed\\n     * @param factory    - The factory used to deploy this account (in the initCode)\\n     * @param paymaster  - The paymaster used by this UserOp\\n     */\\n    event AccountDeployed(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        address factory,\\n        address paymaster\\n    );\\n\\n    /**\\n     * An event emitted if the UserOperation \\\"callData\\\" reverted with non-zero length.\\n     * @param userOpHash   - The request unique identifier.\\n     * @param sender       - The sender of this request.\\n     * @param nonce        - The nonce used in the request.\\n     * @param revertReason - The return bytes from the reverted \\\"callData\\\" call.\\n     */\\n    event UserOperationRevertReason(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        uint256 nonce,\\n        bytes revertReason\\n    );\\n\\n    /**\\n     * An event emitted if the UserOperation Paymaster's \\\"postOp\\\" call reverted with non-zero length.\\n     * @param userOpHash   - The request unique identifier.\\n     * @param sender       - The sender of this request.\\n     * @param nonce        - The nonce used in the request.\\n     * @param revertReason - The return bytes from the reverted call to \\\"postOp\\\".\\n     */\\n    event PostOpRevertReason(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        uint256 nonce,\\n        bytes revertReason\\n    );\\n\\n    /**\\n     * UserOp consumed more than prefund. The UserOperation is reverted, and no refund is made.\\n     * @param userOpHash   - The request unique identifier.\\n     * @param sender       - The sender of this request.\\n     * @param nonce        - The nonce used in the request.\\n     */\\n    event UserOperationPrefundTooLow(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        uint256 nonce\\n    );\\n\\n    /**\\n     * An event emitted by handleOps() and handleAggregatedOps(), before starting the execution loop.\\n     * Any event emitted before this event, is part of the validation.\\n     */\\n    event BeforeExecution();\\n\\n    /**\\n     * Signature aggregator used by the following UserOperationEvents within this bundle.\\n     * @param aggregator - The aggregator used for the following UserOperationEvents.\\n     */\\n    event SignatureAggregatorChanged(address indexed aggregator);\\n\\n    /**\\n     * A custom revert error of handleOps andhandleAggregatedOps, to identify the offending op.\\n     * Should be caught in off-chain handleOps/handleAggregatedOps simulation and not happen on-chain.\\n     * Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\\n     * NOTE: If simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\\n     * @param reason  - Revert reason. The string starts with a unique code \\\"AAmn\\\",\\n     *                  where \\\"m\\\" is \\\"1\\\" for factory, \\\"2\\\" for account and \\\"3\\\" for paymaster issues,\\n     *                  so a failure can be attributed to the correct entity.\\n     */\\n    error FailedOp(uint256 opIndex, string reason);\\n\\n    /**\\n     * A custom revert error of handleOps and handleAggregatedOps, to report a revert by account or paymaster.\\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\\n     * @param reason  - Revert reason. see FailedOp(uint256,string), above\\n     * @param inner   - data from inner cought revert reason\\n     * @dev note that inner is truncated to 2048 bytes\\n     */\\n    error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner);\\n\\n    error PostOpReverted(bytes returnData);\\n\\n    /**\\n     * Error case when a signature aggregator fails to verify the aggregated signature it had created.\\n     * @param aggregator The aggregator that failed to verify the signature\\n     */\\n    error SignatureValidationFailed(address aggregator);\\n\\n    // Return value of getSenderAddress.\\n    error SenderAddressResult(address sender);\\n\\n    // UserOps handled, per aggregator.\\n    struct UserOpsPerAggregator {\\n        PackedUserOperation[] userOps;\\n        // Aggregator address\\n        IAggregator aggregator;\\n        // Aggregated signature\\n        bytes signature;\\n    }\\n\\n    /**\\n     * Execute a batch of UserOperations.\\n     * No signature aggregator is used.\\n     * If any account requires an aggregator (that is, it returned an aggregator when\\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\\n     * @param ops         - The operations to execute.\\n     * @param beneficiary - The address to receive the fees.\\n     */\\n    function handleOps(\\n        PackedUserOperation[] calldata ops,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * Execute a batch of UserOperation with Aggregators\\n     * @param opsPerAggregator - The operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts).\\n     * @param beneficiary      - The address to receive the fees.\\n     */\\n    function handleAggregatedOps(\\n        UserOpsPerAggregator[] calldata opsPerAggregator,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * Generate a request Id - unique identifier for this request.\\n     * The request ID is a hash over the content of the userOp (except the signature), entrypoint address, chainId and (optionally) 7702 delegate address\\n     * @param userOp - The user operation to generate the request ID for.\\n     * @return hash the hash of this UserOperation\\n     */\\n    function getUserOpHash(\\n        PackedUserOperation calldata userOp\\n    ) external view returns (bytes32);\\n\\n    /**\\n     * Gas and return values during simulation.\\n     * @param preOpGas         - The gas used for validation (including preValidationGas)\\n     * @param prefund          - The required prefund for this operation\\n     * @param accountValidationData   - returned validationData from account.\\n     * @param paymasterValidationData - return validationData from paymaster.\\n     * @param paymasterContext - Returned by validatePaymasterUserOp (to be passed into postOp)\\n     */\\n    struct ReturnInfo {\\n        uint256 preOpGas;\\n        uint256 prefund;\\n        uint256 accountValidationData;\\n        uint256 paymasterValidationData;\\n        bytes paymasterContext;\\n    }\\n\\n    /**\\n     * Get counterfactual sender address.\\n     * Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\\n     * This method always revert, and returns the address in SenderAddressResult error.\\n     * @notice this method cannot be used for EIP-7702 derived contracts.\\n     *\\n     * @param initCode - The constructor code to be passed into the UserOperation.\\n     */\\n    function getSenderAddress(bytes memory initCode) external;\\n\\n    error DelegateAndRevert(bool success, bytes ret);\\n\\n    /**\\n     * Helper method for dry-run testing.\\n     * @dev calling this method, the EntryPoint will make a delegatecall to the given data, and report (via revert) the result.\\n     *  The method always revert, so is only useful off-chain for dry run calls, in cases where state-override to replace\\n     *  actual EntryPoint code is less convenient.\\n     * @param target a target contract to make a delegatecall from entrypoint\\n     * @param data data to pass to target in a delegatecall\\n     */\\n    function delegateAndRevert(address target, bytes calldata data) external;\\n\\n    /**\\n     * @notice Retrieves the immutable SenderCreator contract which is responsible for deployment of sender contracts.\\n     */\\n    function senderCreator() external view returns (ISenderCreator);\\n}\\n\",\"keccak256\":\"0x3b0423737e810dd886183ed32cfed9b45edd315f5fb3e1076fc19f86791adc64\",\"license\":\"MIT\"},\"@account-abstraction/contracts/interfaces/INonceManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\ninterface INonceManager {\\n\\n    /**\\n     * Return the next nonce for this sender.\\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\\n     * But UserOp with different keys can come with arbitrary order.\\n     *\\n     * @param sender the account address\\n     * @param key the high 192 bit of the nonce\\n     * @return nonce a full nonce to pass for next UserOp with this sender.\\n     */\\n    function getNonce(address sender, uint192 key)\\n    external view returns (uint256 nonce);\\n\\n    /**\\n     * Manually increment the nonce of the sender.\\n     * This method is exposed just for completeness..\\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\\n     * as the EntryPoint will update the nonce regardless.\\n     * Possible use-case is call it with various keys to \\\"initialize\\\" their nonces to one, so that future\\n     * UserOperations will not pay extra for the first transaction with a given key.\\n     *\\n     * @param key - the \\\"nonce key\\\" to increment the \\\"nonce sequence\\\" for.\\n     */\\n    function incrementNonce(uint192 key) external;\\n}\\n\",\"keccak256\":\"0xee493ae200b8c675bdc0da66f7ac6bb883ecea33672d7d0a95526b9eecdedf87\",\"license\":\"MIT\"},\"@account-abstraction/contracts/interfaces/IPaymaster.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport \\\"./PackedUserOperation.sol\\\";\\n\\n/**\\n * The interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\\n * A paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\\n */\\ninterface IPaymaster {\\n    enum PostOpMode {\\n        // User op succeeded.\\n        opSucceeded,\\n        // User op reverted. Still has to pay for gas.\\n        opReverted,\\n        // Only used internally in the EntryPoint (cleanup after postOp reverts). Never calling paymaster with this value\\n        postOpReverted\\n    }\\n\\n    /**\\n     * Payment validation: check if paymaster agrees to pay.\\n     * Must verify sender is the entryPoint.\\n     * Revert to reject this request.\\n     * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted).\\n     * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\\n     * @param userOp          - The user operation.\\n     * @param userOpHash      - Hash of the user's request data.\\n     * @param maxCost         - The maximum cost of this transaction (based on maximum gas and gas price from userOp).\\n     * @return context        - Value to send to a postOp. Zero length to signify postOp is not required.\\n     * @return validationData - Signature and time-range of this operation, encoded the same as the return\\n     *                          value of validateUserOperation.\\n     *                          <20-byte> aggregatorOrSigFail - 0 for valid signature, 1 to mark signature failure,\\n     *                                                    other values are invalid for paymaster.\\n     *                          <6-byte> validUntil - Last timestamp this operation is valid at, or 0 for \\\"indefinitely\\\"\\n     *                          <6-byte> validAfter - first timestamp this operation is valid\\n     *                          Note that the validation code cannot use block.timestamp (or block.number) directly.\\n     */\\n    function validatePaymasterUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 maxCost\\n    ) external returns (bytes memory context, uint256 validationData);\\n\\n    /**\\n     * Post-operation handler.\\n     * Must verify sender is the entryPoint.\\n     * @param mode          - Enum with the following options:\\n     *                        opSucceeded - User operation succeeded.\\n     *                        opReverted  - User op reverted. The paymaster still has to pay for gas.\\n     *                        postOpReverted - never passed in a call to postOp().\\n     * @param context       - The context value returned by validatePaymasterUserOp\\n     * @param actualGasCost - Actual cost of gas used so far (without this postOp call).\\n     * @param actualUserOpFeePerGas - the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas\\n     *                        and maxPriorityFee (and basefee)\\n     *                        It is not the same as tx.gasprice, which is what the bundler pays.\\n     */\\n    function postOp(\\n        PostOpMode mode,\\n        bytes calldata context,\\n        uint256 actualGasCost,\\n        uint256 actualUserOpFeePerGas\\n    ) external;\\n}\\n\",\"keccak256\":\"0x6be37abc0760d60a41124e2e3f46185a0d3df48b32bd73174790981f76fbdae8\",\"license\":\"MIT\"},\"@account-abstraction/contracts/interfaces/ISenderCreator.sol\":{\"content\":\"\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\ninterface ISenderCreator {\\n    /**\\n     * @dev Creates a new sender contract.\\n     * @return sender Address of the newly created sender contract.\\n     */\\n    function createSender(bytes calldata initCode) external returns (address sender);\\n\\n    /**\\n     * Use initCallData to initialize an EIP-7702 account.\\n     * The caller is the EntryPoint contract and it is already verified to be an EIP-7702 account.\\n     * Note: Can be called multiple times as long as an appropriate initCode is supplied\\n     *\\n     * @param sender - the 'sender' EIP-7702 account to be initialized.\\n     * @param initCallData - the call data to be passed to the sender account call.\\n     */\\n    function initEip7702Sender(address sender, bytes calldata initCallData) external;\\n}\\n\",\"keccak256\":\"0x677f651d733162b80d1af7901e4f36469e362737a8353d1d0cc7bb94489e4ba4\",\"license\":\"MIT\"},\"@account-abstraction/contracts/interfaces/IStakeManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/**\\n * Manage deposits and stakes.\\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\\n * Stake is value locked for at least \\\"unstakeDelay\\\" by the staked entity.\\n */\\ninterface IStakeManager {\\n    event Deposited(address indexed account, uint256 totalDeposit);\\n\\n    event Withdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    // Emitted when stake or unstake delay are modified.\\n    event StakeLocked(\\n        address indexed account,\\n        uint256 totalStaked,\\n        uint256 unstakeDelaySec\\n    );\\n\\n    // Emitted once a stake is scheduled for withdrawal.\\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\\n\\n    event StakeWithdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @param deposit         - The entity's deposit.\\n     * @param staked          - True if this entity is staked.\\n     * @param stake           - Actual amount of ether staked for this entity.\\n     * @param unstakeDelaySec - Minimum delay to withdraw the stake.\\n     * @param withdrawTime    - First block timestamp where 'withdrawStake' will be callable, or zero if already locked.\\n     * @dev Sizes were chosen so that deposit fits into one cell (used during handleOp)\\n     *      and the rest fit into a 2nd cell (used during stake/unstake)\\n     *      - 112 bit allows for 10^15 eth\\n     *      - 48 bit for full timestamp\\n     *      - 32 bit allows 150 years for unstake delay\\n     */\\n    struct DepositInfo {\\n        uint256 deposit;\\n        bool staked;\\n        uint112 stake;\\n        uint32 unstakeDelaySec;\\n        uint48 withdrawTime;\\n    }\\n\\n    // API struct used by getStakeInfo and simulateValidation.\\n    struct StakeInfo {\\n        uint256 stake;\\n        uint256 unstakeDelaySec;\\n    }\\n\\n    /**\\n     * Get deposit info.\\n     * @param account - The account to query.\\n     * @return info   - Full deposit information of given account.\\n     */\\n    function getDepositInfo(\\n        address account\\n    ) external view returns (DepositInfo memory info);\\n\\n    /**\\n     * Get account balance.\\n     * @param account - The account to query.\\n     * @return        - The deposit (for gas payment) of the account.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * Add to the deposit of the given account.\\n     * @param account - The account to add to.\\n     */\\n    function depositTo(address account) external payable;\\n\\n    /**\\n     * Add to the account's stake - amount and delay\\n     * any pending unstake is first cancelled.\\n     * @param unstakeDelaySec - The new lock duration before the deposit can be withdrawn.\\n     */\\n    function addStake(uint32 unstakeDelaySec) external payable;\\n\\n    /**\\n     * Attempt to unlock the stake.\\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\\n     */\\n    function unlockStake() external;\\n\\n    /**\\n     * Withdraw from the (unlocked) stake.\\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\\n     * @param withdrawAddress - The address to send withdrawn value.\\n     */\\n    function withdrawStake(address payable withdrawAddress) external;\\n\\n    /**\\n     * Withdraw from the deposit.\\n     * @param withdrawAddress - The address to send withdrawn value.\\n     * @param withdrawAmount  - The amount to withdraw.\\n     */\\n    function withdrawTo(\\n        address payable withdrawAddress,\\n        uint256 withdrawAmount\\n    ) external;\\n}\\n\",\"keccak256\":\"0xe48e904fcac02295aad07fbfa1c1d449a74bf44c04e432afef6f34d1ef726ae0\",\"license\":\"MIT\"},\"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/**\\n * User Operation struct\\n * @param sender                - The sender account of this request.\\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\\n * @param initCode              - If set, the account contract will be created by this constructor\\n * @param callData              - The method call to execute on this account.\\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\\n *                                Covers batch overhead.\\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\\n *                                The paymaster will pay for the transaction instead of the sender.\\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n */\\nstruct PackedUserOperation {\\n    address sender;\\n    uint256 nonce;\\n    bytes initCode;\\n    bytes callData;\\n    bytes32 accountGasLimits;\\n    uint256 preVerificationGas;\\n    bytes32 gasFees;\\n    bytes paymasterAndData;\\n    bytes signature;\\n}\\n\",\"keccak256\":\"0xb15188e25e45fe73097e279675b6c0beccbd4133ead2260f8f0c4ba840046800\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\\n * old one. This can help prevent common mistakes, such as transfers of ownership to\\n * incorrect accounts, or to contracts that are unable to interact with the\\n * permission system.\\n *\\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     *\\n     * Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        if (pendingOwner() != sender) {\\n            revert OwnableUnauthorizedAccount(sender);\\n        }\\n        _transferOwnership(sender);\\n    }\\n}\\n\",\"keccak256\":\"0xdcad8898fda432696597752e8ec361b87d85c82cb258115427af006dacf7128c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC1363.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @title IERC1363\\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\\n *\\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\\n */\\ninterface IERC1363 is IERC20, IERC165 {\\n    /*\\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\\n     * 0xb0202a11 ===\\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\\n     */\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @param data Additional data with no specified format, sent in call to `spender`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9b6b3e7803bc5f2f8cd7ad57db8ac1def61a9930a5a3107df4882e028a9605d7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../utils/introspection/IERC165.sol\\\";\\n\",\"keccak256\":\"0xde7e9fd9aee8d4f40772f96bb3b58836cbc6dfc0227014a061947f8821ea9724\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\n\",\"keccak256\":\"0xce41876e78d1badc0512229b4d14e4daf83bc1003d7f83978d18e0e56f965b9c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xe06a3f08a987af6ad2e1c1e774405d4fe08f1694b67517438b467cecf0da0ef7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC1363} from \\\"../../../interfaces/IERC1363.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    /**\\n     * @dev An operation with an ERC-20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     *\\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\\n     * only sets the \\\"standard\\\" allowance. Any temporary allowance will remain active, in addition to the value being\\n     * set here.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            safeTransfer(token, to, value);\\n        } else if (!token.transferAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferFromAndCallRelaxed(\\n        IERC1363 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransferFrom(token, from, to, value);\\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\\n     * once without retrying, and relies on the returned value to be true.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            forceApprove(token, to, value);\\n        } else if (!token.approveAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            // bubble errors\\n            if iszero(success) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n\\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\\n    }\\n}\\n\",\"keccak256\":\"0x982c5cb790ab941d1e04f807120a71709d4c313ba0bfc16006447ffbd27fbbd5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8\",\"license\":\"MIT\"},\"src/SafeHarbourPaymaster.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\nimport {\\n    BasePaymaster\\n} from \\\"@account-abstraction/contracts/core/BasePaymaster.sol\\\";\\nimport {\\n    PackedUserOperation\\n} from \\\"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\\\";\\nimport {\\n    IEntryPoint\\n} from \\\"@account-abstraction/contracts/interfaces/IEntryPoint.sol\\\";\\nimport {\\n    _packValidationData\\n} from \\\"@account-abstraction/contracts/core/Helpers.sol\\\";\\nimport {QuotaMixin, QuotaMixinConfig} from \\\"./mixins/QuotaMixin.sol\\\";\\nimport {SlashingMixin, SlashingMixinConfig} from \\\"./mixins/SlashingMixin.sol\\\";\\nimport {ERC4337Mixin} from \\\"./mixins/ERC4337Mixin.sol\\\";\\nimport {PaymasterLib} from \\\"./libs/PaymasterLib.sol\\\";\\nimport {CoreLib} from \\\"./libs/CoreLib.sol\\\";\\nimport {InvalidTarget, InvalidUserOpPaymaster} from \\\"./interfaces/Errors.sol\\\";\\n\\n// TODO: do not use BasePaymaster as it is not optimized to our needs (i.e. no custom errors)\\ncontract SafeHarbourPaymaster is BasePaymaster, QuotaMixin, SlashingMixin {\\n    using PaymasterLib for PackedUserOperation;\\n\\n    constructor(\\n        address manager,\\n        IEntryPoint supportedEntrypoint,\\n        QuotaMixinConfig memory _quotaMixinconfig,\\n        SlashingMixinConfig memory _slashingMixinconfig\\n    )\\n        BasePaymaster(supportedEntrypoint)\\n        QuotaMixin(_quotaMixinconfig)\\n        SlashingMixin(_slashingMixinconfig)\\n    {\\n        transferOwnership(manager);\\n    }\\n\\n    function getSupportedEntrypoint()\\n        public\\n        view\\n        override\\n        returns (IEntryPoint)\\n    {\\n        return entryPoint;\\n    }\\n\\n    /**\\n     * Validate a user operation.\\n     * @param userOp     - The user operation.\\n     * @param maxCost    - The maximum cost of the user operation.\\n     */\\n    function _validatePaymasterUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 maxCost\\n    ) internal override returns (bytes memory context, uint256 validationData) {\\n        (context);\\n        // TODO: check if we should also check that the sender is a supported harbour address.\\n        //       But this is a circular dependency, so they would have to be registered afterwards\\n        //       For now we rely that validators only sign for valid harbour addresses (otherwise they get slashed)\\n\\n        // Theoretically this check is also performed by the 4337 mixin and could be skipped here (especially if the sender is trusted)\\n        require(\\n            bytes4(userOp.callData) == ERC4337Mixin.storeTransaction.selector,\\n            InvalidTarget(bytes4(userOp.callData))\\n        );\\n\\n        require(\\n            userOp.extractPaymaster() == address(this),\\n            InvalidUserOpPaymaster()\\n        );\\n\\n        require(\\n            userOp.extractPaymaster() == address(this),\\n            InvalidTarget(bytes4(userOp.callData))\\n        );\\n\\n        (address validator, , ) = CoreLib.recoverSigner(\\n            userOpHash,\\n            userOp.signature\\n        );\\n        // Range will be checked by Entrypoint\\n        (uint48 validAfter, uint48 validUntil) = userOp.extractValidatorData();\\n        // Max quota per validator is ~18ETH (2**64/10**18) in gas fees\\n        bool validationFailed = !_checkAndUpdateQuota(validator, maxCost);\\n        validationData = _packValidationData(\\n            validationFailed,\\n            validUntil,\\n            validAfter\\n        );\\n    }\\n\\n    // TODO introduce maxCostsToQuota function, to scale the costs\\n\\n    // Slashing amount is based on quota and is converted back to tokens.\\n    function _adjustSlashingAmount(\\n        address validator,\\n        uint96 slashingAmount\\n    ) internal view override returns (uint96) {\\n        uint256 tokensToSlash = (uint256(slashingAmount) *\\n            10 ** QUOTA_PER_FEE_TOKEN_SCALE) / QUOTA_PER_FEE_TOKEN;\\n        uint96 tokenBalance = quotaStatsForSigner[validator].tokenBalance;\\n        // If more tokens than locked should be slashed, we slash what we can get\\n        return\\n            tokensToSlash > tokenBalance\\n                ? tokenBalance\\n                : uint96(tokensToSlash);\\n    }\\n}\\n\",\"keccak256\":\"0xa9e5416e58b7f76c4a098f72143fca157dcdbbf81295f7a6da15579bbad4875e\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/Conditions.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\nimport {\\n    PackedUserOperation\\n} from \\\"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\\\";\\n\\ninterface ISlashingCondition {\\n    function shouldBeSlashed(\\n        address validator,\\n        PackedUserOperation calldata userOp\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x3eddb7ca6aafee25b14f702b9ef1e25e2414346bda3e86029d186d7095ab415f\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\n// ------------------------------------------------------------------\\n// Constants\\n// ------------------------------------------------------------------\\n\\n// The hashes must be the same as the ones in the Safe contract:\\n// https://github.com/safe-global/safe-smart-account/blob/b115c4c5fe23dca6aefeeccc73d312ddd23322c2/contracts/Safe.sol#L54-L63\\n// These should cover Safe versions 1.3.0 and 1.4.1\\n// keccak256(\\\"EIP712Domain(uint256 chainId,address verifyingContract)\\\")\\nbytes32 constant DOMAIN_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\\n\\n// keccak256(\\\"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\\\")\\nbytes32 constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\\n\\n// The lower bound of the S value for a valid secp256k1 signature.\\n// https://github.com/safe-global/safe-smart-account/blob/b115c4c5fe23dca6aefeeccc73d312ddd23322c2/contracts/Safe.sol#L100\\nbytes32 constant SECP256K1_LOW_S_BOUND = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\\n\",\"keccak256\":\"0x8ef29c796b00159d6991fff6e587712411e216e585510d18c18a72a091b46289\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/ERC4337.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\nimport {\\n    IEntryPoint\\n} from \\\"@account-abstraction/contracts/interfaces/IEntryPoint.sol\\\";\\n\\nabstract contract IERC4337InfoProvider {\\n    function getSupportedEntrypoint() public view virtual returns (IEntryPoint);\\n}\\n\",\"keccak256\":\"0xdc87fd7a17b9e958de96f1f95c62e140321a0469d7b8c867b1444c25da14e2f9\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\n// ------------------------------------------------------------------\\n// Errors\\n// ------------------------------------------------------------------\\n\\n/// Thrown when a signature blob is not exactly 65 bytes.\\nerror InvalidECDSASignatureLength();\\n\\n/// Thrown if `ecrecover` yields `address(0)`.\\nerror InvalidSignature();\\n\\n/// Thrown if the S value of the signature is not from the lower half of the curve.\\nerror InvalidSignatureSValue();\\n\\n/// Thrown when a value doesn't fit in a uint128.\\nerror ValueDoesNotFitInUint128();\\n\\n/// @notice Thrown when attempting to store a signature for a transaction (safeTxHash)\\n/// that the signer has already provided a signature for.\\n/// @param signer Signer address.\\n/// @param safeTxHash The EIP-712 hash of the Safe transaction.\\nerror SignerAlreadySignedTransaction(address signer, bytes32 safeTxHash);\\nerror InvalidTarget(bytes4 targetSelector);\\nerror InvalidEntryPoint(address entryPoint);\\nerror InvalidUserOpPaymaster();\\nerror UnexpectedUserSignature();\\nerror UnexpectedSafeTxHash(bytes32 expectedSafeTxHash);\\nerror UnexpectedSigner(address recoveredSigner);\\nerror UnexpectedSignatureR(bytes32 extractedR);\\nerror UnexpectedSignatureVS(bytes32 extractedVS);\\nerror UnexpectedNonce(uint256 expectedNonce);\\n\",\"keccak256\":\"0x924e79ead365a5d2fe02425358432e8959629ef521016fbf8af97456e57276ef\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/Events.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\n// ------------------------------------------------------------------\\n// Events\\n// ------------------------------------------------------------------\\n\\n/**\\n * @notice Emitted whenever a new signature is stored (and possibly the parameters on first sight).\\n *\\n * @param signer     Address recovered from the provided signature.\\n * @param safe       Safe Smart\\u2011Account the transaction targets.\\n * @param safeTxHash EIP\\u2011712 hash identifying the SafeTx.\\n * @param chainId    Intended execution chain.\\n * @param nonce      Safe nonce.\\n * @param listIndex  Position of the signature in the signer\\u2011specific array.\\n */\\nevent SignatureStored(\\n    address indexed signer,\\n    address indexed safe,\\n    bytes32 indexed safeTxHash,\\n    uint256 chainId,\\n    uint256 nonce,\\n    uint256 listIndex\\n);\\n\\n/**\\n * @notice Emitted when a transaction is first stored.\\n * @param safeTxHash EIP-712 hash identifying the SafeTx.\\n * @param safe       Safe Smart-Account the transaction targets.\\n * @param chainId    Intended execution chain.\\n * @param nonce      Safe nonce.\\n * @param to         Destination of the inner call/delegatecall.\\n * @param value      ETH value forwarded by the Safe.\\n * @param operation  0 = CALL, 1 = DELEGATECALL.\\n * @param safeTxGas  Gas forwarded to the inner call.\\n * @param baseGas    Fixed overhead reimbursed to the submitting signer.\\n * @param gasPrice   Gas price used for reimbursement.\\n * @param gasToken   ERC-20 token address for refunds.\\n * @param refundReceiver Address receiving the gas refund.\\n * @param data       Calldata executed by the Safe.\\n */\\nevent NewTransaction(\\n    bytes32 indexed safeTxHash,\\n    address indexed safe,\\n    uint256 indexed chainId,\\n    uint256 nonce,\\n    address to,\\n    uint256 value,\\n    uint8 operation,\\n    uint256 safeTxGas,\\n    uint256 baseGas,\\n    uint256 gasPrice,\\n    address gasToken,\\n    address refundReceiver,\\n    bytes data\\n);\\n\",\"keccak256\":\"0xf112b2c24c05b2b273be09ba30237c0d5b9f5f2e11450f174cb7ac093941aea2\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/HarbourStore.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\nabstract contract IHarbourStore {\\n    /**\\n     * @dev Internal function to store the transaction data and signature after validation.\\n     *\\n     * @param safeTxHash    EIP-712 digest of the transaction.\\n     * @param signer        Signer address to be checked.\\n     */\\n    function _signerSignedTx(\\n        bytes32 safeTxHash,\\n        address signer\\n    ) internal view virtual returns (bool signed);\\n\\n    /**\\n     * @dev Internal function to store a signature after validation.\\n     *\\n     * @param signer        Address that signed the transaction.\\n     * @param safeAddress   Target Safe Smart-Account.\\n     * @param chainId       Chain id the transaction is meant for.\\n     * @param nonce         Safe nonce.\\n     * @param safeTxHash    EIP-712 digest of the transaction.\\n     * @param r             First 32 bytes of the signature.\\n     * @param vs            Compact representation of s and v from EIP-2098.\\n     *\\n     * @return listIndex    Index of the stored signature in the signer-specific list.\\n     */\\n    function _storeSignature(\\n        address signer,\\n        address safeAddress,\\n        uint256 chainId,\\n        uint256 nonce,\\n        bytes32 safeTxHash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal virtual returns (uint256 listIndex);\\n\\n    /**\\n     * @dev Internal function to store the transaction data and signature after validation.\\n     *\\n     * @param safeTxHash     EIP-712 digest of the transaction.\\n     * @param safeAddress    Target Safe Smart\\u2011Account.\\n     * @param chainId        Chain id the transaction is meant for.\\n     * @param nonce          Safe nonce.\\n     * @param to             Destination of the inner call/delegatecall.\\n     * @param value          ETH value forwarded by the Safe.\\n     * @param data           Calldata executed by the Safe.\\n     * @param operation      0 = CALL, 1 = DELEGATECALL.\\n     * @param safeTxGas      Gas forwarded to the inner call.\\n     * @param baseGas        Fixed overhead reimbursed to the submitting signer.\\n     * @param gasPrice       Gas price used for reimbursement.\\n     * @param gasToken       ERC\\u201120 token address for refunds (`address(0)` = ETH).\\n     * @param refundReceiver Address receiving the gas refund.\\n     */\\n    function _storeTransaction(\\n        bytes32 safeTxHash,\\n        address safeAddress,\\n        uint256 chainId,\\n        uint256 nonce,\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        uint8 operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address refundReceiver\\n    ) internal virtual;\\n}\\n\",\"keccak256\":\"0x8b5220db76af351dee1fb783fe30f7c36d9f2d73c81582396bf0cf1b4da93bf3\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/QuotaManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\nabstract contract IQuotaManager {\\n    function _checkAndUpdateQuota(\\n        address signer,\\n        uint256 requiredQuota\\n    ) internal virtual returns (bool);\\n\\n    function _withdrawSignerTokens(\\n        address signer,\\n        address beneficiary,\\n        uint96 amount,\\n        bool ignoreReset\\n    ) internal virtual;\\n\\n    function _transferFeeToken(\\n        address beneficiary,\\n        uint96 amount\\n    ) internal virtual;\\n}\\n\",\"keccak256\":\"0x36a85ab6b085c0dc2a50a26f4214284ffdfc54671fa24bb6e2b2fb7388f070f4\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/Types.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\n// ------------------------------------------------------------------\\n// Data structures\\n// ------------------------------------------------------------------\\n\\n/**\\n * @dev Storage optimised mirror of the SafeTx struct used by Safe contracts.\\n *      Non-optimised version uses uint256 for:\\n *      - value\\n *      - safeTxGas\\n *      - baseGas\\n *      - gasPrice\\n */\\nstruct SafeTransaction {\\n    // stored, operation and to will be packed into the same storage slot\\n    bool stored;\\n    uint8 operation;\\n    address to;\\n    uint128 value;\\n    uint128 safeTxGas;\\n    uint128 baseGas;\\n    uint128 gasPrice;\\n    address gasToken;\\n    address refundReceiver;\\n    bytes data;\\n}\\n\\n/**\\n * @dev Minimal, storage\\u2011optimised representation of an ECDSA signature.\\n */\\nstruct SignatureDataWithTxHashIndex {\\n    bytes32 r;\\n    // vs is the compact representation of s and v coming from\\n    // EIP-2098: https://eips.ethereum.org/EIPS/eip-2098\\n    bytes32 vs;\\n    bytes32 txHash; // EIP\\u2011712 digest this signature belongs to\\n}\\n\",\"keccak256\":\"0x91d6cff0d7c1bacd7c4c4cb6c6ea3f64c58a2e6461e8e77f4a9c222953d44830\",\"license\":\"GPL-3.0-only\"},\"src/libs/CoreLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\nimport \\\"../interfaces/Constants.sol\\\";\\nimport \\\"../interfaces/Types.sol\\\";\\nimport \\\"../interfaces/Errors.sol\\\";\\nimport \\\"../interfaces/Events.sol\\\";\\n\\nlibrary CoreLib {\\n    // ------------------------------------------------------------------\\n    // Internal functions\\n    // ------------------------------------------------------------------\\n\\n    /**\\n     * @notice Computes the unique EIP-712 digest for a SafeTx using the provided parameters and domain.\\n     * @param safeAddress Address of the target Safe Smart Account.\\n     * @param chainId Chain ID included in the domain separator.\\n     * @param nonce Safe transaction nonce.\\n     * @param to Target address the Safe will call.\\n     * @param value ETH value to be sent with the call.\\n     * @param data Call data executed by the Safe.\\n     * @param operation Operation type: 0 = CALL, 1 = DELEGATECALL.\\n     * @param safeTxGas Gas limit for the Safe's internal execution.\\n     * @param baseGas Base gas overhead for reimbursement.\\n     * @param gasPrice Gas price used for reimbursement calculation.\\n     * @param gasToken Token address for refunds (0x0 for ETH).\\n     * @param refundReceiver Address to receive gas refunds.\\n     * @return safeTxHash Keccak256 digest of the EIP-712 encoded SafeTx.\\n     */\\n    function computeSafeTxHash(\\n        address safeAddress,\\n        uint256 chainId,\\n        uint256 nonce,\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        uint8 operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address refundReceiver\\n    ) internal pure returns (bytes32 safeTxHash) {\\n        bytes32 domainSeparator = keccak256(\\n            abi.encode(DOMAIN_TYPEHASH, chainId, safeAddress)\\n        );\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                SAFE_TX_TYPEHASH,\\n                to,\\n                value,\\n                keccak256(data),\\n                operation,\\n                safeTxGas,\\n                baseGas,\\n                gasPrice,\\n                gasToken,\\n                refundReceiver,\\n                nonce\\n            )\\n        );\\n        safeTxHash = keccak256(\\n            abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash)\\n        );\\n    }\\n\\n    /**\\n     * @notice Splits a 65-byte ECDSA signature into its components and recovers the signer address.\\n     * @param digest The message or data hash to verify (EIP-712 digest or eth_sign prefixed).\\n     * @param sig Concatenated 65-byte ECDSA signature (r || s || v).\\n     * @return signer The address that produced the signature (EOA).\\n     * @return r First 32 bytes of the ECDSA signature.\\n     * @return vs Compact representation of s and v coming from EIP-2098.\\n     * @dev Supports both EIP-712 and eth_sign flows by detecting v > 30 and applying the Ethereum Signed Message prefix.\\n     */\\n    function recoverSigner(\\n        bytes32 digest,\\n        bytes calldata sig\\n    ) internal pure returns (address signer, bytes32 r, bytes32 vs) {\\n        uint8 v;\\n        bytes32 s;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            r := calldataload(sig.offset)\\n            s := calldataload(add(sig.offset, 0x20))\\n            v := byte(0, calldataload(add(sig.offset, 0x40)))\\n        }\\n        require(s <= SECP256K1_LOW_S_BOUND, InvalidSignatureSValue());\\n\\n        signer = ecrecover(digest, v, r, s);\\n        require(signer != address(0), InvalidSignature());\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            // Equivalent to:\\n            // vs = bytes32(uint256(v - 27)  << 255 | uint256(s));\\n            // Which should avoid conversion between uint256 and bytes32\\n            vs := or(shl(255, sub(v, 27)), s)\\n        }\\n    }\\n\\n    function recoverSigner(\\n        bytes32 digest,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address signer) {\\n        (bytes32 s, uint8 v) = splitVS(vs);\\n        require(s <= SECP256K1_LOW_S_BOUND, InvalidSignatureSValue());\\n\\n        signer = ecrecover(digest, v, r, s);\\n        require(signer != address(0), InvalidSignature());\\n    }\\n\\n    function splitVS(bytes32 vs) internal pure returns (bytes32 s, uint8 v) {\\n        assembly (\\\"memory-safe\\\") {\\n            // Equivalent to:\\n            // vs = bytes32(uint256(v - 27) << 255 | uint256(s));\\n            // s = bytes32(uint256(vs) & (uint256(1 << 255) - 1))\\n            // v = uint8(uint256(vs >> 255) + 27)\\n            // Which should avoid conversion between uint256 and bytes32\\n            s := and(sub(shl(255, 1), 1), vs)\\n            v := add(shr(255, vs), 27)\\n        }\\n    }\\n\\n    function safeCastUint256ToUint128(\\n        uint256 value\\n    ) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, ValueDoesNotFitInUint128());\\n        return uint128(value);\\n    }\\n}\\n\",\"keccak256\":\"0x0df752b2a2fa54f0db2d2a81d3fc368d0d97d77f86f40682d0ad1ed0660a9b10\",\"license\":\"GPL-3.0-only\"},\"src/libs/PaymasterLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\nimport {\\n    UserOperationLib\\n} from \\\"@account-abstraction/contracts/core/UserOperationLib.sol\\\";\\nimport {\\n    PackedUserOperation\\n} from \\\"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\\\";\\n\\nlibrary PaymasterLib {\\n    using UserOperationLib for PackedUserOperation;\\n\\n    uint256 private constant PAYMASTER_VALID_AFTER_END =\\n        UserOperationLib.PAYMASTER_DATA_OFFSET + 6;\\n    uint256 private constant PAYMASTER_VALID_UNTIL_END =\\n        PAYMASTER_VALID_AFTER_END + 6;\\n\\n    function extractValidatorData(\\n        PackedUserOperation calldata userOp\\n    ) internal pure returns (uint48 validAfter, uint48 validUntil) {\\n        require(\\n            userOp.paymasterAndData.length >= PAYMASTER_VALID_UNTIL_END,\\n            \\\"Invalid Validator Data\\\"\\n        );\\n        validAfter = uint48(\\n            bytes6(\\n                userOp.paymasterAndData[\\n                    UserOperationLib\\n                        .PAYMASTER_DATA_OFFSET:PAYMASTER_VALID_AFTER_END\\n                ]\\n            )\\n        );\\n        validUntil = uint48(\\n            bytes6(\\n                userOp.paymasterAndData[\\n                    PAYMASTER_VALID_AFTER_END:PAYMASTER_VALID_UNTIL_END\\n                ]\\n            )\\n        );\\n    }\\n\\n    function extractPaymaster(\\n        PackedUserOperation calldata userOp\\n    ) internal pure returns (address paymaster) {\\n        return\\n            address(\\n                bytes20(\\n                    userOp.paymasterAndData[\\n                        :UserOperationLib.PAYMASTER_VALIDATION_GAS_OFFSET\\n                    ]\\n                )\\n            );\\n    }\\n\\n    function calculateRequiredPrefund(\\n        PackedUserOperation calldata userOp\\n    ) internal pure returns (uint256 requiredPrefund) {\\n        unchecked {\\n            uint256 callGasLimit = userOp.unpackCallGasLimit();\\n            uint256 verificationGasLimit = userOp.unpackVerificationGasLimit();\\n            uint256 paymasterVerificationGasLimit = userOp\\n                .unpackPaymasterVerificationGasLimit();\\n            uint256 paymasterPostOpGasLimit = userOp.unpackPostOpGasLimit();\\n            uint256 maxFeePerGas = userOp.unpackMaxFeePerGas();\\n            uint256 requiredGas = verificationGasLimit +\\n                callGasLimit +\\n                paymasterVerificationGasLimit +\\n                paymasterPostOpGasLimit +\\n                userOp.preVerificationGas;\\n\\n            requiredPrefund = requiredGas * maxFeePerGas;\\n        }\\n    }\\n\\n    // TODO: harbour is userOp.sender and therefore part of userOpHash and could be removed\\n    function computeValidatorConfirmationHash(\\n        address harbour,\\n        bytes32 userOpHash\\n    ) internal view returns (bytes32 validatorConfirmationHash) {\\n        bytes32 domainSeparator = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"ValidatorConfirmation(address harbour,bytes32 userOpHash)\\\"\\n                ),\\n                harbour,\\n                userOpHash\\n            )\\n        );\\n        validatorConfirmationHash = keccak256(\\n            abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash)\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xc840f024ebdfd11966a2d7a5a29bf81d2fe05943fa7c3919f8cd5689e4035ce4\",\"license\":\"GPL-3.0-only\"},\"src/mixins/ERC4337Mixin.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\nimport {IAccount} from \\\"@account-abstraction/contracts/interfaces/IAccount.sol\\\";\\nimport {\\n    IEntryPoint\\n} from \\\"@account-abstraction/contracts/interfaces/IEntryPoint.sol\\\";\\nimport {\\n    PackedUserOperation\\n} from \\\"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\\\";\\nimport {\\n    _packValidationData\\n} from \\\"@account-abstraction/contracts/core/Helpers.sol\\\";\\nimport {\\n    UserOperationLib\\n} from \\\"@account-abstraction/contracts/core/UserOperationLib.sol\\\";\\nimport {\\n    InvalidECDSASignatureLength,\\n    InvalidEntryPoint,\\n    InvalidTarget,\\n    SignerAlreadySignedTransaction,\\n    UnexpectedNonce,\\n    InvalidUserOpPaymaster,\\n    UnexpectedUserSignature,\\n    UnexpectedSafeTxHash,\\n    UnexpectedSigner\\n} from \\\"../interfaces/Errors.sol\\\";\\nimport {IHarbourStore} from \\\"../interfaces/HarbourStore.sol\\\";\\nimport {IQuotaManager} from \\\"../interfaces/QuotaManager.sol\\\";\\nimport {PaymasterLib} from \\\"../libs/PaymasterLib.sol\\\";\\nimport {CoreLib} from \\\"../libs/CoreLib.sol\\\";\\n\\nstruct ERC4337MixinConfig {\\n    address entryPoint;\\n    uint256 maxPriorityFee;\\n    uint256 preVerificationGasPerByte;\\n    uint256 preVerificationBaseGas;\\n    uint256 verificationGasPerByte;\\n    uint256 callGasPerByte;\\n    address trustedPaymaster;\\n}\\n\\nabstract contract ERC4337Mixin is IAccount, IHarbourStore, IQuotaManager {\\n    using UserOperationLib for PackedUserOperation;\\n    using PaymasterLib for PackedUserOperation;\\n\\n    // ------------------------------------------------------------------\\n    // 4337 functions\\n    // ------------------------------------------------------------------\\n\\n    /**\\n     * @notice The address of the EntryPoint contract supported by this module.\\n     */\\n    address public immutable SUPPORTED_ENTRYPOINT;\\n    // TODO evaluate if this should be upgradable\\n    uint256 public immutable MAX_PRIORITY_FEE;\\n    uint256 public immutable PRE_VERIFICATION_GAS_PER_BYTE;\\n    uint256 public immutable PRE_VERIFICATION_BASE_GAS;\\n    uint256 public immutable VERIFICATION_GAS_PER_BYTE;\\n    uint256 public immutable CALL_GAS_PER_BYTE;\\n    address public immutable TRUSTED_PAYMASTER;\\n\\n    constructor(ERC4337MixinConfig memory _config) {\\n        SUPPORTED_ENTRYPOINT = _config.entryPoint;\\n        MAX_PRIORITY_FEE = _config.maxPriorityFee;\\n        PRE_VERIFICATION_GAS_PER_BYTE = _config.preVerificationGasPerByte;\\n        PRE_VERIFICATION_BASE_GAS = _config.preVerificationBaseGas;\\n        VERIFICATION_GAS_PER_BYTE = _config.verificationGasPerByte;\\n        CALL_GAS_PER_BYTE = _config.callGasPerByte;\\n        TRUSTED_PAYMASTER = _config.trustedPaymaster;\\n    }\\n\\n    /**\\n     * Return the account nonce.\\n     * This method returns the next sequential nonce.\\n     * For a nonce of a specific key, use `entrypoint.getNonce(account, key)`\\n     */\\n    function getNonce(address signer) public view virtual returns (uint256) {\\n        return\\n            IEntryPoint(SUPPORTED_ENTRYPOINT).getNonce(\\n                address(this),\\n                uint192(uint160(signer))\\n            );\\n    }\\n\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32,\\n        uint256\\n    ) external override returns (uint256 validationData) {\\n        // Assumption:\\n        //   - UserOp signature is SafeTx signature\\n        // Requirements:\\n        //   - [x] Check entrypoint\\n        //   - [x] No paymaster support\\n        // Steps:\\n        //   - [x] decode callData\\n        //   - [x] recover signer from SafeTx signature\\n        //   - [x] check that signer has not submitted signature\\n        //   - [x] check that nonce key is signer address\\n        //   - [x] check limits on fee params\\n        //   - [ ] usage checks\\n\\n        require(\\n            msg.sender == SUPPORTED_ENTRYPOINT,\\n            InvalidEntryPoint(msg.sender)\\n        );\\n        // TODO: as signature check should happen in paymaster\\n        require(\\n            userOp.signature.length == 65 || userOp.signature.length == 0,\\n            InvalidECDSASignatureLength()\\n        );\\n\\n        require(\\n            bytes4(userOp.callData) == this.storeTransaction.selector,\\n            InvalidTarget(bytes4(userOp.callData))\\n        );\\n        (\\n            bytes32 safeTxHash,\\n            address signer,\\n            bytes32 r,\\n            bytes32 vs,\\n            uint256 computedDataLength\\n        ) = _verifySafeTxData(userOp.callData[4:]);\\n\\n        // --- DUPLICATE TRANSACTION SIGNATURE CHECK ---\\n        // Revert if this signer has already submitted *any* signature for this *exact* safeTxHash\\n        require(\\n            !_signerSignedTx(safeTxHash, signer),\\n            SignerAlreadySignedTransaction(signer, safeTxHash)\\n        );\\n\\n        _verifySignature(safeTxHash, signer, r, vs);\\n\\n        uint256 nonce = getNonce(signer);\\n        require(userOp.nonce == nonce, UnexpectedNonce(nonce));\\n\\n        // We skip the check that missingAccountFunds should be == 0, as this is the job of the entry point\\n\\n        // Since paymasterAndData are not signed it is possible to to replace the paymaster\\n        // TODO: To evaluate if we should encode the used paymaster into the refund receiver\\n        // OR: for now accept that there is always the chance that the user quota is used first\\n        if (userOp.paymasterAndData.length != 0) {\\n            address paymaster = userOp.extractPaymaster();\\n            require(paymaster == TRUSTED_PAYMASTER, InvalidUserOpPaymaster());\\n            return _packValidationData(false, 0, 0);\\n        } else {\\n            // UserOp Signature is used for validators (via the paymaster) and should be empty when no paymaster is used\\n            require(userOp.signature.length == 0, UnexpectedUserSignature());\\n        }\\n\\n        // `computedDataLength` is used for validations, as userOp.callData can be extended to manipulate the fees\\n        bool validationFailed = !_validGasFees(userOp) ||\\n            !_validGasLimits(userOp, computedDataLength) ||\\n            !_checkAndUpdateQuota(signer, computedDataLength);\\n        return _packValidationData(validationFailed, 0, 0);\\n    }\\n\\n    function _validGasFees(\\n        PackedUserOperation calldata userOp\\n    ) private view returns (bool) {\\n        uint256 maxPriorityFeePerGas = userOp.unpackMaxPriorityFeePerGas();\\n        return maxPriorityFeePerGas <= MAX_PRIORITY_FEE;\\n    }\\n\\n    function _validGasLimits(\\n        PackedUserOperation calldata userOp,\\n        uint256 computedDataLength\\n    ) private view returns (bool) {\\n        // Base calculations of gas limits on calldata size, this is a simple workaround for now\\n        //      -> an alernative for verificationGas could be to do internal gas metering\\n        // Employ a maximum gas limit based on locked tokens\\n        if (\\n            userOp.preVerificationGas >\\n            computedDataLength *\\n                PRE_VERIFICATION_GAS_PER_BYTE +\\n                PRE_VERIFICATION_BASE_GAS\\n        ) return false;\\n        uint256 verificationGasLimit = userOp.unpackVerificationGasLimit();\\n        if (\\n            verificationGasLimit >\\n            computedDataLength * VERIFICATION_GAS_PER_BYTE\\n        ) return false;\\n        uint256 callGasLimit = userOp.unpackCallGasLimit();\\n        if (callGasLimit > computedDataLength * CALL_GAS_PER_BYTE) return false;\\n        return true;\\n    }\\n\\n    function _verifySafeTxData(\\n        bytes calldata callData\\n    ) private pure returns (bytes32, address, bytes32, bytes32, uint256) {\\n        (\\n            bytes32 safeTxHash,\\n            address safeAddress,\\n            uint256 chainId,\\n            uint256 nonce,\\n            address to,\\n            uint256 value,\\n            bytes memory data,\\n            uint8 operation,\\n            uint256 safeTxGas,\\n            uint256 baseGas,\\n            uint256 gasPrice,\\n            address gasToken,\\n            address refundReceiver,\\n            address signer,\\n            bytes32 r,\\n            bytes32 vs\\n        ) = abi.decode(\\n                callData,\\n                (\\n                    bytes32,\\n                    address,\\n                    uint256,\\n                    uint256,\\n                    address,\\n                    uint256,\\n                    bytes,\\n                    uint8,\\n                    uint256,\\n                    uint256,\\n                    uint256,\\n                    address,\\n                    address,\\n                    address,\\n                    bytes32,\\n                    bytes32\\n                )\\n            );\\n        bytes32 computedSafeTxHash = CoreLib.computeSafeTxHash(\\n            safeAddress,\\n            chainId,\\n            nonce,\\n            to,\\n            value,\\n            data,\\n            operation,\\n            safeTxGas,\\n            baseGas,\\n            gasPrice,\\n            gasToken,\\n            refundReceiver\\n        );\\n\\n        require(\\n            computedSafeTxHash == safeTxHash,\\n            UnexpectedSafeTxHash(computedSafeTxHash)\\n        );\\n        // The computed length when properly encoded is based on the data length and the number of params\\n        // 4 bytes selector + 15 params each 32 bytes + 32 bytes offset of data + 32 bytes length of data + data length + 32 bytes buffer for padding\\n        return (safeTxHash, signer, r, vs, data.length + 18 * 32 + 4);\\n    }\\n\\n    function _verifySignature(\\n        bytes32 safeTxHash,\\n        address signer,\\n        bytes32 r,\\n        bytes32 vs\\n    ) private pure {\\n        (address recoveredSigner) = CoreLib.recoverSigner(safeTxHash, r, vs);\\n        require(signer == recoveredSigner, UnexpectedSigner(signer));\\n    }\\n\\n    function storeTransaction(\\n        bytes32 safeTxHash,\\n        address safeAddress,\\n        uint256 chainId,\\n        uint256 nonce,\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        uint8 operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address refundReceiver,\\n        address signer,\\n        bytes32 r,\\n        bytes32 vs\\n    ) external returns (uint256 listIndex) {\\n        require(\\n            msg.sender == SUPPORTED_ENTRYPOINT,\\n            InvalidEntryPoint(msg.sender)\\n        );\\n        _storeTransaction(\\n            safeTxHash,\\n            safeAddress,\\n            chainId,\\n            nonce,\\n            to,\\n            value,\\n            data,\\n            operation,\\n            safeTxGas,\\n            baseGas,\\n            gasPrice,\\n            gasToken,\\n            refundReceiver\\n        );\\n        return\\n            _storeSignature(\\n                signer,\\n                safeAddress,\\n                chainId,\\n                nonce,\\n                safeTxHash,\\n                r,\\n                vs\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0xea926f543e5d161d46bc1311c9b53409181d1acc3d51b057bdcdafd8fcea2dcb\",\"license\":\"GPL-3.0-only\"},\"src/mixins/QuotaMixin.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\nimport {\\n    SafeERC20\\n} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IQuotaManager} from \\\"../interfaces/QuotaManager.sol\\\";\\nimport {CoreLib} from \\\"../libs/CoreLib.sol\\\";\\n\\nstruct QuotaStats {\\n    uint96 tokenBalance; // uint96 might also be enough, as this would be more tokens than most project have in circulation\\n    uint96 usedQuota; // Quota is limited to 96 bits (current Quota == Bytes of data or eth costs for a tx, so that should be ok)\\n    uint48 nextQuotaReset; // timestamps are Safe to limit to 64 bits\\n}\\n\\nstruct QuotaMixinConfig {\\n    uint32 timeframeQuotaReset;\\n    uint16 requiredQuotaMultiplier;\\n    uint96 maxAvailableQuota;\\n    address feeToken;\\n    uint32 quotaPerFeeToken;\\n    uint8 quotaPerFeeTokenScale;\\n}\\n\\nabstract contract QuotaMixin is IQuotaManager {\\n    using SafeERC20 for IERC20;\\n\\n    event Withdraw(address indexed signer, uint256 indexed amount);\\n    event Deposit(address indexed signer, uint256 indexed amount);\\n\\n    mapping(address => QuotaStats) public quotaStatsForSigner;\\n    mapping(address => mapping(bytes32 => uint256)) public withdrawsForSigner;\\n\\n    bool public immutable QUOTA_ENABLED;\\n    uint32 public immutable TIMEFRAME_QUOTA_RESET;\\n    uint96 public immutable MAX_AVAILABLE_QUOTA;\\n    address public immutable FEE_TOKEN;\\n    uint32 public immutable QUOTA_PER_FEE_TOKEN;\\n    uint8 public immutable QUOTA_PER_FEE_TOKEN_SCALE;\\n\\n    constructor(QuotaMixinConfig memory _config) {\\n        QUOTA_ENABLED = _config.feeToken != address(0);\\n        TIMEFRAME_QUOTA_RESET = _config.timeframeQuotaReset;\\n        MAX_AVAILABLE_QUOTA = _config.maxAvailableQuota;\\n        FEE_TOKEN = _config.feeToken;\\n        QUOTA_PER_FEE_TOKEN = _config.quotaPerFeeToken;\\n        QUOTA_PER_FEE_TOKEN_SCALE = _config.quotaPerFeeTokenScale;\\n    }\\n\\n    function depositTokensForSigner(address signer, uint96 amount) public {\\n        // We don't update the nextQuotaReset this way depositing more tokens does not negatively affect the reset schedule\\n        // The reset schedule always starts from 0, therefore is always a multiple of the reset timeframe (unless the timeframe is changed)\\n        quotaStatsForSigner[signer].tokenBalance += amount;\\n        // TODO: check if we want to track total tokens locked (might be useful in a recovery case)\\n        IERC20(FEE_TOKEN).safeTransferFrom(msg.sender, address(this), amount);\\n        emit Deposit(signer, amount);\\n    }\\n\\n    function computeWithdrawHash(\\n        uint256 amount,\\n        address beneficiary,\\n        uint256 nonce\\n    ) internal view returns (bytes32 withdrawHash) {\\n        bytes32 domainSeparator = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"WithdrawRequest(uint256 amount,address beneficiary,uint256 nonce)\\\"\\n                ),\\n                amount,\\n                beneficiary,\\n                nonce\\n            )\\n        );\\n        withdrawHash = keccak256(\\n            abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash)\\n        );\\n    }\\n\\n    function widthdrawTokensForSigner(\\n        bytes calldata signature,\\n        uint96 amount,\\n        address beneficiary,\\n        uint256 nonce\\n    ) public payable {\\n        bytes32 withdrawHash = computeWithdrawHash(amount, beneficiary, nonce);\\n        (address signer, , ) = CoreLib.recoverSigner(withdrawHash, signature);\\n        // Check that withdrawal was not executed yet\\n        require(\\n            withdrawsForSigner[signer][withdrawHash] == 0,\\n            \\\"Withdrawal was already performed\\\"\\n        );\\n        withdrawsForSigner[signer][withdrawHash] = block.timestamp;\\n\\n        _withdrawSignerTokens(signer, beneficiary, amount, false);\\n\\n        emit Withdraw(signer, amount);\\n    }\\n\\n    function _withdrawSignerTokens(\\n        address signer,\\n        address beneficiary,\\n        uint96 amount,\\n        bool skipResetCheck\\n    ) internal override {\\n        QuotaStats storage stats = quotaStatsForSigner[signer];\\n        require(stats.tokenBalance >= amount, \\\"Insufficient Tokens\\\");\\n        // We use the quota reset timeframe as a unlock timeframe\\n        // -> currently the signer is not allowed to sign any Safe transaction during this timeframe\\n        // TODO: have dedicated unlock logic (also to avoid some fee exploit flows)\\n        require(\\n            skipResetCheck || stats.nextQuotaReset < block.timestamp,\\n            \\\"Tokens have been used during this timeframe\\\"\\n        );\\n\\n        stats.tokenBalance -= amount;\\n\\n        if (beneficiary != address(this))\\n            _transferFeeToken(beneficiary, amount);\\n    }\\n\\n    function _transferFeeToken(\\n        address beneficiary,\\n        uint96 amount\\n    ) internal override {\\n        IERC20(FEE_TOKEN).safeTransfer(beneficiary, amount);\\n    }\\n\\n    function availableFreeQuotaForSigner(\\n        address signer\\n    )\\n        public\\n        view\\n        returns (\\n            uint96 availableFreeQuota,\\n            uint96 usedSignerQuota,\\n            uint48 nextSignerQuotaReset\\n        )\\n    {\\n        QuotaStats memory stats = quotaStatsForSigner[signer];\\n        nextSignerQuotaReset = stats.nextQuotaReset;\\n        if (nextSignerQuotaReset > block.timestamp) {\\n            usedSignerQuota = stats.usedQuota;\\n        } else {\\n            // Signer quota should be reset (therefore be 0)\\n            usedSignerQuota = 0;\\n            // The reset time should always be aligned with the timeframe (be a multiple)\\n            // First the time difference since the last reset is calculated (last reset - block time)\\n            // Then the elablesed time in the current timeframe (modulo with timeframe duration)\\n            // Then substract this from the current blocktime to get the start of the current timeframe\\n            // And lastly add the timeframe duration to get the starting point of the next timeframe\\n            uint48 blocktime = uint48(block.timestamp);\\n            nextSignerQuotaReset =\\n                blocktime -\\n                ((blocktime - nextSignerQuotaReset) % TIMEFRAME_QUOTA_RESET) +\\n                TIMEFRAME_QUOTA_RESET;\\n        }\\n        // We cast tokenBalance to uint256 to use more bits for the arithmetics\\n        uint256 maxSignerQuota = (uint256(stats.tokenBalance) *\\n            QUOTA_PER_FEE_TOKEN) / 10 ** QUOTA_PER_FEE_TOKEN_SCALE;\\n\\n        require(\\n            maxSignerQuota <= type(uint96).max,\\n            \\\"Max signer quota too high\\\"\\n        );\\n\\n        uint96 freeSignerQuota = uint96(maxSignerQuota);\\n        // If MAX_AVAILABLE_QUOTA is set to 0 then there is no limit\\n        if (MAX_AVAILABLE_QUOTA > 0 && freeSignerQuota > MAX_AVAILABLE_QUOTA) {\\n            freeSignerQuota = MAX_AVAILABLE_QUOTA;\\n        }\\n        if (usedSignerQuota <= freeSignerQuota) {\\n            availableFreeQuota = freeSignerQuota - usedSignerQuota;\\n        } else {\\n            availableFreeQuota = 0;\\n        }\\n    }\\n\\n    function _updateQuotaParams(\\n        address signer,\\n        uint96 newSignerQuota,\\n        uint48 nextSignerQuotaReset\\n    ) internal {\\n        QuotaStats storage stats = quotaStatsForSigner[signer];\\n        if (nextSignerQuotaReset != stats.nextQuotaReset) {\\n            stats.nextQuotaReset = nextSignerQuotaReset;\\n        }\\n        stats.usedQuota = newSignerQuota;\\n    }\\n\\n    function _checkAndUpdateQuota(\\n        address signer,\\n        uint256 requiredSignerQuota\\n    ) internal override returns (bool) {\\n        if (!QUOTA_ENABLED || requiredSignerQuota == 0) return true;\\n        (\\n            uint96 availableFreeSignerQuota,\\n            uint96 usedSignerQuota,\\n            uint48 nextSignerQuotaReset\\n        ) = availableFreeQuotaForSigner(signer);\\n        if (requiredSignerQuota > availableFreeSignerQuota)\\n            return false;\\n        // Casting to uint64 is safe, as availableFreeSignerQuota is at most a uint64 and we compare it against that\\n        _updateQuotaParams(\\n            signer,\\n            usedSignerQuota + uint96(requiredSignerQuota),\\n            nextSignerQuotaReset\\n        );\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0xa2af1f77f9056653f4c28f609a5ae2bc0fa1d42c79e65be0811c9736e29d50d4\",\"license\":\"GPL-3.0-only\"},\"src/mixins/SlashingMixin.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\nimport {\\n    PackedUserOperation\\n} from \\\"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\\\";\\nimport {\\n    SafeERC20\\n} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IQuotaManager} from \\\"../interfaces/QuotaManager.sol\\\";\\nimport {PaymasterLib} from \\\"../libs/PaymasterLib.sol\\\";\\nimport {CoreLib} from \\\"../libs/CoreLib.sol\\\";\\nimport {IERC4337InfoProvider} from \\\"../interfaces/ERC4337.sol\\\";\\nimport {ISlashingCondition} from \\\"../interfaces/Conditions.sol\\\";\\nimport {InvalidUserOpPaymaster} from \\\"../interfaces/Errors.sol\\\";\\n\\nstruct SlashingMixinConfig {\\n    uint48 enableCoditionsDelay;\\n    ISlashingCondition[] initialConditions;\\n}\\n\\nabstract contract SlashingMixin is IQuotaManager, IERC4337InfoProvider {\\n    using SafeERC20 for IERC20;\\n    using PaymasterLib for PackedUserOperation;\\n\\n    struct ConditionStatus {\\n        uint48 enabledAfter;\\n        uint48 enabledUntil;\\n    }\\n\\n    uint48 public immutable ENABLE_CONDITIONS_DELAY;\\n\\n    event Slashed(\\n        ISlashingCondition indexed offendingCondition,\\n        address indexed validator,\\n        uint256 indexed amount\\n    );\\n\\n    event EnableCondition(\\n        ISlashingCondition indexed offendingCondition,\\n        uint48 enabledFrom\\n    );\\n\\n    event DisableCondition(\\n        ISlashingCondition indexed offendingCondition,\\n        uint48 enabledUntil\\n    );\\n\\n    uint256 public slashedTokens;\\n    mapping(ISlashingCondition => ConditionStatus) public enabledConditions;\\n    mapping(bytes32 => uint256) public slashedUserOps;\\n\\n    constructor(SlashingMixinConfig memory _config) {\\n        ENABLE_CONDITIONS_DELAY = _config.enableCoditionsDelay;\\n        for (uint256 i = 0; i < _config.initialConditions.length; i++) {\\n            enabledConditions[_config.initialConditions[i]] = ConditionStatus({\\n                enabledAfter: uint48(block.timestamp),\\n                enabledUntil: 0\\n            });\\n        }\\n    }\\n\\n    function slashValidator(\\n        ISlashingCondition offendingCondition,\\n        PackedUserOperation calldata userOp\\n    ) public {\\n        // Only slashing for userOps related to this paymaster is allowed\\n        require(\\n            userOp.extractPaymaster() == address(this),\\n            InvalidUserOpPaymaster()\\n        );\\n        (uint256 validAfter, uint256 validUntil) = userOp\\n            .extractValidatorData();\\n        ConditionStatus memory conditionStatus = enabledConditions[\\n            offendingCondition\\n        ];\\n        require(\\n            (conditionStatus.enabledAfter < validUntil || validUntil == 0) &&\\n                (validAfter < conditionStatus.enabledUntil ||\\n                    conditionStatus.enabledUntil == 0),\\n            \\\"Condition not active\\\"\\n        );\\n        bytes32 userOpHash = getSupportedEntrypoint().getUserOpHash(userOp);\\n        bytes32 digest = PaymasterLib.computeValidatorConfirmationHash(\\n            userOp.sender,\\n            userOpHash\\n        );\\n        (address validator, , ) = CoreLib.recoverSigner(\\n            digest,\\n            userOp.signature\\n        );\\n        require(\\n            offendingCondition.shouldBeSlashed(validator, userOp),\\n            \\\"UserOp does not offend the condition\\\"\\n        );\\n        require(slashedUserOps[userOpHash] == 0, \\\"UserOp was already slashed\\\");\\n        uint96 usedQuota = uint96(userOp.calculateRequiredPrefund());\\n        uint96 slashingAmount = _adjustSlashingAmount(validator, usedQuota);\\n        require(slashingAmount > 0, \\\"Nothing to slash\\\");\\n        // Currently only the slashed amount is stored, more information could be stored if necessary\\n        slashedUserOps[userOpHash] = slashingAmount;\\n        slashedTokens += slashingAmount;\\n        // By withdrawing the slashed tokens to the slashing contract they can be transferred later\\n        _withdrawSignerTokens(validator, address(this), slashingAmount, true);\\n        emit Slashed(offendingCondition, validator, slashingAmount);\\n    }\\n\\n    // Can be used to adjust slashing amount, i.e. based on quota relation\\n    function _adjustSlashingAmount(\\n        address,\\n        uint96 slashingAmount\\n    ) internal virtual returns (uint96);\\n\\n    function _enableCondition(ISlashingCondition condition) internal {\\n        require(\\n            enabledConditions[condition].enabledAfter == 0,\\n            \\\"Condition already enabled\\\"\\n        );\\n        uint48 enabledAfter = uint48(block.timestamp) + ENABLE_CONDITIONS_DELAY;\\n        enabledConditions[condition] = ConditionStatus({\\n            enabledAfter: enabledAfter,\\n            enabledUntil: 0\\n        });\\n        emit EnableCondition(condition, enabledAfter);\\n    }\\n\\n    function _disableCondition(ISlashingCondition condition) internal {\\n        ConditionStatus memory conditionStatus = enabledConditions[condition];\\n        require(conditionStatus.enabledAfter != 0, \\\"Condition not enabled\\\");\\n        require(\\n            conditionStatus.enabledUntil == 0,\\n            \\\"Condition already disabled\\\"\\n        );\\n        uint48 enabledUntil = uint48(block.timestamp) + ENABLE_CONDITIONS_DELAY;\\n        enabledConditions[condition].enabledUntil = enabledUntil;\\n        emit EnableCondition(condition, enabledUntil);\\n    }\\n\\n    function _withdrawSlashedTokens(\\n        address beneficiary,\\n        uint96 amount\\n    ) internal {\\n        require(\\n            beneficiary != address(this),\\n            \\\"Cannot transfer to this account\\\"\\n        );\\n        require(amount <= slashedTokens, \\\"Amount too high\\\");\\n        unchecked {\\n            slashedTokens -= amount;\\n        }\\n        _transferFeeToken(beneficiary, amount);\\n    }\\n}\\n\",\"keccak256\":\"0xd86df3ae5a7699b8cf6e7c00934daa95e0f6ed7f1469a8fcc6d7c2aa0bb6f3d0\",\"license\":\"GPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x61018080604052346104d3576132a9803803809161001d828561054c565b83398101908082039061012082126104d3576100388161056f565b602082015190926001600160a01b03821691908282036104d35760c090603f1901126104d3576040519260c084016001600160401b0381118582101761051d5760405261008760408201610583565b8452606081015161ffff811681036104d35760208501526080810151936001600160601b03851685036104d357604081019485526100c760a0830161056f565b606082019081526100da60c08401610583565b906080830191825260e08401519360ff851685036104d35760a08401948552610100810151906001600160401b0382116104d35701956040878b03126104d3576040519661012788610531565b805165ffffffffffff811681036104d35788526020810151906001600160401b0382116104d357018a601f820112156104d35780519a6001600160401b038c1161051d578b60051b916020806040519e8f906101858388018361054c565b815201938201019182116104d357602001915b8183106104fd5750505060208701998a5233156104ea5760018060a01b03196001541660015560205f543360018060a01b03198216175f55602460405180948193339060018060a01b03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a36301ffc9a760e01b8252631313998b60e31b60048301525afa9081156104df575f916104a0575b501561045b5760809490945283516001600160a01b03908116151560a052915163ffffffff90811660c05295516001600160601b031660e05292511661010052905190921661012052905160ff16610140525165ffffffffffff9081166101605242165f5b83515181101561032657604051906102aa82610531565b82825260208201915f83528551928351831015610312576001936020858060a01b03918560051b010151165f52600560205265ffffffffffff60405f209251166bffffffffffff0000000000008354925160301b1691858060601b0319161717905501610293565b634e487b7160e01b5f52603260045260245ffd5b5f546001600160a01b03168333820361044857600180546001600160a01b0319166001600160a01b03929092169182179055604051917f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e227005f80a3612d149081610595823960805181818161095d01528181610a6001528181610b2901528181610bfe01528181610fb301528181611fc8015281816120e9015281816121e00152612848015260a0518181816116dc0152612afb015260c051818181611b5601526125a7015260e051818181611f4c01526124ac0152610100518181816106300152611a33015261012051818181610ca30152818161125f01526124340152610140518181816111e80152818161178a015261245f015261016051816102bf0152f35b63118cdaa760e01b5f523360045260245ffd5b60405162461bcd60e51b815260206004820152601e60248201527f49456e747279506f696e7420696e74657266616365206d69736d6174636800006044820152606490fd5b90506020813d6020116104d7575b816104bb6020938361054c565b810103126104d3575180151581036104d3575f61022e565b5f80fd5b3d91506104ae565b6040513d5f823e3d90fd5b631e4fbdf760e01b5f525f60045260245ffd5b82516001600160a01b03811681036104d357815260209283019201610198565b634e487b7160e01b5f52604160045260245ffd5b604081019081106001600160401b0382111761051d57604052565b601f909101601f19168101906001600160401b0382119082101761051d57604052565b51906001600160a01b03821682036104d357565b519063ffffffff821682036104d35756fe60806040526004361015610011575f80fd5b5f5f3560e01c80630396cb601461208e5780630f5cb70814612052578063205c287814611f7057806338c4c62114611f09578063519e981514611e9157806352b7512c14611b7a5780636f9bb7bd14611b1b5780636f9bf91b14610c63578063715018a614611a5757806373717b08146119e857806379ba5097146118de5780637c627b211461181b5780637eec7d68146117ae57806381f243c3146117525780638da5cb5b1461170157806393df8c31146116a6578063941eaf5314610e285780639f202a0414610db3578063a3be4d7b14610d0f578063a99819be14610cc7578063ad3228c614610c68578063b0d691fe14610c63578063bb9fe6bf14610baf578063c23a5cea14610ad1578063c399ec88146109e8578063d0e30db01461091b578063d912dcca146107fe578063e002f088146102e3578063e2c7b3e014610282578063e30c3978146102305763f2fde38b1461016f575f80fd5b3461022d5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d5773ffffffffffffffffffffffffffffffffffffffff6101bb612173565b6101c36127e5565b16807fffffffffffffffffffffffff0000000000000000000000000000000000000000600154161760015573ffffffffffffffffffffffffffffffffffffffff8254167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e227008380a380f35b80fd5b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57602073ffffffffffffffffffffffffffffffffffffffff60015416604051908152f35b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57602060405165ffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b5060807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d5760043567ffffffffffffffff81116107fa5761032e903690600401612204565b50610337612232565b9060443573ffffffffffffffffffffffffffffffffffffffff81168091036107f6576bffffffffffffffffffffffff83169260405160208101907f47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a794692188252466040820152306060820152606081526103af60808261224d565b51902061044b61047760405160208101907ff004bebf3ce3a32f609e24232a25277f97bc1a0843e36f180d0e414dd5a65b7a825288604082015286606082015260643560808201526080815261040660a08261224d565b51902060405192839160208301958690916042927f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201520190565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0810183528261224d565b5190209260208101357f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a081116107ce5760806020928892604051918883526040810135851a86840152356040830152606082015282805260015afa156107c35773ffffffffffffffffffffffffffffffffffffffff85511692831561079b57838652600360205260408620818752602052604086205461073d578386526003602052604086209086526020524260408620558285526002602052604085209081546bffffffffffffffffffffffff8116908682106106df5765ffffffffffff429160c01c16101561065b576bffffffffffffffffffffffff9161057991612361565b167fffffffffffffffffffffffffffffffffffffffff0000000000000000000000008254161790553081036105d1575b507f884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a94243648380a380f35b61065590604051907fa9059cbb00000000000000000000000000000000000000000000000000000000602083015260248201528360448201526044815261061960648261224d565b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016612c57565b5f6105a9565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f546f6b656e732068617665206265656e207573656420647572696e672074686960448201527f732074696d656672616d650000000000000000000000000000000000000000006064820152fd5b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f496e73756666696369656e7420546f6b656e73000000000000000000000000006044820152fd5b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602060248201527f5769746864726177616c2077617320616c726561647920706572666f726d65646044820152fd5b6004867f8baa579f000000000000000000000000000000000000000000000000000000008152fd5b6040513d86823e3d90fd5b6004877f617cf474000000000000000000000000000000000000000000000000000000008152fd5b8380fd5b5080fd5b503461022d5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57610836612173565b6bffffffffffffffffffffffff73ffffffffffffffffffffffffffffffffffffffff610860612232565b9216918284526002602052604084208261087d83828454166127bb565b167fffffffffffffffffffffffffffffffffffffffff00000000000000000000000082541617905516906108f46040517f23b872dd0000000000000000000000000000000000000000000000000000000060208201523360248201523060448201528360648201526064815261061960848261224d565b7fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c8380a380f35b50807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d578073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016803b156109e55781602491604051928380927fb760faf900000000000000000000000000000000000000000000000000000000825230600483015234905af180156109da576109c95750f35b816109d39161224d565b61022d5780f35b6040513d84823e3d90fd5b50fd5b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d576040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015260208160248173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165afa9081156109da578291610a9b575b602082604051908152f35b90506020813d602011610ac9575b81610ab66020938361224d565b810103126107fa5760209150515f610a90565b3d9150610aa9565b503461022d5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d5780610b0a612173565b610b126127e5565b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001690813b15610bab5773ffffffffffffffffffffffffffffffffffffffff602484928360405195869485937fc23a5cea0000000000000000000000000000000000000000000000000000000085521660048401525af180156109da576109c95750f35b5050fd5b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57610be66127e5565b8073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016803b156109e5578180916004604051809481937fbb9fe6bf0000000000000000000000000000000000000000000000000000000083525af180156109da576109c95750f35b612196565b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b503461022d5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d5760406020916004358152600683522054604051908152f35b503461022d5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d576040610daf9173ffffffffffffffffffffffffffffffffffffffff610d62612173565b1681526002602090815291902054604080516bffffffffffffffffffffffff8084168252606084811c9091169482019490945260c09290921c65ffffffffffff1690820152918291820190565b0390f35b503461022d5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d576040809173ffffffffffffffffffffffffffffffffffffffff610e04612173565b1681526005602052205465ffffffffffff825191818116835260301c166020820152f35b503461022d5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57610e60612173565b906024359067ffffffffffffffff821161022d5781600401926101207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc84360301126107fa57610eaf8461298a565b73ffffffffffffffffffffffffffffffffffffffff3091160361167e579065ffffffffffff9173ffffffffffffffffffffffffffffffffffffffff610ef386612a0c565b94909416911692838352600560205260408320604051906040820182811067ffffffffffffffff8211176116515791849160209493604052549065ffffffffffff8083169283835260301c16948591015210928315611648575b5082611623575b5050156115c557604051937f22cdde4c0000000000000000000000000000000000000000000000000000000085526020600486015260208580610f9a602482018561269b565b038173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165afa9485156109da578295611591575b50803573ffffffffffffffffffffffffffffffffffffffff811680910361158d5761044b61109960405160208101907f47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a7946921882524660408201523060608201526060815261105060808261224d565b5190209260405160208101917f05a0a1db773d73251a561ef1fe2b420121ab814b9980222b3b139b653496620f835260408201528960608201526060815261040660808261224d565b5190206110aa61010486018361276a565b506020810135907f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a082116115655760209285926080926040519283526040810135851a86840152356040830152606082015282805260015afa156115585773ffffffffffffffffffffffffffffffffffffffff825116938415611530576040517f2e31f340000000000000000000000000000000000000000000000000000000008152856004820152604060248201526020818061116b604482018761269b565b038187895af19081156107c35784916114f5575b501561147257858352600660205260408320546114145760848101359160e482016111aa818361276a565b602411611410579060146111c09201359261276a565b60341161140c5761125892611285949260246bffffffffffffffffffffffff9301359061120c7f0000000000000000000000000000000000000000000000000000000000000000612319565b946fffffffffffffffffffffffffffffffff8060a48160c4880135169601359460801c169260801c16906fffffffffffffffffffffffffffffffff81169060801c010101010216612306565b63ffffffff7f0000000000000000000000000000000000000000000000000000000000000000169061232a565b838252600260205260408220546bffffffffffffffffffffffff1690818111156113f757505b6bffffffffffffffffffffffff8116948515611399578252600660205284604083205560045485810180911161136c57600455838252600260205260408220916bffffffffffffffffffffffff835416908682106106df5761065b576bffffffffffffffffffffffff9161131e91612361565b167fffffffffffffffffffffffffffffffffffffffff0000000000000000000000008254161790557f96e0041f14ae401fab2384e3c29da20cb0263ef760c47847db1f13403cea654c5f80a4005b6024837f4e487b710000000000000000000000000000000000000000000000000000000081526011600452fd5b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601060248201527f4e6f7468696e6720746f20736c617368000000000000000000000000000000006044820152fd5b6bffffffffffffffffffffffff9150166112ab565b8480fd5b8580fd5b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f557365724f702077617320616c726561647920736c61736865640000000000006044820152fd5b60846040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f557365724f7020646f6573206e6f74206f6666656e642074686520636f6e646960448201527f74696f6e000000000000000000000000000000000000000000000000000000006064820152fd5b90506020813d602011611528575b816115106020938361224d565b810103126107f6575180151581036107f6575f61117f565b3d9150611503565b6004837f8baa579f000000000000000000000000000000000000000000000000000000008152fd5b50604051903d90823e3d90fd5b6004857f617cf474000000000000000000000000000000000000000000000000000000008152fd5b8280fd5b9094506020813d6020116115bd575b816115ad6020938361224d565b810103126107fa5751935f610fe3565b3d91506115a0565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f436f6e646974696f6e206e6f74206163746976650000000000000000000000006044820152fd5b81925065ffffffffffff161090811561163f575b505f80610f54565b9050155f611637565b1592505f610f4d565b6024867f4e487b710000000000000000000000000000000000000000000000000000000081526041600452fd5b6004827f48882656000000000000000000000000000000000000000000000000000000008152fd5b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d5760206040517f000000000000000000000000000000000000000000000000000000000000000015158152f35b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d5773ffffffffffffffffffffffffffffffffffffffff6020915416604051908152f35b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57602060405160ff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b503461022d5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57604060209173ffffffffffffffffffffffffffffffffffffffff611800612173565b16815260038352818120602435825283522054604051908152f35b503461022d5760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d576003600435101561022d5760243567ffffffffffffffff81116107fa57611876903690600401612204565b5050611880612831565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600d60248201527f6d757374206f76657272696465000000000000000000000000000000000000006044820152fd5b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d573373ffffffffffffffffffffffffffffffffffffffff60015416036119bc577fffffffffffffffffffffffff0000000000000000000000000000000000000000600154166001558054337fffffffffffffffffffffffff0000000000000000000000000000000000000000821617825573ffffffffffffffffffffffffffffffffffffffff3391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b807f118cdaa7000000000000000000000000000000000000000000000000000000006024925233600452fd5b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57611a8e6127e5565b7fffffffffffffffffffffffff0000000000000000000000000000000000000000600154166001558073ffffffffffffffffffffffffffffffffffffffff81547fffffffffffffffffffffffff000000000000000000000000000000000000000081168355167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b503461022d5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d576004359067ffffffffffffffff821161022d5781600401916101207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc82360301126107fa57611bf7612831565b60648101611c687fe1ea48fc000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000611c53611c4d858961276a565b906128ce565b1614611c62611c4d848861276a565b90612934565b611c718461298a565b73ffffffffffffffffffffffffffffffffffffffff30911603611e6957611cce91611cc761010492611c62611c4d3073ffffffffffffffffffffffffffffffffffffffff611cbe8b61298a565b1614928961276a565b018361276a565b5060208101357f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08111611e4157608060209284926040519160243583526040810135851a86840152356040830152606082015282805260015afa15611e355780519173ffffffffffffffffffffffffffffffffffffffff831615611e0d57917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f606093611dac611da07fffffffffffff000000000000000000000000000000000000000000000000000097612a0c565b91909560443590612af9565b611e075760015b79ffffffffffff0000000000000000000000000000000000000000604051988997604089528951958660408b01528660808c8c015e8a878b01015260d01b169260a01b161717602085015201168101030190f35b81611db3565b6004827f8baa579f000000000000000000000000000000000000000000000000000000008152fd5b604051903d90823e3d90fd5b6004837f617cf474000000000000000000000000000000000000000000000000000000008152fd5b6004837f48882656000000000000000000000000000000000000000000000000000000008152fd5b503461022d5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57610daf611ed4611ecf612173565b61238b565b604080516bffffffffffffffffffffffff948516815293909216602084015265ffffffffffff16908201529081906060820190565b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d5760206040516bffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b503461022d5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d5780611fa9612173565b611fb16127e5565b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001690813b15610bab5773ffffffffffffffffffffffffffffffffffffffff604484928360405195869485937f205c287800000000000000000000000000000000000000000000000000000000855216600484015260243560248401525af180156109da576109c95750f35b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d576020600454604051908152f35b5060207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261216f5760043563ffffffff811680910361216f576120d26127e5565b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001690813b1561216f575f906024604051809481937f0396cb60000000000000000000000000000000000000000000000000000000008352600483015234905af1801561216457612156575080f35b61216291505f9061224d565b005b6040513d5f823e3d90fd5b5f80fd5b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361216f57565b3461216f575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261216f57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b9181601f8401121561216f5782359167ffffffffffffffff831161216f576020838186019501011161216f57565b602435906bffffffffffffffffffffffff8216820361216f57565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761228e57604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b9065ffffffffffff8091169116039065ffffffffffff82116122d957565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b818102929181159184041417156122d957565b60ff16604d81116122d957600a0a90565b8115612334570490565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b906bffffffffffffffffffffffff809116911603906bffffffffffffffffffffffff82116122d957565b73ffffffffffffffffffffffffffffffffffffffff165f52600260205260405f20604051906060820182811067ffffffffffffffff82111761228e57604052546bffffffffffffffffffffffff8116825265ffffffffffff60208301916bffffffffffffffffffffffff8160601c16835260c01c1690816040840152814281115f14612586575061245a6bffffffffffffffffffffffff80612489935116945b511663ffffffff7f00000000000000000000000000000000000000000000000000000000000000001690612306565b6124837f0000000000000000000000000000000000000000000000000000000000000000612319565b9061232a565b6bffffffffffffffffffffffff8111612528576bffffffffffffffffffffffff167f00000000000000000000000000000000000000000000000000000000000000006bffffffffffffffffffffffff8116801515908161251e575b50612516575b50826bffffffffffffffffffffffff828116908216116125105761250d91612361565b92565b50505f92565b90505f6124ea565b905082115f6124e4565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f4d6178207369676e65722071756f746120746f6f2068696768000000000000006044820152fd5b929150505f9161259f65ffffffffffff421691826122bb565b9063ffffffff7f0000000000000000000000000000000000000000000000000000000000000000169182156123345765ffffffffffff9183836125e4931606906122bb565b160165ffffffffffff81116122d95761245a6bffffffffffffffffffffffff612489929361242b565b90357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18236030181121561216f57016020813591019167ffffffffffffffff821161216f57813603831361216f57565b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe093818652868601375f8582860101520116010190565b80359173ffffffffffffffffffffffffffffffffffffffff831680930361216f576127679281526020820135602082015261275861274c6127136126f86126e5604087018761260d565b610120604088015261012087019161265d565b612705606087018761260d565b90868303606088015261265d565b6080850135608085015260a085013560a085015260c085013560c085015261273e60e086018661260d565b9085830360e087015261265d565b9261010081019061260d565b9161010081850391015261265d565b90565b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18136030182121561216f570180359067ffffffffffffffff821161216f5760200191813603831361216f57565b906bffffffffffffffffffffffff809116911601906bffffffffffffffffffffffff82116122d957565b73ffffffffffffffffffffffffffffffffffffffff5f5416330361280557565b7f118cdaa7000000000000000000000000000000000000000000000000000000005f523360045260245ffd5b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016330361287057565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f53656e646572206e6f7420456e747279506f696e7400000000000000000000006044820152fd5b919091357fffffffff0000000000000000000000000000000000000000000000000000000081169260048110612902575050565b7fffffffff00000000000000000000000000000000000000000000000000000000929350829060040360031b1b161690565b1561293c5750565b7fffffffff00000000000000000000000000000000000000000000000000000000907f839d9ad2000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b6129989060e081019061276a565b60141161216f573560601c90565b919091357fffffffffffff0000000000000000000000000000000000000000000000000000811692600681106129da575050565b7fffffffffffff0000000000000000000000000000000000000000000000000000929350829060060360031b1b161690565b9060e08201612a1b818461276a565b9190506040809210612a9c57612a31818561276a565b909190603a1161216f57612a4c60066034612a5594016129a6565b60d01c9461276a565b909190603a821061216f57811161216f577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc6603a612a9693019101906129a6565b60d01c90565b606482517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f496e76616c69642056616c696461746f722044617461000000000000000000006044820152fd5b7f0000000000000000000000000000000000000000000000000000000000000000158015612c4f575b612c48576bffffffffffffffffffffffff612b3c8261238b565b9491929092168111612c405773ffffffffffffffffffffffffffffffffffffffff916bffffffffffffffffffffffff612b769216906127bb565b91165f52600260205260405f209182549065ffffffffffff8260c01c1665ffffffffffff821603612bef575b50507fffffffffffffffff000000000000000000000000ffffffffffffffffffffffff77ffffffffffffffffffffffff00000000000000000000000083549260601b169116179055600190565b7dffffffffffff0000000000000000000000000000000000000000000000007fffff000000000000ffffffffffffffffffffffffffffffffffffffffffffffff9160c01b1691161782555f80612ba2565b505050505f90565b5050600190565b508115612b22565b905f602091828151910182855af115612164575f513d612cd5575073ffffffffffffffffffffffffffffffffffffffff81163b155b612c935750565b73ffffffffffffffffffffffffffffffffffffffff907f5274afe7000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b60011415612c8c56fea264697066735822122013b66011e4139d12b6893b791773c70e64e51c79c5e1aeb86e484a058f5b36ff64736f6c634300081d0033",
  "deployedBytecode": "0x60806040526004361015610011575f80fd5b5f5f3560e01c80630396cb601461208e5780630f5cb70814612052578063205c287814611f7057806338c4c62114611f09578063519e981514611e9157806352b7512c14611b7a5780636f9bb7bd14611b1b5780636f9bf91b14610c63578063715018a614611a5757806373717b08146119e857806379ba5097146118de5780637c627b211461181b5780637eec7d68146117ae57806381f243c3146117525780638da5cb5b1461170157806393df8c31146116a6578063941eaf5314610e285780639f202a0414610db3578063a3be4d7b14610d0f578063a99819be14610cc7578063ad3228c614610c68578063b0d691fe14610c63578063bb9fe6bf14610baf578063c23a5cea14610ad1578063c399ec88146109e8578063d0e30db01461091b578063d912dcca146107fe578063e002f088146102e3578063e2c7b3e014610282578063e30c3978146102305763f2fde38b1461016f575f80fd5b3461022d5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d5773ffffffffffffffffffffffffffffffffffffffff6101bb612173565b6101c36127e5565b16807fffffffffffffffffffffffff0000000000000000000000000000000000000000600154161760015573ffffffffffffffffffffffffffffffffffffffff8254167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e227008380a380f35b80fd5b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57602073ffffffffffffffffffffffffffffffffffffffff60015416604051908152f35b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57602060405165ffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b5060807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d5760043567ffffffffffffffff81116107fa5761032e903690600401612204565b50610337612232565b9060443573ffffffffffffffffffffffffffffffffffffffff81168091036107f6576bffffffffffffffffffffffff83169260405160208101907f47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a794692188252466040820152306060820152606081526103af60808261224d565b51902061044b61047760405160208101907ff004bebf3ce3a32f609e24232a25277f97bc1a0843e36f180d0e414dd5a65b7a825288604082015286606082015260643560808201526080815261040660a08261224d565b51902060405192839160208301958690916042927f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201520190565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0810183528261224d565b5190209260208101357f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a081116107ce5760806020928892604051918883526040810135851a86840152356040830152606082015282805260015afa156107c35773ffffffffffffffffffffffffffffffffffffffff85511692831561079b57838652600360205260408620818752602052604086205461073d578386526003602052604086209086526020524260408620558285526002602052604085209081546bffffffffffffffffffffffff8116908682106106df5765ffffffffffff429160c01c16101561065b576bffffffffffffffffffffffff9161057991612361565b167fffffffffffffffffffffffffffffffffffffffff0000000000000000000000008254161790553081036105d1575b507f884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a94243648380a380f35b61065590604051907fa9059cbb00000000000000000000000000000000000000000000000000000000602083015260248201528360448201526044815261061960648261224d565b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016612c57565b5f6105a9565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f546f6b656e732068617665206265656e207573656420647572696e672074686960448201527f732074696d656672616d650000000000000000000000000000000000000000006064820152fd5b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f496e73756666696369656e7420546f6b656e73000000000000000000000000006044820152fd5b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602060248201527f5769746864726177616c2077617320616c726561647920706572666f726d65646044820152fd5b6004867f8baa579f000000000000000000000000000000000000000000000000000000008152fd5b6040513d86823e3d90fd5b6004877f617cf474000000000000000000000000000000000000000000000000000000008152fd5b8380fd5b5080fd5b503461022d5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57610836612173565b6bffffffffffffffffffffffff73ffffffffffffffffffffffffffffffffffffffff610860612232565b9216918284526002602052604084208261087d83828454166127bb565b167fffffffffffffffffffffffffffffffffffffffff00000000000000000000000082541617905516906108f46040517f23b872dd0000000000000000000000000000000000000000000000000000000060208201523360248201523060448201528360648201526064815261061960848261224d565b7fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c8380a380f35b50807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d578073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016803b156109e55781602491604051928380927fb760faf900000000000000000000000000000000000000000000000000000000825230600483015234905af180156109da576109c95750f35b816109d39161224d565b61022d5780f35b6040513d84823e3d90fd5b50fd5b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d576040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015260208160248173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165afa9081156109da578291610a9b575b602082604051908152f35b90506020813d602011610ac9575b81610ab66020938361224d565b810103126107fa5760209150515f610a90565b3d9150610aa9565b503461022d5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d5780610b0a612173565b610b126127e5565b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001690813b15610bab5773ffffffffffffffffffffffffffffffffffffffff602484928360405195869485937fc23a5cea0000000000000000000000000000000000000000000000000000000085521660048401525af180156109da576109c95750f35b5050fd5b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57610be66127e5565b8073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016803b156109e5578180916004604051809481937fbb9fe6bf0000000000000000000000000000000000000000000000000000000083525af180156109da576109c95750f35b612196565b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b503461022d5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d5760406020916004358152600683522054604051908152f35b503461022d5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d576040610daf9173ffffffffffffffffffffffffffffffffffffffff610d62612173565b1681526002602090815291902054604080516bffffffffffffffffffffffff8084168252606084811c9091169482019490945260c09290921c65ffffffffffff1690820152918291820190565b0390f35b503461022d5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d576040809173ffffffffffffffffffffffffffffffffffffffff610e04612173565b1681526005602052205465ffffffffffff825191818116835260301c166020820152f35b503461022d5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57610e60612173565b906024359067ffffffffffffffff821161022d5781600401926101207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc84360301126107fa57610eaf8461298a565b73ffffffffffffffffffffffffffffffffffffffff3091160361167e579065ffffffffffff9173ffffffffffffffffffffffffffffffffffffffff610ef386612a0c565b94909416911692838352600560205260408320604051906040820182811067ffffffffffffffff8211176116515791849160209493604052549065ffffffffffff8083169283835260301c16948591015210928315611648575b5082611623575b5050156115c557604051937f22cdde4c0000000000000000000000000000000000000000000000000000000085526020600486015260208580610f9a602482018561269b565b038173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165afa9485156109da578295611591575b50803573ffffffffffffffffffffffffffffffffffffffff811680910361158d5761044b61109960405160208101907f47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a7946921882524660408201523060608201526060815261105060808261224d565b5190209260405160208101917f05a0a1db773d73251a561ef1fe2b420121ab814b9980222b3b139b653496620f835260408201528960608201526060815261040660808261224d565b5190206110aa61010486018361276a565b506020810135907f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a082116115655760209285926080926040519283526040810135851a86840152356040830152606082015282805260015afa156115585773ffffffffffffffffffffffffffffffffffffffff825116938415611530576040517f2e31f340000000000000000000000000000000000000000000000000000000008152856004820152604060248201526020818061116b604482018761269b565b038187895af19081156107c35784916114f5575b501561147257858352600660205260408320546114145760848101359160e482016111aa818361276a565b602411611410579060146111c09201359261276a565b60341161140c5761125892611285949260246bffffffffffffffffffffffff9301359061120c7f0000000000000000000000000000000000000000000000000000000000000000612319565b946fffffffffffffffffffffffffffffffff8060a48160c4880135169601359460801c169260801c16906fffffffffffffffffffffffffffffffff81169060801c010101010216612306565b63ffffffff7f0000000000000000000000000000000000000000000000000000000000000000169061232a565b838252600260205260408220546bffffffffffffffffffffffff1690818111156113f757505b6bffffffffffffffffffffffff8116948515611399578252600660205284604083205560045485810180911161136c57600455838252600260205260408220916bffffffffffffffffffffffff835416908682106106df5761065b576bffffffffffffffffffffffff9161131e91612361565b167fffffffffffffffffffffffffffffffffffffffff0000000000000000000000008254161790557f96e0041f14ae401fab2384e3c29da20cb0263ef760c47847db1f13403cea654c5f80a4005b6024837f4e487b710000000000000000000000000000000000000000000000000000000081526011600452fd5b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601060248201527f4e6f7468696e6720746f20736c617368000000000000000000000000000000006044820152fd5b6bffffffffffffffffffffffff9150166112ab565b8480fd5b8580fd5b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f557365724f702077617320616c726561647920736c61736865640000000000006044820152fd5b60846040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f557365724f7020646f6573206e6f74206f6666656e642074686520636f6e646960448201527f74696f6e000000000000000000000000000000000000000000000000000000006064820152fd5b90506020813d602011611528575b816115106020938361224d565b810103126107f6575180151581036107f6575f61117f565b3d9150611503565b6004837f8baa579f000000000000000000000000000000000000000000000000000000008152fd5b50604051903d90823e3d90fd5b6004857f617cf474000000000000000000000000000000000000000000000000000000008152fd5b8280fd5b9094506020813d6020116115bd575b816115ad6020938361224d565b810103126107fa5751935f610fe3565b3d91506115a0565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f436f6e646974696f6e206e6f74206163746976650000000000000000000000006044820152fd5b81925065ffffffffffff161090811561163f575b505f80610f54565b9050155f611637565b1592505f610f4d565b6024867f4e487b710000000000000000000000000000000000000000000000000000000081526041600452fd5b6004827f48882656000000000000000000000000000000000000000000000000000000008152fd5b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d5760206040517f000000000000000000000000000000000000000000000000000000000000000015158152f35b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d5773ffffffffffffffffffffffffffffffffffffffff6020915416604051908152f35b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57602060405160ff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b503461022d5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57604060209173ffffffffffffffffffffffffffffffffffffffff611800612173565b16815260038352818120602435825283522054604051908152f35b503461022d5760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d576003600435101561022d5760243567ffffffffffffffff81116107fa57611876903690600401612204565b5050611880612831565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600d60248201527f6d757374206f76657272696465000000000000000000000000000000000000006044820152fd5b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d573373ffffffffffffffffffffffffffffffffffffffff60015416036119bc577fffffffffffffffffffffffff0000000000000000000000000000000000000000600154166001558054337fffffffffffffffffffffffff0000000000000000000000000000000000000000821617825573ffffffffffffffffffffffffffffffffffffffff3391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b807f118cdaa7000000000000000000000000000000000000000000000000000000006024925233600452fd5b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57611a8e6127e5565b7fffffffffffffffffffffffff0000000000000000000000000000000000000000600154166001558073ffffffffffffffffffffffffffffffffffffffff81547fffffffffffffffffffffffff000000000000000000000000000000000000000081168355167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b503461022d5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d576004359067ffffffffffffffff821161022d5781600401916101207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc82360301126107fa57611bf7612831565b60648101611c687fe1ea48fc000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000611c53611c4d858961276a565b906128ce565b1614611c62611c4d848861276a565b90612934565b611c718461298a565b73ffffffffffffffffffffffffffffffffffffffff30911603611e6957611cce91611cc761010492611c62611c4d3073ffffffffffffffffffffffffffffffffffffffff611cbe8b61298a565b1614928961276a565b018361276a565b5060208101357f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08111611e4157608060209284926040519160243583526040810135851a86840152356040830152606082015282805260015afa15611e355780519173ffffffffffffffffffffffffffffffffffffffff831615611e0d57917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f606093611dac611da07fffffffffffff000000000000000000000000000000000000000000000000000097612a0c565b91909560443590612af9565b611e075760015b79ffffffffffff0000000000000000000000000000000000000000604051988997604089528951958660408b01528660808c8c015e8a878b01015260d01b169260a01b161717602085015201168101030190f35b81611db3565b6004827f8baa579f000000000000000000000000000000000000000000000000000000008152fd5b604051903d90823e3d90fd5b6004837f617cf474000000000000000000000000000000000000000000000000000000008152fd5b6004837f48882656000000000000000000000000000000000000000000000000000000008152fd5b503461022d5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d57610daf611ed4611ecf612173565b61238b565b604080516bffffffffffffffffffffffff948516815293909216602084015265ffffffffffff16908201529081906060820190565b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d5760206040516bffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b503461022d5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d5780611fa9612173565b611fb16127e5565b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001690813b15610bab5773ffffffffffffffffffffffffffffffffffffffff604484928360405195869485937f205c287800000000000000000000000000000000000000000000000000000000855216600484015260243560248401525af180156109da576109c95750f35b503461022d57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022d576020600454604051908152f35b5060207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261216f5760043563ffffffff811680910361216f576120d26127e5565b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001690813b1561216f575f906024604051809481937f0396cb60000000000000000000000000000000000000000000000000000000008352600483015234905af1801561216457612156575080f35b61216291505f9061224d565b005b6040513d5f823e3d90fd5b5f80fd5b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361216f57565b3461216f575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261216f57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b9181601f8401121561216f5782359167ffffffffffffffff831161216f576020838186019501011161216f57565b602435906bffffffffffffffffffffffff8216820361216f57565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761228e57604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b9065ffffffffffff8091169116039065ffffffffffff82116122d957565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b818102929181159184041417156122d957565b60ff16604d81116122d957600a0a90565b8115612334570490565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b906bffffffffffffffffffffffff809116911603906bffffffffffffffffffffffff82116122d957565b73ffffffffffffffffffffffffffffffffffffffff165f52600260205260405f20604051906060820182811067ffffffffffffffff82111761228e57604052546bffffffffffffffffffffffff8116825265ffffffffffff60208301916bffffffffffffffffffffffff8160601c16835260c01c1690816040840152814281115f14612586575061245a6bffffffffffffffffffffffff80612489935116945b511663ffffffff7f00000000000000000000000000000000000000000000000000000000000000001690612306565b6124837f0000000000000000000000000000000000000000000000000000000000000000612319565b9061232a565b6bffffffffffffffffffffffff8111612528576bffffffffffffffffffffffff167f00000000000000000000000000000000000000000000000000000000000000006bffffffffffffffffffffffff8116801515908161251e575b50612516575b50826bffffffffffffffffffffffff828116908216116125105761250d91612361565b92565b50505f92565b90505f6124ea565b905082115f6124e4565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f4d6178207369676e65722071756f746120746f6f2068696768000000000000006044820152fd5b929150505f9161259f65ffffffffffff421691826122bb565b9063ffffffff7f0000000000000000000000000000000000000000000000000000000000000000169182156123345765ffffffffffff9183836125e4931606906122bb565b160165ffffffffffff81116122d95761245a6bffffffffffffffffffffffff612489929361242b565b90357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18236030181121561216f57016020813591019167ffffffffffffffff821161216f57813603831361216f57565b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe093818652868601375f8582860101520116010190565b80359173ffffffffffffffffffffffffffffffffffffffff831680930361216f576127679281526020820135602082015261275861274c6127136126f86126e5604087018761260d565b610120604088015261012087019161265d565b612705606087018761260d565b90868303606088015261265d565b6080850135608085015260a085013560a085015260c085013560c085015261273e60e086018661260d565b9085830360e087015261265d565b9261010081019061260d565b9161010081850391015261265d565b90565b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18136030182121561216f570180359067ffffffffffffffff821161216f5760200191813603831361216f57565b906bffffffffffffffffffffffff809116911601906bffffffffffffffffffffffff82116122d957565b73ffffffffffffffffffffffffffffffffffffffff5f5416330361280557565b7f118cdaa7000000000000000000000000000000000000000000000000000000005f523360045260245ffd5b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016330361287057565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f53656e646572206e6f7420456e747279506f696e7400000000000000000000006044820152fd5b919091357fffffffff0000000000000000000000000000000000000000000000000000000081169260048110612902575050565b7fffffffff00000000000000000000000000000000000000000000000000000000929350829060040360031b1b161690565b1561293c5750565b7fffffffff00000000000000000000000000000000000000000000000000000000907f839d9ad2000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b6129989060e081019061276a565b60141161216f573560601c90565b919091357fffffffffffff0000000000000000000000000000000000000000000000000000811692600681106129da575050565b7fffffffffffff0000000000000000000000000000000000000000000000000000929350829060060360031b1b161690565b9060e08201612a1b818461276a565b9190506040809210612a9c57612a31818561276a565b909190603a1161216f57612a4c60066034612a5594016129a6565b60d01c9461276a565b909190603a821061216f57811161216f577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc6603a612a9693019101906129a6565b60d01c90565b606482517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f496e76616c69642056616c696461746f722044617461000000000000000000006044820152fd5b7f0000000000000000000000000000000000000000000000000000000000000000158015612c4f575b612c48576bffffffffffffffffffffffff612b3c8261238b565b9491929092168111612c405773ffffffffffffffffffffffffffffffffffffffff916bffffffffffffffffffffffff612b769216906127bb565b91165f52600260205260405f209182549065ffffffffffff8260c01c1665ffffffffffff821603612bef575b50507fffffffffffffffff000000000000000000000000ffffffffffffffffffffffff77ffffffffffffffffffffffff00000000000000000000000083549260601b169116179055600190565b7dffffffffffff0000000000000000000000000000000000000000000000007fffff000000000000ffffffffffffffffffffffffffffffffffffffffffffffff9160c01b1691161782555f80612ba2565b505050505f90565b5050600190565b508115612b22565b905f602091828151910182855af115612164575f513d612cd5575073ffffffffffffffffffffffffffffffffffffffff81163b155b612c935750565b73ffffffffffffffffffffffffffffffffffffffff907f5274afe7000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b60011415612c8c56fea264697066735822122013b66011e4139d12b6893b791773c70e64e51c79c5e1aeb86e484a058f5b36ff64736f6c634300081d0033",
  "devdoc": {
    "errors": {
      "OwnableInvalidOwner(address)": [
        {
          "details": "The owner is not a valid owner account. (eg. `address(0)`)"
        }
      ],
      "OwnableUnauthorizedAccount(address)": [
        {
          "details": "The caller account is not authorized to perform an operation."
        }
      ],
      "SafeERC20FailedOperation(address)": [
        {
          "details": "An operation with an ERC-20 token failed."
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "acceptOwnership()": {
        "details": "The new owner accepts the ownership transfer."
      },
      "addStake(uint32)": {
        "params": {
          "unstakeDelaySec": "- The unstake delay for this paymaster. Can only be increased."
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "pendingOwner()": {
        "details": "Returns the address of the pending owner."
      },
      "postOp(uint8,bytes,uint256,uint256)": {
        "params": {
          "actualGasCost": "- Actual cost of gas used so far (without this postOp call).",
          "actualUserOpFeePerGas": "- the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas                        and maxPriorityFee (and basefee)                        It is not the same as tx.gasprice, which is what the bundler pays.",
          "context": "- The context value returned by validatePaymasterUserOp",
          "mode": "- Enum with the following options:                        opSucceeded - User operation succeeded.                        opReverted  - User op reverted. The paymaster still has to pay for gas.                        postOpReverted - never passed in a call to postOp()."
        }
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner. Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer."
      },
      "validatePaymasterUserOp((address,uint256,bytes,bytes,bytes32,uint256,bytes32,bytes,bytes),bytes32,uint256)": {
        "params": {
          "maxCost": "- The maximum cost of this transaction (based on maximum gas and gas price from userOp).",
          "userOp": "- The user operation.",
          "userOpHash": "- Hash of the user's request data."
        },
        "returns": {
          "context": "       - Value to send to a postOp. Zero length to signify postOp is not required.",
          "validationData": "- Signature and time-range of this operation, encoded the same as the return                          value of validateUserOperation.                          <20-byte> aggregatorOrSigFail - 0 for valid signature, 1 to mark signature failure,                                                    other values are invalid for paymaster.                          <6-byte> validUntil - Last timestamp this operation is valid at, or 0 for \"indefinitely\"                          <6-byte> validAfter - first timestamp this operation is valid                          Note that the validation code cannot use block.timestamp (or block.number) directly."
        }
      },
      "withdrawStake(address)": {
        "params": {
          "withdrawAddress": "- The address to send withdrawn value."
        }
      },
      "withdrawTo(address,uint256)": {
        "params": {
          "amount": "- Amount to withdraw.",
          "withdrawAddress": "- Target to send to."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "InvalidSignature()": [
        {
          "notice": "Thrown if `ecrecover` yields `address(0)`."
        }
      ],
      "InvalidSignatureSValue()": [
        {
          "notice": "Thrown if the S value of the signature is not from the lower half of the curve."
        }
      ]
    },
    "kind": "user",
    "methods": {
      "addStake(uint32)": {
        "notice": "Add stake for this paymaster. This method can also carry eth value to add to the current stake."
      },
      "deposit()": {
        "notice": "Add a deposit for this paymaster, used for paying for transaction fees."
      },
      "getDeposit()": {
        "notice": "Return current paymaster's deposit on the entryPoint."
      },
      "postOp(uint8,bytes,uint256,uint256)": {
        "notice": "Post-operation handler. Must verify sender is the entryPoint."
      },
      "unlockStake()": {
        "notice": "Unlock the stake, in order to withdraw it. The paymaster can't serve requests once unlocked, until it calls addStake again"
      },
      "validatePaymasterUserOp((address,uint256,bytes,bytes,bytes32,uint256,bytes32,bytes,bytes),bytes32,uint256)": {
        "notice": "Payment validation: check if paymaster agrees to pay. Must verify sender is the entryPoint. Revert to reject this request. Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted). The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns."
      },
      "withdrawStake(address)": {
        "notice": "Withdraw the entire paymaster's stake. stake must be unlocked first (and then wait for the unstakeDelay to be over)"
      },
      "withdrawTo(address,uint256)": {
        "notice": "Withdraw value from the deposit."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 1241,
        "contract": "src/SafeHarbourPaymaster.sol:SafeHarbourPaymaster",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 1389,
        "contract": "src/SafeHarbourPaymaster.sol:SafeHarbourPaymaster",
        "label": "_pendingOwner",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 4292,
        "contract": "src/SafeHarbourPaymaster.sol:SafeHarbourPaymaster",
        "label": "quotaStatsForSigner",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_struct(QuotaStats)4256_storage)"
      },
      {
        "astId": 4298,
        "contract": "src/SafeHarbourPaymaster.sol:SafeHarbourPaymaster",
        "label": "withdrawsForSigner",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_mapping(t_bytes32,t_uint256))"
      },
      {
        "astId": 4853,
        "contract": "src/SafeHarbourPaymaster.sol:SafeHarbourPaymaster",
        "label": "slashedTokens",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 4859,
        "contract": "src/SafeHarbourPaymaster.sol:SafeHarbourPaymaster",
        "label": "enabledConditions",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_contract(ISlashingCondition)2954,t_struct(ConditionStatus)4826_storage)"
      },
      {
        "astId": 4863,
        "contract": "src/SafeHarbourPaymaster.sol:SafeHarbourPaymaster",
        "label": "slashedUserOps",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_bytes32,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(ISlashingCondition)2954": {
        "encoding": "inplace",
        "label": "contract ISlashingCondition",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_mapping(t_bytes32,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(bytes32 => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_uint256)"
      },
      "t_mapping(t_address,t_struct(QuotaStats)4256_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct QuotaStats)",
        "numberOfBytes": "32",
        "value": "t_struct(QuotaStats)4256_storage"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_contract(ISlashingCondition)2954,t_struct(ConditionStatus)4826_storage)": {
        "encoding": "mapping",
        "key": "t_contract(ISlashingCondition)2954",
        "label": "mapping(contract ISlashingCondition => struct SlashingMixin.ConditionStatus)",
        "numberOfBytes": "32",
        "value": "t_struct(ConditionStatus)4826_storage"
      },
      "t_struct(ConditionStatus)4826_storage": {
        "encoding": "inplace",
        "label": "struct SlashingMixin.ConditionStatus",
        "members": [
          {
            "astId": 4823,
            "contract": "src/SafeHarbourPaymaster.sol:SafeHarbourPaymaster",
            "label": "enabledAfter",
            "offset": 0,
            "slot": "0",
            "type": "t_uint48"
          },
          {
            "astId": 4825,
            "contract": "src/SafeHarbourPaymaster.sol:SafeHarbourPaymaster",
            "label": "enabledUntil",
            "offset": 6,
            "slot": "0",
            "type": "t_uint48"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(QuotaStats)4256_storage": {
        "encoding": "inplace",
        "label": "struct QuotaStats",
        "members": [
          {
            "astId": 4251,
            "contract": "src/SafeHarbourPaymaster.sol:SafeHarbourPaymaster",
            "label": "tokenBalance",
            "offset": 0,
            "slot": "0",
            "type": "t_uint96"
          },
          {
            "astId": 4253,
            "contract": "src/SafeHarbourPaymaster.sol:SafeHarbourPaymaster",
            "label": "usedQuota",
            "offset": 12,
            "slot": "0",
            "type": "t_uint96"
          },
          {
            "astId": 4255,
            "contract": "src/SafeHarbourPaymaster.sol:SafeHarbourPaymaster",
            "label": "nextQuotaReset",
            "offset": 24,
            "slot": "0",
            "type": "t_uint48"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint48": {
        "encoding": "inplace",
        "label": "uint48",
        "numberOfBytes": "6"
      },
      "t_uint96": {
        "encoding": "inplace",
        "label": "uint96",
        "numberOfBytes": "12"
      }
    }
  }
}