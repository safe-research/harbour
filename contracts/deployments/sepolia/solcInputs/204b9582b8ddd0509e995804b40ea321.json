{
  "language": "Solidity",
  "sources": {
    "@account-abstraction/contracts/core/Helpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/* solhint-disable no-inline-assembly */\n\n\n /*\n  * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n  * must return this value in case of signature failure, instead of revert.\n  */\nuint256 constant SIG_VALIDATION_FAILED = 1;\n\n\n/*\n * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n * return this value on success.\n */\nuint256 constant SIG_VALIDATION_SUCCESS = 0;\n\n\n/**\n * Returned data from validateUserOp.\n * validateUserOp returns a uint256, which is created by `_packedValidationData` and\n * parsed by `_parseValidationData`.\n * @param aggregator  - address(0) - The account validated the signature by itself.\n *                      address(1) - The account failed to validate the signature.\n *                      otherwise - This is an address of a signature aggregator that must\n *                                  be used to validate the signature.\n * @param validAfter  - This UserOp is valid only after this timestamp.\n * @param validUntil - Last timestamp this operation is valid at, or 0 for \"indefinitely\".\n */\nstruct ValidationData {\n    address aggregator;\n    uint48 validAfter;\n    uint48 validUntil;\n}\n\n/**\n * Extract aggregator/sigFailed, validAfter, validUntil.\n * Also convert zero validUntil to type(uint48).max.\n * @param validationData - The packed validation data.\n * @return data - The unpacked in-memory validation data.\n */\nfunction _parseValidationData(\n    uint256 validationData\n) pure returns (ValidationData memory data) {\n    address aggregator = address(uint160(validationData));\n    uint48 validUntil = uint48(validationData >> 160);\n    if (validUntil == 0) {\n        validUntil = type(uint48).max;\n    }\n    uint48 validAfter = uint48(validationData >> (48 + 160));\n    return ValidationData(aggregator, validAfter, validUntil);\n}\n\n/**\n * Helper to pack the return value for validateUserOp.\n * @param data - The ValidationData to pack.\n * @return the packed validation data.\n */\nfunction _packValidationData(\n    ValidationData memory data\n) pure returns (uint256) {\n    return\n        uint160(data.aggregator) |\n        (uint256(data.validUntil) << 160) |\n        (uint256(data.validAfter) << (160 + 48));\n}\n\n/**\n * Helper to pack the return value for validateUserOp, when not using an aggregator.\n * @param sigFailed  - True for signature failure, false for success.\n * @param validUntil - Last timestamp this operation is valid at, or 0 for \"indefinitely\".\n * @param validAfter - First timestamp this UserOperation is valid.\n * @return the packed validation data.\n */\nfunction _packValidationData(\n    bool sigFailed,\n    uint48 validUntil,\n    uint48 validAfter\n) pure returns (uint256) {\n    return\n        (sigFailed ?  SIG_VALIDATION_FAILED : SIG_VALIDATION_SUCCESS) |\n        (uint256(validUntil) << 160) |\n        (uint256(validAfter) << (160 + 48));\n}\n\n/**\n * keccak function over calldata.\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\n *\n * @param data - the calldata bytes array to perform keccak on.\n * @return ret - the keccak hash of the 'data' array.\n */\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\n        assembly (\"memory-safe\") {\n            let mem := mload(0x40)\n            let len := data.length\n            calldatacopy(mem, data.offset, len)\n            ret := keccak256(mem, len)\n        }\n    }\n\n\n/**\n * The minimum of two numbers.\n * @param a - First number.\n * @param b - Second number.\n * @return - the minimum value.\n */\n    function min(uint256 a, uint256 b) pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n/**\n * standard solidity memory allocation finalization.\n * copied from solidity generated code\n * @param memPointer - The current memory pointer\n * @param allocationSize - Bytes allocated from memPointer.\n */\n    function finalizeAllocation(uint256 memPointer, uint256 allocationSize) pure {\n\n        assembly (\"memory-safe\"){\n            finalize_allocation(memPointer, allocationSize)\n\n            function finalize_allocation(memPtr, size) {\n                let newFreePtr := add(memPtr, round_up_to_mul_of_32(size))\n                mstore(64, newFreePtr)\n            }\n\n            function round_up_to_mul_of_32(value) -> result {\n                result := and(add(value, 31), not(31))\n            }\n        }\n    }\n"
    },
    "@account-abstraction/contracts/core/UserOperationLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/PackedUserOperation.sol\";\nimport {calldataKeccak, min} from \"./Helpers.sol\";\n\n/**\n * Utility functions helpful when working with UserOperation structs.\n */\nlibrary UserOperationLib {\n\n    uint256 public constant PAYMASTER_VALIDATION_GAS_OFFSET = 20;\n    uint256 public constant PAYMASTER_POSTOP_GAS_OFFSET = 36;\n    uint256 public constant PAYMASTER_DATA_OFFSET = 52;\n\n    /**\n     * Relayer/block builder might submit the TX with higher priorityFee,\n     * but the user should not pay above what he signed for.\n     * @param userOp - The user operation data.\n     */\n    function gasPrice(\n        PackedUserOperation calldata userOp\n    ) internal view returns (uint256) {\n        unchecked {\n            (uint256 maxPriorityFeePerGas, uint256 maxFeePerGas) = unpackUints(userOp.gasFees);\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n        }\n    }\n\n    bytes32 internal constant PACKED_USEROP_TYPEHASH =\n    keccak256(\n        \"PackedUserOperation(address sender,uint256 nonce,bytes initCode,bytes callData,bytes32 accountGasLimits,uint256 preVerificationGas,bytes32 gasFees,bytes paymasterAndData)\"\n    );\n\n    /**\n     * Pack the user operation data into bytes for hashing.\n     * @param userOp - The user operation data.\n     * @param overrideInitCodeHash - If set, encode this instead of the initCode field in the userOp.\n     */\n    function encode(\n        PackedUserOperation calldata userOp,\n        bytes32 overrideInitCodeHash\n    ) internal pure returns (bytes memory ret) {\n        address sender = userOp.sender;\n        uint256 nonce = userOp.nonce;\n        bytes32 hashInitCode = overrideInitCodeHash != 0 ? overrideInitCodeHash : calldataKeccak(userOp.initCode);\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\n        bytes32 accountGasLimits = userOp.accountGasLimits;\n        uint256 preVerificationGas = userOp.preVerificationGas;\n        bytes32 gasFees = userOp.gasFees;\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\n\n        return abi.encode(\n            UserOperationLib.PACKED_USEROP_TYPEHASH,\n            sender, nonce,\n            hashInitCode, hashCallData,\n            accountGasLimits, preVerificationGas, gasFees,\n            hashPaymasterAndData\n        );\n    }\n\n    function unpackUints(\n        bytes32 packed\n    ) internal pure returns (uint256 high128, uint256 low128) {\n        return (unpackHigh128(packed), unpackLow128(packed));\n    }\n\n    // Unpack just the high 128-bits from a packed value\n    function unpackHigh128(bytes32 packed) internal pure returns (uint256) {\n        return uint256(packed) >> 128;\n    }\n\n    // Unpack just the low 128-bits from a packed value\n    function unpackLow128(bytes32 packed) internal pure returns (uint256) {\n        return uint128(uint256(packed));\n    }\n\n    function unpackMaxPriorityFeePerGas(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackHigh128(userOp.gasFees);\n    }\n\n    function unpackMaxFeePerGas(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackLow128(userOp.gasFees);\n    }\n\n    function unpackVerificationGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackHigh128(userOp.accountGasLimits);\n    }\n\n    function unpackCallGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackLow128(userOp.accountGasLimits);\n    }\n\n    function unpackPaymasterVerificationGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET]));\n    }\n\n    function unpackPostOpGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]));\n    }\n\n    function unpackPaymasterStaticFields(\n        bytes calldata paymasterAndData\n    ) internal pure returns (address paymaster, uint256 validationGasLimit, uint256 postOpGasLimit) {\n        return (\n            address(bytes20(paymasterAndData[: PAYMASTER_VALIDATION_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]))\n        );\n    }\n\n    /**\n     * Hash the user operation data.\n     * @param userOp - The user operation data.\n     * @param overrideInitCodeHash - If set, the initCode hash will be replaced with this value just for UserOp hashing.\n     */\n    function hash(\n        PackedUserOperation calldata userOp,\n        bytes32 overrideInitCodeHash\n    ) internal pure returns (bytes32) {\n        return keccak256(encode(userOp, overrideInitCodeHash));\n    }\n}\n"
    },
    "@account-abstraction/contracts/interfaces/IAccount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./PackedUserOperation.sol\";\n\ninterface IAccount {\n    /**\n     * Validate user's signature and nonce\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n     * This allows making a \"simulation call\" without a valid signature\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\n     *\n     * @dev Must validate caller is the entryPoint.\n     *      Must validate the signature and nonce\n     * @param userOp              - The operation that is about to be executed.\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for signature.\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\n     *                              This is the minimum amount to transfer to the sender(entryPoint) to be\n     *                              able to make the call. The excess is left as a deposit in the entrypoint\n     *                              for future calls. Can be withdrawn anytime using \"entryPoint.withdrawTo()\".\n     *                              In case there is a paymaster in the request (or the current deposit is high\n     *                              enough), this value will be zero.\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData` and\n     *                              `_unpackValidationData` to encode and decode.\n     *                              <20-byte> aggregatorOrSigFail - 0 for valid signature, 1 to mark signature failure,\n     *                                 otherwise, an address of an \"aggregator\" contract.\n     *                              <6-byte> validUntil - Last timestamp this operation is valid at, or 0 for \"indefinitely\"\n     *                              <6-byte> validAfter - First timestamp this operation is valid\n     *                                                    If an account doesn't use time-range, it is enough to\n     *                                                    return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *                              Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external returns (uint256 validationData);\n}\n"
    },
    "@account-abstraction/contracts/interfaces/IAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * Aggregated Signatures validator.\n */\ninterface IAggregator {\n    /**\n     * Validate an aggregated signature.\n     * Reverts if the aggregated signature does not match the given list of operations.\n     * @param userOps   - An array of UserOperations to validate the signature for.\n     * @param signature - The aggregated signature.\n     */\n    function validateSignatures(\n        PackedUserOperation[] calldata userOps,\n        bytes calldata signature\n    ) external;\n\n    /**\n     * Validate the signature of a single userOp.\n     * This method should be called by bundler after EntryPointSimulation.simulateValidation() returns\n     * the aggregator this account uses.\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\n     * @param userOp        - The userOperation received from the user.\n     * @return sigForUserOp - The value to put into the signature field of the userOp when calling handleOps.\n     *                        (usually empty, unless account and aggregator support some kind of \"multisig\".\n     */\n    function validateUserOpSignature(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes memory sigForUserOp);\n\n    /**\n     * Aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code to perform this aggregation.\n     * @param userOps              - An array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature - The aggregated signature.\n     */\n    function aggregateSignatures(\n        PackedUserOperation[] calldata userOps\n    ) external view returns (bytes memory aggregatedSignature);\n}\n"
    },
    "@account-abstraction/contracts/interfaces/IEntryPoint.sol": {
      "content": "/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"./PackedUserOperation.sol\";\nimport \"./IStakeManager.sol\";\nimport \"./IAggregator.sol\";\nimport \"./INonceManager.sol\";\nimport \"./ISenderCreator.sol\";\n\ninterface IEntryPoint is IStakeManager, INonceManager {\n    /***\n     * An event emitted after each successful request.\n     * @param userOpHash    - Unique identifier for the request (hash its entire content, except signature).\n     * @param sender        - The account that generates this request.\n     * @param paymaster     - If non-null, the paymaster that pays for this request.\n     * @param nonce         - The nonce value from the request.\n     * @param success       - True if the sender transaction succeeded, false if reverted.\n     * @param actualGasCost - Actual amount paid (by account or paymaster) for this UserOperation.\n     * @param actualGasUsed - Total gas used by this UserOperation (including preVerification, creation,\n     *                        validation and execution).\n     */\n    event UserOperationEvent(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address indexed paymaster,\n        uint256 nonce,\n        bool success,\n        uint256 actualGasCost,\n        uint256 actualGasUsed\n    );\n\n    /**\n     * Account \"sender\" was deployed.\n     * @param userOpHash - The userOp that deployed this account. UserOperationEvent will follow.\n     * @param sender     - The account that is deployed\n     * @param factory    - The factory used to deploy this account (in the initCode)\n     * @param paymaster  - The paymaster used by this UserOp\n     */\n    event AccountDeployed(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address factory,\n        address paymaster\n    );\n\n    /**\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the reverted \"callData\" call.\n     */\n    event UserOperationRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * An event emitted if the UserOperation Paymaster's \"postOp\" call reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the reverted call to \"postOp\".\n     */\n    event PostOpRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * UserOp consumed more than prefund. The UserOperation is reverted, and no refund is made.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     */\n    event UserOperationPrefundTooLow(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce\n    );\n\n    /**\n     * An event emitted by handleOps() and handleAggregatedOps(), before starting the execution loop.\n     * Any event emitted before this event, is part of the validation.\n     */\n    event BeforeExecution();\n\n    /**\n     * Signature aggregator used by the following UserOperationEvents within this bundle.\n     * @param aggregator - The aggregator used for the following UserOperationEvents.\n     */\n    event SignatureAggregatorChanged(address indexed aggregator);\n\n    /**\n     * A custom revert error of handleOps andhandleAggregatedOps, to identify the offending op.\n     * Should be caught in off-chain handleOps/handleAggregatedOps simulation and not happen on-chain.\n     * Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\n     * NOTE: If simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. The string starts with a unique code \"AAmn\",\n     *                  where \"m\" is \"1\" for factory, \"2\" for account and \"3\" for paymaster issues,\n     *                  so a failure can be attributed to the correct entity.\n     */\n    error FailedOp(uint256 opIndex, string reason);\n\n    /**\n     * A custom revert error of handleOps and handleAggregatedOps, to report a revert by account or paymaster.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. see FailedOp(uint256,string), above\n     * @param inner   - data from inner cought revert reason\n     * @dev note that inner is truncated to 2048 bytes\n     */\n    error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner);\n\n    error PostOpReverted(bytes returnData);\n\n    /**\n     * Error case when a signature aggregator fails to verify the aggregated signature it had created.\n     * @param aggregator The aggregator that failed to verify the signature\n     */\n    error SignatureValidationFailed(address aggregator);\n\n    // Return value of getSenderAddress.\n    error SenderAddressResult(address sender);\n\n    // UserOps handled, per aggregator.\n    struct UserOpsPerAggregator {\n        PackedUserOperation[] userOps;\n        // Aggregator address\n        IAggregator aggregator;\n        // Aggregated signature\n        bytes signature;\n    }\n\n    /**\n     * Execute a batch of UserOperations.\n     * No signature aggregator is used.\n     * If any account requires an aggregator (that is, it returned an aggregator when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops         - The operations to execute.\n     * @param beneficiary - The address to receive the fees.\n     */\n    function handleOps(\n        PackedUserOperation[] calldata ops,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator - The operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts).\n     * @param beneficiary      - The address to receive the fees.\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Generate a request Id - unique identifier for this request.\n     * The request ID is a hash over the content of the userOp (except the signature), entrypoint address, chainId and (optionally) 7702 delegate address\n     * @param userOp - The user operation to generate the request ID for.\n     * @return hash the hash of this UserOperation\n     */\n    function getUserOpHash(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes32);\n\n    /**\n     * Gas and return values during simulation.\n     * @param preOpGas         - The gas used for validation (including preValidationGas)\n     * @param prefund          - The required prefund for this operation\n     * @param accountValidationData   - returned validationData from account.\n     * @param paymasterValidationData - return validationData from paymaster.\n     * @param paymasterContext - Returned by validatePaymasterUserOp (to be passed into postOp)\n     */\n    struct ReturnInfo {\n        uint256 preOpGas;\n        uint256 prefund;\n        uint256 accountValidationData;\n        uint256 paymasterValidationData;\n        bytes paymasterContext;\n    }\n\n    /**\n     * Get counterfactual sender address.\n     * Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * This method always revert, and returns the address in SenderAddressResult error.\n     * @notice this method cannot be used for EIP-7702 derived contracts.\n     *\n     * @param initCode - The constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes memory initCode) external;\n\n    error DelegateAndRevert(bool success, bytes ret);\n\n    /**\n     * Helper method for dry-run testing.\n     * @dev calling this method, the EntryPoint will make a delegatecall to the given data, and report (via revert) the result.\n     *  The method always revert, so is only useful off-chain for dry run calls, in cases where state-override to replace\n     *  actual EntryPoint code is less convenient.\n     * @param target a target contract to make a delegatecall from entrypoint\n     * @param data data to pass to target in a delegatecall\n     */\n    function delegateAndRevert(address target, bytes calldata data) external;\n\n    /**\n     * @notice Retrieves the immutable SenderCreator contract which is responsible for deployment of sender contracts.\n     */\n    function senderCreator() external view returns (ISenderCreator);\n}\n"
    },
    "@account-abstraction/contracts/interfaces/INonceManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ninterface INonceManager {\n\n    /**\n     * Return the next nonce for this sender.\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\n     * But UserOp with different keys can come with arbitrary order.\n     *\n     * @param sender the account address\n     * @param key the high 192 bit of the nonce\n     * @return nonce a full nonce to pass for next UserOp with this sender.\n     */\n    function getNonce(address sender, uint192 key)\n    external view returns (uint256 nonce);\n\n    /**\n     * Manually increment the nonce of the sender.\n     * This method is exposed just for completeness..\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\n     * as the EntryPoint will update the nonce regardless.\n     * Possible use-case is call it with various keys to \"initialize\" their nonces to one, so that future\n     * UserOperations will not pay extra for the first transaction with a given key.\n     *\n     * @param key - the \"nonce key\" to increment the \"nonce sequence\" for.\n     */\n    function incrementNonce(uint192 key) external;\n}\n"
    },
    "@account-abstraction/contracts/interfaces/ISenderCreator.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ninterface ISenderCreator {\n    /**\n     * @dev Creates a new sender contract.\n     * @return sender Address of the newly created sender contract.\n     */\n    function createSender(bytes calldata initCode) external returns (address sender);\n\n    /**\n     * Use initCallData to initialize an EIP-7702 account.\n     * The caller is the EntryPoint contract and it is already verified to be an EIP-7702 account.\n     * Note: Can be called multiple times as long as an appropriate initCode is supplied\n     *\n     * @param sender - the 'sender' EIP-7702 account to be initialized.\n     * @param initCallData - the call data to be passed to the sender account call.\n     */\n    function initEip7702Sender(address sender, bytes calldata initCallData) external;\n}\n"
    },
    "@account-abstraction/contracts/interfaces/IStakeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/**\n * Manage deposits and stakes.\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\n * Stake is value locked for at least \"unstakeDelay\" by the staked entity.\n */\ninterface IStakeManager {\n    event Deposited(address indexed account, uint256 totalDeposit);\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    // Emitted when stake or unstake delay are modified.\n    event StakeLocked(\n        address indexed account,\n        uint256 totalStaked,\n        uint256 unstakeDelaySec\n    );\n\n    // Emitted once a stake is scheduled for withdrawal.\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\n\n    event StakeWithdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /**\n     * @param deposit         - The entity's deposit.\n     * @param staked          - True if this entity is staked.\n     * @param stake           - Actual amount of ether staked for this entity.\n     * @param unstakeDelaySec - Minimum delay to withdraw the stake.\n     * @param withdrawTime    - First block timestamp where 'withdrawStake' will be callable, or zero if already locked.\n     * @dev Sizes were chosen so that deposit fits into one cell (used during handleOp)\n     *      and the rest fit into a 2nd cell (used during stake/unstake)\n     *      - 112 bit allows for 10^15 eth\n     *      - 48 bit for full timestamp\n     *      - 32 bit allows 150 years for unstake delay\n     */\n    struct DepositInfo {\n        uint256 deposit;\n        bool staked;\n        uint112 stake;\n        uint32 unstakeDelaySec;\n        uint48 withdrawTime;\n    }\n\n    // API struct used by getStakeInfo and simulateValidation.\n    struct StakeInfo {\n        uint256 stake;\n        uint256 unstakeDelaySec;\n    }\n\n    /**\n     * Get deposit info.\n     * @param account - The account to query.\n     * @return info   - Full deposit information of given account.\n     */\n    function getDepositInfo(\n        address account\n    ) external view returns (DepositInfo memory info);\n\n    /**\n     * Get account balance.\n     * @param account - The account to query.\n     * @return        - The deposit (for gas payment) of the account.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * Add to the deposit of the given account.\n     * @param account - The account to add to.\n     */\n    function depositTo(address account) external payable;\n\n    /**\n     * Add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param unstakeDelaySec - The new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 unstakeDelaySec) external payable;\n\n    /**\n     * Attempt to unlock the stake.\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external;\n\n    /**\n     * Withdraw from the (unlocked) stake.\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external;\n\n    /**\n     * Withdraw from the deposit.\n     * @param withdrawAddress - The address to send withdrawn value.\n     * @param withdrawAmount  - The amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external;\n}\n"
    },
    "@account-abstraction/contracts/interfaces/PackedUserOperation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"
    },
    "@safe-global/safe-contracts/contracts/handler/HandlerContext.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title Handler Context - Allows the fallback handler to extract addition context from the calldata\n * @dev The fallback manager appends the following context to the calldata:\n *      1. Fallback manager caller address (non-padded)\n * based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/f8cc8b844a9f92f63dc55aa581f7d643a1bc5ac1/contracts/metatx/ERC2771Context.sol\n * @author Richard Meissner - @rmeissner\n */\nabstract contract HandlerContext {\n    /**\n     * @notice Allows fetching the original caller address.\n     * @dev This is only reliable in combination with a FallbackManager that supports this (e.g. Safe contract >=1.3.0).\n     *      When using this functionality make sure that the linked _manager (aka msg.sender) supports this.\n     *      This function does not rely on a trusted forwarder. Use the returned value only to\n     *      check information against the calling manager.\n     * @return sender Original caller address.\n     */\n    function _msgSender() internal pure returns (address sender) {\n        // The assembly code is more direct than the Solidity version using `abi.decode`.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\n        }\n    }\n\n    /**\n     * @notice Returns the FallbackManager address\n     * @return Fallback manager address\n     */\n    function _manager() internal view returns (address) {\n        return msg.sender;\n    }\n}\n"
    },
    "src/interfaces/AbstractHarbourStore.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.29;\n\nabstract contract IHarbourStore {\n    /**\n     * @dev Internal function to store the transaction data and signature after validation.\n     *\n     * @param safeTxHash    EIP-712 digest of the transaction.\n     * @param signer        Signer address to be checked.\n     */\n    function _signerSignedTx(\n        bytes32 safeTxHash,\n        address signer\n    ) internal view virtual returns (bool signed);\n\n    /**\n     * @dev Internal function to store a signature after validation.\n     *\n     * @param signer        Address that signed the transaction.\n     * @param safeAddress   Target Safe Smart-Account.\n     * @param chainId       Chain id the transaction is meant for.\n     * @param nonce         Safe nonce.\n     * @param safeTxHash    EIP-712 digest of the transaction.\n     * @param r             First 32 bytes of the signature.\n     * @param vs            Compact representation of s and v from EIP-2098.\n     *\n     * @return listIndex    Index of the stored signature in the signer-specific list.\n     */\n    function _storeSignature(\n        address signer,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        bytes32 safeTxHash,\n        bytes32 r,\n        bytes32 vs\n    ) internal virtual returns (uint256 listIndex);\n\n    /**\n     * @dev Internal function to store the transaction data and signature after validation.\n     *\n     * @param safeTxHash     EIP-712 digest of the transaction.\n     * @param safeAddress    Target Safe Smart‑Account.\n     * @param chainId        Chain id the transaction is meant for.\n     * @param nonce          Safe nonce.\n     * @param to             Destination of the inner call/delegatecall.\n     * @param value          ETH value forwarded by the Safe.\n     * @param data           Calldata executed by the Safe.\n     * @param operation      0 = CALL, 1 = DELEGATECALL.\n     * @param safeTxGas      Gas forwarded to the inner call.\n     * @param baseGas        Fixed overhead reimbursed to the submitting signer.\n     * @param gasPrice       Gas price used for reimbursement.\n     * @param gasToken       ERC‑20 token address for refunds (`address(0)` = ETH).\n     * @param refundReceiver Address receiving the gas refund.\n     */\n    function _storeTransaction(\n        bytes32 safeTxHash,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver\n    ) internal virtual;\n}\n"
    },
    "src/interfaces/Constants.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.29;\n\n// ------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------\n\n// The hashes must be the same as the ones in the Safe contract:\n// https://github.com/safe-global/safe-smart-account/blob/b115c4c5fe23dca6aefeeccc73d312ddd23322c2/contracts/Safe.sol#L54-L63\n// These should cover Safe versions 1.3.0 and 1.4.1\n// keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\")\nbytes32 constant _DOMAIN_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n// keccak256(\"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\")\nbytes32 constant _SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n// The lower bound of the S value for a valid secp256k1 signature.\n// https://github.com/safe-global/safe-smart-account/blob/b115c4c5fe23dca6aefeeccc73d312ddd23322c2/contracts/Safe.sol#L100\nbytes32 constant SECP256K1_LOW_S_BOUND = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\n"
    },
    "src/interfaces/Errors.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.29;\n\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\n\n/// Thrown when a signature blob is not exactly 65 bytes.\nerror InvalidECDSASignatureLength();\n\n/// Thrown if `ecrecover` yields `address(0)`.\nerror InvalidSignature();\n\n/// Thrown if the S value of the signature is not from the lower half of the curve.\nerror InvalidSignatureSValue();\n\n/// Thrown when a value doesn't fit in a uint128.\nerror ValueDoesNotFitInUint128();\n\n/// @notice Thrown when attempting to store a signature for a transaction (safeTxHash)\n/// that the signer has already provided a signature for.\n/// @param signer Signer address.\n/// @param safeTxHash The EIP-712 hash of the Safe transaction.\nerror SignerAlreadySignedTransaction(address signer, bytes32 safeTxHash);\nerror InvalidTarget(bytes4 targetSelector);\nerror InvalidEntryPoint(address entryPoint);\nerror InvalidUserOpPaymasterAndData();\nerror UnexpectedSafeTxHash(bytes32 expectedSafeTxHash);\nerror UnexpectedSigner(address recoveredSigner);\nerror UnexpectedSignatureR(bytes32 extractedR);\nerror UnexpectedSignatureVS(bytes32 extractedVS);\nerror UnexpectedNonce(uint256 expectedNonce);\n"
    },
    "src/interfaces/Events.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.29;\n\n// ------------------------------------------------------------------\n// Events\n// ------------------------------------------------------------------\n\n/**\n * @notice Emitted whenever a new signature is stored (and possibly the parameters on first sight).\n *\n * @param signer     Address recovered from the provided signature.\n * @param safe       Safe Smart‑Account the transaction targets.\n * @param safeTxHash EIP‑712 hash identifying the SafeTx.\n * @param chainId    Intended execution chain.\n * @param nonce      Safe nonce.\n * @param listIndex  Position of the signature in the signer‑specific array.\n */\nevent SignatureStored(\n    address indexed signer,\n    address indexed safe,\n    bytes32 indexed safeTxHash,\n    uint256 chainId,\n    uint256 nonce,\n    uint256 listIndex\n);\n\n/**\n * @notice Emitted when a transaction is first stored.\n * @param safeTxHash EIP-712 hash identifying the SafeTx.\n * @param safe       Safe Smart-Account the transaction targets.\n * @param chainId    Intended execution chain.\n * @param nonce      Safe nonce.\n * @param to         Destination of the inner call/delegatecall.\n * @param value      ETH value forwarded by the Safe.\n * @param operation  0 = CALL, 1 = DELEGATECALL.\n * @param safeTxGas  Gas forwarded to the inner call.\n * @param baseGas    Fixed overhead reimbursed to the submitting signer.\n * @param gasPrice   Gas price used for reimbursement.\n * @param gasToken   ERC-20 token address for refunds.\n * @param refundReceiver Address receiving the gas refund.\n * @param data       Calldata executed by the Safe.\n */\nevent NewTransaction(\n    bytes32 indexed safeTxHash,\n    address indexed safe,\n    uint256 indexed chainId,\n    uint256 nonce,\n    address to,\n    uint256 value,\n    uint8 operation,\n    uint256 safeTxGas,\n    uint256 baseGas,\n    uint256 gasPrice,\n    address gasToken,\n    address refundReceiver,\n    bytes data\n);\n"
    },
    "src/interfaces/Types.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.29;\n\n// ------------------------------------------------------------------\n// Data structures\n// ------------------------------------------------------------------\n\n/**\n * @dev Storage optimised mirror of the SafeTx struct used by Safe contracts.\n *      Non-optimised version uses uint256 for:\n *      - value\n *      - safeTxGas\n *      - baseGas\n *      - gasPrice\n */\nstruct SafeTransaction {\n    // stored, operation and to will be packed into the same storage slot\n    bool stored;\n    uint8 operation;\n    address to;\n    uint128 value;\n    uint128 safeTxGas;\n    uint128 baseGas;\n    uint128 gasPrice;\n    address gasToken;\n    address refundReceiver;\n    bytes data;\n}\n\n/**\n * @dev Minimal, storage‑optimised representation of an ECDSA signature.\n */\nstruct SignatureDataWithTxHashIndex {\n    bytes32 r;\n    // vs is the compact representation of s and v coming from\n    // EIP-2098: https://eips.ethereum.org/EIPS/eip-2098\n    bytes32 vs;\n    bytes32 txHash; // EIP‑712 digest this signature belongs to\n}\n"
    },
    "src/libs/CoreLib.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.29;\n\nimport \"../interfaces/Constants.sol\";\nimport \"../interfaces/Types.sol\";\nimport \"../interfaces/Errors.sol\";\nimport \"../interfaces/Events.sol\";\n\nlibrary CoreLib {\n    // ------------------------------------------------------------------\n    // Internal functions\n    // ------------------------------------------------------------------\n\n    /**\n     * @notice Computes the unique EIP-712 digest for a SafeTx using the provided parameters and domain.\n     * @param safeAddress Address of the target Safe Smart Account.\n     * @param chainId Chain ID included in the domain separator.\n     * @param nonce Safe transaction nonce.\n     * @param to Target address the Safe will call.\n     * @param value ETH value to be sent with the call.\n     * @param data Call data executed by the Safe.\n     * @param operation Operation type: 0 = CALL, 1 = DELEGATECALL.\n     * @param safeTxGas Gas limit for the Safe's internal execution.\n     * @param baseGas Base gas overhead for reimbursement.\n     * @param gasPrice Gas price used for reimbursement calculation.\n     * @param gasToken Token address for refunds (0x0 for ETH).\n     * @param refundReceiver Address to receive gas refunds.\n     * @return safeTxHash Keccak256 digest of the EIP-712 encoded SafeTx.\n     */\n    function _computeSafeTxHash(\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver\n    ) internal pure returns (bytes32 safeTxHash) {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(_DOMAIN_TYPEHASH, chainId, safeAddress)\n        );\n        bytes32 structHash = keccak256(\n            abi.encode(\n                _SAFE_TX_TYPEHASH,\n                to,\n                value,\n                keccak256(data),\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                nonce\n            )\n        );\n        safeTxHash = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n    }\n\n    /**\n     * @notice Splits a 65-byte ECDSA signature into its components and recovers the signer address.\n     * @param digest The message or data hash to verify (EIP-712 digest or eth_sign prefixed).\n     * @param sig Concatenated 65-byte ECDSA signature (r || s || v).\n     * @return signer The address that produced the signature (EOA).\n     * @return r First 32 bytes of the ECDSA signature.\n     * @return vs Compact representation of s and v coming from EIP-2098.\n     * @dev Supports both EIP-712 and eth_sign flows by detecting v > 30 and applying the Ethereum Signed Message prefix.\n     */\n    function _recoverSigner(\n        bytes32 digest,\n        bytes calldata sig\n    ) internal pure returns (address signer, bytes32 r, bytes32 vs) {\n        uint8 v;\n        bytes32 s;\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            r := calldataload(sig.offset)\n            s := calldataload(add(sig.offset, 0x20))\n            v := byte(0, calldataload(add(sig.offset, 0x40)))\n        }\n        require(s <= SECP256K1_LOW_S_BOUND, InvalidSignatureSValue());\n\n        signer = ecrecover(digest, v, r, s);\n        require(signer != address(0), InvalidSignature());\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            // Equivalent to:\n            // vs = bytes32(uint256(v - 27)  << 255 | uint256(s));\n            // Which should avoid conversion between uint256 and bytes32\n            vs := or(shl(255, sub(v, 27)), s)\n        }\n    }\n\n    function _safeCastUint256ToUint128(\n        uint256 value\n    ) internal pure returns (uint128) {\n        require(value <= type(uint128).max, ValueDoesNotFitInUint128());\n        return uint128(value);\n    }\n}\n"
    },
    "src/mixins/ERC4337Mixin.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.29;\n\nimport {\n    HandlerContext\n} from \"@safe-global/safe-contracts/contracts/handler/HandlerContext.sol\";\nimport {IAccount} from \"@account-abstraction/contracts/interfaces/IAccount.sol\";\nimport {\n    IEntryPoint\n} from \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\nimport {\n    PackedUserOperation\n} from \"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\";\nimport {\n    _packValidationData\n} from \"@account-abstraction/contracts/core/Helpers.sol\";\nimport {\n    UserOperationLib\n} from \"@account-abstraction/contracts/core/UserOperationLib.sol\";\nimport \"../interfaces/Errors.sol\";\nimport \"../interfaces/AbstractHarbourStore.sol\";\nimport \"../libs/CoreLib.sol\";\n\nabstract contract ERC4337Mixin is IAccount, IHarbourStore {\n    // ------------------------------------------------------------------\n    // 4337 functions\n    // ------------------------------------------------------------------\n\n    /**\n     * @notice The address of the EntryPoint contract supported by this module.\n     */\n    address public immutable SUPPORTED_ENTRYPOINT;\n\n    constructor(address _entryPoint) {\n        SUPPORTED_ENTRYPOINT = _entryPoint;\n    }\n\n    /**\n     * Return the account nonce.\n     * This method returns the next sequential nonce.\n     * For a nonce of a specific key, use `entrypoint.getNonce(account, key)`\n     */\n    function getNonce(address signer) public view virtual returns (uint256) {\n        return\n            IEntryPoint(SUPPORTED_ENTRYPOINT).getNonce(\n                address(this),\n                uint192(uint160(signer))\n            );\n    }\n\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32,\n        uint256 missingAccountFunds\n    ) external override returns (uint256 validationData) {\n        // Assumption:\n        //   - UserOp signature is SafeTx signature\n        // Requirements:\n        //   - [x] Check entrypoint\n        //   - [x] No paymaster support\n        // Steps:\n        //   - [x] decode callData\n        //   - [x] recover signer from SafeTx signature\n        //   - [x] check that signer has not submitted signature\n        //   - [x] check that nonce key is signer address\n        //   - [x] pay missing funds\n        //   - [ ] usage checks -> set validation data\n\n        require(\n            msg.sender == SUPPORTED_ENTRYPOINT,\n            InvalidEntryPoint(msg.sender)\n        );\n        require(\n            userOp.paymasterAndData.length == 0,\n            InvalidUserOpPaymasterAndData()\n        );\n        require(userOp.signature.length == 65, InvalidECDSASignatureLength());\n\n        require(\n            bytes4(userOp.callData) == this.storeTransaction.selector,\n            InvalidTarget(bytes4(userOp.callData))\n        );\n        (\n            bytes32 safeTxHash,\n            address signer,\n            bytes32 r,\n            bytes32 vs\n        ) = _verifySafeTxHash(userOp.callData[4:]);\n\n        // --- DUPLICATE TRANSACTION SIGNATURE CHECK ---\n        // Revert if this signer has already submitted *any* signature for this *exact* safeTxHash\n        require(\n            !_signerSignedTx(safeTxHash, signer),\n            SignerAlreadySignedTransaction(signer, safeTxHash)\n        );\n\n        _verifySignature(safeTxHash, userOp.signature, signer, r, vs);\n\n        uint256 nonce = getNonce(signer);\n        require(userOp.nonce == nonce, UnexpectedNonce(nonce));\n\n        // We trust the entry point to set the correct prefund value, based on the operation params\n        // We need to perform this even if the signature is not valid, else the simulation function of the entry point will not work.\n        if (missingAccountFunds != 0) {\n            // We intentionally ignore errors in paying the missing account funds, as the entry point is responsible for\n            // verifying the prefund has been paid. This behaviour matches the reference base account implementation.\n            (bool success, ) = payable(msg.sender).call{\n                value: missingAccountFunds\n            }(\"\");\n            (success);\n        }\n\n        return _packValidationData(false, 0, 0);\n    }\n\n    function _verifySafeTxHash(\n        bytes calldata callData\n    ) private pure returns (bytes32, address, bytes32, bytes32) {\n        (\n            bytes32 safeTxHash,\n            address safeAddress,\n            uint256 chainId,\n            uint256 nonce,\n            address to,\n            uint256 value,\n            bytes memory data,\n            uint8 operation,\n            uint256 safeTxGas,\n            uint256 baseGas,\n            uint256 gasPrice,\n            address gasToken,\n            address refundReceiver,\n            address signer,\n            bytes32 r,\n            bytes32 vs\n        ) = abi.decode(\n                callData,\n                (\n                    bytes32,\n                    address,\n                    uint256,\n                    uint256,\n                    address,\n                    uint256,\n                    bytes,\n                    uint8,\n                    uint256,\n                    uint256,\n                    uint256,\n                    address,\n                    address,\n                    address,\n                    bytes32,\n                    bytes32\n                )\n            );\n        bytes32 computedSafeTxHash = CoreLib._computeSafeTxHash(\n            safeAddress,\n            chainId,\n            nonce,\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver\n        );\n\n        require(\n            computedSafeTxHash == safeTxHash,\n            UnexpectedSafeTxHash(computedSafeTxHash)\n        );\n        return (safeTxHash, signer, r, vs);\n    }\n\n    function _verifySignature(\n        bytes32 safeTxHash,\n        bytes calldata signature,\n        address signer,\n        bytes32 r,\n        bytes32 vs\n    ) private pure {\n        (\n            address recoveredSigner,\n            bytes32 extractedR,\n            bytes32 extractedVS\n        ) = CoreLib._recoverSigner(safeTxHash, signature);\n        require(signer == recoveredSigner, UnexpectedSigner(signer));\n        require(r == extractedR, UnexpectedSignatureR(r));\n        require(vs == extractedVS, UnexpectedSignatureVS(vs));\n    }\n\n    function storeTransaction(\n        bytes32 safeTxHash,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        address signer,\n        bytes32 r,\n        bytes32 vs\n    ) external returns (uint256 listIndex) {\n        require(\n            msg.sender == SUPPORTED_ENTRYPOINT,\n            InvalidEntryPoint(msg.sender)\n        );\n        _storeTransaction(\n            safeTxHash,\n            safeAddress,\n            chainId,\n            nonce,\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver\n        );\n        return\n            _storeSignature(\n                signer,\n                safeAddress,\n                chainId,\n                nonce,\n                safeTxHash,\n                r,\n                vs\n            );\n    }\n}\n"
    },
    "src/SafeInternationalHarbour.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.29;\n\nimport \"./interfaces/Constants.sol\";\nimport \"./interfaces/Errors.sol\";\nimport \"./interfaces/Types.sol\";\nimport \"./interfaces/Events.sol\";\nimport \"./libs/CoreLib.sol\";\nimport \"./mixins/ERC4337Mixin.sol\";\n\n/**\n * @title SafeInternationalHarbour\n * @notice Permissionless, append‑only registry that lets **any EOA signer** publish Safe\n *         transactions (\"SafeTx\") and their signatures. Clients without an off‑chain indexer can reconstruct the full multisig payload with only:\n *         1. the Safe address;\n *         2. the target `chainId`;\n *         3. the Safe `nonce`; and\n *         4. the current Safe owners set.\n *\n * Each unique `safeTxHash` (EIP‑712 digest of the SafeTx struct) is persisted **once** together with\n * its parameters. Signatures are appended under the composite key\n * `(signer, safe, chainId, nonce)`, enabling on‑chain, gas‑efficient look‑ups.\n *\n * ### ⚠️ Contract‑based signers unsupported\n * Only ECDSA signatures from externally‑owned accounts (EOAs) are supported. Contract wallets that\n * rely on ERC‑1271 or similar cannot be verified on‑chain in a chain‑agnostic way and are therefore\n * **not supported**.\n *\n * @dev The {SignatureStored} event is the only hook required by indexers; however, the contract is\n *      fully functional without any off‑chain infrastructure.\n */\ncontract SafeInternationalHarbour is ERC4337Mixin {\n    // ------------------------------------------------------------------\n    // Storage\n    // ------------------------------------------------------------------\n\n    /// Mapping `safeTxHash → SafeTransaction` parameters\n    mapping(bytes32 => SafeTransaction) private _txDetails;\n\n    /// Mapping `signer → safe → chainId → nonce → SignatureDataWithTxHashIndex[]`\n    /// Stores the list of signatures provided by a signer for a given Safe context.\n    /// Note: A single list entry here could contain signatures for *different* `safeTxHash` values\n    /// if those transactions share the same (safe, chainId, nonce). Use `_hasSignerSignedTx`\n    /// to ensure a signer only signs a specific `safeTxHash` once.\n    mapping(address signer => mapping(address safe => mapping(uint256 chainId => mapping(uint256 nonce => SignatureDataWithTxHashIndex[]))))\n        private _sigData;\n\n    /// @dev Tracks if a signer has already submitted *any* signature for a specific safeTxHash,\n    ///      preventing duplicate signatures for the *exact same* transaction digest.\n    ///      This complements `_sigData` by ensuring uniqueness per (safeTxHash, signer) pair.\n    /// Mapping `safeTxHash → signer → bool`\n    mapping(bytes32 safeTxHash => mapping(address signer => bool))\n        private _hasSignerSignedTx;\n\n    constructor(address _entryPoint) ERC4337Mixin(_entryPoint) {}\n\n    // ------------------------------------------------------------------\n    // External & public write functions\n    // ------------------------------------------------------------------\n\n    /**\n     * @notice Publish a Safe transaction and/or append a signature to it.\n     *\n     * @dev If `safeTxHash` has been seen before, its parameters are *not* validated nor overwritten –\n     *      the call simply appends the `(r,s)` pair for `signer`.\n     *\n     * @param safeAddress    Target Safe Smart‑Account.\n     * @param chainId        Chain id the transaction is meant for.\n     * @param nonce          Safe nonce.\n     * @param to             Destination of the inner call/delegatecall.\n     * @param value          ETH value forwarded by the Safe.\n     * @param data           Calldata executed by the Safe.\n     * @param operation      0 = CALL, 1 = DELEGATECALL.\n     * @param safeTxGas      Gas forwarded to the inner call.\n     * @param baseGas        Fixed overhead reimbursed to the submitting signer.\n     * @param gasPrice       Gas price used for reimbursement.\n     * @param gasToken       ERC‑20 token address for refunds (`address(0)` = ETH).\n     * @param refundReceiver Address receiving the gas refund.\n     * @param signature      **Single** 65‑byte ECDSA signature.\n     *\n     * @return listIndex     Index of the stored signature in the signer‑specific list.\n     *\n     * @custom:events Emits {SignatureStored}.\n     */\n    function enqueueTransaction(\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        bytes calldata signature\n    ) external returns (uint256 listIndex) {\n        require(signature.length == 65, InvalidECDSASignatureLength());\n\n        // ------------------------------------------------------------------\n        // Build the EIP‑712 digest that uniquely identifies the SafeTx\n        // ------------------------------------------------------------------\n        bytes32 safeTxHash = CoreLib._computeSafeTxHash(\n            safeAddress,\n            chainId,\n            nonce,\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver\n        );\n\n        (address signer, bytes32 r, bytes32 vs) = CoreLib._recoverSigner(\n            safeTxHash,\n            signature\n        );\n\n        _storeTransaction(\n            safeTxHash,\n            safeAddress,\n            chainId,\n            nonce,\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver\n        );\n\n        // --- DUPLICATE TRANSACTION SIGNATURE CHECK ---\n        // Revert if this signer has already submitted *any* signature for this *exact* safeTxHash\n        require(\n            !_signerSignedTx(safeTxHash, signer),\n            SignerAlreadySignedTransaction(signer, safeTxHash)\n        );\n        return\n            _storeSignature(\n                signer,\n                safeAddress,\n                chainId,\n                nonce,\n                safeTxHash,\n                r,\n                vs\n            );\n    }\n\n    // ------------------------------------------------------------------\n    // External & public read functions\n    // ------------------------------------------------------------------\n\n    /**\n     * @notice Retrieve the full parameter set of a Safe transaction.\n     *\n     * @param safeTxHash EIP‑712 digest of the transaction.\n     *\n     * @return txParams Struct with all SafeTx parameters (zero‑initialised if unknown).\n     */\n    function retrieveTransaction(\n        bytes32 safeTxHash\n    ) external view returns (SafeTransaction memory txParams) {\n        txParams = _txDetails[safeTxHash];\n    }\n\n    /**\n     * @notice Paginated getter for signature entries.\n     *\n     * @param signerAddress Address that created the signatures.\n     * @param safeAddress   Safe Smart‑Account.\n     * @param chainId       Target chain id.\n     * @param nonce         Safe nonce.\n     * @param start         Zero‑based start index of the slice.\n     * @param count         Maximum number of entries to return.\n     *\n     * @return page       Array slice `[start … start+count)` (may be shorter).\n     * @return totalCount Total number of signatures stored for the tuple.\n     */\n    function retrieveSignatures(\n        address signerAddress,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        uint256 start,\n        uint256 count\n    )\n        external\n        view\n        returns (SignatureDataWithTxHashIndex[] memory page, uint256 totalCount)\n    {\n        SignatureDataWithTxHashIndex[] storage all = _sigData[signerAddress][\n            safeAddress\n        ][chainId][nonce];\n        totalCount = all.length;\n        if (start >= totalCount)\n            return (new SignatureDataWithTxHashIndex[](0), totalCount);\n\n        uint256 end = start + count;\n        if (end > totalCount) end = totalCount;\n        uint256 len = end - start;\n\n        page = new SignatureDataWithTxHashIndex[](len);\n        for (uint256 i; i < len; ++i) {\n            page[i] = all[start + i];\n        }\n    }\n\n    /**\n     * @notice Convenience getter returning the **number** of signatures stored for the key tuple.\n     *\n     * @param signerAddress Signer address.\n     * @param safeAddress   Safe Smart‑Account.\n     * @param chainId       Target chain id.\n     * @param nonce         Safe nonce.\n     *\n     * @return count Length of the signature list.\n     */\n    function retrieveSignaturesCount(\n        address signerAddress,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce\n    ) external view returns (uint256 count) {\n        count = _sigData[signerAddress][safeAddress][chainId][nonce].length;\n    }\n\n    // ------------------------------------------------------------------\n    // Internal functions\n    // ------------------------------------------------------------------\n\n    /**\n     * @dev Internal function to store the transaction data and signature after validation.\n     *\n     * @param safeTxHash    EIP-712 digest of the transaction.\n     * @param signer        Signer address to be checked.\n     */\n    function _signerSignedTx(\n        bytes32 safeTxHash,\n        address signer\n    ) internal view override returns (bool signed) {\n        signed = _hasSignerSignedTx[safeTxHash][signer];\n    }\n\n    /**\n     * @dev Internal function to store the transaction data and signature after validation.\n     *\n     * @param safeTxHash     EIP-712 digest of the transaction.\n     * @param safeAddress    Target Safe Smart‑Account.\n     * @param chainId        Chain id the transaction is meant for.\n     * @param nonce          Safe nonce.\n     * @param to             Destination of the inner call/delegatecall.\n     * @param value          ETH value forwarded by the Safe.\n     * @param data           Calldata executed by the Safe.\n     * @param operation      0 = CALL, 1 = DELEGATECALL.\n     * @param safeTxGas      Gas forwarded to the inner call.\n     * @param baseGas        Fixed overhead reimbursed to the submitting signer.\n     * @param gasPrice       Gas price used for reimbursement.\n     * @param gasToken       ERC‑20 token address for refunds (`address(0)` = ETH).\n     * @param refundReceiver Address receiving the gas refund.\n     */\n    function _storeTransaction(\n        bytes32 safeTxHash,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver\n    ) internal override {\n        // Store parameters only once (idempotent write)\n        SafeTransaction storage slot = _txDetails[safeTxHash];\n        if (!slot.stored) {\n            // first encounter → persist full parameter set\n            slot.stored = true;\n            slot.to = to;\n            slot.operation = operation;\n\n            // Writing to storage is expensive, so we only write if the value is non-zero\n            if (value > 0) {\n                slot.value = CoreLib._safeCastUint256ToUint128(value);\n            }\n            if (safeTxGas > 0) {\n                slot.safeTxGas = CoreLib._safeCastUint256ToUint128(safeTxGas);\n            }\n            if (baseGas > 0) {\n                slot.baseGas = CoreLib._safeCastUint256ToUint128(baseGas);\n            }\n            if (gasPrice > 0) {\n                slot.gasPrice = CoreLib._safeCastUint256ToUint128(gasPrice);\n            }\n            if (gasToken != address(0)) {\n                slot.gasToken = gasToken;\n            }\n            if (refundReceiver != address(0)) {\n                slot.refundReceiver = refundReceiver;\n            }\n            if (data.length > 0) {\n                slot.data = data;\n            }\n\n            emit NewTransaction(\n                safeTxHash,\n                safeAddress,\n                chainId,\n                nonce,\n                to,\n                value,\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                data\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function to store a signature after validation.\n     *\n     * @param signer        Address that signed the transaction.\n     * @param safeAddress   Target Safe Smart-Account.\n     * @param chainId       Chain id the transaction is meant for.\n     * @param nonce         Safe nonce.\n     * @param safeTxHash    EIP-712 digest of the transaction.\n     * @param r             First 32 bytes of the signature.\n     * @param vs            Compact representation of s and v from EIP-2098.\n     *\n     * @return listIndex    Index of the stored signature in the signer-specific list.\n     */\n    function _storeSignature(\n        address signer,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        bytes32 safeTxHash,\n        bytes32 r,\n        bytes32 vs\n    ) internal override returns (uint256 listIndex) {\n        _hasSignerSignedTx[safeTxHash][signer] = true;\n\n        SignatureDataWithTxHashIndex[] storage list = _sigData[signer][\n            safeAddress\n        ][chainId][nonce];\n        listIndex = list.length;\n\n        list.push(\n            SignatureDataWithTxHashIndex({r: r, vs: vs, txHash: safeTxHash})\n        );\n\n        emit SignatureStored(\n            signer,\n            safeAddress,\n            safeTxHash,\n            chainId,\n            nonce,\n            listIndex\n        );\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "cancun",
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}