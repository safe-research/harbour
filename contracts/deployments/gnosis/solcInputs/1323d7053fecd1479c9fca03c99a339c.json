{
  "language": "Solidity",
  "sources": {
    "@account-abstraction/contracts/core/BasePaymaster.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/* solhint-disable reason-string */\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"../interfaces/IPaymaster.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"./UserOperationLib.sol\";\n/**\n * Helper class for creating a paymaster.\n * provides helper methods for staking.\n * Validates that the postOp is called only by the entryPoint.\n */\nabstract contract BasePaymaster is IPaymaster, Ownable2Step {\n    IEntryPoint public immutable entryPoint;\n\n    uint256 internal constant PAYMASTER_VALIDATION_GAS_OFFSET = UserOperationLib.PAYMASTER_VALIDATION_GAS_OFFSET;\n    uint256 internal constant PAYMASTER_POSTOP_GAS_OFFSET = UserOperationLib.PAYMASTER_POSTOP_GAS_OFFSET;\n    uint256 internal constant PAYMASTER_DATA_OFFSET = UserOperationLib.PAYMASTER_DATA_OFFSET;\n\n    constructor(IEntryPoint _entryPoint) Ownable(msg.sender) {\n        _validateEntryPointInterface(_entryPoint);\n        entryPoint = _entryPoint;\n    }\n\n    // Sanity check: make sure this EntryPoint was compiled against the same\n    // IEntryPoint of this paymaster\n    function _validateEntryPointInterface(IEntryPoint _entryPoint) internal virtual {\n        require(IERC165(address(_entryPoint)).supportsInterface(type(IEntryPoint).interfaceId), \"IEntryPoint interface mismatch\");\n    }\n\n    /// @inheritdoc IPaymaster\n    function validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) external override returns (bytes memory context, uint256 validationData) {\n        _requireFromEntryPoint();\n        return _validatePaymasterUserOp(userOp, userOpHash, maxCost);\n    }\n\n    /**\n     * Validate a user operation.\n     * @param userOp     - The user operation.\n     * @param userOpHash - The hash of the user operation.\n     * @param maxCost    - The maximum cost of the user operation.\n     */\n    function _validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) internal virtual returns (bytes memory context, uint256 validationData);\n\n    /// @inheritdoc IPaymaster\n    function postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    ) external override {\n        _requireFromEntryPoint();\n        _postOp(mode, context, actualGasCost, actualUserOpFeePerGas);\n    }\n\n    /**\n     * Post-operation handler.\n     * (verified to be called only through the entryPoint)\n     * @dev If subclass returns a non-empty context from validatePaymasterUserOp,\n     *      it must also implement this method.\n     * @param mode          - Enum with the following options:\n     *                        opSucceeded - User operation succeeded.\n     *                        opReverted  - User op reverted. The paymaster still has to pay for gas.\n     *                        postOpReverted - never passed in a call to postOp().\n     * @param context       - The context value returned by validatePaymasterUserOp\n     * @param actualGasCost - Actual cost of gas used so far (without this postOp call).\n     * @param actualUserOpFeePerGas - the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas\n     *                        and maxPriorityFee (and basefee)\n     *                        It is not the same as tx.gasprice, which is what the bundler pays.\n     */\n    function _postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    ) internal virtual {\n        (mode, context, actualGasCost, actualUserOpFeePerGas); // unused params\n        // subclass must override this method if validatePaymasterUserOp returns a context\n        revert(\"must override\");\n    }\n\n    /**\n     * Add a deposit for this paymaster, used for paying for transaction fees.\n     */\n    function deposit() public payable {\n        entryPoint.depositTo{value: msg.value}(address(this));\n    }\n\n    /**\n     * Withdraw value from the deposit.\n     * @param withdrawAddress - Target to send to.\n     * @param amount          - Amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 amount\n    ) public onlyOwner {\n        entryPoint.withdrawTo(withdrawAddress, amount);\n    }\n\n    /**\n     * Add stake for this paymaster.\n     * This method can also carry eth value to add to the current stake.\n     * @param unstakeDelaySec - The unstake delay for this paymaster. Can only be increased.\n     */\n    function addStake(uint32 unstakeDelaySec) external payable onlyOwner {\n        entryPoint.addStake{value: msg.value}(unstakeDelaySec);\n    }\n\n    /**\n     * Return current paymaster's deposit on the entryPoint.\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint.balanceOf(address(this));\n    }\n\n    /**\n     * Unlock the stake, in order to withdraw it.\n     * The paymaster can't serve requests once unlocked, until it calls addStake again\n     */\n    function unlockStake() external onlyOwner {\n        entryPoint.unlockStake();\n    }\n\n    /**\n     * Withdraw the entire paymaster's stake.\n     * stake must be unlocked first (and then wait for the unstakeDelay to be over)\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external onlyOwner {\n        entryPoint.withdrawStake(withdrawAddress);\n    }\n\n    /**\n     * Validate the call is made from a valid entrypoint\n     */\n    function _requireFromEntryPoint() internal virtual {\n        require(msg.sender == address(entryPoint), \"Sender not EntryPoint\");\n    }\n}\n"
    },
    "@account-abstraction/contracts/core/Helpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/* solhint-disable no-inline-assembly */\n\n\n /*\n  * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n  * must return this value in case of signature failure, instead of revert.\n  */\nuint256 constant SIG_VALIDATION_FAILED = 1;\n\n\n/*\n * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n * return this value on success.\n */\nuint256 constant SIG_VALIDATION_SUCCESS = 0;\n\n\n/**\n * Returned data from validateUserOp.\n * validateUserOp returns a uint256, which is created by `_packedValidationData` and\n * parsed by `_parseValidationData`.\n * @param aggregator  - address(0) - The account validated the signature by itself.\n *                      address(1) - The account failed to validate the signature.\n *                      otherwise - This is an address of a signature aggregator that must\n *                                  be used to validate the signature.\n * @param validAfter  - This UserOp is valid only after this timestamp.\n * @param validUntil - Last timestamp this operation is valid at, or 0 for \"indefinitely\".\n */\nstruct ValidationData {\n    address aggregator;\n    uint48 validAfter;\n    uint48 validUntil;\n}\n\n/**\n * Extract aggregator/sigFailed, validAfter, validUntil.\n * Also convert zero validUntil to type(uint48).max.\n * @param validationData - The packed validation data.\n * @return data - The unpacked in-memory validation data.\n */\nfunction _parseValidationData(\n    uint256 validationData\n) pure returns (ValidationData memory data) {\n    address aggregator = address(uint160(validationData));\n    uint48 validUntil = uint48(validationData >> 160);\n    if (validUntil == 0) {\n        validUntil = type(uint48).max;\n    }\n    uint48 validAfter = uint48(validationData >> (48 + 160));\n    return ValidationData(aggregator, validAfter, validUntil);\n}\n\n/**\n * Helper to pack the return value for validateUserOp.\n * @param data - The ValidationData to pack.\n * @return the packed validation data.\n */\nfunction _packValidationData(\n    ValidationData memory data\n) pure returns (uint256) {\n    return\n        uint160(data.aggregator) |\n        (uint256(data.validUntil) << 160) |\n        (uint256(data.validAfter) << (160 + 48));\n}\n\n/**\n * Helper to pack the return value for validateUserOp, when not using an aggregator.\n * @param sigFailed  - True for signature failure, false for success.\n * @param validUntil - Last timestamp this operation is valid at, or 0 for \"indefinitely\".\n * @param validAfter - First timestamp this UserOperation is valid.\n * @return the packed validation data.\n */\nfunction _packValidationData(\n    bool sigFailed,\n    uint48 validUntil,\n    uint48 validAfter\n) pure returns (uint256) {\n    return\n        (sigFailed ?  SIG_VALIDATION_FAILED : SIG_VALIDATION_SUCCESS) |\n        (uint256(validUntil) << 160) |\n        (uint256(validAfter) << (160 + 48));\n}\n\n/**\n * keccak function over calldata.\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\n *\n * @param data - the calldata bytes array to perform keccak on.\n * @return ret - the keccak hash of the 'data' array.\n */\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\n        assembly (\"memory-safe\") {\n            let mem := mload(0x40)\n            let len := data.length\n            calldatacopy(mem, data.offset, len)\n            ret := keccak256(mem, len)\n        }\n    }\n\n\n/**\n * The minimum of two numbers.\n * @param a - First number.\n * @param b - Second number.\n * @return - the minimum value.\n */\n    function min(uint256 a, uint256 b) pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n/**\n * standard solidity memory allocation finalization.\n * copied from solidity generated code\n * @param memPointer - The current memory pointer\n * @param allocationSize - Bytes allocated from memPointer.\n */\n    function finalizeAllocation(uint256 memPointer, uint256 allocationSize) pure {\n\n        assembly (\"memory-safe\"){\n            finalize_allocation(memPointer, allocationSize)\n\n            function finalize_allocation(memPtr, size) {\n                let newFreePtr := add(memPtr, round_up_to_mul_of_32(size))\n                mstore(64, newFreePtr)\n            }\n\n            function round_up_to_mul_of_32(value) -> result {\n                result := and(add(value, 31), not(31))\n            }\n        }\n    }\n"
    },
    "@account-abstraction/contracts/core/UserOperationLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/PackedUserOperation.sol\";\nimport {calldataKeccak, min} from \"./Helpers.sol\";\n\n/**\n * Utility functions helpful when working with UserOperation structs.\n */\nlibrary UserOperationLib {\n\n    uint256 public constant PAYMASTER_VALIDATION_GAS_OFFSET = 20;\n    uint256 public constant PAYMASTER_POSTOP_GAS_OFFSET = 36;\n    uint256 public constant PAYMASTER_DATA_OFFSET = 52;\n\n    /**\n     * Relayer/block builder might submit the TX with higher priorityFee,\n     * but the user should not pay above what he signed for.\n     * @param userOp - The user operation data.\n     */\n    function gasPrice(\n        PackedUserOperation calldata userOp\n    ) internal view returns (uint256) {\n        unchecked {\n            (uint256 maxPriorityFeePerGas, uint256 maxFeePerGas) = unpackUints(userOp.gasFees);\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n        }\n    }\n\n    bytes32 internal constant PACKED_USEROP_TYPEHASH =\n    keccak256(\n        \"PackedUserOperation(address sender,uint256 nonce,bytes initCode,bytes callData,bytes32 accountGasLimits,uint256 preVerificationGas,bytes32 gasFees,bytes paymasterAndData)\"\n    );\n\n    /**\n     * Pack the user operation data into bytes for hashing.\n     * @param userOp - The user operation data.\n     * @param overrideInitCodeHash - If set, encode this instead of the initCode field in the userOp.\n     */\n    function encode(\n        PackedUserOperation calldata userOp,\n        bytes32 overrideInitCodeHash\n    ) internal pure returns (bytes memory ret) {\n        address sender = userOp.sender;\n        uint256 nonce = userOp.nonce;\n        bytes32 hashInitCode = overrideInitCodeHash != 0 ? overrideInitCodeHash : calldataKeccak(userOp.initCode);\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\n        bytes32 accountGasLimits = userOp.accountGasLimits;\n        uint256 preVerificationGas = userOp.preVerificationGas;\n        bytes32 gasFees = userOp.gasFees;\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\n\n        return abi.encode(\n            UserOperationLib.PACKED_USEROP_TYPEHASH,\n            sender, nonce,\n            hashInitCode, hashCallData,\n            accountGasLimits, preVerificationGas, gasFees,\n            hashPaymasterAndData\n        );\n    }\n\n    function unpackUints(\n        bytes32 packed\n    ) internal pure returns (uint256 high128, uint256 low128) {\n        return (unpackHigh128(packed), unpackLow128(packed));\n    }\n\n    // Unpack just the high 128-bits from a packed value\n    function unpackHigh128(bytes32 packed) internal pure returns (uint256) {\n        return uint256(packed) >> 128;\n    }\n\n    // Unpack just the low 128-bits from a packed value\n    function unpackLow128(bytes32 packed) internal pure returns (uint256) {\n        return uint128(uint256(packed));\n    }\n\n    function unpackMaxPriorityFeePerGas(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackHigh128(userOp.gasFees);\n    }\n\n    function unpackMaxFeePerGas(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackLow128(userOp.gasFees);\n    }\n\n    function unpackVerificationGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackHigh128(userOp.accountGasLimits);\n    }\n\n    function unpackCallGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackLow128(userOp.accountGasLimits);\n    }\n\n    function unpackPaymasterVerificationGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET]));\n    }\n\n    function unpackPostOpGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]));\n    }\n\n    function unpackPaymasterStaticFields(\n        bytes calldata paymasterAndData\n    ) internal pure returns (address paymaster, uint256 validationGasLimit, uint256 postOpGasLimit) {\n        return (\n            address(bytes20(paymasterAndData[: PAYMASTER_VALIDATION_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]))\n        );\n    }\n\n    /**\n     * Hash the user operation data.\n     * @param userOp - The user operation data.\n     * @param overrideInitCodeHash - If set, the initCode hash will be replaced with this value just for UserOp hashing.\n     */\n    function hash(\n        PackedUserOperation calldata userOp,\n        bytes32 overrideInitCodeHash\n    ) internal pure returns (bytes32) {\n        return keccak256(encode(userOp, overrideInitCodeHash));\n    }\n}\n"
    },
    "@account-abstraction/contracts/interfaces/IAccount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./PackedUserOperation.sol\";\n\ninterface IAccount {\n    /**\n     * Validate user's signature and nonce\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n     * This allows making a \"simulation call\" without a valid signature\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\n     *\n     * @dev Must validate caller is the entryPoint.\n     *      Must validate the signature and nonce\n     * @param userOp              - The operation that is about to be executed.\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for signature.\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\n     *                              This is the minimum amount to transfer to the sender(entryPoint) to be\n     *                              able to make the call. The excess is left as a deposit in the entrypoint\n     *                              for future calls. Can be withdrawn anytime using \"entryPoint.withdrawTo()\".\n     *                              In case there is a paymaster in the request (or the current deposit is high\n     *                              enough), this value will be zero.\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData` and\n     *                              `_unpackValidationData` to encode and decode.\n     *                              <20-byte> aggregatorOrSigFail - 0 for valid signature, 1 to mark signature failure,\n     *                                 otherwise, an address of an \"aggregator\" contract.\n     *                              <6-byte> validUntil - Last timestamp this operation is valid at, or 0 for \"indefinitely\"\n     *                              <6-byte> validAfter - First timestamp this operation is valid\n     *                                                    If an account doesn't use time-range, it is enough to\n     *                                                    return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *                              Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external returns (uint256 validationData);\n}\n"
    },
    "@account-abstraction/contracts/interfaces/IAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * Aggregated Signatures validator.\n */\ninterface IAggregator {\n    /**\n     * Validate an aggregated signature.\n     * Reverts if the aggregated signature does not match the given list of operations.\n     * @param userOps   - An array of UserOperations to validate the signature for.\n     * @param signature - The aggregated signature.\n     */\n    function validateSignatures(\n        PackedUserOperation[] calldata userOps,\n        bytes calldata signature\n    ) external;\n\n    /**\n     * Validate the signature of a single userOp.\n     * This method should be called by bundler after EntryPointSimulation.simulateValidation() returns\n     * the aggregator this account uses.\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\n     * @param userOp        - The userOperation received from the user.\n     * @return sigForUserOp - The value to put into the signature field of the userOp when calling handleOps.\n     *                        (usually empty, unless account and aggregator support some kind of \"multisig\".\n     */\n    function validateUserOpSignature(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes memory sigForUserOp);\n\n    /**\n     * Aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code to perform this aggregation.\n     * @param userOps              - An array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature - The aggregated signature.\n     */\n    function aggregateSignatures(\n        PackedUserOperation[] calldata userOps\n    ) external view returns (bytes memory aggregatedSignature);\n}\n"
    },
    "@account-abstraction/contracts/interfaces/IEntryPoint.sol": {
      "content": "/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"./PackedUserOperation.sol\";\nimport \"./IStakeManager.sol\";\nimport \"./IAggregator.sol\";\nimport \"./INonceManager.sol\";\nimport \"./ISenderCreator.sol\";\n\ninterface IEntryPoint is IStakeManager, INonceManager {\n    /***\n     * An event emitted after each successful request.\n     * @param userOpHash    - Unique identifier for the request (hash its entire content, except signature).\n     * @param sender        - The account that generates this request.\n     * @param paymaster     - If non-null, the paymaster that pays for this request.\n     * @param nonce         - The nonce value from the request.\n     * @param success       - True if the sender transaction succeeded, false if reverted.\n     * @param actualGasCost - Actual amount paid (by account or paymaster) for this UserOperation.\n     * @param actualGasUsed - Total gas used by this UserOperation (including preVerification, creation,\n     *                        validation and execution).\n     */\n    event UserOperationEvent(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address indexed paymaster,\n        uint256 nonce,\n        bool success,\n        uint256 actualGasCost,\n        uint256 actualGasUsed\n    );\n\n    /**\n     * Account \"sender\" was deployed.\n     * @param userOpHash - The userOp that deployed this account. UserOperationEvent will follow.\n     * @param sender     - The account that is deployed\n     * @param factory    - The factory used to deploy this account (in the initCode)\n     * @param paymaster  - The paymaster used by this UserOp\n     */\n    event AccountDeployed(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address factory,\n        address paymaster\n    );\n\n    /**\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the reverted \"callData\" call.\n     */\n    event UserOperationRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * An event emitted if the UserOperation Paymaster's \"postOp\" call reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the reverted call to \"postOp\".\n     */\n    event PostOpRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * UserOp consumed more than prefund. The UserOperation is reverted, and no refund is made.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     */\n    event UserOperationPrefundTooLow(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce\n    );\n\n    /**\n     * An event emitted by handleOps() and handleAggregatedOps(), before starting the execution loop.\n     * Any event emitted before this event, is part of the validation.\n     */\n    event BeforeExecution();\n\n    /**\n     * Signature aggregator used by the following UserOperationEvents within this bundle.\n     * @param aggregator - The aggregator used for the following UserOperationEvents.\n     */\n    event SignatureAggregatorChanged(address indexed aggregator);\n\n    /**\n     * A custom revert error of handleOps andhandleAggregatedOps, to identify the offending op.\n     * Should be caught in off-chain handleOps/handleAggregatedOps simulation and not happen on-chain.\n     * Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\n     * NOTE: If simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. The string starts with a unique code \"AAmn\",\n     *                  where \"m\" is \"1\" for factory, \"2\" for account and \"3\" for paymaster issues,\n     *                  so a failure can be attributed to the correct entity.\n     */\n    error FailedOp(uint256 opIndex, string reason);\n\n    /**\n     * A custom revert error of handleOps and handleAggregatedOps, to report a revert by account or paymaster.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. see FailedOp(uint256,string), above\n     * @param inner   - data from inner cought revert reason\n     * @dev note that inner is truncated to 2048 bytes\n     */\n    error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner);\n\n    error PostOpReverted(bytes returnData);\n\n    /**\n     * Error case when a signature aggregator fails to verify the aggregated signature it had created.\n     * @param aggregator The aggregator that failed to verify the signature\n     */\n    error SignatureValidationFailed(address aggregator);\n\n    // Return value of getSenderAddress.\n    error SenderAddressResult(address sender);\n\n    // UserOps handled, per aggregator.\n    struct UserOpsPerAggregator {\n        PackedUserOperation[] userOps;\n        // Aggregator address\n        IAggregator aggregator;\n        // Aggregated signature\n        bytes signature;\n    }\n\n    /**\n     * Execute a batch of UserOperations.\n     * No signature aggregator is used.\n     * If any account requires an aggregator (that is, it returned an aggregator when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops         - The operations to execute.\n     * @param beneficiary - The address to receive the fees.\n     */\n    function handleOps(\n        PackedUserOperation[] calldata ops,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator - The operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts).\n     * @param beneficiary      - The address to receive the fees.\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Generate a request Id - unique identifier for this request.\n     * The request ID is a hash over the content of the userOp (except the signature), entrypoint address, chainId and (optionally) 7702 delegate address\n     * @param userOp - The user operation to generate the request ID for.\n     * @return hash the hash of this UserOperation\n     */\n    function getUserOpHash(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes32);\n\n    /**\n     * Gas and return values during simulation.\n     * @param preOpGas         - The gas used for validation (including preValidationGas)\n     * @param prefund          - The required prefund for this operation\n     * @param accountValidationData   - returned validationData from account.\n     * @param paymasterValidationData - return validationData from paymaster.\n     * @param paymasterContext - Returned by validatePaymasterUserOp (to be passed into postOp)\n     */\n    struct ReturnInfo {\n        uint256 preOpGas;\n        uint256 prefund;\n        uint256 accountValidationData;\n        uint256 paymasterValidationData;\n        bytes paymasterContext;\n    }\n\n    /**\n     * Get counterfactual sender address.\n     * Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * This method always revert, and returns the address in SenderAddressResult error.\n     * @notice this method cannot be used for EIP-7702 derived contracts.\n     *\n     * @param initCode - The constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes memory initCode) external;\n\n    error DelegateAndRevert(bool success, bytes ret);\n\n    /**\n     * Helper method for dry-run testing.\n     * @dev calling this method, the EntryPoint will make a delegatecall to the given data, and report (via revert) the result.\n     *  The method always revert, so is only useful off-chain for dry run calls, in cases where state-override to replace\n     *  actual EntryPoint code is less convenient.\n     * @param target a target contract to make a delegatecall from entrypoint\n     * @param data data to pass to target in a delegatecall\n     */\n    function delegateAndRevert(address target, bytes calldata data) external;\n\n    /**\n     * @notice Retrieves the immutable SenderCreator contract which is responsible for deployment of sender contracts.\n     */\n    function senderCreator() external view returns (ISenderCreator);\n}\n"
    },
    "@account-abstraction/contracts/interfaces/INonceManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ninterface INonceManager {\n\n    /**\n     * Return the next nonce for this sender.\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\n     * But UserOp with different keys can come with arbitrary order.\n     *\n     * @param sender the account address\n     * @param key the high 192 bit of the nonce\n     * @return nonce a full nonce to pass for next UserOp with this sender.\n     */\n    function getNonce(address sender, uint192 key)\n    external view returns (uint256 nonce);\n\n    /**\n     * Manually increment the nonce of the sender.\n     * This method is exposed just for completeness..\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\n     * as the EntryPoint will update the nonce regardless.\n     * Possible use-case is call it with various keys to \"initialize\" their nonces to one, so that future\n     * UserOperations will not pay extra for the first transaction with a given key.\n     *\n     * @param key - the \"nonce key\" to increment the \"nonce sequence\" for.\n     */\n    function incrementNonce(uint192 key) external;\n}\n"
    },
    "@account-abstraction/contracts/interfaces/IPaymaster.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * The interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\n * A paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\n */\ninterface IPaymaster {\n    enum PostOpMode {\n        // User op succeeded.\n        opSucceeded,\n        // User op reverted. Still has to pay for gas.\n        opReverted,\n        // Only used internally in the EntryPoint (cleanup after postOp reverts). Never calling paymaster with this value\n        postOpReverted\n    }\n\n    /**\n     * Payment validation: check if paymaster agrees to pay.\n     * Must verify sender is the entryPoint.\n     * Revert to reject this request.\n     * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted).\n     * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\n     * @param userOp          - The user operation.\n     * @param userOpHash      - Hash of the user's request data.\n     * @param maxCost         - The maximum cost of this transaction (based on maximum gas and gas price from userOp).\n     * @return context        - Value to send to a postOp. Zero length to signify postOp is not required.\n     * @return validationData - Signature and time-range of this operation, encoded the same as the return\n     *                          value of validateUserOperation.\n     *                          <20-byte> aggregatorOrSigFail - 0 for valid signature, 1 to mark signature failure,\n     *                                                    other values are invalid for paymaster.\n     *                          <6-byte> validUntil - Last timestamp this operation is valid at, or 0 for \"indefinitely\"\n     *                          <6-byte> validAfter - first timestamp this operation is valid\n     *                          Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) external returns (bytes memory context, uint256 validationData);\n\n    /**\n     * Post-operation handler.\n     * Must verify sender is the entryPoint.\n     * @param mode          - Enum with the following options:\n     *                        opSucceeded - User operation succeeded.\n     *                        opReverted  - User op reverted. The paymaster still has to pay for gas.\n     *                        postOpReverted - never passed in a call to postOp().\n     * @param context       - The context value returned by validatePaymasterUserOp\n     * @param actualGasCost - Actual cost of gas used so far (without this postOp call).\n     * @param actualUserOpFeePerGas - the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas\n     *                        and maxPriorityFee (and basefee)\n     *                        It is not the same as tx.gasprice, which is what the bundler pays.\n     */\n    function postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    ) external;\n}\n"
    },
    "@account-abstraction/contracts/interfaces/ISenderCreator.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ninterface ISenderCreator {\n    /**\n     * @dev Creates a new sender contract.\n     * @return sender Address of the newly created sender contract.\n     */\n    function createSender(bytes calldata initCode) external returns (address sender);\n\n    /**\n     * Use initCallData to initialize an EIP-7702 account.\n     * The caller is the EntryPoint contract and it is already verified to be an EIP-7702 account.\n     * Note: Can be called multiple times as long as an appropriate initCode is supplied\n     *\n     * @param sender - the 'sender' EIP-7702 account to be initialized.\n     * @param initCallData - the call data to be passed to the sender account call.\n     */\n    function initEip7702Sender(address sender, bytes calldata initCallData) external;\n}\n"
    },
    "@account-abstraction/contracts/interfaces/IStakeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/**\n * Manage deposits and stakes.\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\n * Stake is value locked for at least \"unstakeDelay\" by the staked entity.\n */\ninterface IStakeManager {\n    event Deposited(address indexed account, uint256 totalDeposit);\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    // Emitted when stake or unstake delay are modified.\n    event StakeLocked(\n        address indexed account,\n        uint256 totalStaked,\n        uint256 unstakeDelaySec\n    );\n\n    // Emitted once a stake is scheduled for withdrawal.\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\n\n    event StakeWithdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /**\n     * @param deposit         - The entity's deposit.\n     * @param staked          - True if this entity is staked.\n     * @param stake           - Actual amount of ether staked for this entity.\n     * @param unstakeDelaySec - Minimum delay to withdraw the stake.\n     * @param withdrawTime    - First block timestamp where 'withdrawStake' will be callable, or zero if already locked.\n     * @dev Sizes were chosen so that deposit fits into one cell (used during handleOp)\n     *      and the rest fit into a 2nd cell (used during stake/unstake)\n     *      - 112 bit allows for 10^15 eth\n     *      - 48 bit for full timestamp\n     *      - 32 bit allows 150 years for unstake delay\n     */\n    struct DepositInfo {\n        uint256 deposit;\n        bool staked;\n        uint112 stake;\n        uint32 unstakeDelaySec;\n        uint48 withdrawTime;\n    }\n\n    // API struct used by getStakeInfo and simulateValidation.\n    struct StakeInfo {\n        uint256 stake;\n        uint256 unstakeDelaySec;\n    }\n\n    /**\n     * Get deposit info.\n     * @param account - The account to query.\n     * @return info   - Full deposit information of given account.\n     */\n    function getDepositInfo(\n        address account\n    ) external view returns (DepositInfo memory info);\n\n    /**\n     * Get account balance.\n     * @param account - The account to query.\n     * @return        - The deposit (for gas payment) of the account.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * Add to the deposit of the given account.\n     * @param account - The account to add to.\n     */\n    function depositTo(address account) external payable;\n\n    /**\n     * Add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param unstakeDelaySec - The new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 unstakeDelaySec) external payable;\n\n    /**\n     * Attempt to unlock the stake.\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external;\n\n    /**\n     * Withdraw from the (unlocked) stake.\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external;\n\n    /**\n     * Withdraw from the deposit.\n     * @param withdrawAddress - The address to send withdrawn value.\n     * @param withdrawAmount  - The amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external;\n}\n"
    },
    "@account-abstraction/contracts/interfaces/PackedUserOperation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     *\n     * Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/interfaces/Conditions.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\nimport {\n    PackedUserOperation\n} from \"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\";\n\ninterface ISlashingCondition {\n    function shouldBeSlashed(\n        address validator,\n        PackedUserOperation calldata userOp\n    ) external returns (bool);\n}\n"
    },
    "src/interfaces/Constants.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\n// ------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------\n\n// The hashes must be the same as the ones in the Safe contract:\n// https://github.com/safe-global/safe-smart-account/blob/b115c4c5fe23dca6aefeeccc73d312ddd23322c2/contracts/Safe.sol#L54-L63\n// These should cover Safe versions 1.3.0 and 1.4.1\n// keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\")\nbytes32 constant SAFE_DOMAIN_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n// keccak256(\"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\")\nbytes32 constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n// keccak256(\"EIP712Domain(address verifyingContract,bytes32 salt)\")\nbytes32 constant HARBOUR_DOMAIN_TYPEHASH = 0x6268546d6d3d3a16ed8cfd22f4fe09a1d17f9af43838183ba533d41e284cf326;\n\n// keccak256(\"EncryptionKey(bytes32 context,bytes32 publicKey)\")\nbytes32 constant ENCRYPTION_KEY_TYPEHASH = 0xc61c2d0b1f1942c20e1ecd68ca0337b62afaa25024fc73f2aad19b5696efb313;\n\n// The lower bound of the S value for a valid secp256k1 signature.\n// https://github.com/safe-global/safe-smart-account/blob/b115c4c5fe23dca6aefeeccc73d312ddd23322c2/contracts/Safe.sol#L100\nbytes32 constant SECP256K1_LOW_S_BOUND = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\n"
    },
    "src/interfaces/ERC165.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "src/interfaces/ERC4337.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\nimport {\n    IEntryPoint\n} from \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\n\nabstract contract IERC4337InfoProvider {\n    function getSupportedEntrypoint() public view virtual returns (IEntryPoint);\n}\n"
    },
    "src/interfaces/Errors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\n\n/**\n * @notice Thrown when a signature blob is not exactly 65 bytes.\n */\nerror InvalidECDSASignatureLength();\n\n/**\n * @notice Thrown if `ecrecover` yields `address(0)`.\n */\nerror InvalidSignature();\n\n/**\n * @notice Thrown if the S value of the signature is not from the lower half of the curve.\n */\nerror InvalidSignatureSValue();\n\n/**\n * @notice Thrown when a value doesn't fit in a uint128.\n */\nerror ValueDoesNotFitInUint128();\n\n/**\n * @notice Thrown when attempting to store a signature for a transaction (safeTxHash)\n * that the signer has already provided a signature for.\n * @param signer Signer address.\n * @param safeTxHash The EIP-712 hash of the Safe transaction.\n */\nerror SignerAlreadySignedTransaction(address signer, bytes32 safeTxHash);\nerror InvalidTarget(bytes4 targetSelector);\nerror InvalidEntryPoint(address entryPoint);\nerror InvalidUserOpPaymaster();\nerror InvalidValidatorData();\nerror UnexpectedUserSignature();\nerror UnexpectedSafeTxHash(bytes32 expectedSafeTxHash);\nerror UnexpectedSigner(address recoveredSigner);\nerror UnexpectedSignatureR(bytes32 extractedR);\nerror UnexpectedSignatureVS(bytes32 extractedVS);\nerror UnexpectedNonce(address expectedKey);\n\n/**\n * @notice Thrown when attempting to enqueue nothing. That is, when calling `enqueueTransaction` on\n *         the {SafeSecretHarbour} with empty `signature` and `encryptionBlob`.\n */\nerror NothingToEnqueue();\n\n// ------------------------------------------------------------------\n// Quota Errors\n// ------------------------------------------------------------------\n\nerror WithdrawalAlreadyPerformed(bytes32 withdrawalHash);\nerror InsufficientTokensForWithdrawal();\nerror TokensInUse();\nerror QuotaOverflow(uint256 maxSignerQuota);\n\n// ------------------------------------------------------------------\n// Slashing Errors\n// ------------------------------------------------------------------\n\nerror ConditionAlreadyEnabled();\nerror ConditionAlreadyDisabled();\nerror ConditionNotEnabled();\nerror ConditionWasNotActive();\nerror ConditionNotOffended();\nerror UserOpAlreadySlashed();\nerror NothingToSlash();\nerror InvalidBeneficiary();\n"
    },
    "src/interfaces/Events.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\n// ------------------------------------------------------------------\n// Events\n// ------------------------------------------------------------------\n\n/**\n * @notice Emitted whenever a new signature is stored (and possibly the parameters on first sight).\n *\n * @param signer     Address recovered from the provided signature.\n * @param safe       Safe Smart-Account the transaction targets.\n * @param safeTxHash EIP-712 hash identifying the SafeTx.\n * @param chainId    Intended execution chain.\n * @param nonce      Safe nonce.\n * @param listIndex  Position of the signature in the signer-specific array.\n */\nevent SignatureStored(\n    address indexed signer,\n    address indexed safe,\n    bytes32 indexed safeTxHash,\n    uint256 chainId,\n    uint256 nonce,\n    uint256 listIndex\n);\n\n/**\n * @notice Emitted when a transaction is first stored.\n * @param safeTxHash EIP-712 hash identifying the SafeTx.\n * @param safe       Safe Smart-Account the transaction targets.\n * @param chainId    Intended execution chain.\n * @param nonce      Safe nonce.\n * @param to         Destination of the inner call/delegatecall.\n * @param value      ETH value forwarded by the Safe.\n * @param operation  0 = CALL, 1 = DELEGATECALL.\n * @param safeTxGas  Gas forwarded to the inner call.\n * @param baseGas    Fixed overhead reimbursed to the submitting signer.\n * @param gasPrice   Gas price used for reimbursement.\n * @param gasToken   ERC-20 token address for refunds.\n * @param refundReceiver Address receiving the gas refund.\n * @param data       Calldata executed by the Safe.\n */\nevent NewTransaction(\n    bytes32 indexed safeTxHash,\n    address indexed safe,\n    uint256 indexed chainId,\n    uint256 nonce,\n    address to,\n    uint256 value,\n    uint8 operation,\n    uint256 safeTxGas,\n    uint256 baseGas,\n    uint256 gasPrice,\n    address gasToken,\n    address refundReceiver,\n    bytes data\n);\n\n/**\n * @notice Emitted whenever an encryption key is registered for a signer.\n *\n * @param signer    The signer for which the key was registered.\n * @param context   A 32-byte contract associated with the encryption key.\n * @param publicKey A 32-byte encryption public key.\n */\nevent EncryptionKeyRegistered(\n    address indexed signer,\n    bytes32 context,\n    bytes32 publicKey\n);\n\n/**\n * @notice Emitted whenever a signed encrypted Safe transaction is registered.\n *\n * @param uid            A unique registration identifier that can be used for event filtering.\n * @param safeTxHash     EIP-712 hash identifying the Safe transaction.\n * @param encryptionBlob A blob containing encrypted transaction data. This can either be the\n *                       encrypted transaction itself, or additional encrypted keys to new signer\n *                       public keys. The exact format is not enforced and application dependent.\n *                       The reference implementation uses JWE to encrypt the RLP-encoded Safe\n *                       transaction with A256-GCM encryption, and ECDH-ES+A256KW for wrapping the\n *                       encryption keys for recipients' X25519 public keys.\n */\nevent SafeTransactionRegistered(\n    bytes32 indexed uid,\n    bytes32 indexed safeTxHash,\n    bytes encryptionBlob\n);\n\n/**\n * @notice Emitted when a Safe transaction is signed.\n *\n * @param signer     The signer address.\n * @param safeTxHash The Safe transaction hash that was signed.\n * @param signature  The Safe transaction signature.\n */\nevent SafeTransactionSigned(\n    address indexed signer,\n    bytes32 indexed safeTxHash,\n    bytes signature\n);\n"
    },
    "src/interfaces/Harbour.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\nimport {EncryptionKey, SafeTransactionRegistrationHandle} from \"./Types.sol\";\n\n/// @title Safe Secret Harbour Interface\ninterface ISafeSecretHarbour {\n    function registerEncryptionKey(bytes32 context, bytes32 publicKey) external;\n\n    function registerEncryptionKeyFor(\n        address signer,\n        bytes32 context,\n        bytes32 publicKey,\n        bytes calldata signature\n    ) external;\n\n    function enqueueTransaction(\n        uint256 chainId,\n        address safe,\n        uint256 nonce,\n        bytes32 safeTxStructHash,\n        bytes calldata signature,\n        bytes calldata encryptionBlob\n    ) external returns (bytes32 uid);\n\n    function retrieveEncryptionPublicKeys(\n        address[] calldata signers\n    ) external view returns (bytes32[] memory publicKeys);\n\n    function retrieveEncryptionKey(\n        address signers\n    ) external view returns (EncryptionKey memory encryptionKey);\n\n    function retrieveRegistrations(\n        uint256 chainId,\n        address safe,\n        uint256 nonce,\n        address notary,\n        uint256 start,\n        uint256 count\n    )\n        external\n        view\n        returns (\n            SafeTransactionRegistrationHandle[] memory page,\n            uint256 totalCount\n        );\n\n    function retrieveSignatures(\n        address[] calldata signers,\n        bytes32 safeTxHash\n    ) external view returns (uint256[] memory blockNumbers);\n}\n"
    },
    "src/interfaces/HarbourStore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\nabstract contract IHarbourStore {\n    /**\n     * @dev Internal function to check if a signature is stored\n     *\n     * @param signatureHash    Hash of the signature\n     */\n    function _signatureStored(\n        bytes32 signatureHash\n    ) internal view virtual returns (bool stored);\n\n    /**\n     * @dev Internal function to store a signature after validation.\n     *\n     * @param signer        Address that signed the transaction.\n     * @param safeAddress   Target Safe Smart-Account.\n     * @param chainId       Chain id the transaction is meant for.\n     * @param nonce         Safe nonce.\n     * @param safeTxHash    EIP-712 digest of the transaction.\n     * @param r             First 32 bytes of the signature.\n     * @param vs            Compact representation of s and v from EIP-2098.\n     *\n     * @return listIndex    Index of the stored signature in the signer-specific list.\n     */\n    function _storeSignature(\n        address signer,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        bytes32 safeTxHash,\n        bytes32 r,\n        bytes32 vs\n    ) internal virtual returns (uint256 listIndex);\n\n    /**\n     * @dev Internal function to store the transaction data and signature after validation.\n     *\n     * @param safeTxHash     EIP-712 digest of the transaction.\n     * @param safeAddress    Target Safe Smart-Account.\n     * @param chainId        Chain id the transaction is meant for.\n     * @param nonce          Safe nonce.\n     * @param to             Destination of the inner call/delegatecall.\n     * @param value          ETH value forwarded by the Safe.\n     * @param data           Calldata executed by the Safe.\n     * @param operation      0 = CALL, 1 = DELEGATECALL.\n     * @param safeTxGas      Gas forwarded to the inner call.\n     * @param baseGas        Fixed overhead reimbursed to the submitting signer.\n     * @param gasPrice       Gas price used for reimbursement.\n     * @param gasToken       ERC-20 token address for refunds (`address(0)` = ETH).\n     * @param refundReceiver Address receiving the gas refund.\n     */\n    function _storeTransaction(\n        bytes32 safeTxHash,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver\n    ) internal virtual;\n}\n"
    },
    "src/interfaces/QuotaManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\nabstract contract IQuotaManager {\n    function _checkAndUpdateQuota(\n        address signer,\n        uint256 requiredQuota\n    ) internal virtual returns (bool);\n\n    function _withdrawSignerTokens(\n        address signer,\n        address beneficiary,\n        uint96 amount,\n        bool ignoreReset\n    ) internal virtual;\n\n    function _transferFeeToken(\n        address beneficiary,\n        uint96 amount\n    ) internal virtual;\n}\n"
    },
    "src/interfaces/Types.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\n// ------------------------------------------------------------------\n// Data structures\n// ------------------------------------------------------------------\n\n/**\n * @dev Storage optimised mirror of the SafeTx struct used by Safe contracts.\n *      Non-optimised version uses uint256 for:\n *      - value\n *      - safeTxGas\n *      - baseGas\n *      - gasPrice\n */\nstruct SafeTransaction {\n    // stored, operation and to will be packed into the same storage slot\n    bool stored;\n    uint8 operation;\n    address to;\n    uint128 value;\n    uint128 safeTxGas;\n    uint128 baseGas;\n    uint128 gasPrice;\n    address gasToken;\n    address refundReceiver;\n    bytes data;\n}\n\n/**\n * @dev Minimal, storage-optimised representation of an ECDSA signature.\n */\nstruct SignatureDataWithTxHashIndex {\n    bytes32 r;\n    // vs is the compact representation of s and v coming from\n    // EIP-2098: https://eips.ethereum.org/EIPS/eip-2098\n    bytes32 vs;\n    bytes32 txHash; // EIP-712 digest this signature belongs to\n}\n\n/**\n * @dev A public encryption key.\n *\n * @custom:field context   An application-defined context. This can be used as a salt in\n *                         deterministic encryption key derivation schemes (for example, it can be\n *                         the `nonce` and `issuedAt` values for a Sign-in with Ethereum signature\n *                         to be used as entropy for deriving an X25519 encryption key pair).\n * @custom:field publicKey The public encryption key. Note that this contract does not enforce any\n *                         specific key format, the only restriction is that the key must fit in 32\n *                         bytes. The reference client implementation uses Curve25519 public keys.\n */\nstruct EncryptionKey {\n    bytes32 context;\n    bytes32 publicKey;\n}\n\n/**\n * @dev An encrypted Safe transaction registration handle.\n */\nstruct SafeTransactionRegistrationHandle {\n    uint256 blockNumber;\n    bytes32 uid;\n}\n"
    },
    "src/libs/BlockNumbers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\n/**\n * @title Block Numbers\n * @notice A storage efficient list of block numbers.\n * @dev The storage layout is similar to that of an `uint64[]` dynamic array, with the exception\n *      that the first 3 elements are stored in the same slot as the array length. This is a nice\n *      optimization which makes short lists be stored in a single slot. Note that this implicitely\n *      limits blocks to the range `[0, type(uint64).max)` and length to `type(uint64).max`.\n *\n *      The layout in storage for the block numbers, given a `BlockNumbers.T` at storage slot `s`:\n *\n *                   b |  2       1       1\n *                   i |  5       9       2       6\n *                   t |  6       6       8       4       0\n *               slot\\ |\n *      ---------------+-----------------------------------\n *                     |\n *                     |  +-------+-------+-------+-------+\n *                   s |  |  [2]  |  [1]  |  [0]  |  len  |\n *                     |  +-------+-------+-------+-------+\n *                     |\n *                     |  +-------+-------+-------+-------+\n *        keccak256(s) |  |  [6]  |  [5]  |  [4]  |  [3]  |\n *                     |  +-------+-------+-------+-------+\n *      keccak256(s)+1 |  |  [10] |  [9]  |  [8]  |  [7]  |\n *                     |  +-------+-------+-------+-------+\n *      keccak256(s)+2 |  |  [14] |  [12] |  [12] |  [11] |\n *                     |  +-------+-------+-------+-------+\n *                 ... |\n */\nlibrary BlockNumbers {\n    /**\n     * @notice A block number list storage type.\n     * @dev This type is **only** intended for use as a storage variable.\n     */\n    struct T {\n        uint256 prefix;\n    }\n\n    /**\n     * @notice A block number iterator over a storage block number list.\n     * @dev The fields in this type are for internal use only! This library provides functions for\n     *      reading and advancing the iterator.\n     */\n    struct Iterator {\n        // The current storage slot that was read from. Once all of the (4) block numbers from the\n        // current slot are read, this value used for computing the next storage slot to read from.\n        uint256 slot;\n        // The data that was read from the current storage slot. This contains 4 block numbers at\n        // first but shifts out one block number every time the iterator moves forward. This is\n        // kept in the iterator state to prevent `sload`-ing from `slot` multiple times.\n        uint256 data;\n        // The remaining count in the iterator. This is initialized to the length of the block list\n        // and reduced by one every time the iterator moves forward (or truncated with `take`).\n        uint256 cnt;\n        // The remaining blocks in the current `slot` and `data`. This is used to determine when\n        // the next `slot` should be computed and `sload`-ed from.\n        uint256 rem;\n        // A flag that indicates that this is the \"first\" slot we are reading from. Solidity stores\n        // the length of the array in the prefix slot, and the items in `keccak256(slot)`. In our\n        // optimized list, the prefix slot stores `[2] || [1] || [0] || length`, and we need this\n        // flag to know to whether the next slot is `keccak(slot)` or `slot + 1`.\n        bool first;\n    }\n\n    /**\n     * @notice Appends a new block number to the list.\n     * @return index The index at which the new item was added.\n     */\n    function append(\n        T storage self,\n        uint256 blockNumber\n    ) internal returns (uint256 index) {\n        unchecked {\n            uint256 prefix = self.prefix;\n            index = prefix & type(uint64).max;\n\n            // Overflow check to see if either `index + 1` or block number overflows a `uint64`,\n            // and panic if it does. We use a bit-wise or to compress both checks into a single\n            // comparison.\n            if ((index + 1) | blockNumber > type(uint64).max) {\n                _panicOverflow();\n            }\n\n            if (index < 3) {\n                // The block number is stored in the prefix slot. Compute the shift so that the\n                // block ends up in the right bits of the 32-byte word:\n                //\n                // b  2       1       1\n                // i  5       9       2       6\n                // t  6       6       8       4       0\n                //    +-------+-------+-------+-------+\n                //    |  [2]  |  [1]  |  [0]  |  len  |\n                //    +-------+-------+-------+-------+\n\n                uint256 shift = (index + 1) << 6; // (index + 1) * 64\n                self.prefix = (prefix + 1) | (blockNumber << shift); // len++; [index] = blockNumber\n            } else {\n                // The block number is stored in one of the value slots. We need to compute both the\n                // value slot where the item is, accounting for the fact that only 3 items fit in\n                // the prefix slot, and 4 items fit in each value slot thereafter:\n                //\n                // b  2       1       1\n                // i  5       9       2       6\n                // t  6       6       8       4       0\n                //    +-------+-------+-------+-------+\n                //    | [i+3] | [i+2] | [i+1] |  [i]  |\n                //    +-------+-------+-------+-------+\n\n                uint256 j = index - 3; // discount the first 3 items from the prefix slot.\n                uint256 offset = j >> 2; // (j / 4): is the value slot offset\n                uint256 shift = (j & 3) << 6; // (j % 4) * 64\n\n                // sstore[keccak256(self.slot) + offset] |= blockNumber << shift\n                // solhint-disable-next-line no-inline-assembly\n                assembly (\"memory-safe\") {\n                    mstore(0, self.slot)\n                    let slot := add(keccak256(0, 32), offset)\n                    sstore(slot, or(sload(slot), shl(shift, blockNumber)))\n                }\n                self.prefix = prefix + 1; // len++\n            }\n        }\n    }\n\n    /**\n     * @notice Get the length of the block numbers list.\n     */\n    function len(T storage self) internal view returns (uint256 length) {\n        return self.prefix & type(uint64).max;\n    }\n\n    /**\n     * @notice Create an iterator over the block numbers.\n     * @dev The iterator is implemented to minimize storage reads.\n     */\n    function iter(T storage self) internal view returns (Iterator memory it) {\n        // it.slot = self.slot\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            mstore(it, self.slot)\n        }\n        unchecked {\n            it.data = self.prefix;\n            // TODO(nlordell): If we _really_ want to optimize, we can pack `cnt`, `rem` and\n            // `first` into a single slot, but that isn't necessary for now.\n            it.cnt = it.data & type(uint64).max;\n            it.rem = 3;\n            it.first = true;\n        }\n    }\n\n    /**\n     * @notice Returns the count of remaining items in the iterator.\n     */\n    function count(\n        Iterator memory self\n    ) internal pure returns (uint256 length) {\n        return self.cnt;\n    }\n\n    /**\n     * @notice Moves the iterator to the next block number.\n     */\n    function next(Iterator memory self) internal view returns (bool remaining) {\n        remaining = self.cnt != 0;\n        // We implement `next` by skipping one value. This removes a lot of duplicate code. Note\n        // that, generally, callers are MUST NOT expect `value` to be valid after `skip`-ing, and\n        // the fact we use `skip` in `next` is an implementation detail.\n        skip(self, 1);\n    }\n\n    /**\n     * @notice Skips items in the iterator.\n     * @dev `next` MUST be called after `skip`-ing.\n     */\n    function skip(Iterator memory self, uint256 n) internal view {\n        // If we skip past the end of the iterator, then the iterator is done and there is nothing\n        // else to do! The next call to `next` will return `false` meaning that there are no more\n        // values.\n        if (self.cnt < n) {\n            self.cnt = 0;\n            return;\n        }\n\n        unchecked {\n            self.cnt -= n;\n            if (self.rem >= n) {\n                // We skipped some amount that is smaller than the number of items remaining in the\n                // last `sload`-ed `data`. We just need to shift out the values that were skipped\n                // and adjust the `rem`-aining item amount accordingly.\n\n                self.data = self.data >> (n << 6); // data >> (n * 64)\n                self.rem -= n;\n            } else {\n                // HERE BE DRAGONS. We skipped some amount of items that requires us to `sload` some\n                // new `data` from a different `slot`. We also need to update `rem` and `data`, as\n                // we may have skipped somewhere in the middle of a value slot.\n\n                // Figure out how many additional items we need to skip past the last item remaining\n                // in the `data` from the last `sload`-ed slot. It makes computations below simpler.\n                n -= self.rem;\n\n                // We know that we moved **at least** 1 slot forward, but we need to figure out\n                // exactly how many additional slots forward we went (for example, if we `skip(100)`\n                // we have to read way past the next `slot`). Since _only_ the prefix (fist) slot\n                // fits 3 items and we are here if we moved past it, we can compute the additional\n                // slots to skip assuming exactly 4 items per slot.\n                uint256 slots = n >> 2; // slots = n / 4\n                if (self.first) {\n                    // self.slot = keccak256(abi.encode(self.slot)) + slots;\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly (\"memory-safe\") {\n                        mstore(self, add(keccak256(self, 32), slots))\n                    }\n                    self.first = false;\n                } else {\n                    self.slot += 1 + slots;\n                }\n\n                // Now we need to compute where we landed in the of the `slot`, and adjust both\n                // `rem` and `data` accordingly (to handle the case where we skip somewhere in\n                // the middle of a value slot).\n                self.rem = 4 - (n & 3); // rem = 4 - (n % 4)\n                uint256 shift = (3 - self.rem) << 6; // shift = (3 - rem) * 64\n\n                // self.data = sload(self.slot) >> shift\n                // solhint-disable-next-line no-inline-assembly\n                assembly (\"memory-safe\") {\n                    mstore(add(self, 32), shr(shift, sload(mload(self))))\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Truncates the iterator to a maximum of `cnt` items.\n     */\n    function take(Iterator memory self, uint256 cnt) internal pure {\n        if (self.cnt > cnt) {\n            self.cnt = cnt;\n        }\n    }\n\n    /**\n     * @notice Returns the current value of the iterator.\n     * @dev The caller MUST ONLY call this function after a call to `next` which returned `true`.\n     *      Calling this after initialization (`iter`) or `skip` is undefined behaviour.\n     */\n    function value(\n        Iterator memory self\n    ) internal pure returns (uint256 blockNumber) {\n        return self.data & type(uint64).max;\n    }\n\n    /**\n     * @dev Generate an overflow panic. This function is required and implemented in assembly since\n     *      Solidity does not support panicking with `revert Panic(0x11)`.\n     *\n     *      <https://docs.soliditylang.org/en/v0.8.29/control-structures.html#panic-via-assert-and-error-via-require>\n     */\n    function _panicOverflow() private pure {\n        // revert Panic(0x11)\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            mstore(0, 0x4e487b71) // Panic(uint256)\n            mstore(32, 0x11) // arithmetic underflow or overflow\n            revert(28, 36)\n        }\n    }\n}\n"
    },
    "src/libs/CoreLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\nimport {\n    ENCRYPTION_KEY_TYPEHASH,\n    HARBOUR_DOMAIN_TYPEHASH,\n    SAFE_DOMAIN_TYPEHASH,\n    SAFE_TX_TYPEHASH,\n    SECP256K1_LOW_S_BOUND\n} from \"../interfaces/Constants.sol\";\nimport {\n    InvalidECDSASignatureLength,\n    InvalidSignatureSValue,\n    InvalidSignature,\n    ValueDoesNotFitInUint128\n} from \"../interfaces/Errors.sol\";\n\nlibrary CoreLib {\n    // ------------------------------------------------------------------\n    // Internal functions\n    // ------------------------------------------------------------------\n\n    /**\n     * @notice Computes the EIP-712 hash for a given domain and message.\n     *\n     * @param domainSeparator   The EIP-712 domain separator hash.\n     * @param messageStructHash The EIP-712 struct hash of the message.\n     *\n     * @return digest           The EIP-712 digest.\n     */\n    function computeErc712Hash(\n        bytes32 domainSeparator,\n        bytes32 messageStructHash\n    ) internal pure returns (bytes32 digest) {\n        digest = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, messageStructHash)\n        );\n    }\n\n    /**\n     * @notice Computes the EIP-712 domain separator for a Safe.\n     *\n     * @param chainId          The chain ID of the Safe Smart Account.\n     * @param safe             The address of the Safe Smart Account.\n     *\n     * @return domainSeparator The EIP-712 domain separator hash.\n     */\n    function safeDomainSeparator(\n        uint256 chainId,\n        address safe\n    ) internal pure returns (bytes32 domainSeparator) {\n        domainSeparator = keccak256(\n            abi.encode(SAFE_DOMAIN_TYPEHASH, chainId, safe)\n        );\n    }\n\n    /**\n     * @notice Computes the unique EIP-712 digest for a SafeTx using the provided parameters and domain.\n     *\n     * @param safeAddress    Address of the target Safe Smart Account.\n     * @param chainId        Chain ID included in the domain separator.\n     * @param nonce          Safe transaction nonce.\n     * @param to             Target address the Safe will call.\n     * @param value          ETH value to be sent with the call.\n     * @param data           Call data executed by the Safe.\n     * @param operation      Operation type: 0 = CALL, 1 = DELEGATECALL.\n     * @param safeTxGas      Gas limit for the Safe's internal execution.\n     * @param baseGas        Base gas overhead for reimbursement.\n     * @param gasPrice       Gas price used for reimbursement calculation.\n     * @param gasToken       Token address for refunds (0x0 for ETH).\n     * @param refundReceiver Address to receive gas refunds.\n     *\n     * @return safeTxHash    Keccak256 digest of the EIP-712 encoded SafeTx.\n     */\n    function computeSafeTxHash(\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver\n    ) internal pure returns (bytes32 safeTxHash) {\n        bytes32 domainSeparator = safeDomainSeparator(chainId, safeAddress);\n        bytes32 safeTxStructHash = keccak256(\n            abi.encode(\n                SAFE_TX_TYPEHASH,\n                to,\n                value,\n                keccak256(data),\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                nonce\n            )\n        );\n        safeTxHash = computeErc712Hash(domainSeparator, safeTxStructHash);\n    }\n\n    /**\n     * @notice Computes a Safe transaction hash from partial data.\n     *\n     * @param chainId          Chain ID included in the domain separator.\n     * @param safeAddress      Address of the target Safe Smart Account.\n     * @param safeTxStructHash The EIP-712 struct hash of the Safe transaction data.\n     *\n     * @return safeTxHash      Keccak256 digest of the EIP-712 encoded SafeTx.\n     */\n    function computePartialSafeTxHash(\n        uint256 chainId,\n        address safeAddress,\n        bytes32 safeTxStructHash\n    ) internal pure returns (bytes32 safeTxHash) {\n        bytes32 domainSeparator = safeDomainSeparator(chainId, safeAddress);\n        safeTxHash = computeErc712Hash(domainSeparator, safeTxStructHash);\n    }\n\n    /**\n     * @notice Computes the EIP-712 domain separator for Harbour.\n     *\n     * @param chainId          The chain ID of the Harbour.\n     * @param harbour          The address of the Harbour.\n     *\n     * @return domainSeparator The EIP-712 domain separator hash.\n     */\n    function harbourDomainSeparator(\n        uint256 chainId,\n        address harbour\n    ) internal pure returns (bytes32 domainSeparator) {\n        // NOTE: The Harbour domain separator does _NOT_ use the chain ID as\n        // part of the domain, but instead as part of the salt. Why? Harbour\n        // contains cross-chain data, so approvals for harbour actions (like\n        // registering an encryption key) aren't tied to a specific chain but\n        // rather a Harbour deployment. Furthermore, this allows wallets to sign\n        // for Harbour actions to be relayed without changing networks.\n        domainSeparator = keccak256(\n            abi.encode(HARBOUR_DOMAIN_TYPEHASH, harbour, chainId)\n        );\n    }\n\n    /**\n     * @notice Computes the encryption key hash for authentication.\n     *\n     * @param context            A 32-byte context specific to the public encryption key.\n     * @param publicKey          The public encryption key.\n     *\n     * @return encryptionKeyHash The EIP-712 encoded encryption key hash.\n     */\n    function computeEncryptionKeyHash(\n        uint256 chainId,\n        address harbour,\n        bytes32 context,\n        bytes32 publicKey\n    ) internal pure returns (bytes32 encryptionKeyHash) {\n        bytes32 domainSeparator = harbourDomainSeparator(chainId, harbour);\n        bytes32 encryptionKeyStructHash = keccak256(\n            abi.encode(ENCRYPTION_KEY_TYPEHASH, context, publicKey)\n        );\n        encryptionKeyHash = computeErc712Hash(\n            domainSeparator,\n            encryptionKeyStructHash\n        );\n    }\n\n    /**\n     * @notice Splits a 65-byte ECDSA signature into its components and recovers the signer address.\n     *\n     * @dev Supports both EIP-712 and eth_sign flows by detecting v > 30 and applying the Ethereum Signed Message prefix.\n     *\n     * @param digest  The message or data hash to verify (ERC-712 digest or eth_sign prefixed).\n     * @param sig     Concatenated 65-byte ECDSA signature (r || s || v).\n     *\n     * @return signer The address that produced the signature (EOA).\n     * @return r      First 32 bytes of the ECDSA signature.\n     * @return vs     Compact representation of s and v coming from EIP-2098.\n     */\n    function recoverSigner(\n        bytes32 digest,\n        bytes calldata sig\n    ) internal pure returns (address signer, bytes32 r, bytes32 vs) {\n        require(sig.length == 65, InvalidECDSASignatureLength());\n        uint256 v;\n        bytes32 s;\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            r := calldataload(sig.offset)\n            s := calldataload(add(sig.offset, 0x20))\n            v := byte(0, calldataload(add(sig.offset, 0x40)))\n        }\n        require(s <= SECP256K1_LOW_S_BOUND, InvalidSignatureSValue());\n\n        signer = ecrecover(digest, uint8(v), r, s);\n        require(signer != address(0), InvalidSignature());\n        unchecked {\n            vs = bytes32((uint256(v - 27) << 255) | uint256(s));\n        }\n    }\n\n    /**\n     * @notice Recovers the signer address from an EIP-2098 compact signature.\n     *\n     * @param digest  The message or data hash to verify (ERC-712 digest or eth_sign prefixed).\n     * @param r       First 32 bytes of the ECDSA signature.\n     * @param vs      Compact representation of s and v coming from EIP-2098.\n     *\n     * @return signer The address that produced the signature (EOA).\n     */\n    function recoverSigner(\n        bytes32 digest,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address signer) {\n        (bytes32 s, uint8 v) = splitVS(vs);\n        require(s <= SECP256K1_LOW_S_BOUND, InvalidSignatureSValue());\n\n        signer = ecrecover(digest, v, r, s);\n        require(signer != address(0), InvalidSignature());\n    }\n\n    function splitVS(bytes32 vs) internal pure returns (bytes32 s, uint8 v) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            // Equivalent to:\n            // s = bytes32(uint256(vs) & (uint256(1 << 255) - 1))\n            // v = uint8(uint256(vs >> 255) + 27)\n            // Assembly is slighly more gas efficient here\n            s := and(sub(shl(255, 1), 1), vs)\n            v := add(shr(255, vs), 27)\n        }\n    }\n\n    function safeCastUint256ToUint128(\n        uint256 value\n    ) internal pure returns (uint128) {\n        require(value <= type(uint128).max, ValueDoesNotFitInUint128());\n        return uint128(value);\n    }\n}\n"
    },
    "src/libs/PaymasterLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\nimport {\n    UserOperationLib\n} from \"@account-abstraction/contracts/core/UserOperationLib.sol\";\nimport {\n    PackedUserOperation\n} from \"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\";\nimport {InvalidValidatorData} from \"../interfaces/Errors.sol\";\n\nlibrary PaymasterLib {\n    using UserOperationLib for PackedUserOperation;\n\n    uint256 private constant PAYMASTER_VALID_AFTER_END =\n        UserOperationLib.PAYMASTER_DATA_OFFSET + 6;\n    uint256 private constant PAYMASTER_VALID_UNTIL_END =\n        PAYMASTER_VALID_AFTER_END + 6;\n\n    function extractValidatorData(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (uint48 validAfter, uint48 validUntil) {\n        require(\n            userOp.paymasterAndData.length >= PAYMASTER_VALID_UNTIL_END,\n            InvalidValidatorData()\n        );\n        validAfter = uint48(\n            bytes6(\n                userOp.paymasterAndData[\n                    UserOperationLib\n                        .PAYMASTER_DATA_OFFSET:PAYMASTER_VALID_AFTER_END\n                ]\n            )\n        );\n        validUntil = uint48(\n            bytes6(\n                userOp.paymasterAndData[\n                    PAYMASTER_VALID_AFTER_END:PAYMASTER_VALID_UNTIL_END\n                ]\n            )\n        );\n    }\n\n    function extractPaymaster(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (address paymaster) {\n        return\n            address(\n                bytes20(\n                    userOp.paymasterAndData[\n                        :UserOperationLib.PAYMASTER_VALIDATION_GAS_OFFSET\n                    ]\n                )\n            );\n    }\n\n    function calculateRequiredPrefund(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (uint256 requiredPrefund) {\n        unchecked {\n            uint256 callGasLimit = userOp.unpackCallGasLimit();\n            uint256 verificationGasLimit = userOp.unpackVerificationGasLimit();\n            uint256 paymasterVerificationGasLimit = userOp\n                .unpackPaymasterVerificationGasLimit();\n            uint256 paymasterPostOpGasLimit = userOp.unpackPostOpGasLimit();\n            uint256 maxFeePerGas = userOp.unpackMaxFeePerGas();\n            uint256 requiredGas = verificationGasLimit +\n                callGasLimit +\n                paymasterVerificationGasLimit +\n                paymasterPostOpGasLimit +\n                userOp.preVerificationGas;\n\n            requiredPrefund = requiredGas * maxFeePerGas;\n        }\n    }\n\n    // TODO: harbour is userOp.sender and therefore part of userOpHash and could be removed\n    function computeValidatorConfirmationHash(\n        address harbour,\n        bytes32 userOpHash\n    ) internal view returns (bytes32 validatorConfirmationHash) {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n                ),\n                block.chainid,\n                address(this)\n            )\n        );\n        bytes32 structHash = keccak256(\n            abi.encode(\n                keccak256(\n                    \"ValidatorConfirmation(address harbour,bytes32 userOpHash)\"\n                ),\n                harbour,\n                userOpHash\n            )\n        );\n        validatorConfirmationHash = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n    }\n}\n"
    },
    "src/libs/RegistrationKey.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\n/**\n * @title Safe Secret Harbour Registration Key\n * @dev This registration key is used internally as a mapping key to transaction registration block\n *      numbers. It allows enumeration of block numbers where Safe transactions for a given chain,\n *      Safe, and nonce were registered by a notary.\n */\nlibrary RegistrationKey {\n    type T is bytes32;\n\n    /**\n     * @notice Compute the registeration key for a given `(chainId, safe, nonce, signer)` tuple.\n     */\n    function get(\n        uint256 chainId,\n        address safe,\n        uint256 nonce,\n        address notary\n    ) internal pure returns (T key) {\n        // uid = keccak256(chainId, safe, nonce, notary)\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(ptr, chainId)\n            mstore(add(ptr, 32), safe)\n            mstore(add(ptr, 64), nonce)\n            mstore(add(ptr, 96), notary)\n            key := keccak256(ptr, 128)\n        }\n    }\n\n    /**\n     * @notice Computes an opaque unique identifier for the specified registration key and index.\n     *\n     * @dev This UID is indexed in transaction registration events, and can be used to an RPC node\n     *      for Ethereum logs for a specific transaction registration. This allows the harbour\n     *      contract to be used without event indexing with RPC nodes that do not support queries\n     *      over large block ranges.\n     */\n    function uniqueIdentifier(\n        T self,\n        uint256 index\n    ) internal pure returns (bytes32 uid) {\n        // uid = keccak256(self, index)\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            mstore(0, self)\n            mstore(32, index)\n            uid := keccak256(0, 64)\n        }\n    }\n}\n"
    },
    "src/mixins/ERC4337Mixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\nimport {IAccount} from \"@account-abstraction/contracts/interfaces/IAccount.sol\";\nimport {\n    IEntryPoint\n} from \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\nimport {\n    PackedUserOperation\n} from \"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\";\nimport {\n    _packValidationData\n} from \"@account-abstraction/contracts/core/Helpers.sol\";\nimport {\n    UserOperationLib\n} from \"@account-abstraction/contracts/core/UserOperationLib.sol\";\nimport {\n    InvalidEntryPoint,\n    InvalidTarget,\n    SignerAlreadySignedTransaction,\n    UnexpectedNonce,\n    InvalidUserOpPaymaster,\n    UnexpectedSafeTxHash,\n    UnexpectedSigner\n} from \"../interfaces/Errors.sol\";\nimport {IHarbourStore} from \"../interfaces/HarbourStore.sol\";\nimport {PaymasterLib} from \"../libs/PaymasterLib.sol\";\nimport {CoreLib} from \"../libs/CoreLib.sol\";\n\nstruct ERC4337MixinConfig {\n    address entryPoint;\n}\n\nabstract contract ERC4337Mixin is IAccount, IHarbourStore {\n    using UserOperationLib for PackedUserOperation;\n    using PaymasterLib for PackedUserOperation;\n\n    // ------------------------------------------------------------------\n    // 4337 functions\n    // ------------------------------------------------------------------\n\n    /**\n     * @notice The address of the EntryPoint contract supported by this module.\n     */\n    address public immutable SUPPORTED_ENTRYPOINT;\n\n    constructor(ERC4337MixinConfig memory _config) {\n        SUPPORTED_ENTRYPOINT = _config.entryPoint;\n    }\n\n    /**\n     * @notice Return the nonce for a specific signer.\n     * @param signer Address of the signer of the Safe transaction.\n     * @return Nonce for the signer\n     */\n    function getNonce(address signer) public view virtual returns (uint256) {\n        return\n            IEntryPoint(SUPPORTED_ENTRYPOINT).getNonce(\n                address(this),\n                uint192(uint160(signer))\n            );\n    }\n\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32,\n        uint256\n    ) external view override returns (uint256 validationData) {\n        require(\n            msg.sender == SUPPORTED_ENTRYPOINT,\n            InvalidEntryPoint(msg.sender)\n        );\n\n        require(\n            bytes4(userOp.callData) == this.storeTransaction.selector,\n            InvalidTarget(bytes4(userOp.callData))\n        );\n        (\n            bytes32 safeTxHash,\n            address signer,\n            bytes32 r,\n            bytes32 vs\n        ) = _verifySafeTxData(userOp.callData[4:]);\n\n        // --- DUPLICATE TRANSACTION SIGNATURE CHECK ---\n        // Revert if this signer has already submitted *any* signature for this *exact* safeTxHash\n        require(\n            !_signatureStored(keccak256(abi.encodePacked(r, vs))),\n            SignerAlreadySignedTransaction(signer, safeTxHash)\n        );\n\n        _verifySignature(safeTxHash, signer, r, vs);\n\n        require(\n            uint192(userOp.nonce >> 64) == uint192(uint160(signer)),\n            UnexpectedNonce(signer)\n        );\n\n        // We skip the check that missingAccountFunds should be == 0, as this is the job of the entry point\n\n        // Harbour can only be used with a paymaster when using 4337\n        require(userOp.paymasterAndData.length > 0, InvalidUserOpPaymaster());\n        return _packValidationData(false, 0, 0);\n    }\n\n    function _verifySafeTxData(\n        bytes calldata callData\n    ) private pure returns (bytes32, address, bytes32, bytes32) {\n        (\n            bytes32 safeTxHash,\n            address safeAddress,\n            uint256 chainId,\n            uint256 nonce,\n            address to,\n            uint256 value,\n            bytes memory data,\n            uint8 operation,\n            uint256 safeTxGas,\n            uint256 baseGas,\n            uint256 gasPrice,\n            address gasToken,\n            address refundReceiver,\n            address signer,\n            bytes32 r,\n            bytes32 vs\n        ) = abi.decode(\n                callData,\n                (\n                    bytes32,\n                    address,\n                    uint256,\n                    uint256,\n                    address,\n                    uint256,\n                    bytes,\n                    uint8,\n                    uint256,\n                    uint256,\n                    uint256,\n                    address,\n                    address,\n                    address,\n                    bytes32,\n                    bytes32\n                )\n            );\n        bytes32 computedSafeTxHash = CoreLib.computeSafeTxHash(\n            safeAddress,\n            chainId,\n            nonce,\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver\n        );\n\n        require(\n            computedSafeTxHash == safeTxHash,\n            UnexpectedSafeTxHash(computedSafeTxHash)\n        );\n        // The computed length when properly encoded is based on the data length and the number of params\n        // 4 bytes selector + 15 params each 32 bytes + 32 bytes offset of data + 32 bytes length of data + data length + 32 bytes buffer for padding\n        return (safeTxHash, signer, r, vs);\n    }\n\n    function _verifySignature(\n        bytes32 safeTxHash,\n        address signer,\n        bytes32 r,\n        bytes32 vs\n    ) private pure {\n        (address recoveredSigner) = CoreLib.recoverSigner(safeTxHash, r, vs);\n        require(signer == recoveredSigner, UnexpectedSigner(signer));\n    }\n\n    function storeTransaction(\n        bytes32 safeTxHash,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        address signer,\n        bytes32 r,\n        bytes32 vs\n    ) external returns (uint256 listIndex) {\n        require(\n            msg.sender == SUPPORTED_ENTRYPOINT,\n            InvalidEntryPoint(msg.sender)\n        );\n        _storeTransaction(\n            safeTxHash,\n            safeAddress,\n            chainId,\n            nonce,\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver\n        );\n        return\n            _storeSignature(\n                signer,\n                safeAddress,\n                chainId,\n                nonce,\n                safeTxHash,\n                r,\n                vs\n            );\n    }\n}\n"
    },
    "src/mixins/QuotaMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IQuotaManager} from \"../interfaces/QuotaManager.sol\";\nimport {CoreLib} from \"../libs/CoreLib.sol\";\nimport {\n    WithdrawalAlreadyPerformed,\n    InsufficientTokensForWithdrawal,\n    TokensInUse,\n    QuotaOverflow\n} from \"../interfaces/Errors.sol\";\n\nstruct QuotaStats {\n    uint96 tokenBalance; // uint96 might also be enough, as this would be more tokens than most project have in circulation\n    uint96 usedQuota; // Quota is limited to 96 bits (current Quota == Bytes of data or eth costs for a tx, so that should be ok)\n    uint48 nextQuotaReset; // timestamps are Safe to limit to 64 bits\n}\n\nstruct QuotaMixinConfig {\n    uint32 timeframeQuotaReset;\n    uint16 requiredQuotaMultiplier;\n    uint96 maxAvailableQuota;\n    address feeToken;\n    uint32 quotaPerFeeToken;\n    uint8 quotaPerFeeTokenScale;\n}\n\nabstract contract QuotaMixin is IQuotaManager {\n    using SafeERC20 for IERC20;\n\n    event Withdraw(address indexed signer, uint256 indexed amount);\n    event Deposit(address indexed signer, uint256 indexed amount);\n\n    mapping(address => QuotaStats) public quotaStatsForSigner;\n    mapping(address => mapping(bytes32 => uint256)) public withdrawsForSigner;\n\n    bool public immutable QUOTA_ENABLED;\n    uint32 public immutable TIMEFRAME_QUOTA_RESET;\n    uint96 public immutable MAX_AVAILABLE_QUOTA;\n    address public immutable FEE_TOKEN;\n    uint32 public immutable QUOTA_PER_FEE_TOKEN;\n    uint8 public immutable QUOTA_PER_FEE_TOKEN_SCALE;\n\n    constructor(QuotaMixinConfig memory _config) {\n        QUOTA_ENABLED = _config.feeToken != address(0);\n        TIMEFRAME_QUOTA_RESET = _config.timeframeQuotaReset;\n        MAX_AVAILABLE_QUOTA = _config.maxAvailableQuota;\n        FEE_TOKEN = _config.feeToken;\n        QUOTA_PER_FEE_TOKEN = _config.quotaPerFeeToken;\n        QUOTA_PER_FEE_TOKEN_SCALE = _config.quotaPerFeeTokenScale;\n    }\n\n    function depositTokensForSigner(address signer, uint96 amount) public {\n        // We don't update the nextQuotaReset this way depositing more tokens does not negatively affect the reset schedule\n        // The reset schedule always starts from 0, therefore is always a multiple of the reset timeframe (unless the timeframe is changed)\n        quotaStatsForSigner[signer].tokenBalance += amount;\n        // TODO: check if we want to track total tokens locked (might be useful in a recovery case)\n        IERC20(FEE_TOKEN).safeTransferFrom(msg.sender, address(this), amount);\n        emit Deposit(signer, amount);\n    }\n\n    function computeWithdrawHash(\n        uint256 amount,\n        address beneficiary,\n        uint256 nonce\n    ) internal view returns (bytes32 withdrawHash) {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n                ),\n                block.chainid,\n                address(this)\n            )\n        );\n        bytes32 structHash = keccak256(\n            abi.encode(\n                keccak256(\n                    \"WithdrawRequest(uint256 amount,address beneficiary,uint256 nonce)\"\n                ),\n                amount,\n                beneficiary,\n                nonce\n            )\n        );\n        withdrawHash = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n    }\n\n    function widthdrawTokensForSigner(\n        bytes calldata signature,\n        uint96 amount,\n        address beneficiary,\n        uint256 nonce\n    ) public payable {\n        bytes32 withdrawHash = computeWithdrawHash(amount, beneficiary, nonce);\n        (address signer, , ) = CoreLib.recoverSigner(withdrawHash, signature);\n        // Check that withdrawal was not executed yet\n        require(\n            withdrawsForSigner[signer][withdrawHash] == 0,\n            WithdrawalAlreadyPerformed(withdrawHash)\n        );\n        withdrawsForSigner[signer][withdrawHash] = block.timestamp;\n\n        _withdrawSignerTokens(signer, beneficiary, amount, false);\n\n        emit Withdraw(signer, amount);\n    }\n\n    function _withdrawSignerTokens(\n        address signer,\n        address beneficiary,\n        uint96 amount,\n        bool skipResetCheck\n    ) internal override {\n        QuotaStats storage stats = quotaStatsForSigner[signer];\n        require(\n            stats.tokenBalance >= amount,\n            InsufficientTokensForWithdrawal()\n        );\n        // We use the quota reset timeframe as a unlock timeframe\n        // -> currently the signer is not allowed to sign any Safe transaction during this timeframe\n        // TODO: have dedicated unlock logic (also to avoid some fee exploit flows)\n        require(\n            skipResetCheck || stats.nextQuotaReset < block.timestamp,\n            TokensInUse()\n        );\n\n        stats.tokenBalance -= amount;\n\n        if (beneficiary != address(this)) {\n            _transferFeeToken(beneficiary, amount);\n        }\n    }\n\n    function _transferFeeToken(\n        address beneficiary,\n        uint96 amount\n    ) internal override {\n        IERC20(FEE_TOKEN).safeTransfer(beneficiary, amount);\n    }\n\n    function availableFreeQuotaForSigner(\n        address signer\n    )\n        public\n        view\n        returns (\n            uint96 availableFreeQuota,\n            uint96 usedSignerQuota,\n            uint48 nextSignerQuotaReset\n        )\n    {\n        QuotaStats memory stats = quotaStatsForSigner[signer];\n        nextSignerQuotaReset = stats.nextQuotaReset;\n        if (nextSignerQuotaReset > block.timestamp) {\n            usedSignerQuota = stats.usedQuota;\n        } else {\n            // Signer quota should be reset (therefore be 0)\n            usedSignerQuota = 0;\n            // The reset time should always be aligned with the timeframe (be a multiple)\n            // First the time difference since the last reset is calculated (last reset - block time)\n            // Then the elablesed time in the current timeframe (modulo with timeframe duration)\n            // Then substract this from the current blocktime to get the start of the current timeframe\n            // And lastly add the timeframe duration to get the starting point of the next timeframe\n            uint48 blocktime = uint48(block.timestamp);\n            nextSignerQuotaReset =\n                blocktime -\n                ((blocktime - nextSignerQuotaReset) % TIMEFRAME_QUOTA_RESET) +\n                TIMEFRAME_QUOTA_RESET;\n        }\n        // We cast tokenBalance to uint256 to use more bits for the arithmetics\n        uint256 maxSignerQuota = (uint256(stats.tokenBalance) *\n            QUOTA_PER_FEE_TOKEN) / 10 ** QUOTA_PER_FEE_TOKEN_SCALE;\n\n        require(\n            maxSignerQuota <= type(uint96).max,\n            QuotaOverflow(maxSignerQuota)\n        );\n\n        uint96 freeSignerQuota = uint96(maxSignerQuota);\n        // If MAX_AVAILABLE_QUOTA is set to 0 then there is no limit\n        if (MAX_AVAILABLE_QUOTA > 0 && freeSignerQuota > MAX_AVAILABLE_QUOTA) {\n            freeSignerQuota = MAX_AVAILABLE_QUOTA;\n        }\n        if (usedSignerQuota <= freeSignerQuota) {\n            availableFreeQuota = freeSignerQuota - usedSignerQuota;\n        } else {\n            availableFreeQuota = 0;\n        }\n    }\n\n    function _updateQuotaParams(\n        address signer,\n        uint96 newSignerQuota,\n        uint48 nextSignerQuotaReset\n    ) internal {\n        QuotaStats storage stats = quotaStatsForSigner[signer];\n        if (nextSignerQuotaReset != stats.nextQuotaReset) {\n            stats.nextQuotaReset = nextSignerQuotaReset;\n        }\n        stats.usedQuota = newSignerQuota;\n    }\n\n    function _checkAndUpdateQuota(\n        address signer,\n        uint256 requiredSignerQuota\n    ) internal override returns (bool) {\n        if (!QUOTA_ENABLED || requiredSignerQuota == 0) return true;\n        (\n            uint96 availableFreeSignerQuota,\n            uint96 usedSignerQuota,\n            uint48 nextSignerQuotaReset\n        ) = availableFreeQuotaForSigner(signer);\n        if (requiredSignerQuota > availableFreeSignerQuota) return false;\n        // Casting to uint64 is safe, as availableFreeSignerQuota is at most a uint64 and we compare it against that\n        _updateQuotaParams(\n            signer,\n            usedSignerQuota + uint96(requiredSignerQuota),\n            nextSignerQuotaReset\n        );\n        return true;\n    }\n}\n"
    },
    "src/mixins/SlashingMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\nimport {\n    PackedUserOperation\n} from \"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IQuotaManager} from \"../interfaces/QuotaManager.sol\";\nimport {PaymasterLib} from \"../libs/PaymasterLib.sol\";\nimport {CoreLib} from \"../libs/CoreLib.sol\";\nimport {IERC4337InfoProvider} from \"../interfaces/ERC4337.sol\";\nimport {ISlashingCondition} from \"../interfaces/Conditions.sol\";\nimport {\n    InsufficientTokensForWithdrawal,\n    InvalidUserOpPaymaster,\n    ConditionWasNotActive,\n    ConditionAlreadyEnabled,\n    ConditionAlreadyDisabled,\n    ConditionNotEnabled,\n    ConditionNotOffended,\n    UserOpAlreadySlashed,\n    NothingToSlash,\n    InvalidBeneficiary\n} from \"../interfaces/Errors.sol\";\n\nstruct SlashingMixinConfig {\n    uint48 enableCoditionsDelay;\n    ISlashingCondition[] initialConditions;\n}\n\nabstract contract SlashingMixin is IQuotaManager, IERC4337InfoProvider {\n    using SafeERC20 for IERC20;\n    using PaymasterLib for PackedUserOperation;\n\n    struct ConditionStatus {\n        uint48 enabledAfter;\n        uint48 enabledUntil;\n    }\n\n    uint48 public immutable ENABLE_CONDITIONS_DELAY;\n\n    event Slashed(\n        ISlashingCondition indexed offendingCondition,\n        address indexed validator,\n        uint256 indexed amount\n    );\n\n    event EnableCondition(\n        ISlashingCondition indexed offendingCondition,\n        uint48 enabledFrom\n    );\n\n    event DisableCondition(\n        ISlashingCondition indexed offendingCondition,\n        uint48 enabledUntil\n    );\n\n    uint256 public slashedTokens;\n    mapping(ISlashingCondition => ConditionStatus) public enabledConditions;\n    mapping(bytes32 => uint256) public slashedUserOps;\n\n    constructor(SlashingMixinConfig memory _config) {\n        ENABLE_CONDITIONS_DELAY = _config.enableCoditionsDelay;\n        for (uint256 i = 0; i < _config.initialConditions.length; i++) {\n            enabledConditions[_config.initialConditions[i]] = ConditionStatus({\n                enabledAfter: uint48(block.timestamp),\n                enabledUntil: 0\n            });\n        }\n    }\n\n    function slashValidator(\n        ISlashingCondition offendingCondition,\n        PackedUserOperation calldata userOp\n    ) public {\n        // Only slashing for userOps related to this paymaster is allowed\n        require(\n            userOp.extractPaymaster() == address(this),\n            InvalidUserOpPaymaster()\n        );\n        (uint256 validAfter, uint256 validUntil) = userOp\n            .extractValidatorData();\n        ConditionStatus memory conditionStatus = enabledConditions[\n            offendingCondition\n        ];\n        require(\n            (conditionStatus.enabledAfter < validUntil || validUntil == 0) &&\n                (validAfter < conditionStatus.enabledUntil ||\n                    conditionStatus.enabledUntil == 0),\n            ConditionWasNotActive()\n        );\n        bytes32 userOpHash = getSupportedEntrypoint().getUserOpHash(userOp);\n        bytes32 digest = PaymasterLib.computeValidatorConfirmationHash(\n            userOp.sender,\n            userOpHash\n        );\n        (address validator, , ) = CoreLib.recoverSigner(\n            digest,\n            userOp.signature\n        );\n        require(\n            offendingCondition.shouldBeSlashed(validator, userOp),\n            ConditionNotOffended()\n        );\n        require(slashedUserOps[userOpHash] == 0, UserOpAlreadySlashed());\n        uint96 usedQuota = uint96(userOp.calculateRequiredPrefund());\n        uint96 slashingAmount = _adjustSlashingAmount(validator, usedQuota);\n        require(slashingAmount > 0, NothingToSlash());\n        // Currently only the slashed amount is stored, more information could be stored if necessary\n        slashedUserOps[userOpHash] = slashingAmount;\n        slashedTokens += slashingAmount;\n        // By withdrawing the slashed tokens to the slashing contract they can be transferred later\n        _withdrawSignerTokens(validator, address(this), slashingAmount, true);\n        emit Slashed(offendingCondition, validator, slashingAmount);\n    }\n\n    // Can be used to adjust slashing amount, i.e. based on quota relation\n    function _adjustSlashingAmount(\n        address validator,\n        uint96 slashingAmount\n    ) internal virtual returns (uint96);\n\n    function _enableCondition(ISlashingCondition condition) internal {\n        require(\n            enabledConditions[condition].enabledAfter == 0,\n            ConditionAlreadyEnabled()\n        );\n        uint48 enabledAfter = uint48(block.timestamp) + ENABLE_CONDITIONS_DELAY;\n        enabledConditions[condition] = ConditionStatus({\n            enabledAfter: enabledAfter,\n            enabledUntil: 0\n        });\n        emit EnableCondition(condition, enabledAfter);\n    }\n\n    function _disableCondition(ISlashingCondition condition) internal {\n        ConditionStatus memory conditionStatus = enabledConditions[condition];\n        require(conditionStatus.enabledAfter != 0, ConditionNotEnabled());\n        require(conditionStatus.enabledUntil == 0, ConditionAlreadyDisabled());\n        uint48 enabledUntil = uint48(block.timestamp) + ENABLE_CONDITIONS_DELAY;\n        enabledConditions[condition].enabledUntil = enabledUntil;\n        emit EnableCondition(condition, enabledUntil);\n    }\n\n    function _withdrawSlashedTokens(\n        address beneficiary,\n        uint96 amount\n    ) internal {\n        require(beneficiary != address(this), InvalidBeneficiary());\n        require(amount <= slashedTokens, InsufficientTokensForWithdrawal());\n        unchecked {\n            slashedTokens -= amount;\n        }\n        _transferFeeToken(beneficiary, amount);\n    }\n}\n"
    },
    "src/SafeHarbourPaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\nimport {\n    BasePaymaster\n} from \"@account-abstraction/contracts/core/BasePaymaster.sol\";\nimport {\n    PackedUserOperation\n} from \"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\";\nimport {\n    IEntryPoint\n} from \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\nimport {\n    _packValidationData\n} from \"@account-abstraction/contracts/core/Helpers.sol\";\nimport {QuotaMixin, QuotaMixinConfig} from \"./mixins/QuotaMixin.sol\";\nimport {SlashingMixin, SlashingMixinConfig} from \"./mixins/SlashingMixin.sol\";\nimport {ERC4337Mixin} from \"./mixins/ERC4337Mixin.sol\";\nimport {PaymasterLib} from \"./libs/PaymasterLib.sol\";\nimport {CoreLib} from \"./libs/CoreLib.sol\";\nimport {InvalidTarget, InvalidUserOpPaymaster} from \"./interfaces/Errors.sol\";\n\n// TODO: do not use BasePaymaster as it is not optimized to our needs (i.e. no custom errors)\ncontract SafeHarbourPaymaster is BasePaymaster, QuotaMixin, SlashingMixin {\n    using PaymasterLib for PackedUserOperation;\n\n    constructor(\n        address manager,\n        IEntryPoint supportedEntrypoint,\n        QuotaMixinConfig memory _quotaMixinconfig,\n        SlashingMixinConfig memory _slashingMixinconfig\n    )\n        BasePaymaster(supportedEntrypoint)\n        QuotaMixin(_quotaMixinconfig)\n        SlashingMixin(_slashingMixinconfig)\n    {\n        transferOwnership(manager);\n    }\n\n    function getSupportedEntrypoint()\n        public\n        view\n        override\n        returns (IEntryPoint)\n    {\n        return entryPoint;\n    }\n\n    /**\n     * Validate a user operation.\n     * @param userOp     - The user operation.\n     * @param maxCost    - The maximum cost of the user operation.\n     */\n    function _validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) internal override returns (bytes memory context, uint256 validationData) {\n        (context);\n\n        // Theoretically this check is also performed by the 4337 mixin and could be skipped here (especially if the sender is trusted)\n        require(\n            bytes4(userOp.callData) == ERC4337Mixin.storeTransaction.selector,\n            InvalidTarget(bytes4(userOp.callData))\n        );\n\n        require(\n            userOp.extractPaymaster() == address(this),\n            InvalidUserOpPaymaster()\n        );\n\n        (address validator, , ) = CoreLib.recoverSigner(\n            userOpHash,\n            userOp.signature\n        );\n        // Range will be checked by Entrypoint\n        (uint48 validAfter, uint48 validUntil) = userOp.extractValidatorData();\n        // Max quota per validator is ~18ETH (2**64/10**18) in gas fees\n        bool validationFailed = !_checkAndUpdateQuota(validator, maxCost);\n        validationData = _packValidationData(\n            validationFailed,\n            validUntil,\n            validAfter\n        );\n    }\n\n    // Slashing amount is based on quota and is converted back to tokens.\n    function _adjustSlashingAmount(\n        address validator,\n        uint96 slashingAmount\n    ) internal view override returns (uint96) {\n        uint256 tokensToSlash = (uint256(slashingAmount) *\n            10 ** QUOTA_PER_FEE_TOKEN_SCALE) / QUOTA_PER_FEE_TOKEN;\n        uint96 tokenBalance = quotaStatsForSigner[validator].tokenBalance;\n        // If more tokens than locked should be slashed, we slash what we can get\n        return\n            tokensToSlash > tokenBalance ? tokenBalance : uint96(tokensToSlash);\n    }\n}\n"
    },
    "src/SafeInternationalHarbour.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\nimport {SignerAlreadySignedTransaction} from \"./interfaces/Errors.sol\";\nimport {\n    SafeTransaction,\n    SignatureDataWithTxHashIndex\n} from \"./interfaces/Types.sol\";\nimport {SignatureStored, NewTransaction} from \"./interfaces/Events.sol\";\nimport {CoreLib} from \"./libs/CoreLib.sol\";\nimport {ERC4337Mixin, ERC4337MixinConfig} from \"./mixins/ERC4337Mixin.sol\";\n// Imported for natspec inheritance\n// solhint-disable-next-line no-unused-import\nimport {IHarbourStore} from \"./interfaces/HarbourStore.sol\";\n\n/**\n * @title SafeInternationalHarbour\n * @notice Permissionless, append-only registry that lets **any EOA signer** publish Safe\n *         transactions (\"SafeTx\") and their signatures. Clients without an off-chain indexer can reconstruct the full multisig payload with only:\n *         1. the Safe address;\n *         2. the target `chainId`;\n *         3. the Safe `nonce`; and\n *         4. the current Safe owners set.\n *\n * Each unique `safeTxHash` (EIP-712 digest of the SafeTx struct) is persisted **once** together with\n * its parameters. Signatures are appended under the composite key\n * `(signer, safe, chainId, nonce)`, enabling on-chain, gas-efficient look-ups.\n *\n * ###  Contract-based signers unsupported\n * Only ECDSA signatures from externally-owned accounts (EOAs) are supported. Contract wallets that\n * rely on ERC-1271 or similar cannot be verified on-chain in a chain-agnostic way and are therefore\n * **not supported**.\n *\n * @dev The {SignatureStored} event is the only hook required by indexers; however, the contract is\n *      fully functional without any off-chain infrastructure.\n */\ncontract SafeInternationalHarbour is ERC4337Mixin {\n    // ------------------------------------------------------------------\n    // Storage\n    // ------------------------------------------------------------------\n\n    // Mapping `safeTxHash  SafeTransaction` parameters\n    mapping(bytes32 => SafeTransaction) private _txDetails;\n\n    // Mapping `signer  safe  chainId  nonce  SignatureData[]`\n    // Stores the list of signatures provided by a signer for a given Safe context.\n    // Note: A single list entry here could contain signatures for *different* `safeTxHash` values\n    // if those transactions share the same (safe, chainId, nonce). Use `_hasSignerSignedTx`\n    // to ensure a signer only signs a specific `safeTxHash` once.\n    struct SignatureData {\n        bytes32 r;\n        bytes32 vs;\n    }\n    mapping(address signer => mapping(address safe => mapping(uint256 chainId => mapping(uint256 nonce => SignatureData[]))))\n        private _sigData;\n\n    mapping(bytes32 signatureHash => bytes32 safeTxHash) private _signatureLink;\n\n    constructor(\n        ERC4337MixinConfig memory _erc4337Mixinconfig\n    ) ERC4337Mixin(_erc4337Mixinconfig) {}\n\n    // ------------------------------------------------------------------\n    // External & public write functions\n    // ------------------------------------------------------------------\n\n    /**\n     * @notice Publish a Safe transaction and/or append a signature to it.\n     *\n     * @dev If `safeTxHash` has been seen before, its parameters are *not* validated nor overwritten \n     *      the call simply appends the `(r,s)` pair for `signer`.\n     *\n     * @param safeAddress    Target Safe Smart-Account.\n     * @param chainId        Chain id the transaction is meant for.\n     * @param nonce          Safe nonce.\n     * @param to             Destination of the inner call/delegatecall.\n     * @param value          ETH value forwarded by the Safe.\n     * @param data           Calldata executed by the Safe.\n     * @param operation      0 = CALL, 1 = DELEGATECALL.\n     * @param safeTxGas      Gas forwarded to the inner call.\n     * @param baseGas        Fixed overhead reimbursed to the submitting signer.\n     * @param gasPrice       Gas price used for reimbursement.\n     * @param gasToken       ERC-20 token address for refunds (`address(0)` = ETH).\n     * @param refundReceiver Address receiving the gas refund.\n     * @param signature      **Single** 65-byte ECDSA signature.\n     *\n     * @return listIndex     Index of the stored signature in the signer-specific list.\n     *\n     * @custom:events Emits {SignatureStored}.\n     */\n    function enqueueTransaction(\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        bytes calldata signature\n    ) external returns (uint256 listIndex) {\n        // ------------------------------------------------------------------\n        // Build the EIP-712 digest that uniquely identifies the SafeTx\n        // ------------------------------------------------------------------\n        bytes32 safeTxHash = CoreLib.computeSafeTxHash(\n            safeAddress,\n            chainId,\n            nonce,\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver\n        );\n\n        (address signer, bytes32 r, bytes32 vs) = CoreLib.recoverSigner(\n            safeTxHash,\n            signature\n        );\n\n        _storeTransaction(\n            safeTxHash,\n            safeAddress,\n            chainId,\n            nonce,\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver\n        );\n\n        // --- DUPLICATE TRANSACTION SIGNATURE CHECK ---\n        // Revert if this signer has already submitted *any* signature for this *exact* safeTxHash\n        require(\n            !_signatureStored(keccak256(abi.encodePacked(r, vs))),\n            SignerAlreadySignedTransaction(signer, safeTxHash)\n        );\n        return\n            _storeSignature(\n                signer,\n                safeAddress,\n                chainId,\n                nonce,\n                safeTxHash,\n                r,\n                vs\n            );\n    }\n\n    // ------------------------------------------------------------------\n    // External & public read functions\n    // ------------------------------------------------------------------\n\n    /**\n     * @notice Retrieve the full parameter set of a Safe transaction.\n     *\n     * @param safeTxHash EIP-712 digest of the transaction.\n     *\n     * @return txParams Struct with all SafeTx parameters (zero-initialised if unknown).\n     */\n    function retrieveTransaction(\n        bytes32 safeTxHash\n    ) external view returns (SafeTransaction memory txParams) {\n        txParams = _txDetails[safeTxHash];\n    }\n\n    /**\n     * @notice Paginated getter for signature entries.\n     *\n     * @param signerAddress Address that created the signatures.\n     * @param safeAddress   Safe Smart-Account.\n     * @param chainId       Target chain id.\n     * @param nonce         Safe nonce.\n     * @param start         Zero-based start index of the slice.\n     * @param count         Maximum number of entries to return.\n     *\n     * @return page       Array slice `[start  start+count)` (may be shorter).\n     * @return totalCount Total number of signatures stored for the tuple.\n     */\n    function retrieveSignatures(\n        address signerAddress,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        uint256 start,\n        uint256 count\n    )\n        external\n        view\n        returns (SignatureDataWithTxHashIndex[] memory page, uint256 totalCount)\n    {\n        SignatureData[] storage all = _sigData[signerAddress][safeAddress][\n            chainId\n        ][nonce];\n        totalCount = all.length;\n        if (start >= totalCount)\n            return (new SignatureDataWithTxHashIndex[](0), totalCount);\n\n        uint256 end = start + count;\n        if (end > totalCount) end = totalCount;\n        uint256 len = end - start;\n\n        page = new SignatureDataWithTxHashIndex[](len);\n        for (uint256 i; i < len; ++i) {\n            bytes32 r = all[start + i].r;\n            bytes32 vs = all[start + i].vs;\n            page[i] = SignatureDataWithTxHashIndex({\n                r: r,\n                vs: vs,\n                txHash: _signatureLink[keccak256(abi.encodePacked(r, vs))]\n            });\n        }\n    }\n\n    /**\n     * @notice Convenience getter returning the **number** of signatures stored for the key tuple.\n     *\n     * @param signerAddress Signer address.\n     * @param safeAddress   Safe Smart-Account.\n     * @param chainId       Target chain id.\n     * @param nonce         Safe nonce.\n     *\n     * @return count Length of the signature list.\n     */\n    function retrieveSignaturesCount(\n        address signerAddress,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce\n    ) external view returns (uint256 count) {\n        count = _sigData[signerAddress][safeAddress][chainId][nonce].length;\n    }\n\n    // ------------------------------------------------------------------\n    // Internal functions\n    // ------------------------------------------------------------------\n\n    /**\n     * @inheritdoc IHarbourStore\n     */\n    function _signatureStored(\n        bytes32 signatureHash\n    ) internal view override returns (bool signed) {\n        signed = _signatureLink[signatureHash] != 0;\n    }\n\n    /**\n     * @inheritdoc IHarbourStore\n     */\n    function _storeTransaction(\n        bytes32 safeTxHash,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver\n    ) internal override {\n        // Store parameters only once (idempotent write)\n        SafeTransaction storage slot = _txDetails[safeTxHash];\n        if (!slot.stored) {\n            // first encounter  persist full parameter set\n            slot.stored = true;\n            slot.to = to;\n            slot.operation = operation;\n\n            // Writing to storage is expensive, so we only write if the value is non-zero\n            if (value > 0) {\n                slot.value = CoreLib.safeCastUint256ToUint128(value);\n            }\n            if (safeTxGas > 0) {\n                slot.safeTxGas = CoreLib.safeCastUint256ToUint128(safeTxGas);\n            }\n            if (baseGas > 0) {\n                slot.baseGas = CoreLib.safeCastUint256ToUint128(baseGas);\n            }\n            if (gasPrice > 0) {\n                slot.gasPrice = CoreLib.safeCastUint256ToUint128(gasPrice);\n            }\n            if (gasToken != address(0)) {\n                slot.gasToken = gasToken;\n            }\n            if (refundReceiver != address(0)) {\n                slot.refundReceiver = refundReceiver;\n            }\n            if (data.length > 0) {\n                slot.data = data;\n            }\n\n            emit NewTransaction(\n                safeTxHash,\n                safeAddress,\n                chainId,\n                nonce,\n                to,\n                value,\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                data\n            );\n        }\n    }\n\n    /**\n     * @inheritdoc IHarbourStore\n     */\n    function _storeSignature(\n        address signer,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        bytes32 safeTxHash,\n        bytes32 r,\n        bytes32 vs\n    ) internal override returns (uint256 listIndex) {\n        _signatureLink[keccak256(abi.encodePacked(r, vs))] = safeTxHash;\n\n        SignatureData[] storage list = _sigData[signer][safeAddress][chainId][\n            nonce\n        ];\n        listIndex = list.length;\n\n        list.push(SignatureData({r: r, vs: vs}));\n\n        emit SignatureStored(\n            signer,\n            safeAddress,\n            safeTxHash,\n            chainId,\n            nonce,\n            listIndex\n        );\n    }\n}\n"
    },
    "src/SafeSecretHarbour.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\nimport {\n    NothingToEnqueue,\n    SignerAlreadySignedTransaction,\n    UnexpectedSigner\n} from \"./interfaces/Errors.sol\";\nimport {\n    EncryptionKeyRegistered,\n    SafeTransactionRegistered,\n    SafeTransactionSigned\n} from \"./interfaces/Events.sol\";\nimport {ISafeSecretHarbour} from \"./interfaces/Harbour.sol\";\nimport {\n    EncryptionKey,\n    SafeTransactionRegistrationHandle\n} from \"./interfaces/Types.sol\";\nimport {IERC165} from \"./interfaces/ERC165.sol\";\nimport {BlockNumbers} from \"./libs/BlockNumbers.sol\";\nimport {CoreLib} from \"./libs/CoreLib.sol\";\nimport {RegistrationKey} from \"./libs/RegistrationKey.sol\";\n\n/**\n * @title Safe Secret Harbour\n * @notice Permissionless, append-only registry that lets **any EOA signer** publish encrypted Safe\n *         transactions (\"SafeTx\") and their signatures. Clients without an off-chain indexer can\n *         reconstruct the full multisig payload with only:\n *         1. the Safe address;\n *         2. the target `chainId`;\n *         3. the Safe `nonce`;\n *         4. the current Safe owners set; and\n *         5. a key to decrypt the transaction payload.\n *\n *         Each unique `safeTxHash` (ERC-712 digest of the SafeTx struct) may be registered more\n *         than once, to allow rotating the encryption.\n *\n *         Additionally, this contract contains a public encryption key registry, and functions as\n *         a trustless channel for signers to communicate public encryption keys amongst themselves\n *         in order to support asymmetric encryption schemes of the transaction data.\n */\ncontract SafeSecretHarbour is IERC165, ISafeSecretHarbour {\n    using BlockNumbers for BlockNumbers.T;\n    using BlockNumbers for BlockNumbers.Iterator;\n    using RegistrationKey for RegistrationKey.T;\n\n    // ------------------------------------------------------------------\n    // Storage\n    // ------------------------------------------------------------------\n\n    /**\n     * @dev Mapping of signers to their encryption keys.\n     */\n    mapping(address signer => EncryptionKey) private _encryptionKeys;\n\n    /**\n     * @dev Mapping of registration key to an array of block numbers where a Safe transaction was\n     *      registered with the harbour.\n     *\n     *      Note that the same Safe transaction can be registered **multiple times** with harbour.\n     *      This is important to allow appending additional encryption data (such as new wrapped\n     *      encryption keys for signers that either rotated or registered their public encryption\n     *      key after the initial transaction submission.\n     */\n    mapping(RegistrationKey.T => BlockNumbers.T) private _registrations;\n\n    /**\n     * @dev Mapping per signer from Safe transaction hashes to the block in which a signature was\n     *      registered.\n     */\n    mapping(address signer => mapping(bytes32 safeTxHash => uint256 blockNumber))\n        private _signatures;\n\n    // ------------------------------------------------------------------\n    // ERC-165 Implementation\n    // ------------------------------------------------------------------\n\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) external pure returns (bool) {\n        return\n            interfaceId == type(IERC165).interfaceId ||\n            interfaceId == type(ISafeSecretHarbour).interfaceId;\n    }\n\n    // ------------------------------------------------------------------\n    // External & public write functions\n    // ------------------------------------------------------------------\n\n    /**\n     * @notice Register a public encryption key for a signer.\n     *\n     * @param context   A 32-byte context specific to the public encryption key.\n     * @param publicKey The public encryption key to be registered for the `msg.sender` signer.\n     */\n    function registerEncryptionKey(\n        bytes32 context,\n        bytes32 publicKey\n    ) external {\n        _registerEncryptionKey(msg.sender, context, publicKey);\n    }\n\n    /**\n     * @notice Register a public encryption key on behalf of a signer.\n     *\n     * @param signer    The signer to register the encryption key for.\n     * @param context   A 32-byte context specific to the public encryption key.\n     * @param publicKey The public encryption key to be registered for the `signer`.\n     * @param signature The ECDSA signature of the `signer` over the encryption key registration.\n     */\n    function registerEncryptionKeyFor(\n        address signer,\n        bytes32 context,\n        bytes32 publicKey,\n        bytes calldata signature\n    ) external {\n        bytes32 encryptionKeyHash = CoreLib.computeEncryptionKeyHash(\n            block.chainid,\n            address(this),\n            context,\n            publicKey\n        );\n        (address recoveredSigner, , ) = CoreLib.recoverSigner(\n            encryptionKeyHash,\n            signature\n        );\n        require(recoveredSigner == signer, UnexpectedSigner(recoveredSigner));\n        _registerEncryptionKey(signer, context, publicKey);\n    }\n\n    /**\n     * @notice Register an encrypted Safe transaction and signature.\n     *\n     * @dev This function serves two purposes:\n     *      1. To register Safe transaction encryption data\n     *      2. To add signatures to a Safe transaction\n     *\n     * @param chainId          Chain id the transaction is meant for.\n     * @param safe             Target Safe Smart-Account.\n     * @param nonce            Safe nonce.\n     * @param safeTxStructHash The ERC-712 struct hash of the Safe transaction data.\n     * @param encryptionBlob   A blob containing encrypted transaction data. This can either be the\n     *                         encrypted transaction itself, or additional encrypted keys to new\n     *                         signer public keys. The exact format is not enforced and application\n     *                         dependent. There are no guarantees that the blob actually matches the\n     *                         provided `safeTxStructHash`. The reference implementation uses JWE to\n     *                         encrypt the RLP-encoded Safe transaction with key wrapping for the\n     *                         recipients' X25519 public keys. _Optional_: can be omitted to\n     *                         register a signature without any new encrypted transaction data.\n     * @param signature        A 65-byte ECDSA signature. _Optional_: can be omitted to register\n     *                         new encrypted transaction data without a signature.\n     *\n     * @return uid             The unique signer-specific identifer of the transaction registration.\n     *                         Zero if `encryptionBlob` is empty.\n     *\n     * @custom:events Emits {SafeTransactionSigned} and {SafeTransactionRegistered}.\n     */\n    function enqueueTransaction(\n        uint256 chainId,\n        address safe,\n        uint256 nonce,\n        bytes32 safeTxStructHash,\n        bytes calldata signature,\n        bytes calldata encryptionBlob\n    ) external returns (bytes32 uid) {\n        require(\n            signature.length | encryptionBlob.length != 0,\n            NothingToEnqueue()\n        );\n\n        bytes32 safeTxHash = CoreLib.computePartialSafeTxHash(\n            chainId,\n            safe,\n            safeTxStructHash\n        );\n\n        if (signature.length != 0) {\n            _registerSignature(safeTxHash, signature);\n        }\n\n        if (encryptionBlob.length != 0) {\n            uid = _registerTransaction(\n                chainId,\n                safe,\n                nonce,\n                msg.sender,\n                safeTxHash,\n                encryptionBlob\n            );\n        }\n    }\n\n    // ------------------------------------------------------------------\n    // External & public read functions\n    // ------------------------------------------------------------------\n\n    /**\n     * @notice Retrieves encryption public keys for the specified signers.\n     *\n     * @param signers     The list of signers to fetch encryption keys for.\n     *\n     * @return publicKeys The encryption public keys for each of the signers, or `0` if none was\n     *                    registered. The keys are in the same order as the signers array (i.e. for\n     *                    all `i`, the key for `signer[i]` is `publicKey[i]`).\n     */\n    function retrieveEncryptionPublicKeys(\n        address[] calldata signers\n    ) external view returns (bytes32[] memory publicKeys) {\n        publicKeys = new bytes32[](signers.length);\n        for (uint256 i = 0; i < signers.length; i++) {\n            publicKeys[i] = _encryptionKeys[signers[i]].publicKey;\n        }\n    }\n\n    /**\n     * @notice Retrieves the encryption keys for a signer.\n     *\n     * @param signer         The signer to fetch encryption keys for.\n     *\n     * @return encryptionKey The registered encryption key.\n     */\n    function retrieveEncryptionKey(\n        address signer\n    ) external view returns (EncryptionKey memory encryptionKey) {\n        encryptionKey = _encryptionKeys[signer];\n    }\n\n    /**\n     * @notice Paginated getter for Safe transaction registrations.\n     *\n     * @dev Note that this function does not return the full registered transaction directly, but\n     *      a unique identifier and block number that can be used to query an log with the full\n     *      transaction details.\n     *\n     * @param chainId     Target chain id.\n     * @param safe        Safe Smart-Account.\n     * @param nonce       Safe nonce.\n     * @param notary      Address that registered ecrypted transaction data.\n     * @param start       Zero-based start index of the slice.\n     * @param count       Maximum number of entries to return.\n     *\n     * @return page       Array slice `[start  start+count)` (may be shorter).\n     * @return totalCount Total number of registrations for the `(chainId, safe, nonce, signer)`\n     *                    tuple.\n     */\n    function retrieveRegistrations(\n        uint256 chainId,\n        address safe,\n        uint256 nonce,\n        address notary,\n        uint256 start,\n        uint256 count\n    )\n        external\n        view\n        returns (\n            SafeTransactionRegistrationHandle[] memory page,\n            uint256 totalCount\n        )\n    {\n        RegistrationKey.T registration = RegistrationKey.get(\n            chainId,\n            safe,\n            nonce,\n            notary\n        );\n        BlockNumbers.Iterator memory it = _registrations[registration].iter();\n\n        totalCount = it.count();\n        it.skip(start);\n        it.take(count);\n\n        page = new SafeTransactionRegistrationHandle[](it.count());\n        unchecked {\n            for (uint256 i = 0; it.next(); i++) {\n                SafeTransactionRegistrationHandle memory item = page[i];\n                item.blockNumber = it.value();\n                item.uid = registration.uniqueIdentifier(start + i);\n            }\n        }\n    }\n\n    /**\n     * @notice Convenience getter returning the **number** of registrations stored for a specific\n     *         `(chainId, safe, nonce, notary)` tuple.\n     *\n     * @param chainId Target chain id.\n     * @param safe    Safe Smart-Account.\n     * @param nonce   Safe nonce.\n     * @param notary  Notary address.\n     *\n     * @return count  Number of registrations.\n     */\n    function retrieveRegistrationCount(\n        uint256 chainId,\n        address safe,\n        uint256 nonce,\n        address notary\n    ) external view returns (uint256 count) {\n        RegistrationKey.T registration = RegistrationKey.get(\n            chainId,\n            safe,\n            nonce,\n            notary\n        );\n        count = _registrations[registration].len();\n    }\n\n    /**\n     * @notice Retrieve Safe transaction signatures for the specified signers.\n     *\n     * @dev Note that this function does not return the signature directly, the block number that\n     *      can be used to query an log with the signature bytes.\n     *\n     * @param signers    The signer addresses.\n     * @param safeTxHash ERC-712 digest of the transaction\n     *\n     * @return blockNumbers The block numbers containing the Safe transaction signature events for\n     *                      the specified signers and Safe transaction hash.\n     */\n    function retrieveSignatures(\n        address[] calldata signers,\n        bytes32 safeTxHash\n    ) external view returns (uint256[] memory blockNumbers) {\n        blockNumbers = new uint256[](signers.length);\n        unchecked {\n            for (uint256 i = 0; i < signers.length; i++) {\n                blockNumbers[i] = _signatures[signers[i]][safeTxHash];\n            }\n        }\n    }\n\n    // ------------------------------------------------------------------\n    // Private functions\n    // ------------------------------------------------------------------\n\n    /**\n     * @notice Private function to register a public encryption key for a signer.\n     *\n     * @param signer    The signer to register the encryption key for.\n     * @param context   A 32-byte context specific to the public encryption key.\n     * @param publicKey The public encryption key to be registered for the `signer`.\n     */\n    function _registerEncryptionKey(\n        address signer,\n        bytes32 context,\n        bytes32 publicKey\n    ) private {\n        _encryptionKeys[signer] = EncryptionKey(context, publicKey);\n        emit EncryptionKeyRegistered(signer, context, publicKey);\n    }\n\n    /**\n     * @dev Private function to register a Safe transaction.\n     *\n     * @param chainId        Chain id the transaction is meant for.\n     * @param safe           Safe Smart-Account.\n     * @param nonce          Safe nonce.\n     * @param notary         The account that submitted the encrypted transaction data blob for\n     *                       registration.\n     * @param safeTxHash     ERC-712 digest of the transaction.\n     * @param encryptionBlob The Safe transaction encryption blob.\n     *\n     * @return uid       The unique signer-specific identifer of the registration.\n     */\n    function _registerTransaction(\n        uint256 chainId,\n        address safe,\n        uint256 nonce,\n        address notary,\n        bytes32 safeTxHash,\n        bytes calldata encryptionBlob\n    ) private returns (bytes32 uid) {\n        RegistrationKey.T registration = RegistrationKey.get(\n            chainId,\n            safe,\n            nonce,\n            notary\n        );\n        uint256 index = _registrations[registration].append(block.number);\n\n        uid = registration.uniqueIdentifier(index);\n        emit SafeTransactionRegistered(uid, safeTxHash, encryptionBlob);\n    }\n\n    /**\n     * @dev Private function to register a Safe transaction signature after validation.\n     *\n     * @param safeTxHash ERC-712 digest of the transaction.\n     * @param signature  The ECDSA signature bytes.\n     */\n    function _registerSignature(\n        bytes32 safeTxHash,\n        bytes calldata signature\n    ) private {\n        (address signer, , ) = CoreLib.recoverSigner(safeTxHash, signature);\n        require(\n            _signatures[signer][safeTxHash] == 0,\n            SignerAlreadySignedTransaction(signer, safeTxHash)\n        );\n\n        _signatures[signer][safeTxHash] = block.number;\n        emit SafeTransactionSigned(signer, safeTxHash, signature);\n    }\n}\n"
    },
    "src/test/TestCoreLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\nimport {CoreLib} from \"../libs/CoreLib.sol\";\n\ncontract TestCoreLib {\n    function testSplitSV(bytes32 vs) public pure returns (bytes32 s, uint8 v) {\n        return CoreLib.splitVS(vs);\n    }\n}\n"
    },
    "src/test/TestErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\nerror NotImplemented();\n"
    },
    "src/test/TestQuotaManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n/* solhint-disable no-unused-import */\npragma solidity ^0.8.29;\n\nimport {QuotaMixin, QuotaMixinConfig} from \"../mixins/QuotaMixin.sol\";\n\ncontract TestQuotaManager is QuotaMixin {\n    error TestOverQuota();\n\n    constructor(\n        QuotaMixinConfig memory _quotaMixinconfig\n    ) QuotaMixin(_quotaMixinconfig) {}\n\n    function checkAndUpdateQuota(\n        address signer,\n        uint256 requiredSignerQuota\n    ) public {\n        require(\n            _checkAndUpdateQuota(signer, requiredSignerQuota),\n            TestOverQuota()\n        );\n    }\n}\n"
    },
    "src/test/TestSlasher.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\nimport {SlashingMixin, SlashingMixinConfig} from \"../mixins/SlashingMixin.sol\";\nimport {IEntryPoint} from \"../interfaces/ERC4337.sol\";\nimport {NotImplemented} from \"./TestErrors.sol\";\n\n/* solhint-disable no-empty-blocks */\ncontract TestSlasher is SlashingMixin {\n    error TestOverQuota();\n\n    address public immutable SUPPORTED_ENTRYPOINT;\n    address public immutable FEE_TOKEN;\n\n    constructor(\n        address _entryPoint,\n        address _feeToken,\n        SlashingMixinConfig memory _config\n    ) SlashingMixin(_config) {\n        FEE_TOKEN = _feeToken;\n        SUPPORTED_ENTRYPOINT = _entryPoint;\n    }\n\n    function getSupportedEntrypoint()\n        public\n        view\n        override\n        returns (IEntryPoint)\n    {\n        return IEntryPoint(SUPPORTED_ENTRYPOINT);\n    }\n\n    function _checkAndUpdateQuota(\n        address,\n        uint256\n    ) internal pure override returns (bool) {\n        revert NotImplemented();\n    }\n\n    function _withdrawSignerTokens(\n        address,\n        address,\n        uint96,\n        bool\n    ) internal pure override {\n        // noop\n    }\n\n    function _transferFeeToken(address, uint96) internal pure override {\n        revert NotImplemented();\n    }\n\n    function _adjustSlashingAmount(\n        address,\n        uint96 slashingAmount\n    ) internal pure override returns (uint96) {\n        return slashingAmount;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "cancun",
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}