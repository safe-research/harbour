{
  "language": "Solidity",
  "sources": {
    "src/SafeInternationalHarbour.sol": {
      "content": "// // SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.29;\n\n/**\n * @title SafeInternationalHarbour\n * @notice Permissionless, append-only registry that lets **any EOA signer** publish Safe\n *         transactions (\"SafeTx\") and their signatures. Clients without an off-chain indexer can reconstruct the full multisig payload with only:\n *         1. the Safe address;\n *         2. the target `chainId`;\n *         3. the Safe `nonce`; and\n *         4. the current Safe owners set.\n *\n * Each unique `safeTxHash` (EIP-712 digest of the SafeTx struct) is persisted **once** together with\n * its parameters. Signatures are appended under the composite key\n * `(signer, safe, chainId, nonce)`, enabling on-chain, gas-efficient look-ups.\n *\n * ### ⚠️ Contract-based signers unsupported\n * Only ECDSA signatures from externally-owned accounts (EOAs) are supported. Contract wallets that\n * rely on ERC-1271 or similar cannot be verified on-chain in a chain-agnostic way and are therefore\n * **not supported**.\n *\n * @dev The {SignatureStored} event is the only hook required by indexers; however, the contract is\n *      fully functional without any off-chain infrastructure.\n */\ncontract SafeInternationalHarbour {\n    // ------------------------------------------------------------------\n    // Errors\n    // ------------------------------------------------------------------\n\n    /// Thrown when a signature blob is not exactly 65 bytes.\n    error InvalidECDSASignatureLength();\n\n    /// Thrown if `ecrecover` yields `address(0)`.\n    error InvalidSignature();\n\n    /// Thrown if the S value of the signature is not from the lower half of the curve.\n    error InvalidSignatureSValue();\n\n\n    /// Thrown when a value doesn't fit in a uint128.\n    error ValueDoesNotFitInUint128();\n\n    /// @notice Thrown when attempting to store a signature for a transaction (safeTxHash)\n    /// that the signer has already provided a signature for.\n    /// @param signer Signer address.\n    /// @param safeTxHash The EIP-712 hash of the Safe transaction.\n    error SignerAlreadySignedTransaction(address signer, bytes32 safeTxHash);\n\n    // ------------------------------------------------------------------\n    // Constants\n    // ------------------------------------------------------------------\n\n    /// The hashes must be the same as the ones in the Safe contract:\n    /// https://github.com/safe-global/safe-smart-account/blob/b115c4c5fe23dca6aefeeccc73d312ddd23322c2/contracts/Safe.sol#L54-L63\n    /// These should cover Safe versions 1.3.0 and 1.4.1\n    /// keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\")\n    bytes32 private constant DOMAIN_TYPEHASH =\n        0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    /// keccak256(\"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\")\n    bytes32 private constant SAFE_TX_TYPEHASH =\n        0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    /// The lower bound of the S value for a valid secp256k1 signature.\n    /// https://github.com/safe-global/safe-smart-account/blob/b115c4c5fe23dca6aefeeccc73d312ddd23322c2/contracts/Safe.sol#L100\n    bytes32 private constant SECP256K1_LOW_S_BOUND =\n        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\n\n    // ------------------------------------------------------------------\n    // Data structures\n    // ------------------------------------------------------------------\n\n    /**\n     * @dev Storage optimised mirror of the SafeTx struct used by Safe contracts.\n     *      Non-optimised version uses uint256 for:\n     *      - value\n     *      - safeTxGas\n     *      - baseGas\n     *      - gasPrice\n     */\n    struct SafeTransaction {\n        // stored, operation and to will be packed into the same storage slot\n        bool stored;\n        uint8 operation;\n        address to;\n        uint128 value;\n        uint128 safeTxGas;\n        uint128 baseGas;\n        uint128 gasPrice;\n        address gasToken;\n        address refundReceiver;\n        bytes data;\n    }\n\n    /**\n     * @dev Minimal, storage-optimised representation of an ECDSA signature.\n     */\n    struct SignatureDataWithTxHashIndex {\n        bytes32 r;\n        // vs is the compact representation of s and v coming from\n        // EIP-2098: https://eips.ethereum.org/EIPS/eip-2098\n        bytes32 vs;\n        bytes32 txHash; // EIP-712 digest this signature belongs to\n    }\n\n    // ------------------------------------------------------------------\n    // Storage\n    // ------------------------------------------------------------------\n\n    /// Mapping `safeTxHash → SafeTransaction` parameters\n    mapping(bytes32 => SafeTransaction) private _txDetails;\n\n    /// Mapping `signer → safe → chainId → nonce → SignatureDataWithTxHashIndex[]`\n    /// Stores the list of signatures provided by a signer for a given Safe context.\n    /// Note: A single list entry here could contain signatures for *different* `safeTxHash` values\n    /// if those transactions share the same (safe, chainId, nonce). Use `_hasSignerSignedTx`\n    /// to ensure a signer only signs a specific `safeTxHash` once.\n    mapping(address signer => mapping(address safe => mapping(uint256 chainId => mapping(uint256 nonce => SignatureDataWithTxHashIndex[]))))\n        private _sigData;\n\n    /// @dev Tracks if a signer has already submitted *any* signature for a specific safeTxHash,\n    ///      preventing duplicate signatures for the *exact same* transaction digest.\n    ///      This complements `_sigData` by ensuring uniqueness per (safeTxHash, signer) pair.\n    /// Mapping `safeTxHash → signer → bool`\n    mapping(bytes32 safeTxHash => mapping(address signer => bool))\n        private _hasSignerSignedTx;\n\n    // ------------------------------------------------------------------\n    // Events\n    // ------------------------------------------------------------------\n\n    /**\n     * @notice Emitted whenever a new signature is stored (and possibly the parameters on first sight).\n     *\n     * @param signer     Address recovered from the provided signature.\n     * @param safe       Safe Smart-Account the transaction targets.\n     * @param safeTxHash EIP-712 hash identifying the SafeTx.\n     * @param chainId    Intended execution chain.\n     * @param nonce      Safe nonce.\n     * @param listIndex  Position of the signature in the signer-specific array.\n     */\n    event SignatureStored(\n        address indexed signer,\n        address indexed safe,\n        bytes32 indexed safeTxHash,\n        uint256 chainId,\n        uint256 nonce,\n        uint256 listIndex\n    );\n\n    /**\n     * @notice Emitted when a transaction is first stored.\n     * @param safeTxHash EIP-712 hash identifying the SafeTx.\n     * @param safe       Safe Smart-Account the transaction targets.\n     * @param chainId    Intended execution chain.\n     * @param nonce      Safe nonce.\n     * @param to         Destination of the inner call/delegatecall.\n     * @param value      ETH value forwarded by the Safe.\n     * @param operation  0 = CALL, 1 = DELEGATECALL.\n     * @param safeTxGas  Gas forwarded to the inner call.\n     * @param baseGas    Fixed overhead reimbursed to the submitting signer.\n     * @param gasPrice   Gas price used for reimbursement.\n     * @param gasToken   ERC-20 token address for refunds.\n     * @param refundReceiver Address receiving the gas refund.\n     * @param data       Calldata executed by the Safe.\n     */\n    event NewTransaction(\n        bytes32 indexed safeTxHash,\n        address indexed safe,\n        uint256 indexed chainId,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        bytes data\n    );\n\n    // ------------------------------------------------------------------\n    // External & public functions\n    // ------------------------------------------------------------------\n\n    /**\n     * @notice Publish a Safe transaction and/or append a signature to it.\n     *\n     * @dev If `safeTxHash` has been seen before, its parameters are *not* validated nor overwritten –\n     *      the call simply appends the `(r,s)` pair for `signer`.\n     *\n     * @param safeAddress    Target Safe Smart-Account.\n     * @param chainId        Chain id the transaction is meant for.\n     * @param nonce          Safe nonce.\n     * @param to             Destination of the inner call/delegatecall.\n     * @param value          ETH value forwarded by the Safe.\n     * @param data           Calldata executed by the Safe.\n     * @param operation      0 = CALL, 1 = DELEGATECALL.\n     * @param safeTxGas      Gas forwarded to the inner call.\n     * @param baseGas        Fixed overhead reimbursed to the submitting signer.\n     * @param gasPrice       Gas price used for reimbursement.\n     * @param gasToken       ERC-20 token address for refunds (`address(0)` = ETH).\n     * @param refundReceiver Address receiving the gas refund.\n     * @param signature      **Single** 65-byte ECDSA signature.\n     *\n     * @return listIndex     Index of the stored signature in the signer-specific list.\n     *\n     * @custom:events Emits {SignatureStored}.\n     */\n    function enqueueTransaction(\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        bytes calldata signature\n    ) external returns (uint256 listIndex) {\n        require(signature.length == 65, InvalidECDSASignatureLength());\n\n        // ------------------------------------------------------------------\n        // Build the EIP-712 digest that uniquely identifies the SafeTx\n        // ------------------------------------------------------------------\n        bytes32 safeTxHash = computeSafeTxHash(\n            safeAddress,\n            chainId,\n            nonce,\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver\n        );\n\n        (address signer, bytes32 r, bytes32 vs) = recoverSigner(\n            safeTxHash,\n            signature\n        );\n\n        // Store parameters only once (idempotent write)\n        SafeTransaction storage slot = _txDetails[safeTxHash];\n        if (!slot.stored) {\n            // first encounter → persist full parameter set\n            slot.stored = true;\n            slot.to = to;\n            slot.operation = operation;\n\n            // Writing to storage is expensive, so we only write if the value is non-zero\n            if (value > 0) {\n                slot.value = _safeCastUint256ToUint128(value);\n            }\n            if (safeTxGas > 0) {\n                slot.safeTxGas = _safeCastUint256ToUint128(safeTxGas);\n            }\n            if (baseGas > 0) {\n                slot.baseGas = _safeCastUint256ToUint128(baseGas);\n            }\n            if (gasPrice > 0) {\n                slot.gasPrice = _safeCastUint256ToUint128(gasPrice);\n            }\n            if (gasToken != address(0)) {\n                slot.gasToken = gasToken;\n            }\n            if (refundReceiver != address(0)) {\n                slot.refundReceiver = refundReceiver;\n            }\n            if (data.length > 0) {\n                slot.data = data;\n            }\n\n            emit NewTransaction(\n                safeTxHash,\n                safeAddress,\n                chainId,\n                nonce,\n                to,\n                value,\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                data\n            );\n        }\n\n        return\n            _storeSignature(\n                signer,\n                safeAddress,\n                chainId,\n                nonce,\n                safeTxHash,\n                r,\n                vs\n            );\n    }\n\n    /**\n     * @dev Internal function to store a signature after validation.\n     *\n     * @param signer        Address that signed the transaction.\n     * @param safeAddress   Target Safe Smart-Account.\n     * @param chainId       Chain id the transaction is meant for.\n     * @param nonce         Safe nonce.\n     * @param safeTxHash    EIP-712 digest of the transaction.\n     * @param r             First 32 bytes of the signature.\n     * @param vs            Compact representation of s and v from EIP-2098.\n     *\n     * @return listIndex    Index of the stored signature in the signer-specific list.\n     */\n    function _storeSignature(\n        address signer,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        bytes32 safeTxHash,\n        bytes32 r,\n        bytes32 vs\n    ) internal returns (uint256 listIndex) {\n        // --- DUPLICATE TRANSACTION SIGNATURE CHECK ---\n        // Revert if this signer has already submitted *any* signature for this *exact* safeTxHash\n        require(\n            !_hasSignerSignedTx[safeTxHash][signer],\n            SignerAlreadySignedTransaction(signer, safeTxHash)\n        );\n\n        _hasSignerSignedTx[safeTxHash][signer] = true;\n\n        SignatureDataWithTxHashIndex[] storage list = _sigData[signer][\n            safeAddress\n        ][chainId][nonce];\n        listIndex = list.length;\n\n        list.push(\n            SignatureDataWithTxHashIndex({r: r, vs: vs, txHash: safeTxHash})\n        );\n\n        emit SignatureStored(\n            signer,\n            safeAddress,\n            safeTxHash,\n            chainId,\n            nonce,\n            listIndex\n        );\n    }\n\n    /**\n     * @notice Retrieve the full parameter set of a Safe transaction.\n     *\n     * @param safeTxHash EIP-712 digest of the transaction.\n     *\n     * @return txParams Struct with all SafeTx parameters (zero-initialised if unknown).\n     */\n    function retrieveTransaction(\n        bytes32 safeTxHash\n    ) external view returns (SafeTransaction memory txParams) {\n        txParams = _txDetails[safeTxHash];\n    }\n\n    /**\n     * @notice Paginated getter for signature entries.\n     *\n     * @param signerAddress Address that created the signatures.\n     * @param safeAddress   Safe Smart-Account.\n     * @param chainId       Target chain id.\n     * @param nonce         Safe nonce.\n     * @param start         Zero-based start index of the slice.\n     * @param count         Maximum number of entries to return.\n     *\n     * @return page       Array slice `[start … start+count)` (may be shorter).\n     * @return totalCount Total number of signatures stored for the tuple.\n     */\n    function retrieveSignatures(\n        address signerAddress,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        uint256 start,\n        uint256 count\n    )\n        external\n        view\n        returns (SignatureDataWithTxHashIndex[] memory page, uint256 totalCount)\n    {\n        SignatureDataWithTxHashIndex[] storage all = _sigData[signerAddress][\n            safeAddress\n        ][chainId][nonce];\n        totalCount = all.length;\n        if (start >= totalCount)\n            return (new SignatureDataWithTxHashIndex[](0), totalCount);\n\n        uint256 end = start + count;\n        if (end > totalCount) end = totalCount;\n        uint256 len = end - start;\n\n        page = new SignatureDataWithTxHashIndex[](len);\n        for (uint256 i; i < len; ++i) {\n            page[i] = all[start + i];\n        }\n    }\n\n    /**\n     * @notice Convenience getter returning the **number** of signatures stored for the key tuple.\n     *\n     * @param signerAddress Signer address.\n     * @param safeAddress   Safe Smart-Account.\n     * @param chainId       Target chain id.\n     * @param nonce         Safe nonce.\n     *\n     * @return count Length of the signature list.\n     */\n    function retrieveSignaturesCount(\n        address signerAddress,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce\n    ) external view returns (uint256 count) {\n        count = _sigData[signerAddress][safeAddress][chainId][nonce].length;\n    }\n\n    /**\n     * @notice Computes the unique EIP-712 digest for a SafeTx using the provided parameters and domain.\n     * @param safeAddress Address of the target Safe Smart Account.\n     * @param chainId Chain ID included in the domain separator.\n     * @param nonce Safe transaction nonce.\n     * @param to Target address the Safe will call.\n     * @param value ETH value to be sent with the call.\n     * @param data Call data executed by the Safe.\n     * @param operation Operation type: 0 = CALL, 1 = DELEGATECALL.\n     * @param safeTxGas Gas limit for the Safe's internal execution.\n     * @param baseGas Base gas overhead for reimbursement.\n     * @param gasPrice Gas price used for reimbursement calculation.\n     * @param gasToken Token address for refunds (0x0 for ETH).\n     * @param refundReceiver Address to receive gas refunds.\n     * @return safeTxHash Keccak256 digest of the EIP-712 encoded SafeTx.\n     */\n    function computeSafeTxHash(\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver\n    ) private pure returns (bytes32 safeTxHash) {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, chainId, safeAddress)\n        );\n        bytes32 structHash = keccak256(\n            abi.encode(\n                SAFE_TX_TYPEHASH,\n                to,\n                value,\n                keccak256(data),\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                nonce\n            )\n        );\n        safeTxHash = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n    }\n\n    /**\n     * @notice Splits a 65-byte ECDSA signature into its components and recovers the signer address.\n     * @param digest The message or data hash to verify (EIP-712 digest or eth_sign prefixed).\n     * @param sig Concatenated 65-byte ECDSA signature (r || s || v).\n     * @return signer The address that produced the signature (EOA).\n     * @return r First 32 bytes of the ECDSA signature.\n     * @return vs Compact representation of s and v coming from EIP-2098.\n     * @dev Supports both EIP-712 and eth_sign flows by detecting v > 30 and applying the Ethereum Signed Message prefix.\n     */\n    function recoverSigner(\n        bytes32 digest,\n        bytes calldata sig\n    ) private pure returns (address signer, bytes32 r, bytes32 vs) {\n        uint8 v;\n        bytes32 s;\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            r := calldataload(sig.offset)\n            s := calldataload(add(sig.offset, 0x20))\n            v := byte(0, calldataload(add(sig.offset, 0x40)))\n        }\n        require(s <= SECP256K1_LOW_S_BOUND, InvalidSignatureSValue());\n\n        signer = ecrecover(digest, v, r, s);\n        require(signer != address(0), InvalidSignature());\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            // Equivalent to:\n            // vs = bytes32(uint256(v - 27)  << 255 | uint256(s));\n            // Which should avoid conversion between uint256 and bytes32\n            vs := or(shl(255, sub(v, 27)), s)\n        }\n    }\n\n    function _safeCastUint256ToUint128(\n        uint256 value\n    ) private pure returns (uint128) {\n        require(value <= type(uint128).max, ValueDoesNotFitInUint128());\n        return uint128(value);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}