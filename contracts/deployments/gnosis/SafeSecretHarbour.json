{
  "address": "0x2F150e90Ec1d33A3D939bcF4ED80108ACd47995b",
  "abi": [
    {
      "inputs": [],
      "name": "EncryptionKeyRegistrationExpired",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidECDSASignatureLength",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "currentNonce",
          "type": "uint256"
        }
      ],
      "name": "InvalidEncryptionKeyRegistrationNonce",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSignature",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSignatureSValue",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NothingToEnqueue",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "signer",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "safeTxHash",
          "type": "bytes32"
        }
      ],
      "name": "SignerAlreadySignedTransaction",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "recoveredSigner",
          "type": "address"
        }
      ],
      "name": "UnexpectedSigner",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "signer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "context",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "publicKey",
          "type": "bytes32"
        }
      ],
      "name": "EncryptionKeyRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "uid",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "safeTxHash",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "encryptionBlob",
          "type": "bytes"
        }
      ],
      "name": "SafeTransactionRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "signer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "safeTxHash",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "SafeTransactionSigned",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "safe",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "safeTxStructHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "encryptionBlob",
          "type": "bytes"
        }
      ],
      "name": "enqueueTransaction",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "uid",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "context",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "publicKey",
          "type": "bytes32"
        }
      ],
      "name": "registerEncryptionKey",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "signer",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "context",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "publicKey",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "registerEncryptionKeyFor",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "signer",
          "type": "address"
        }
      ],
      "name": "retrieveEncryptionKey",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "context",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "publicKey",
              "type": "bytes32"
            }
          ],
          "internalType": "struct EncryptionKey",
          "name": "encryptionKey",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "signer",
          "type": "address"
        }
      ],
      "name": "retrieveEncryptionKeyRegistrationNonce",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "signers",
          "type": "address[]"
        }
      ],
      "name": "retrieveEncryptionPublicKeys",
      "outputs": [
        {
          "internalType": "bytes32[]",
          "name": "publicKeys",
          "type": "bytes32[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "signers",
          "type": "address[]"
        },
        {
          "internalType": "bytes32",
          "name": "safeTxHash",
          "type": "bytes32"
        }
      ],
      "name": "retrieveSignatures",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "blockNumbers",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "safe",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "notary",
          "type": "address"
        }
      ],
      "name": "retrieveTransactionCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "count",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "safe",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "notary",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "start",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "count",
          "type": "uint256"
        }
      ],
      "name": "retrieveTransactions",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "blockNumber",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "uid",
              "type": "bytes32"
            }
          ],
          "internalType": "struct SafeTransactionRegistrationHandle[]",
          "name": "page",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "totalCount",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0xb37795f33f64e81bc76e59f3a748538f234f1774a4222a9a1bbead623539d9f7",
  "receipt": {
    "to": "0x914d7Fec6aaC8cd542e72Bca78B30650d45643d7",
    "from": "0xFEb6565bdd4Aec9bD836f3Ec7c7c0ffA79d025A4",
    "contractAddress": null,
    "transactionIndex": 13,
    "gasUsed": "1077148",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x3e8ea185c2ca58c2cbcc666aff61789e911c7fbd312d945f5289f2fe84cfe483",
    "transactionHash": "0xb37795f33f64e81bc76e59f3a748538f234f1774a4222a9a1bbead623539d9f7",
    "logs": [],
    "blockNumber": 41953027,
    "cumulativeGasUsed": "10526371",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "c0bc0a22b7a6c2ca0baddf8faf3e8db6",
  "metadata": "{\"compiler\":{\"version\":\"0.8.29+commit.ab55807c\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"EncryptionKeyRegistrationExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidECDSASignatureLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentNonce\",\"type\":\"uint256\"}],\"name\":\"InvalidEncryptionKeyRegistrationNonce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignatureSValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NothingToEnqueue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"safeTxHash\",\"type\":\"bytes32\"}],\"name\":\"SignerAlreadySignedTransaction\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recoveredSigner\",\"type\":\"address\"}],\"name\":\"UnexpectedSigner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"publicKey\",\"type\":\"bytes32\"}],\"name\":\"EncryptionKeyRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"uid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"safeTxHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"encryptionBlob\",\"type\":\"bytes\"}],\"name\":\"SafeTransactionRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"safeTxHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"SafeTransactionSigned\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"safeTxStructHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"encryptionBlob\",\"type\":\"bytes\"}],\"name\":\"enqueueTransaction\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"uid\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"publicKey\",\"type\":\"bytes32\"}],\"name\":\"registerEncryptionKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"publicKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"registerEncryptionKeyFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"retrieveEncryptionKey\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"publicKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct EncryptionKey\",\"name\":\"encryptionKey\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"retrieveEncryptionKeyRegistrationNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"signers\",\"type\":\"address[]\"}],\"name\":\"retrieveEncryptionPublicKeys\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"publicKeys\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"signers\",\"type\":\"address[]\"},{\"internalType\":\"bytes32\",\"name\":\"safeTxHash\",\"type\":\"bytes32\"}],\"name\":\"retrieveSignatures\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"blockNumbers\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"notary\",\"type\":\"address\"}],\"name\":\"retrieveTransactionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"notary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"retrieveTransactions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"uid\",\"type\":\"bytes32\"}],\"internalType\":\"struct SafeTransactionRegistrationHandle[]\",\"name\":\"page\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"totalCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"InvalidEncryptionKeyRegistrationNonce(uint256)\":[{\"params\":{\"currentNonce\":\"The current encryption key registration nonce, which is valid.\"}}],\"SignerAlreadySignedTransaction(address,bytes32)\":[{\"params\":{\"safeTxHash\":\"The EIP-712 hash of the Safe transaction.\",\"signer\":\"Signer address.\"}}]},\"events\":{\"EncryptionKeyRegistered(address,bytes32,bytes32)\":{\"params\":{\"context\":\"A 32-byte contract associated with the encryption key.\",\"publicKey\":\"A 32-byte encryption public key.\",\"signer\":\"The signer for which the key was registered.\"}},\"SafeTransactionRegistered(bytes32,bytes32,bytes)\":{\"params\":{\"encryptionBlob\":\"A blob containing encrypted transaction data. This can either be the                       encrypted transaction itself, or additional encrypted keys to new signer                       public keys. The exact format is not enforced and application dependent.                       The reference implementation uses JWE to encrypt the RLP-encoded Safe                       transaction with A256-GCM encryption, and ECDH-ES+A256KW for wrapping the                       encryption keys for recipients' X25519 public keys.\",\"safeTxHash\":\"EIP-712 hash identifying the Safe transaction.\",\"uid\":\"A unique registration identifier that can be used for event filtering.\"}},\"SafeTransactionSigned(address,bytes32,bytes)\":{\"params\":{\"safeTxHash\":\"The Safe transaction hash that was signed.\",\"signature\":\"The Safe transaction signature.\",\"signer\":\"The signer address.\"}}},\"kind\":\"dev\",\"methods\":{\"enqueueTransaction(uint256,address,uint256,bytes32,bytes,bytes)\":{\"custom:events\":\"Emits {SafeTransactionSigned} and {SafeTransactionRegistered}.\",\"details\":\"This function serves two purposes:      1. To register Safe transaction encryption data      2. To add signatures to a Safe transaction\",\"params\":{\"chainId\":\"Chain id the transaction is meant for.\",\"encryptionBlob\":\"A blob containing encrypted transaction data. This can either be the                         encrypted transaction itself, or additional encrypted keys to new                         signer public keys. The exact format is not enforced and application                         dependent. There are no guarantees that the blob actually matches the                         provided `safeTxStructHash`. The reference implementation uses JWE to                         encrypt the RLP-encoded Safe transaction with key wrapping for the                         recipients' X25519 public keys. _Optional_: can be omitted to                         register a signature without any new encrypted transaction data.\",\"nonce\":\"Safe nonce.\",\"safe\":\"Target Safe Smart-Account.\",\"safeTxStructHash\":\"The ERC-712 struct hash of the Safe transaction data.\",\"signature\":\"A 65-byte ECDSA signature. _Optional_: can be omitted to register                         new encrypted transaction data without a signature.\"},\"returns\":{\"uid\":\"            The unique signer-specific identifer of the transaction registration.                         Zero if `encryptionBlob` is empty.\"}},\"registerEncryptionKey(bytes32,bytes32)\":{\"params\":{\"context\":\"A 32-byte context specific to the public encryption key.\",\"publicKey\":\"The public encryption key to be registered for the `msg.sender` signer.\"}},\"registerEncryptionKeyFor(address,bytes32,bytes32,uint256,uint256,bytes)\":{\"params\":{\"context\":\"A 32-byte context specific to the public encryption key.\",\"deadline\":\"Deadline for the registration.\",\"nonce\":\"Encryption key registration nonce.\",\"publicKey\":\"The public encryption key to be registered for the `signer`.\",\"signature\":\"The ECDSA signature of the `signer` over the encryption key registration.\",\"signer\":\"The signer to register the encryption key for.\"}},\"retrieveEncryptionKey(address)\":{\"params\":{\"signer\":\"The signer to fetch encryption keys for.\"},\"returns\":{\"encryptionKey\":\"The registered encryption key.\"}},\"retrieveEncryptionKeyRegistrationNonce(address)\":{\"params\":{\"signer\":\"The signer to fetch encryption key registration nonce for.\"},\"returns\":{\"nonce\":\"The current encryption key registration nonce.\"}},\"retrieveEncryptionPublicKeys(address[])\":{\"params\":{\"signers\":\"The list of signers to fetch encryption keys for.\"},\"returns\":{\"publicKeys\":\"The encryption public keys for each of the signers, or `0` if none was                    registered. The keys are in the same order as the signers array (i.e. for                    all `i`, the key for `signer[i]` is `publicKey[i]`).\"}},\"retrieveSignatures(address[],bytes32)\":{\"details\":\"Note that this function does not return the signature directly, the block number that      can be used to query an log with the signature bytes.\",\"params\":{\"safeTxHash\":\"ERC-712 digest of the transaction\",\"signers\":\"The signer addresses.\"},\"returns\":{\"blockNumbers\":\"The block numbers containing the Safe transaction signature events for                      the specified signers and Safe transaction hash.\"}},\"retrieveTransactionCount(uint256,address,uint256,address)\":{\"params\":{\"chainId\":\"Target chain id.\",\"nonce\":\"Safe nonce.\",\"notary\":\"Notary address.\",\"safe\":\"Safe Smart-Account.\"},\"returns\":{\"count\":\" Number of registrations.\"}},\"retrieveTransactions(uint256,address,uint256,address,uint256,uint256)\":{\"details\":\"Note that this function does not return the full registered transaction directly, but      a unique identifier and block number that can be used to query an log with the full      transaction details.\",\"params\":{\"chainId\":\"Target chain id.\",\"count\":\"Maximum number of entries to return.\",\"nonce\":\"Safe nonce.\",\"notary\":\"Address that registered ecrypted transaction data.\",\"safe\":\"Safe Smart-Account.\",\"start\":\"Zero-based start index of the slice.\"},\"returns\":{\"page\":\"      Array slice `[start \\u2026 start+count)` (may be shorter).\",\"totalCount\":\"Total number of registrations for the `(chainId, safe, nonce, signer)`                    tuple.\"}}},\"stateVariables\":{\"_encryptionKeyRegistrationNonces\":{\"details\":\"Mapping of signers to their encryption key registration nonces, to prevent replaying      past encryption key registrations after a key rotation.\"},\"_encryptionKeys\":{\"details\":\"Mapping of signers to their encryption keys.\"},\"_signatures\":{\"details\":\"Mapping per signer from Safe transaction hashes to the block in which a signature was      registered.\"},\"_transactions\":{\"details\":\"Mapping of registration selector to an array of block numbers where Safe transactions      were registered with the harbour.      Note that the same Safe transaction can be registered **multiple times** with harbour.      This is important to allow appending additional encryption data (such as new wrapped      encryption keys for signers that either rotated or registered their public encryption      key after the initial transaction submission).\"}},\"title\":\"Safe Secret Harbour\",\"version\":1},\"userdoc\":{\"errors\":{\"EncryptionKeyRegistrationExpired()\":[{\"notice\":\"Thrown when attempting to register an encryption key on behalf of the user with an         expired signature.\"}],\"InvalidECDSASignatureLength()\":[{\"notice\":\"Thrown when a signature blob is not exactly 65 bytes.\"}],\"InvalidEncryptionKeyRegistrationNonce(uint256)\":[{\"notice\":\"Thrown when registering an encryption key on behalf of a signer with an invalid nonce.\"}],\"InvalidSignature()\":[{\"notice\":\"Thrown if `ecrecover` yields `address(0)`.\"}],\"InvalidSignatureSValue()\":[{\"notice\":\"Thrown if the S value of the signature is not from the lower half of the curve.\"}],\"NothingToEnqueue()\":[{\"notice\":\"Thrown when attempting to enqueue nothing. That is, when calling `enqueueTransaction` on         the {SafeSecretHarbour} with empty `signature` and `encryptionBlob`.\"}],\"SignerAlreadySignedTransaction(address,bytes32)\":[{\"notice\":\"Thrown when attempting to store a signature for a transaction (safeTxHash) that the signer has already provided a signature for.\"}]},\"events\":{\"EncryptionKeyRegistered(address,bytes32,bytes32)\":{\"notice\":\"Emitted whenever an encryption key is registered for a signer.\"},\"SafeTransactionRegistered(bytes32,bytes32,bytes)\":{\"notice\":\"Emitted whenever a signed encrypted Safe transaction is registered.\"},\"SafeTransactionSigned(address,bytes32,bytes)\":{\"notice\":\"Emitted when a Safe transaction is signed.\"}},\"kind\":\"user\",\"methods\":{\"enqueueTransaction(uint256,address,uint256,bytes32,bytes,bytes)\":{\"notice\":\"Register an encrypted Safe transaction and signature.\"},\"registerEncryptionKey(bytes32,bytes32)\":{\"notice\":\"Register a public encryption key for a signer.\"},\"registerEncryptionKeyFor(address,bytes32,bytes32,uint256,uint256,bytes)\":{\"notice\":\"Register a public encryption key on behalf of a signer.\"},\"retrieveEncryptionKey(address)\":{\"notice\":\"Retrieves the encryption keys for a signer.\"},\"retrieveEncryptionKeyRegistrationNonce(address)\":{\"notice\":\"Retrieves the current encryption key registration nonce for signing.\"},\"retrieveEncryptionPublicKeys(address[])\":{\"notice\":\"Retrieves encryption public keys for the specified signers.\"},\"retrieveSignatures(address[],bytes32)\":{\"notice\":\"Retrieve Safe transaction signatures for the specified signers.\"},\"retrieveTransactionCount(uint256,address,uint256,address)\":{\"notice\":\"Convenience getter returning the **number** of transaction registered for a specific         `(chainId, safe, nonce, notary)` tuple.\"},\"retrieveTransactions(uint256,address,uint256,address,uint256,uint256)\":{\"notice\":\"Paginated getter for Safe transactions.\"}},\"notice\":\"Permissionless, append-only registry that lets **any EOA signer** publish encrypted Safe         transactions (\\\"SafeTx\\\") and their signatures. Clients without an off-chain indexer can         reconstruct the full multisig payload with only:         1. the Safe address;         2. the target `chainId`;         3. the Safe `nonce`;         4. the current Safe owners set; and         5. a key to decrypt the transaction payload.         Each unique `safeTxHash` (ERC-712 digest of the SafeTx struct) may be registered more         than once, to allow rotating the encryption.         Additionally, this contract contains a public encryption key registry, and functions as         a trustless channel for signers to communicate public encryption keys amongst themselves         in order to support asymmetric encryption schemes of the transaction data.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/SafeSecretHarbour.sol\":\"SafeSecretHarbour\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"src/SafeSecretHarbour.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\nimport {\\n    EncryptionKeyRegistrationExpired,\\n    InvalidEncryptionKeyRegistrationNonce,\\n    NothingToEnqueue,\\n    SignerAlreadySignedTransaction,\\n    UnexpectedSigner\\n} from \\\"./interfaces/Errors.sol\\\";\\nimport {\\n    EncryptionKeyRegistered,\\n    SafeTransactionRegistered,\\n    SafeTransactionSigned\\n} from \\\"./interfaces/Events.sol\\\";\\nimport {ISafeSecretHarbour} from \\\"./interfaces/Harbour.sol\\\";\\nimport {\\n    EncryptionKey,\\n    SafeTransactionRegistrationHandle\\n} from \\\"./interfaces/Types.sol\\\";\\nimport {IERC165} from \\\"./interfaces/ERC165.sol\\\";\\nimport {BlockNumbers} from \\\"./libs/BlockNumbers.sol\\\";\\nimport {CoreLib} from \\\"./libs/CoreLib.sol\\\";\\nimport {RegistrationSelector} from \\\"./libs/RegistrationSelector.sol\\\";\\n\\n/**\\n * @title Safe Secret Harbour\\n * @notice Permissionless, append-only registry that lets **any EOA signer** publish encrypted Safe\\n *         transactions (\\\"SafeTx\\\") and their signatures. Clients without an off-chain indexer can\\n *         reconstruct the full multisig payload with only:\\n *         1. the Safe address;\\n *         2. the target `chainId`;\\n *         3. the Safe `nonce`;\\n *         4. the current Safe owners set; and\\n *         5. a key to decrypt the transaction payload.\\n *\\n *         Each unique `safeTxHash` (ERC-712 digest of the SafeTx struct) may be registered more\\n *         than once, to allow rotating the encryption.\\n *\\n *         Additionally, this contract contains a public encryption key registry, and functions as\\n *         a trustless channel for signers to communicate public encryption keys amongst themselves\\n *         in order to support asymmetric encryption schemes of the transaction data.\\n */\\ncontract SafeSecretHarbour is IERC165, ISafeSecretHarbour {\\n    using BlockNumbers for BlockNumbers.T;\\n    using BlockNumbers for BlockNumbers.Iterator;\\n    using RegistrationSelector for RegistrationSelector.T;\\n\\n    // ------------------------------------------------------------------\\n    // Storage\\n    // ------------------------------------------------------------------\\n\\n    /**\\n     * @dev Mapping of signers to their encryption keys.\\n     */\\n    mapping(address signer => EncryptionKey) private _encryptionKeys;\\n\\n    /**\\n     * @dev Mapping of signers to their encryption key registration nonces, to prevent replaying\\n     *      past encryption key registrations after a key rotation.\\n     */\\n    mapping(address signer => uint256) private _encryptionKeyRegistrationNonces;\\n\\n    /**\\n     * @dev Mapping of registration selector to an array of block numbers where Safe transactions\\n     *      were registered with the harbour.\\n     *\\n     *      Note that the same Safe transaction can be registered **multiple times** with harbour.\\n     *      This is important to allow appending additional encryption data (such as new wrapped\\n     *      encryption keys for signers that either rotated or registered their public encryption\\n     *      key after the initial transaction submission).\\n     */\\n    mapping(RegistrationSelector.T => BlockNumbers.T) private _transactions;\\n\\n    /**\\n     * @dev Mapping per signer from Safe transaction hashes to the block in which a signature was\\n     *      registered.\\n     */\\n    mapping(address signer => mapping(bytes32 safeTxHash => uint256 blockNumber))\\n        private _signatures;\\n\\n    // ------------------------------------------------------------------\\n    // ERC-165 Implementation\\n    // ------------------------------------------------------------------\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) external pure returns (bool) {\\n        return\\n            interfaceId == type(IERC165).interfaceId ||\\n            interfaceId == type(ISafeSecretHarbour).interfaceId;\\n    }\\n\\n    // ------------------------------------------------------------------\\n    // External & public write functions\\n    // ------------------------------------------------------------------\\n\\n    /**\\n     * @notice Register a public encryption key for a signer.\\n     *\\n     * @param context   A 32-byte context specific to the public encryption key.\\n     * @param publicKey The public encryption key to be registered for the `msg.sender` signer.\\n     */\\n    function registerEncryptionKey(\\n        bytes32 context,\\n        bytes32 publicKey\\n    ) external {\\n        _registerEncryptionKey(msg.sender, context, publicKey);\\n    }\\n\\n    /**\\n     * @notice Register a public encryption key on behalf of a signer.\\n     *\\n     * @param signer    The signer to register the encryption key for.\\n     * @param context   A 32-byte context specific to the public encryption key.\\n     * @param publicKey The public encryption key to be registered for the `signer`.\\n     * @param nonce     Encryption key registration nonce.\\n     * @param deadline  Deadline for the registration.\\n     * @param signature The ECDSA signature of the `signer` over the encryption key registration.\\n     */\\n    function registerEncryptionKeyFor(\\n        address signer,\\n        bytes32 context,\\n        bytes32 publicKey,\\n        uint256 nonce,\\n        uint256 deadline,\\n        bytes calldata signature\\n    ) external {\\n        uint256 currentNonce = _encryptionKeyRegistrationNonces[signer];\\n        require(\\n            nonce == currentNonce,\\n            InvalidEncryptionKeyRegistrationNonce(currentNonce)\\n        );\\n        require(\\n            deadline >= block.timestamp,\\n            EncryptionKeyRegistrationExpired()\\n        );\\n\\n        bytes32 registrationHash = CoreLib.computeEncryptionKeyRegistrationHash(\\n            address(this),\\n            context,\\n            publicKey,\\n            block.chainid,\\n            nonce,\\n            deadline\\n        );\\n        (address recoveredSigner, , ) = CoreLib.recoverSigner(\\n            registrationHash,\\n            signature\\n        );\\n        require(recoveredSigner == signer, UnexpectedSigner(recoveredSigner));\\n\\n        _encryptionKeyRegistrationNonces[signer] = nonce + 1;\\n        _registerEncryptionKey(signer, context, publicKey);\\n    }\\n\\n    /**\\n     * @notice Register an encrypted Safe transaction and signature.\\n     *\\n     * @dev This function serves two purposes:\\n     *      1. To register Safe transaction encryption data\\n     *      2. To add signatures to a Safe transaction\\n     *\\n     * @param chainId          Chain id the transaction is meant for.\\n     * @param safe             Target Safe Smart-Account.\\n     * @param nonce            Safe nonce.\\n     * @param safeTxStructHash The ERC-712 struct hash of the Safe transaction data.\\n     * @param encryptionBlob   A blob containing encrypted transaction data. This can either be the\\n     *                         encrypted transaction itself, or additional encrypted keys to new\\n     *                         signer public keys. The exact format is not enforced and application\\n     *                         dependent. There are no guarantees that the blob actually matches the\\n     *                         provided `safeTxStructHash`. The reference implementation uses JWE to\\n     *                         encrypt the RLP-encoded Safe transaction with key wrapping for the\\n     *                         recipients' X25519 public keys. _Optional_: can be omitted to\\n     *                         register a signature without any new encrypted transaction data.\\n     * @param signature        A 65-byte ECDSA signature. _Optional_: can be omitted to register\\n     *                         new encrypted transaction data without a signature.\\n     *\\n     * @return uid             The unique signer-specific identifer of the transaction registration.\\n     *                         Zero if `encryptionBlob` is empty.\\n     *\\n     * @custom:events Emits {SafeTransactionSigned} and {SafeTransactionRegistered}.\\n     */\\n    function enqueueTransaction(\\n        uint256 chainId,\\n        address safe,\\n        uint256 nonce,\\n        bytes32 safeTxStructHash,\\n        bytes calldata signature,\\n        bytes calldata encryptionBlob\\n    ) external returns (bytes32 uid) {\\n        require(\\n            signature.length | encryptionBlob.length != 0,\\n            NothingToEnqueue()\\n        );\\n\\n        bytes32 safeTxHash = CoreLib.computePartialSafeTxHash(\\n            chainId,\\n            safe,\\n            safeTxStructHash\\n        );\\n\\n        if (signature.length != 0) {\\n            _registerSignature(safeTxHash, signature);\\n        }\\n\\n        if (encryptionBlob.length != 0) {\\n            uid = _registerTransaction(\\n                chainId,\\n                safe,\\n                nonce,\\n                msg.sender,\\n                safeTxHash,\\n                encryptionBlob\\n            );\\n        }\\n    }\\n\\n    // ------------------------------------------------------------------\\n    // External & public read functions\\n    // ------------------------------------------------------------------\\n\\n    /**\\n     * @notice Retrieves encryption public keys for the specified signers.\\n     *\\n     * @param signers     The list of signers to fetch encryption keys for.\\n     *\\n     * @return publicKeys The encryption public keys for each of the signers, or `0` if none was\\n     *                    registered. The keys are in the same order as the signers array (i.e. for\\n     *                    all `i`, the key for `signer[i]` is `publicKey[i]`).\\n     */\\n    function retrieveEncryptionPublicKeys(\\n        address[] calldata signers\\n    ) external view returns (bytes32[] memory publicKeys) {\\n        publicKeys = new bytes32[](signers.length);\\n        for (uint256 i = 0; i < signers.length; i++) {\\n            publicKeys[i] = _encryptionKeys[signers[i]].publicKey;\\n        }\\n    }\\n\\n    /**\\n     * @notice Retrieves the encryption keys for a signer.\\n     *\\n     * @param signer         The signer to fetch encryption keys for.\\n     *\\n     * @return encryptionKey The registered encryption key.\\n     */\\n    function retrieveEncryptionKey(\\n        address signer\\n    ) external view returns (EncryptionKey memory encryptionKey) {\\n        encryptionKey = _encryptionKeys[signer];\\n    }\\n\\n    /**\\n     * @notice Retrieves the current encryption key registration nonce for signing.\\n     *\\n     * @param signer The signer to fetch encryption key registration nonce for.\\n     *\\n     * @return nonce The current encryption key registration nonce.\\n     */\\n    function retrieveEncryptionKeyRegistrationNonce(\\n        address signer\\n    ) external view returns (uint256 nonce) {\\n        nonce = _encryptionKeyRegistrationNonces[signer];\\n    }\\n\\n    /**\\n     * @notice Paginated getter for Safe transactions.\\n     *\\n     * @dev Note that this function does not return the full registered transaction directly, but\\n     *      a unique identifier and block number that can be used to query an log with the full\\n     *      transaction details.\\n     *\\n     * @param chainId     Target chain id.\\n     * @param safe        Safe Smart-Account.\\n     * @param nonce       Safe nonce.\\n     * @param notary      Address that registered ecrypted transaction data.\\n     * @param start       Zero-based start index of the slice.\\n     * @param count       Maximum number of entries to return.\\n     *\\n     * @return page       Array slice `[start \\u2026 start+count)` (may be shorter).\\n     * @return totalCount Total number of registrations for the `(chainId, safe, nonce, signer)`\\n     *                    tuple.\\n     */\\n    function retrieveTransactions(\\n        uint256 chainId,\\n        address safe,\\n        uint256 nonce,\\n        address notary,\\n        uint256 start,\\n        uint256 count\\n    )\\n        external\\n        view\\n        returns (\\n            SafeTransactionRegistrationHandle[] memory page,\\n            uint256 totalCount\\n        )\\n    {\\n        RegistrationSelector.T registration = RegistrationSelector.get(\\n            chainId,\\n            safe,\\n            nonce,\\n            notary\\n        );\\n        BlockNumbers.Iterator memory it = _transactions[registration].iter();\\n\\n        totalCount = it.count();\\n        it.skip(start);\\n        it.take(count);\\n\\n        page = new SafeTransactionRegistrationHandle[](it.count());\\n        unchecked {\\n            for (uint256 i = 0; it.next(); i++) {\\n                SafeTransactionRegistrationHandle memory item = page[i];\\n                item.blockNumber = it.value();\\n                item.uid = registration.uniqueIdentifier(start + i);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Convenience getter returning the **number** of transaction registered for a specific\\n     *         `(chainId, safe, nonce, notary)` tuple.\\n     *\\n     * @param chainId Target chain id.\\n     * @param safe    Safe Smart-Account.\\n     * @param nonce   Safe nonce.\\n     * @param notary  Notary address.\\n     *\\n     * @return count  Number of registrations.\\n     */\\n    function retrieveTransactionCount(\\n        uint256 chainId,\\n        address safe,\\n        uint256 nonce,\\n        address notary\\n    ) external view returns (uint256 count) {\\n        RegistrationSelector.T registration = RegistrationSelector.get(\\n            chainId,\\n            safe,\\n            nonce,\\n            notary\\n        );\\n        count = _transactions[registration].len();\\n    }\\n\\n    /**\\n     * @notice Retrieve Safe transaction signatures for the specified signers.\\n     *\\n     * @dev Note that this function does not return the signature directly, the block number that\\n     *      can be used to query an log with the signature bytes.\\n     *\\n     * @param signers    The signer addresses.\\n     * @param safeTxHash ERC-712 digest of the transaction\\n     *\\n     * @return blockNumbers The block numbers containing the Safe transaction signature events for\\n     *                      the specified signers and Safe transaction hash.\\n     */\\n    function retrieveSignatures(\\n        address[] calldata signers,\\n        bytes32 safeTxHash\\n    ) external view returns (uint256[] memory blockNumbers) {\\n        blockNumbers = new uint256[](signers.length);\\n        unchecked {\\n            for (uint256 i = 0; i < signers.length; i++) {\\n                blockNumbers[i] = _signatures[signers[i]][safeTxHash];\\n            }\\n        }\\n    }\\n\\n    // ------------------------------------------------------------------\\n    // Private functions\\n    // ------------------------------------------------------------------\\n\\n    /**\\n     * @notice Private function to register a public encryption key for a signer.\\n     *\\n     * @param signer    The signer to register the encryption key for.\\n     * @param context   A 32-byte context specific to the public encryption key.\\n     * @param publicKey The public encryption key to be registered for the `signer`.\\n     */\\n    function _registerEncryptionKey(\\n        address signer,\\n        bytes32 context,\\n        bytes32 publicKey\\n    ) private {\\n        _encryptionKeys[signer] = EncryptionKey(context, publicKey);\\n        emit EncryptionKeyRegistered(signer, context, publicKey);\\n    }\\n\\n    /**\\n     * @dev Private function to register a Safe transaction.\\n     *\\n     * @param chainId        Chain id the transaction is meant for.\\n     * @param safe           Safe Smart-Account.\\n     * @param nonce          Safe nonce.\\n     * @param notary         The account that submitted the encrypted transaction data blob for\\n     *                       registration.\\n     * @param safeTxHash     ERC-712 digest of the transaction.\\n     * @param encryptionBlob The Safe transaction encryption blob.\\n     *\\n     * @return uid       The unique signer-specific identifer of the registration.\\n     */\\n    function _registerTransaction(\\n        uint256 chainId,\\n        address safe,\\n        uint256 nonce,\\n        address notary,\\n        bytes32 safeTxHash,\\n        bytes calldata encryptionBlob\\n    ) private returns (bytes32 uid) {\\n        RegistrationSelector.T registration = RegistrationSelector.get(\\n            chainId,\\n            safe,\\n            nonce,\\n            notary\\n        );\\n        uint256 index = _transactions[registration].append(block.number);\\n\\n        uid = registration.uniqueIdentifier(index);\\n        emit SafeTransactionRegistered(uid, safeTxHash, encryptionBlob);\\n    }\\n\\n    /**\\n     * @dev Private function to register a Safe transaction signature after validation.\\n     *\\n     * @param safeTxHash ERC-712 digest of the transaction.\\n     * @param signature  The ECDSA signature bytes.\\n     */\\n    function _registerSignature(\\n        bytes32 safeTxHash,\\n        bytes calldata signature\\n    ) private {\\n        (address signer, , ) = CoreLib.recoverSigner(safeTxHash, signature);\\n        require(\\n            _signatures[signer][safeTxHash] == 0,\\n            SignerAlreadySignedTransaction(signer, safeTxHash)\\n        );\\n\\n        _signatures[signer][safeTxHash] = block.number;\\n        emit SafeTransactionSigned(signer, safeTxHash, signature);\\n    }\\n}\\n\",\"keccak256\":\"0xad2bc03846dde4736ec503c58efef9ec624e18651b4f102dddcc27a16cf316e1\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\n// ------------------------------------------------------------------\\n// Constants\\n// ------------------------------------------------------------------\\n\\n// The hashes must be the same as the ones in the Safe contract:\\n// https://github.com/safe-global/safe-smart-account/blob/b115c4c5fe23dca6aefeeccc73d312ddd23322c2/contracts/Safe.sol#L54-L63\\n// These should cover Safe versions 1.3.0 and 1.4.1\\n// keccak256(\\\"EIP712Domain(uint256 chainId,address verifyingContract)\\\")\\nbytes32 constant SAFE_DOMAIN_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\\n\\n// keccak256(\\\"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\\\")\\nbytes32 constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\\n\\n// keccak256(\\\"EIP712Domain(address verifyingContract)\\\")\\nbytes32 constant HARBOUR_DOMAIN_TYPEHASH = 0x035aff83d86937d35b32e04f0ddc6ff469290eef2f1b692d8a815c89404d4749;\\n\\n// keccak256(\\\"EncryptionKeyRegistration(bytes32 context,bytes32 publicKey,uint256 harbourChainId,uint256 nonce,uint256 deadline)\\\")\\nbytes32 constant ENCRYPTION_KEY_REGISTRATION_TYPEHASH = 0x5577dd2e8f3cae24f69b98e4cdf50cb186492fb1ca342a9a6cf161733ca273b2;\\n\\n// The lower bound of the S value for a valid secp256k1 signature.\\n// https://github.com/safe-global/safe-smart-account/blob/b115c4c5fe23dca6aefeeccc73d312ddd23322c2/contracts/Safe.sol#L100\\nbytes32 constant SECP256K1_LOW_S_BOUND = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\\n\",\"keccak256\":\"0x2dacabc8d742fc4a1454a7e9320237674b80dc52231d4f070b89590a0ea856ff\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x755362c400b653816dd22a4587ef85eca6dfa7a2a6a06f6b8d2cc7f3fe1e663b\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\n// ------------------------------------------------------------------\\n// Errors\\n// ------------------------------------------------------------------\\n\\n/**\\n * @notice Thrown when a signature blob is not exactly 65 bytes.\\n */\\nerror InvalidECDSASignatureLength();\\n\\n/**\\n * @notice Thrown if `ecrecover` yields `address(0)`.\\n */\\nerror InvalidSignature();\\n\\n/**\\n * @notice Thrown if the S value of the signature is not from the lower half of the curve.\\n */\\nerror InvalidSignatureSValue();\\n\\n/**\\n * @notice Thrown when a value doesn't fit in a uint128.\\n */\\nerror ValueDoesNotFitInUint128();\\n\\n/**\\n * @notice Thrown when attempting to store a signature for a transaction (safeTxHash)\\n * that the signer has already provided a signature for.\\n * @param signer Signer address.\\n * @param safeTxHash The EIP-712 hash of the Safe transaction.\\n */\\nerror SignerAlreadySignedTransaction(address signer, bytes32 safeTxHash);\\nerror InvalidTarget(bytes4 targetSelector);\\nerror InvalidEntryPoint(address entryPoint);\\nerror InvalidUserOpPaymaster();\\nerror InvalidValidatorData();\\nerror UnexpectedUserSignature();\\nerror UnexpectedSafeTxHash(bytes32 expectedSafeTxHash);\\nerror UnexpectedSigner(address recoveredSigner);\\nerror UnexpectedSignatureR(bytes32 extractedR);\\nerror UnexpectedSignatureVS(bytes32 extractedVS);\\nerror UnexpectedNonce(address expectedKey);\\n\\n/**\\n * @notice Thrown when registering an encryption key on behalf of a signer with an invalid nonce.\\n *\\n * @param currentNonce The current encryption key registration nonce, which is valid.\\n */\\nerror InvalidEncryptionKeyRegistrationNonce(uint256 currentNonce);\\n\\n/**\\n * @notice Thrown when attempting to register an encryption key on behalf of the user with an\\n *         expired signature.\\n */\\nerror EncryptionKeyRegistrationExpired();\\n\\n/**\\n * @notice Thrown when attempting to enqueue nothing. That is, when calling `enqueueTransaction` on\\n *         the {SafeSecretHarbour} with empty `signature` and `encryptionBlob`.\\n */\\nerror NothingToEnqueue();\\n\\n// ------------------------------------------------------------------\\n// Quota Errors\\n// ------------------------------------------------------------------\\n\\nerror WithdrawalAlreadyPerformed(bytes32 withdrawalHash);\\nerror InsufficientTokensForWithdrawal();\\nerror TokensInUse();\\nerror QuotaOverflow(uint256 maxSignerQuota);\\n\\n// ------------------------------------------------------------------\\n// Slashing Errors\\n// ------------------------------------------------------------------\\n\\nerror ConditionAlreadyEnabled();\\nerror ConditionAlreadyDisabled();\\nerror ConditionNotEnabled();\\nerror ConditionWasNotActive();\\nerror ConditionNotOffended();\\nerror UserOpAlreadySlashed();\\nerror NothingToSlash();\\nerror InvalidBeneficiary();\\n\",\"keccak256\":\"0xb4a127f861bf96ab6546520f9ec7e56b4f250632be8fc4496ba3b4bb922363f9\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/Events.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\n// ------------------------------------------------------------------\\n// Events\\n// ------------------------------------------------------------------\\n\\n/**\\n * @notice Emitted whenever a new signature is stored (and possibly the parameters on first sight).\\n *\\n * @param signer     Address recovered from the provided signature.\\n * @param safe       Safe Smart-Account the transaction targets.\\n * @param safeTxHash EIP-712 hash identifying the SafeTx.\\n * @param chainId    Intended execution chain.\\n * @param nonce      Safe nonce.\\n * @param listIndex  Position of the signature in the signer-specific array.\\n */\\nevent SignatureStored(\\n    address indexed signer,\\n    address indexed safe,\\n    bytes32 indexed safeTxHash,\\n    uint256 chainId,\\n    uint256 nonce,\\n    uint256 listIndex\\n);\\n\\n/**\\n * @notice Emitted when a transaction is first stored.\\n * @param safeTxHash EIP-712 hash identifying the SafeTx.\\n * @param safe       Safe Smart-Account the transaction targets.\\n * @param chainId    Intended execution chain.\\n * @param nonce      Safe nonce.\\n * @param to         Destination of the inner call/delegatecall.\\n * @param value      ETH value forwarded by the Safe.\\n * @param operation  0 = CALL, 1 = DELEGATECALL.\\n * @param safeTxGas  Gas forwarded to the inner call.\\n * @param baseGas    Fixed overhead reimbursed to the submitting signer.\\n * @param gasPrice   Gas price used for reimbursement.\\n * @param gasToken   ERC-20 token address for refunds.\\n * @param refundReceiver Address receiving the gas refund.\\n * @param data       Calldata executed by the Safe.\\n */\\nevent NewTransaction(\\n    bytes32 indexed safeTxHash,\\n    address indexed safe,\\n    uint256 indexed chainId,\\n    uint256 nonce,\\n    address to,\\n    uint256 value,\\n    uint8 operation,\\n    uint256 safeTxGas,\\n    uint256 baseGas,\\n    uint256 gasPrice,\\n    address gasToken,\\n    address refundReceiver,\\n    bytes data\\n);\\n\\n/**\\n * @notice Emitted whenever an encryption key is registered for a signer.\\n *\\n * @param signer    The signer for which the key was registered.\\n * @param context   A 32-byte contract associated with the encryption key.\\n * @param publicKey A 32-byte encryption public key.\\n */\\nevent EncryptionKeyRegistered(\\n    address indexed signer,\\n    bytes32 context,\\n    bytes32 publicKey\\n);\\n\\n/**\\n * @notice Emitted whenever a signed encrypted Safe transaction is registered.\\n *\\n * @param uid            A unique registration identifier that can be used for event filtering.\\n * @param safeTxHash     EIP-712 hash identifying the Safe transaction.\\n * @param encryptionBlob A blob containing encrypted transaction data. This can either be the\\n *                       encrypted transaction itself, or additional encrypted keys to new signer\\n *                       public keys. The exact format is not enforced and application dependent.\\n *                       The reference implementation uses JWE to encrypt the RLP-encoded Safe\\n *                       transaction with A256-GCM encryption, and ECDH-ES+A256KW for wrapping the\\n *                       encryption keys for recipients' X25519 public keys.\\n */\\nevent SafeTransactionRegistered(\\n    bytes32 indexed uid,\\n    bytes32 indexed safeTxHash,\\n    bytes encryptionBlob\\n);\\n\\n/**\\n * @notice Emitted when a Safe transaction is signed.\\n *\\n * @param signer     The signer address.\\n * @param safeTxHash The Safe transaction hash that was signed.\\n * @param signature  The Safe transaction signature.\\n */\\nevent SafeTransactionSigned(\\n    address indexed signer,\\n    bytes32 indexed safeTxHash,\\n    bytes signature\\n);\\n\",\"keccak256\":\"0x420e85868c65e47ebbb981b99ae86448ea93e92bf13c22b52124b6a2e8dd0055\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/Harbour.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\nimport {EncryptionKey, SafeTransactionRegistrationHandle} from \\\"./Types.sol\\\";\\n\\n/// @title Safe Secret Harbour Interface\\ninterface ISafeSecretHarbour {\\n    function registerEncryptionKey(bytes32 context, bytes32 publicKey) external;\\n\\n    function registerEncryptionKeyFor(\\n        address signer,\\n        bytes32 context,\\n        bytes32 publicKey,\\n        uint256 nonce,\\n        uint256 deadline,\\n        bytes calldata signature\\n    ) external;\\n\\n    function enqueueTransaction(\\n        uint256 chainId,\\n        address safe,\\n        uint256 nonce,\\n        bytes32 safeTxStructHash,\\n        bytes calldata signature,\\n        bytes calldata encryptionBlob\\n    ) external returns (bytes32 uid);\\n\\n    function retrieveEncryptionPublicKeys(\\n        address[] calldata signers\\n    ) external view returns (bytes32[] memory publicKeys);\\n\\n    function retrieveEncryptionKey(\\n        address signers\\n    ) external view returns (EncryptionKey memory encryptionKey);\\n\\n    function retrieveEncryptionKeyRegistrationNonce(\\n        address signers\\n    ) external view returns (uint256 nonce);\\n\\n    function retrieveTransactions(\\n        uint256 chainId,\\n        address safe,\\n        uint256 nonce,\\n        address notary,\\n        uint256 start,\\n        uint256 count\\n    )\\n        external\\n        view\\n        returns (\\n            SafeTransactionRegistrationHandle[] memory page,\\n            uint256 totalCount\\n        );\\n\\n    function retrieveSignatures(\\n        address[] calldata signers,\\n        bytes32 safeTxHash\\n    ) external view returns (uint256[] memory blockNumbers);\\n}\\n\",\"keccak256\":\"0x70d348e96cc2e52f16d1a7d5c089e22a0b3961083052b61c86ead19db2567872\",\"license\":\"GPL-3.0-only\"},\"src/interfaces/Types.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\n// ------------------------------------------------------------------\\n// Data structures\\n// ------------------------------------------------------------------\\n\\n/**\\n * @dev Storage optimised mirror of the SafeTx struct used by Safe contracts.\\n *      Non-optimised version uses uint256 for:\\n *      - value\\n *      - safeTxGas\\n *      - baseGas\\n *      - gasPrice\\n */\\nstruct SafeTransaction {\\n    // stored, operation and to will be packed into the same storage slot\\n    bool stored;\\n    uint8 operation;\\n    address to;\\n    uint128 value;\\n    uint128 safeTxGas;\\n    uint128 baseGas;\\n    uint128 gasPrice;\\n    address gasToken;\\n    address refundReceiver;\\n    bytes data;\\n}\\n\\n/**\\n * @dev Minimal, storage-optimised representation of an ECDSA signature.\\n */\\nstruct SignatureDataWithTxHashIndex {\\n    bytes32 r;\\n    // vs is the compact representation of s and v coming from\\n    // EIP-2098: https://eips.ethereum.org/EIPS/eip-2098\\n    bytes32 vs;\\n    bytes32 txHash; // EIP-712 digest this signature belongs to\\n}\\n\\n/**\\n * @dev A public encryption key.\\n *\\n * @custom:field context   An application-defined context. This can be used as a salt in\\n *                         deterministic encryption key derivation schemes (for example, it can be\\n *                         the `nonce` and `issuedAt` values for a Sign-in with Ethereum signature\\n *                         to be used as entropy for deriving an X25519 encryption key pair).\\n * @custom:field publicKey The public encryption key. Note that this contract does not enforce any\\n *                         specific key format, the only restriction is that the key must fit in 32\\n *                         bytes. The reference client implementation uses Curve25519 public keys.\\n */\\nstruct EncryptionKey {\\n    bytes32 context;\\n    bytes32 publicKey;\\n}\\n\\n/**\\n * @dev An encrypted Safe transaction registration handle.\\n */\\nstruct SafeTransactionRegistrationHandle {\\n    uint256 blockNumber;\\n    bytes32 uid;\\n}\\n\",\"keccak256\":\"0xdb2ba1d6bd78f19f6d14c565265f231955e73706144ad3de1d0994c9999749d1\",\"license\":\"GPL-3.0-only\"},\"src/libs/BlockNumbers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\n/**\\n * @title Block Numbers\\n * @notice A storage efficient list of block numbers.\\n * @dev The storage layout is similar to that of an `uint64[]` dynamic array, with the exception\\n *      that the first 3 elements are stored in the same slot as the array length. This is a nice\\n *      optimization which makes short lists be stored in a single slot. Note that this implicitely\\n *      limits blocks to the range `[0, type(uint64).max)` and length to `type(uint64).max`.\\n *\\n *      The layout in storage for the block numbers, given a `BlockNumbers.T` at storage slot `s`:\\n *\\n *                   b |  2       1       1\\n *                   i |  5       9       2       6\\n *                   t |  6       6       8       4       0\\n *               slot\\\\ |\\n *      ---------------+-----------------------------------\\n *                     |\\n *                     |  +-------+-------+-------+-------+\\n *                   s |  |  [2]  |  [1]  |  [0]  |  len  |\\n *                     |  +-------+-------+-------+-------+\\n *                     |\\n *                     |  +-------+-------+-------+-------+\\n *        keccak256(s) |  |  [6]  |  [5]  |  [4]  |  [3]  |\\n *                     |  +-------+-------+-------+-------+\\n *      keccak256(s)+1 |  |  [10] |  [9]  |  [8]  |  [7]  |\\n *                     |  +-------+-------+-------+-------+\\n *      keccak256(s)+2 |  |  [14] |  [12] |  [12] |  [11] |\\n *                     |  +-------+-------+-------+-------+\\n *                 ... |\\n */\\nlibrary BlockNumbers {\\n    /**\\n     * @notice A block number list storage type.\\n     * @dev This type is **only** intended for use as a storage variable.\\n     */\\n    struct T {\\n        uint256 prefix;\\n    }\\n\\n    /**\\n     * @notice A block number iterator over a storage block number list.\\n     * @dev The fields in this type are for internal use only! This library provides functions for\\n     *      reading and advancing the iterator.\\n     */\\n    struct Iterator {\\n        // The current storage slot that was read from. Once all of the (4) block numbers from the\\n        // current slot are read, this value used for computing the next storage slot to read from.\\n        uint256 slot;\\n        // The data that was read from the current storage slot. This contains 4 block numbers at\\n        // first but shifts out one block number every time the iterator moves forward. This is\\n        // kept in the iterator state to prevent `sload`-ing from `slot` multiple times.\\n        uint256 data;\\n        // The remaining count in the iterator. This is initialized to the length of the block list\\n        // and reduced by one every time the iterator moves forward (or truncated with `take`).\\n        uint256 cnt;\\n        // The remaining blocks in the current `slot` and `data`. This is used to determine when\\n        // the next `slot` should be computed and `sload`-ed from.\\n        uint256 rem;\\n        // A flag that indicates that this is the \\\"first\\\" slot we are reading from. Solidity stores\\n        // the length of the array in the prefix slot, and the items in `keccak256(slot)`. In our\\n        // optimized list, the prefix slot stores `[2] || [1] || [0] || length`, and we need this\\n        // flag to know to whether the next slot is `keccak(slot)` or `slot + 1`.\\n        bool first;\\n    }\\n\\n    /**\\n     * @notice Appends a new block number to the list.\\n     * @return index The index at which the new item was added.\\n     */\\n    function append(\\n        T storage self,\\n        uint256 blockNumber\\n    ) internal returns (uint256 index) {\\n        unchecked {\\n            uint256 prefix = self.prefix;\\n            index = prefix & type(uint64).max;\\n\\n            // Overflow check to see if either `index + 1` or block number overflows a `uint64`,\\n            // and panic if it does. We use a bit-wise or to compress both checks into a single\\n            // comparison.\\n            if ((index + 1) | blockNumber > type(uint64).max) {\\n                _panicOverflow();\\n            }\\n\\n            if (index < 3) {\\n                // The block number is stored in the prefix slot. Compute the shift so that the\\n                // block ends up in the right bits of the 32-byte word:\\n                //\\n                // b  2       1       1\\n                // i  5       9       2       6\\n                // t  6       6       8       4       0\\n                //    +-------+-------+-------+-------+\\n                //    |  [2]  |  [1]  |  [0]  |  len  |\\n                //    +-------+-------+-------+-------+\\n\\n                uint256 shift = (index + 1) << 6; // (index + 1) * 64\\n                self.prefix = (prefix + 1) | (blockNumber << shift); // len++; [index] = blockNumber\\n            } else {\\n                // The block number is stored in one of the value slots. We need to compute both the\\n                // value slot where the item is, accounting for the fact that only 3 items fit in\\n                // the prefix slot, and 4 items fit in each value slot thereafter:\\n                //\\n                // b  2       1       1\\n                // i  5       9       2       6\\n                // t  6       6       8       4       0\\n                //    +-------+-------+-------+-------+\\n                //    | [i+3] | [i+2] | [i+1] |  [i]  |\\n                //    +-------+-------+-------+-------+\\n\\n                uint256 j = index - 3; // discount the first 3 items from the prefix slot.\\n                uint256 offset = j >> 2; // (j / 4): is the value slot offset\\n                uint256 shift = (j & 3) << 6; // (j % 4) * 64\\n\\n                // sstore[keccak256(self.slot) + offset] |= blockNumber << shift\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly (\\\"memory-safe\\\") {\\n                    mstore(0, self.slot)\\n                    let slot := add(keccak256(0, 32), offset)\\n                    sstore(slot, or(sload(slot), shl(shift, blockNumber)))\\n                }\\n                self.prefix = prefix + 1; // len++\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the length of the block numbers list.\\n     */\\n    function len(T storage self) internal view returns (uint256 length) {\\n        return self.prefix & type(uint64).max;\\n    }\\n\\n    /**\\n     * @notice Create an iterator over the block numbers.\\n     * @dev The iterator is implemented to minimize storage reads.\\n     */\\n    function iter(T storage self) internal view returns (Iterator memory it) {\\n        // it.slot = self.slot\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(it, self.slot)\\n        }\\n        unchecked {\\n            it.data = self.prefix;\\n            // TODO(nlordell): If we _really_ want to optimize, we can pack `cnt`, `rem` and\\n            // `first` into a single slot, but that isn't necessary for now.\\n            it.cnt = it.data & type(uint64).max;\\n            it.rem = 3;\\n            it.first = true;\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the count of remaining items in the iterator.\\n     */\\n    function count(\\n        Iterator memory self\\n    ) internal pure returns (uint256 length) {\\n        return self.cnt;\\n    }\\n\\n    /**\\n     * @notice Moves the iterator to the next block number.\\n     */\\n    function next(Iterator memory self) internal view returns (bool remaining) {\\n        remaining = self.cnt != 0;\\n        // We implement `next` by skipping one value. This removes a lot of duplicate code. Note\\n        // that, generally, callers are MUST NOT expect `value` to be valid after `skip`-ing, and\\n        // the fact we use `skip` in `next` is an implementation detail.\\n        skip(self, 1);\\n    }\\n\\n    /**\\n     * @notice Skips items in the iterator.\\n     * @dev `next` MUST be called after `skip`-ing.\\n     */\\n    function skip(Iterator memory self, uint256 n) internal view {\\n        // If we skip past the end of the iterator, then the iterator is done and there is nothing\\n        // else to do! The next call to `next` will return `false` meaning that there are no more\\n        // values.\\n        if (self.cnt < n) {\\n            self.cnt = 0;\\n            return;\\n        }\\n\\n        unchecked {\\n            self.cnt -= n;\\n            if (self.rem >= n) {\\n                // We skipped some amount that is smaller than the number of items remaining in the\\n                // last `sload`-ed `data`. We just need to shift out the values that were skipped\\n                // and adjust the `rem`-aining item amount accordingly.\\n\\n                self.data = self.data >> (n << 6); // data >> (n * 64)\\n                self.rem -= n;\\n            } else {\\n                // HERE BE DRAGONS. We skipped some amount of items that requires us to `sload` some\\n                // new `data` from a different `slot`. We also need to update `rem` and `data`, as\\n                // we may have skipped somewhere in the middle of a value slot.\\n\\n                // Figure out how many additional items we need to skip past the last item remaining\\n                // in the `data` from the last `sload`-ed slot. It makes computations below simpler.\\n                n -= self.rem;\\n\\n                // We know that we moved **at least** 1 slot forward, but we need to figure out\\n                // exactly how many additional slots forward we went (for example, if we `skip(100)`\\n                // we have to read way past the next `slot`). Since _only_ the prefix (fist) slot\\n                // fits 3 items and we are here if we moved past it, we can compute the additional\\n                // slots to skip assuming exactly 4 items per slot.\\n                uint256 slots = n >> 2; // slots = n / 4\\n                if (self.first) {\\n                    // self.slot = keccak256(abi.encode(self.slot)) + slots;\\n                    // solhint-disable-next-line no-inline-assembly\\n                    assembly (\\\"memory-safe\\\") {\\n                        mstore(self, add(keccak256(self, 32), slots))\\n                    }\\n                    self.first = false;\\n                } else {\\n                    self.slot += 1 + slots;\\n                }\\n\\n                // Now we need to compute where we landed in the of the `slot`, and adjust both\\n                // `rem` and `data` accordingly (to handle the case where we skip somewhere in\\n                // the middle of a value slot).\\n                self.rem = 4 - (n & 3); // rem = 4 - (n % 4)\\n                uint256 shift = (3 - self.rem) << 6; // shift = (3 - rem) * 64\\n\\n                // self.data = sload(self.slot) >> shift\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly (\\\"memory-safe\\\") {\\n                    mstore(add(self, 32), shr(shift, sload(mload(self))))\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Truncates the iterator to a maximum of `cnt` items.\\n     */\\n    function take(Iterator memory self, uint256 cnt) internal pure {\\n        if (self.cnt > cnt) {\\n            self.cnt = cnt;\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the current value of the iterator.\\n     * @dev The caller MUST ONLY call this function after a call to `next` which returned `true`.\\n     *      Calling this after initialization (`iter`) or `skip` is undefined behaviour.\\n     */\\n    function value(\\n        Iterator memory self\\n    ) internal pure returns (uint256 blockNumber) {\\n        return self.data & type(uint64).max;\\n    }\\n\\n    /**\\n     * @dev Generate an overflow panic. This function is required and implemented in assembly since\\n     *      Solidity does not support panicking with `revert Panic(0x11)`.\\n     *\\n     *      <https://docs.soliditylang.org/en/v0.8.29/control-structures.html#panic-via-assert-and-error-via-require>\\n     */\\n    function _panicOverflow() private pure {\\n        // revert Panic(0x11)\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0, 0x4e487b71) // Panic(uint256)\\n            mstore(32, 0x11) // arithmetic underflow or overflow\\n            revert(28, 36)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1f63fe72208ecb0f459817e6d1f90f2477b346a5532e1996979f04e19a59a55b\",\"license\":\"GPL-3.0-only\"},\"src/libs/CoreLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\nimport {\\n    ENCRYPTION_KEY_REGISTRATION_TYPEHASH,\\n    HARBOUR_DOMAIN_TYPEHASH,\\n    SAFE_DOMAIN_TYPEHASH,\\n    SAFE_TX_TYPEHASH,\\n    SECP256K1_LOW_S_BOUND\\n} from \\\"../interfaces/Constants.sol\\\";\\nimport {\\n    InvalidECDSASignatureLength,\\n    InvalidSignatureSValue,\\n    InvalidSignature,\\n    ValueDoesNotFitInUint128\\n} from \\\"../interfaces/Errors.sol\\\";\\n\\nlibrary CoreLib {\\n    // ------------------------------------------------------------------\\n    // Internal functions\\n    // ------------------------------------------------------------------\\n\\n    /**\\n     * @notice Computes the EIP-712 hash for a given domain and message.\\n     *\\n     * @param domainSeparator   The EIP-712 domain separator hash.\\n     * @param messageStructHash The EIP-712 struct hash of the message.\\n     *\\n     * @return digest           The EIP-712 digest.\\n     */\\n    function computeErc712Hash(\\n        bytes32 domainSeparator,\\n        bytes32 messageStructHash\\n    ) internal pure returns (bytes32 digest) {\\n        digest = keccak256(\\n            abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, messageStructHash)\\n        );\\n    }\\n\\n    /**\\n     * @notice Computes the EIP-712 domain separator for a Safe.\\n     *\\n     * @param chainId          The chain ID of the Safe Smart Account.\\n     * @param safe             The address of the Safe Smart Account.\\n     *\\n     * @return domainSeparator The EIP-712 domain separator hash.\\n     */\\n    function safeDomainSeparator(\\n        uint256 chainId,\\n        address safe\\n    ) internal pure returns (bytes32 domainSeparator) {\\n        domainSeparator = keccak256(\\n            abi.encode(SAFE_DOMAIN_TYPEHASH, chainId, safe)\\n        );\\n    }\\n\\n    /**\\n     * @notice Computes the unique EIP-712 digest for a SafeTx using the provided parameters and domain.\\n     *\\n     * @param safeAddress    Address of the target Safe Smart Account.\\n     * @param chainId        Chain ID included in the domain separator.\\n     * @param nonce          Safe transaction nonce.\\n     * @param to             Target address the Safe will call.\\n     * @param value          ETH value to be sent with the call.\\n     * @param data           Call data executed by the Safe.\\n     * @param operation      Operation type: 0 = CALL, 1 = DELEGATECALL.\\n     * @param safeTxGas      Gas limit for the Safe's internal execution.\\n     * @param baseGas        Base gas overhead for reimbursement.\\n     * @param gasPrice       Gas price used for reimbursement calculation.\\n     * @param gasToken       Token address for refunds (0x0 for ETH).\\n     * @param refundReceiver Address to receive gas refunds.\\n     *\\n     * @return safeTxHash    Keccak256 digest of the EIP-712 encoded SafeTx.\\n     */\\n    function computeSafeTxHash(\\n        address safeAddress,\\n        uint256 chainId,\\n        uint256 nonce,\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        uint8 operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address refundReceiver\\n    ) internal pure returns (bytes32 safeTxHash) {\\n        bytes32 domainSeparator = safeDomainSeparator(chainId, safeAddress);\\n        bytes32 safeTxStructHash = keccak256(\\n            abi.encode(\\n                SAFE_TX_TYPEHASH,\\n                to,\\n                value,\\n                keccak256(data),\\n                operation,\\n                safeTxGas,\\n                baseGas,\\n                gasPrice,\\n                gasToken,\\n                refundReceiver,\\n                nonce\\n            )\\n        );\\n        safeTxHash = computeErc712Hash(domainSeparator, safeTxStructHash);\\n    }\\n\\n    /**\\n     * @notice Computes a Safe transaction hash from partial data.\\n     *\\n     * @param chainId          Chain ID included in the domain separator.\\n     * @param safeAddress      Address of the target Safe Smart Account.\\n     * @param safeTxStructHash The EIP-712 struct hash of the Safe transaction data.\\n     *\\n     * @return safeTxHash      Keccak256 digest of the EIP-712 encoded SafeTx.\\n     */\\n    function computePartialSafeTxHash(\\n        uint256 chainId,\\n        address safeAddress,\\n        bytes32 safeTxStructHash\\n    ) internal pure returns (bytes32 safeTxHash) {\\n        bytes32 domainSeparator = safeDomainSeparator(chainId, safeAddress);\\n        safeTxHash = computeErc712Hash(domainSeparator, safeTxStructHash);\\n    }\\n\\n    /**\\n     * @notice Computes the EIP-712 domain separator for Harbour.\\n     *\\n     * @param harbour          The address of the Harbour contract.\\n     *\\n     * @return domainSeparator The EIP-712 domain separator hash.\\n     */\\n    function harbourDomainSeparator(\\n        address harbour\\n    ) internal pure returns (bytes32 domainSeparator) {\\n        // NOTE: The Harbour domain separator does _NOT_ use the chain ID as\\n        // part of the domain. Why? Harbour contains cross-chain data, so\\n        // approvals for harbour actions (like registering an encryption key)\\n        // aren't tied to a specific chain.\\n        domainSeparator = keccak256(\\n            abi.encode(HARBOUR_DOMAIN_TYPEHASH, harbour)\\n        );\\n    }\\n\\n    /**\\n     * @notice Computes the encryption key registration hash for authentication.\\n     *\\n     * @dev Note that Harbour encryption key registration hashes include the harbour chain ID in\\n     *      the message and not in the signing domain. This is because the encryption key is used\\n     *      for Safe transactions on **all** chains, and not just on the chain Harbour chain where\\n     *      it is stored. Essentially, `harbourChainId` represents the chain where the encryption\\n     *      key is _stored_ and not where it is _used_.\\n     *\\n     * @param harbour           The address of the Harbour contract.\\n     * @param context           A 32-byte context specific to the public encryption key.\\n     * @param publicKey         The public encryption key.\\n     * @param harbourChainId    The Harbour chain where the encryption key will be stored.\\n     * @param nonce             The encryption key registration nonce.\\n     * @param deadline          Deadline for the registration.\\n     *\\n     * @return registrationHash The EIP-712 encoded encryption key registration hash.\\n     */\\n    function computeEncryptionKeyRegistrationHash(\\n        address harbour,\\n        bytes32 context,\\n        bytes32 publicKey,\\n        uint256 harbourChainId,\\n        uint256 nonce,\\n        uint256 deadline\\n    ) internal pure returns (bytes32 registrationHash) {\\n        bytes32 domainSeparator = harbourDomainSeparator(harbour);\\n        bytes32 registrationStructHash = keccak256(\\n            abi.encode(\\n                ENCRYPTION_KEY_REGISTRATION_TYPEHASH,\\n                context,\\n                publicKey,\\n                harbourChainId,\\n                nonce,\\n                deadline\\n            )\\n        );\\n        registrationHash = computeErc712Hash(\\n            domainSeparator,\\n            registrationStructHash\\n        );\\n    }\\n\\n    /**\\n     * @notice Splits a 65-byte ECDSA signature into its components and recovers the signer address.\\n     *\\n     * @dev Supports both EIP-712 and eth_sign flows by detecting v > 30 and applying the Ethereum Signed Message prefix.\\n     *\\n     * @param digest  The message or data hash to verify (ERC-712 digest or eth_sign prefixed).\\n     * @param sig     Concatenated 65-byte ECDSA signature (r || s || v).\\n     *\\n     * @return signer The address that produced the signature (EOA).\\n     * @return r      First 32 bytes of the ECDSA signature.\\n     * @return vs     Compact representation of s and v coming from EIP-2098.\\n     */\\n    function recoverSigner(\\n        bytes32 digest,\\n        bytes calldata sig\\n    ) internal pure returns (address signer, bytes32 r, bytes32 vs) {\\n        require(sig.length == 65, InvalidECDSASignatureLength());\\n        uint256 v;\\n        bytes32 s;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            r := calldataload(sig.offset)\\n            s := calldataload(add(sig.offset, 0x20))\\n            v := byte(0, calldataload(add(sig.offset, 0x40)))\\n        }\\n        require(s <= SECP256K1_LOW_S_BOUND, InvalidSignatureSValue());\\n\\n        signer = ecrecover(digest, uint8(v), r, s);\\n        require(signer != address(0), InvalidSignature());\\n        unchecked {\\n            vs = bytes32((uint256(v - 27) << 255) | uint256(s));\\n        }\\n    }\\n\\n    /**\\n     * @notice Recovers the signer address from an EIP-2098 compact signature.\\n     *\\n     * @param digest  The message or data hash to verify (ERC-712 digest or eth_sign prefixed).\\n     * @param r       First 32 bytes of the ECDSA signature.\\n     * @param vs      Compact representation of s and v coming from EIP-2098.\\n     *\\n     * @return signer The address that produced the signature (EOA).\\n     */\\n    function recoverSigner(\\n        bytes32 digest,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address signer) {\\n        (bytes32 s, uint8 v) = splitVS(vs);\\n        require(s <= SECP256K1_LOW_S_BOUND, InvalidSignatureSValue());\\n\\n        signer = ecrecover(digest, v, r, s);\\n        require(signer != address(0), InvalidSignature());\\n    }\\n\\n    function splitVS(bytes32 vs) internal pure returns (bytes32 s, uint8 v) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            // Equivalent to:\\n            // s = bytes32(uint256(vs) & (uint256(1 << 255) - 1))\\n            // v = uint8(uint256(vs >> 255) + 27)\\n            // Assembly is slighly more gas efficient here\\n            s := and(sub(shl(255, 1), 1), vs)\\n            v := add(shr(255, vs), 27)\\n        }\\n    }\\n\\n    function safeCastUint256ToUint128(\\n        uint256 value\\n    ) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, ValueDoesNotFitInUint128());\\n        return uint128(value);\\n    }\\n}\\n\",\"keccak256\":\"0xe93f9c4d86bec6cdc0d0244a50ed17bc3a1dbbca29d72ce1b056ab187d37be97\",\"license\":\"GPL-3.0-only\"},\"src/libs/RegistrationSelector.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.29;\\n\\n/**\\n * @title Safe Secret Harbour Registration Selector\\n * @dev This registration selector is used internally as a mapping key to transaction registration\\n *      block numbers. It allows enumeration of block numbers where Safe transactions were\\n *      registered by a notary for a given chain, Safe address, and nonce.\\n */\\nlibrary RegistrationSelector {\\n    type T is bytes32;\\n\\n    /**\\n     * @notice Compute the registration selector for a given `(chainId, safe, nonce, signer)` tuple.\\n     */\\n    function get(\\n        uint256 chainId,\\n        address safe,\\n        uint256 nonce,\\n        address notary\\n    ) internal pure returns (T key) {\\n        // uid = keccak256(chainId, safe, nonce, notary)\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            let ptr := mload(0x40)\\n            mstore(ptr, chainId)\\n            mstore(add(ptr, 32), safe)\\n            mstore(add(ptr, 64), nonce)\\n            mstore(add(ptr, 96), notary)\\n            key := keccak256(ptr, 128)\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes an opaque unique identifier for a registration selector and index.\\n     *\\n     * @dev This UID is indexed in transaction registration events, and can be used to query an RPC\\n     *      node for Ethereum logs for a specific transaction registration. This allows the harbour\\n     *      contract to be used without event indexing with RPC nodes that do not support queries\\n     *      over large block ranges, without keeping lots amount of data in contract storage.\\n     */\\n    function uniqueIdentifier(\\n        T self,\\n        uint256 index\\n    ) internal pure returns (bytes32 uid) {\\n        // uid = keccak256(self, index)\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0, self)\\n            mstore(32, index)\\n            uid := keccak256(0, 64)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe226a0bd2c832e6f907b992b7fbcd8a126c2240167651fb35cf3c57a26dc481e\",\"license\":\"GPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x6080806040523460155761128e908161001a8239f35b5f80fdfe6080806040526004361015610012575f80fd5b5f3560e01c90816301ffc9a714610c18575080630f74be61146109e15780634575b0be146107c45780635729f5bc14610761578063a2bd0ea4146106db578063a5b347db1461059f578063beb680f71461028c578063ed51bdbd14610158578063f24e49a8146100ce5763f9022c291461008a575f80fd5b346100ca5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca576100c860243560043533610fd0565b005b5f80fd5b346100ca5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca5773ffffffffffffffffffffffffffffffffffffffff61011a610cd4565b610122610e11565b50165f525f6020526040805f20815161013a81610d9c565b60206001835493848452015491019081528251918252516020820152f35b346100ca5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca5760043567ffffffffffffffff81116100ca576101a7903690600401610d6b565b6101b081610df9565b916101be6040519384610db8565b8183526101ca82610df9565b917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe06020850193013684375f5b818110610242578385604051918291602083019060208452518091526040830191905f5b818110610229575050500390f35b825184528594506020938401939092019160010161021b565b8073ffffffffffffffffffffffffffffffffffffffff61026d6102686001948688610e6a565b610e7a565b165f525f6020528160405f2001546102858288610e29565b52016101f7565b346100ca5760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca576004356102c6610cf7565b60843567ffffffffffffffff81116100ca576102e6903690600401610d3d565b60a49291923567ffffffffffffffff81116100ca57610309903690600401610d3d565b9290945f948484171561057757610380604051602081017f47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218815284604083015273ffffffffffffffffffffffffffffffffffffffff8616606083015260608252610374608083610db8565b6064359151902061120c565b93806104b2575b50508361039a575b602085604051908152f35b6103c3929394503391604435608093916040519384526020840152604083015260608201522090565b92835f52600260205260405f2080549467ffffffffffffffff861691600183019667ffffffffffffffff438917116104a057602097600385101561045757600190439060061b1b91011790555b5f5284527f91e8532b65f3b9d750bfc0e0879965927e9fdc2e36d77ccf93cc55312a443e1160405f2093849261044b604051928392836111c7565b0390a38280808061038f565b506001907ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd8501835f528060021c8a5f20019060c0439160061b161b8154179055019055610410565b634e487b715f5260116020526024601cfd5b73ffffffffffffffffffffffffffffffffffffffff6104d2828488610e9b565b50501691825f52600360205260405f20865f5260205260405f20546105475782917f359c43a08133079178a2470d20af22008b6117e43782f815330a431ce2ed57209187945f52600360205260405f20855f526020524360405f205561053d604051928392836111c7565b0390a38680610387565b85837f41e3e888000000000000000000000000000000000000000000000000000000005f5260045260245260445ffd5b7f3f51f097000000000000000000000000000000000000000000000000000000005f5260045ffd5b346100ca5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca5760043567ffffffffffffffff81116100ca576105ee903690600401610d6b565b602435916105fb82610df9565b926106096040519485610db8565b82845261061583610df9565b927fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe06020860194013685375f5b81811061068d578486604051918291602083019060208452518091526040830191905f5b818110610674575050500390f35b8251845285945060209384019390920191600101610666565b8073ffffffffffffffffffffffffffffffffffffffff6106b36102686001948689610e6a565b165f52600360205260405f20845f5260205260405f20546106d48289610e29565b5201610642565b346100ca5760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca57610741610715610cf7565b61071d610d1a565b60408051600435815260208101939093526044359083015260608201526080902090565b5f526002602052602067ffffffffffffffff60405f205416604051908152f35b346100ca5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca5773ffffffffffffffffffffffffffffffffffffffff6107ad610cd4565b165f526001602052602060405f2054604051908152f35b346100ca5760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca576107fb610cf7565b610803610d1a565b6040805160043581526020810193909352604435908301526060820152608090206084359060a435815f52600260205260405f209160405160a0810181811067ffffffffffffffff8211176109b457604052602081019267ffffffffffffffff6040830195808452548086521690818652600360608401526001608084015261088c878461112c565b808651116109ac575b508451917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe06108dc6108c685610df9565b946108d46040519687610db8565b808652610df9565b015f5b8181106109895750505f5b8651156108f683611044565b6109335760018161090a6108f69387610e29565b5167ffffffffffffffff8951168152875f52818b01602052602060405f209101520190506108ea565b828460405190604082019260408352815180945260206060840192015f945b80861061096757505082935060208301520390f35b9092602060406001928287518051835201518382015201940195019490610952565b60209060405161099881610d9c565b5f81525f83820152828288010152016108df565b855286610895565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b346100ca5760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca57610a18610cd4565b60243560443590606435926084359360a43567ffffffffffffffff81116100ca57610a47903690600401610d3d565b9573ffffffffffffffffffffffffffffffffffffffff841696875f52600160205260405f2054808503610bed5750428210610bc55773ffffffffffffffffffffffffffffffffffffffff92610b3d610b429360405160208101907f035aff83d86937d35b32e04f0ddc6ff469290eef2f1b692d8a815c89404d4749825230604082015260408152610ad9606082610db8565b5190209060405160208101917f5577dd2e8f3cae24f69b98e4cdf50cb186492fb1ca342a9a6cf161733ca273b283528b60408301528c60608301524660808301528960a083015260c082015260c08152610b3460e082610db8565b5190209061120c565b610e9b565b505016858103610b9a575060018101809111610b6d576100c8945f52600160205260405f2055610fd0565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b7fa150e3da000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7f84cfe826000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f22081de4000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b346100ca5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca57600435907fffffffff0000000000000000000000000000000000000000000000000000000082168092036100ca57817f01ffc9a70000000000000000000000000000000000000000000000000000000060209314908115610caa575b5015158152f35b7fe030e4730000000000000000000000000000000000000000000000000000000091501483610ca3565b6004359073ffffffffffffffffffffffffffffffffffffffff821682036100ca57565b6024359073ffffffffffffffffffffffffffffffffffffffff821682036100ca57565b6064359073ffffffffffffffffffffffffffffffffffffffff821682036100ca57565b9181601f840112156100ca5782359167ffffffffffffffff83116100ca57602083818601950101116100ca57565b9181601f840112156100ca5782359167ffffffffffffffff83116100ca576020808501948460051b0101116100ca57565b6040810190811067ffffffffffffffff8211176109b457604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff8211176109b457604052565b67ffffffffffffffff81116109b45760051b60200190565b60405190610e1e82610d9c565b5f6020838281520152565b8051821015610e3d5760209160051b010190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b9190811015610e3d5760051b0190565b3573ffffffffffffffffffffffffffffffffffffffff811681036100ca5790565b929091604103610fa857813591604060208201359101355f1a937f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08211610f80575f6080602092604051908152878482015286604082015284606082015282805260015afa15610f75575f519373ffffffffffffffffffffffffffffffffffffffff851615610f4d577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe50160ff1b1790565b7f8baa579f000000000000000000000000000000000000000000000000000000005f5260045ffd5b6040513d5f823e3d90fd5b7f617cf474000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f85e6258e000000000000000000000000000000000000000000000000000000005f5260045ffd5b917f1fd34304e8383f1f1847b03c9e21612ffd92ab1bd59028ab29cb5cc1d79220f191604091825161100181610d9c565b828152600173ffffffffffffffffffffffffffffffffffffffff60208301978489521696875f525f602052855f20925183555191015582519182526020820152a2565b6040810160018151106111265780517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff019052606081018051909190600181106110bb5750602001805160401c90527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8151019052565b916003602092936001038060021c60808601805115155f14611118575f91868820018752525b16908160040390527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff835154910160061b1c910152565b5085510160010185526110e1565b5f915052565b9060408201818151106111c05781815103905260608201918251828110155f14611164575060200180518260061b1c90528151039052565b600390602093949294038060021c60808601805115155f14611118575f918688200187525216908160040390527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff835154910160061b1c910152565b5f90525050565b90601f836040947fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09360208652816020870152868601375f8582860101520116010190565b906040519060208201927f190100000000000000000000000000000000000000000000000000000000000084526022830152604282015260428152611252606282610db8565b5190209056fea2646970667358221220bf814850da69310566faf2920e1bb4ebf867a7083301ab9171938f426db0ba8164736f6c634300081d0033",
  "deployedBytecode": "0x6080806040526004361015610012575f80fd5b5f3560e01c90816301ffc9a714610c18575080630f74be61146109e15780634575b0be146107c45780635729f5bc14610761578063a2bd0ea4146106db578063a5b347db1461059f578063beb680f71461028c578063ed51bdbd14610158578063f24e49a8146100ce5763f9022c291461008a575f80fd5b346100ca5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca576100c860243560043533610fd0565b005b5f80fd5b346100ca5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca5773ffffffffffffffffffffffffffffffffffffffff61011a610cd4565b610122610e11565b50165f525f6020526040805f20815161013a81610d9c565b60206001835493848452015491019081528251918252516020820152f35b346100ca5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca5760043567ffffffffffffffff81116100ca576101a7903690600401610d6b565b6101b081610df9565b916101be6040519384610db8565b8183526101ca82610df9565b917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe06020850193013684375f5b818110610242578385604051918291602083019060208452518091526040830191905f5b818110610229575050500390f35b825184528594506020938401939092019160010161021b565b8073ffffffffffffffffffffffffffffffffffffffff61026d6102686001948688610e6a565b610e7a565b165f525f6020528160405f2001546102858288610e29565b52016101f7565b346100ca5760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca576004356102c6610cf7565b60843567ffffffffffffffff81116100ca576102e6903690600401610d3d565b60a49291923567ffffffffffffffff81116100ca57610309903690600401610d3d565b9290945f948484171561057757610380604051602081017f47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218815284604083015273ffffffffffffffffffffffffffffffffffffffff8616606083015260608252610374608083610db8565b6064359151902061120c565b93806104b2575b50508361039a575b602085604051908152f35b6103c3929394503391604435608093916040519384526020840152604083015260608201522090565b92835f52600260205260405f2080549467ffffffffffffffff861691600183019667ffffffffffffffff438917116104a057602097600385101561045757600190439060061b1b91011790555b5f5284527f91e8532b65f3b9d750bfc0e0879965927e9fdc2e36d77ccf93cc55312a443e1160405f2093849261044b604051928392836111c7565b0390a38280808061038f565b506001907ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd8501835f528060021c8a5f20019060c0439160061b161b8154179055019055610410565b634e487b715f5260116020526024601cfd5b73ffffffffffffffffffffffffffffffffffffffff6104d2828488610e9b565b50501691825f52600360205260405f20865f5260205260405f20546105475782917f359c43a08133079178a2470d20af22008b6117e43782f815330a431ce2ed57209187945f52600360205260405f20855f526020524360405f205561053d604051928392836111c7565b0390a38680610387565b85837f41e3e888000000000000000000000000000000000000000000000000000000005f5260045260245260445ffd5b7f3f51f097000000000000000000000000000000000000000000000000000000005f5260045ffd5b346100ca5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca5760043567ffffffffffffffff81116100ca576105ee903690600401610d6b565b602435916105fb82610df9565b926106096040519485610db8565b82845261061583610df9565b927fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe06020860194013685375f5b81811061068d578486604051918291602083019060208452518091526040830191905f5b818110610674575050500390f35b8251845285945060209384019390920191600101610666565b8073ffffffffffffffffffffffffffffffffffffffff6106b36102686001948689610e6a565b165f52600360205260405f20845f5260205260405f20546106d48289610e29565b5201610642565b346100ca5760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca57610741610715610cf7565b61071d610d1a565b60408051600435815260208101939093526044359083015260608201526080902090565b5f526002602052602067ffffffffffffffff60405f205416604051908152f35b346100ca5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca5773ffffffffffffffffffffffffffffffffffffffff6107ad610cd4565b165f526001602052602060405f2054604051908152f35b346100ca5760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca576107fb610cf7565b610803610d1a565b6040805160043581526020810193909352604435908301526060820152608090206084359060a435815f52600260205260405f209160405160a0810181811067ffffffffffffffff8211176109b457604052602081019267ffffffffffffffff6040830195808452548086521690818652600360608401526001608084015261088c878461112c565b808651116109ac575b508451917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe06108dc6108c685610df9565b946108d46040519687610db8565b808652610df9565b015f5b8181106109895750505f5b8651156108f683611044565b6109335760018161090a6108f69387610e29565b5167ffffffffffffffff8951168152875f52818b01602052602060405f209101520190506108ea565b828460405190604082019260408352815180945260206060840192015f945b80861061096757505082935060208301520390f35b9092602060406001928287518051835201518382015201940195019490610952565b60209060405161099881610d9c565b5f81525f83820152828288010152016108df565b855286610895565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b346100ca5760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca57610a18610cd4565b60243560443590606435926084359360a43567ffffffffffffffff81116100ca57610a47903690600401610d3d565b9573ffffffffffffffffffffffffffffffffffffffff841696875f52600160205260405f2054808503610bed5750428210610bc55773ffffffffffffffffffffffffffffffffffffffff92610b3d610b429360405160208101907f035aff83d86937d35b32e04f0ddc6ff469290eef2f1b692d8a815c89404d4749825230604082015260408152610ad9606082610db8565b5190209060405160208101917f5577dd2e8f3cae24f69b98e4cdf50cb186492fb1ca342a9a6cf161733ca273b283528b60408301528c60608301524660808301528960a083015260c082015260c08152610b3460e082610db8565b5190209061120c565b610e9b565b505016858103610b9a575060018101809111610b6d576100c8945f52600160205260405f2055610fd0565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b7fa150e3da000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7f84cfe826000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f22081de4000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b346100ca5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100ca57600435907fffffffff0000000000000000000000000000000000000000000000000000000082168092036100ca57817f01ffc9a70000000000000000000000000000000000000000000000000000000060209314908115610caa575b5015158152f35b7fe030e4730000000000000000000000000000000000000000000000000000000091501483610ca3565b6004359073ffffffffffffffffffffffffffffffffffffffff821682036100ca57565b6024359073ffffffffffffffffffffffffffffffffffffffff821682036100ca57565b6064359073ffffffffffffffffffffffffffffffffffffffff821682036100ca57565b9181601f840112156100ca5782359167ffffffffffffffff83116100ca57602083818601950101116100ca57565b9181601f840112156100ca5782359167ffffffffffffffff83116100ca576020808501948460051b0101116100ca57565b6040810190811067ffffffffffffffff8211176109b457604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff8211176109b457604052565b67ffffffffffffffff81116109b45760051b60200190565b60405190610e1e82610d9c565b5f6020838281520152565b8051821015610e3d5760209160051b010190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b9190811015610e3d5760051b0190565b3573ffffffffffffffffffffffffffffffffffffffff811681036100ca5790565b929091604103610fa857813591604060208201359101355f1a937f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08211610f80575f6080602092604051908152878482015286604082015284606082015282805260015afa15610f75575f519373ffffffffffffffffffffffffffffffffffffffff851615610f4d577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe50160ff1b1790565b7f8baa579f000000000000000000000000000000000000000000000000000000005f5260045ffd5b6040513d5f823e3d90fd5b7f617cf474000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f85e6258e000000000000000000000000000000000000000000000000000000005f5260045ffd5b917f1fd34304e8383f1f1847b03c9e21612ffd92ab1bd59028ab29cb5cc1d79220f191604091825161100181610d9c565b828152600173ffffffffffffffffffffffffffffffffffffffff60208301978489521696875f525f602052855f20925183555191015582519182526020820152a2565b6040810160018151106111265780517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff019052606081018051909190600181106110bb5750602001805160401c90527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8151019052565b916003602092936001038060021c60808601805115155f14611118575f91868820018752525b16908160040390527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff835154910160061b1c910152565b5085510160010185526110e1565b5f915052565b9060408201818151106111c05781815103905260608201918251828110155f14611164575060200180518260061b1c90528151039052565b600390602093949294038060021c60808601805115155f14611118575f918688200187525216908160040390527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff835154910160061b1c910152565b5f90525050565b90601f836040947fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09360208652816020870152868601375f8582860101520116010190565b906040519060208201927f190100000000000000000000000000000000000000000000000000000000000084526022830152604282015260428152611252606282610db8565b5190209056fea2646970667358221220bf814850da69310566faf2920e1bb4ebf867a7083301ab9171938f426db0ba8164736f6c634300081d0033",
  "devdoc": {
    "errors": {
      "InvalidEncryptionKeyRegistrationNonce(uint256)": [
        {
          "params": {
            "currentNonce": "The current encryption key registration nonce, which is valid."
          }
        }
      ],
      "SignerAlreadySignedTransaction(address,bytes32)": [
        {
          "params": {
            "safeTxHash": "The EIP-712 hash of the Safe transaction.",
            "signer": "Signer address."
          }
        }
      ]
    },
    "events": {
      "EncryptionKeyRegistered(address,bytes32,bytes32)": {
        "params": {
          "context": "A 32-byte contract associated with the encryption key.",
          "publicKey": "A 32-byte encryption public key.",
          "signer": "The signer for which the key was registered."
        }
      },
      "SafeTransactionRegistered(bytes32,bytes32,bytes)": {
        "params": {
          "encryptionBlob": "A blob containing encrypted transaction data. This can either be the                       encrypted transaction itself, or additional encrypted keys to new signer                       public keys. The exact format is not enforced and application dependent.                       The reference implementation uses JWE to encrypt the RLP-encoded Safe                       transaction with A256-GCM encryption, and ECDH-ES+A256KW for wrapping the                       encryption keys for recipients' X25519 public keys.",
          "safeTxHash": "EIP-712 hash identifying the Safe transaction.",
          "uid": "A unique registration identifier that can be used for event filtering."
        }
      },
      "SafeTransactionSigned(address,bytes32,bytes)": {
        "params": {
          "safeTxHash": "The Safe transaction hash that was signed.",
          "signature": "The Safe transaction signature.",
          "signer": "The signer address."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "enqueueTransaction(uint256,address,uint256,bytes32,bytes,bytes)": {
        "custom:events": "Emits {SafeTransactionSigned} and {SafeTransactionRegistered}.",
        "details": "This function serves two purposes:      1. To register Safe transaction encryption data      2. To add signatures to a Safe transaction",
        "params": {
          "chainId": "Chain id the transaction is meant for.",
          "encryptionBlob": "A blob containing encrypted transaction data. This can either be the                         encrypted transaction itself, or additional encrypted keys to new                         signer public keys. The exact format is not enforced and application                         dependent. There are no guarantees that the blob actually matches the                         provided `safeTxStructHash`. The reference implementation uses JWE to                         encrypt the RLP-encoded Safe transaction with key wrapping for the                         recipients' X25519 public keys. _Optional_: can be omitted to                         register a signature without any new encrypted transaction data.",
          "nonce": "Safe nonce.",
          "safe": "Target Safe Smart-Account.",
          "safeTxStructHash": "The ERC-712 struct hash of the Safe transaction data.",
          "signature": "A 65-byte ECDSA signature. _Optional_: can be omitted to register                         new encrypted transaction data without a signature."
        },
        "returns": {
          "uid": "            The unique signer-specific identifer of the transaction registration.                         Zero if `encryptionBlob` is empty."
        }
      },
      "registerEncryptionKey(bytes32,bytes32)": {
        "params": {
          "context": "A 32-byte context specific to the public encryption key.",
          "publicKey": "The public encryption key to be registered for the `msg.sender` signer."
        }
      },
      "registerEncryptionKeyFor(address,bytes32,bytes32,uint256,uint256,bytes)": {
        "params": {
          "context": "A 32-byte context specific to the public encryption key.",
          "deadline": "Deadline for the registration.",
          "nonce": "Encryption key registration nonce.",
          "publicKey": "The public encryption key to be registered for the `signer`.",
          "signature": "The ECDSA signature of the `signer` over the encryption key registration.",
          "signer": "The signer to register the encryption key for."
        }
      },
      "retrieveEncryptionKey(address)": {
        "params": {
          "signer": "The signer to fetch encryption keys for."
        },
        "returns": {
          "encryptionKey": "The registered encryption key."
        }
      },
      "retrieveEncryptionKeyRegistrationNonce(address)": {
        "params": {
          "signer": "The signer to fetch encryption key registration nonce for."
        },
        "returns": {
          "nonce": "The current encryption key registration nonce."
        }
      },
      "retrieveEncryptionPublicKeys(address[])": {
        "params": {
          "signers": "The list of signers to fetch encryption keys for."
        },
        "returns": {
          "publicKeys": "The encryption public keys for each of the signers, or `0` if none was                    registered. The keys are in the same order as the signers array (i.e. for                    all `i`, the key for `signer[i]` is `publicKey[i]`)."
        }
      },
      "retrieveSignatures(address[],bytes32)": {
        "details": "Note that this function does not return the signature directly, the block number that      can be used to query an log with the signature bytes.",
        "params": {
          "safeTxHash": "ERC-712 digest of the transaction",
          "signers": "The signer addresses."
        },
        "returns": {
          "blockNumbers": "The block numbers containing the Safe transaction signature events for                      the specified signers and Safe transaction hash."
        }
      },
      "retrieveTransactionCount(uint256,address,uint256,address)": {
        "params": {
          "chainId": "Target chain id.",
          "nonce": "Safe nonce.",
          "notary": "Notary address.",
          "safe": "Safe Smart-Account."
        },
        "returns": {
          "count": " Number of registrations."
        }
      },
      "retrieveTransactions(uint256,address,uint256,address,uint256,uint256)": {
        "details": "Note that this function does not return the full registered transaction directly, but      a unique identifier and block number that can be used to query an log with the full      transaction details.",
        "params": {
          "chainId": "Target chain id.",
          "count": "Maximum number of entries to return.",
          "nonce": "Safe nonce.",
          "notary": "Address that registered ecrypted transaction data.",
          "safe": "Safe Smart-Account.",
          "start": "Zero-based start index of the slice."
        },
        "returns": {
          "page": "      Array slice `[start … start+count)` (may be shorter).",
          "totalCount": "Total number of registrations for the `(chainId, safe, nonce, signer)`                    tuple."
        }
      }
    },
    "stateVariables": {
      "_encryptionKeyRegistrationNonces": {
        "details": "Mapping of signers to their encryption key registration nonces, to prevent replaying      past encryption key registrations after a key rotation."
      },
      "_encryptionKeys": {
        "details": "Mapping of signers to their encryption keys."
      },
      "_signatures": {
        "details": "Mapping per signer from Safe transaction hashes to the block in which a signature was      registered."
      },
      "_transactions": {
        "details": "Mapping of registration selector to an array of block numbers where Safe transactions      were registered with the harbour.      Note that the same Safe transaction can be registered **multiple times** with harbour.      This is important to allow appending additional encryption data (such as new wrapped      encryption keys for signers that either rotated or registered their public encryption      key after the initial transaction submission)."
      }
    },
    "title": "Safe Secret Harbour",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "EncryptionKeyRegistrationExpired()": [
        {
          "notice": "Thrown when attempting to register an encryption key on behalf of the user with an         expired signature."
        }
      ],
      "InvalidECDSASignatureLength()": [
        {
          "notice": "Thrown when a signature blob is not exactly 65 bytes."
        }
      ],
      "InvalidEncryptionKeyRegistrationNonce(uint256)": [
        {
          "notice": "Thrown when registering an encryption key on behalf of a signer with an invalid nonce."
        }
      ],
      "InvalidSignature()": [
        {
          "notice": "Thrown if `ecrecover` yields `address(0)`."
        }
      ],
      "InvalidSignatureSValue()": [
        {
          "notice": "Thrown if the S value of the signature is not from the lower half of the curve."
        }
      ],
      "NothingToEnqueue()": [
        {
          "notice": "Thrown when attempting to enqueue nothing. That is, when calling `enqueueTransaction` on         the {SafeSecretHarbour} with empty `signature` and `encryptionBlob`."
        }
      ],
      "SignerAlreadySignedTransaction(address,bytes32)": [
        {
          "notice": "Thrown when attempting to store a signature for a transaction (safeTxHash) that the signer has already provided a signature for."
        }
      ]
    },
    "events": {
      "EncryptionKeyRegistered(address,bytes32,bytes32)": {
        "notice": "Emitted whenever an encryption key is registered for a signer."
      },
      "SafeTransactionRegistered(bytes32,bytes32,bytes)": {
        "notice": "Emitted whenever a signed encrypted Safe transaction is registered."
      },
      "SafeTransactionSigned(address,bytes32,bytes)": {
        "notice": "Emitted when a Safe transaction is signed."
      }
    },
    "kind": "user",
    "methods": {
      "enqueueTransaction(uint256,address,uint256,bytes32,bytes,bytes)": {
        "notice": "Register an encrypted Safe transaction and signature."
      },
      "registerEncryptionKey(bytes32,bytes32)": {
        "notice": "Register a public encryption key for a signer."
      },
      "registerEncryptionKeyFor(address,bytes32,bytes32,uint256,uint256,bytes)": {
        "notice": "Register a public encryption key on behalf of a signer."
      },
      "retrieveEncryptionKey(address)": {
        "notice": "Retrieves the encryption keys for a signer."
      },
      "retrieveEncryptionKeyRegistrationNonce(address)": {
        "notice": "Retrieves the current encryption key registration nonce for signing."
      },
      "retrieveEncryptionPublicKeys(address[])": {
        "notice": "Retrieves encryption public keys for the specified signers."
      },
      "retrieveSignatures(address[],bytes32)": {
        "notice": "Retrieve Safe transaction signatures for the specified signers."
      },
      "retrieveTransactionCount(uint256,address,uint256,address)": {
        "notice": "Convenience getter returning the **number** of transaction registered for a specific         `(chainId, safe, nonce, notary)` tuple."
      },
      "retrieveTransactions(uint256,address,uint256,address,uint256,uint256)": {
        "notice": "Paginated getter for Safe transactions."
      }
    },
    "notice": "Permissionless, append-only registry that lets **any EOA signer** publish encrypted Safe         transactions (\"SafeTx\") and their signatures. Clients without an off-chain indexer can         reconstruct the full multisig payload with only:         1. the Safe address;         2. the target `chainId`;         3. the Safe `nonce`;         4. the current Safe owners set; and         5. a key to decrypt the transaction payload.         Each unique `safeTxHash` (ERC-712 digest of the SafeTx struct) may be registered more         than once, to allow rotating the encryption.         Additionally, this contract contains a public encryption key registry, and functions as         a trustless channel for signers to communicate public encryption keys amongst themselves         in order to support asymmetric encryption schemes of the transaction data.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 2992,
        "contract": "src/SafeSecretHarbour.sol:SafeSecretHarbour",
        "label": "_encryptionKeys",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_struct(EncryptionKey)4060_storage)"
      },
      {
        "astId": 2997,
        "contract": "src/SafeSecretHarbour.sol:SafeSecretHarbour",
        "label": "_encryptionKeyRegistrationNonces",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 3004,
        "contract": "src/SafeSecretHarbour.sol:SafeSecretHarbour",
        "label": "_transactions",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_userDefinedValueType(T)5038,t_struct(T)4073_storage)"
      },
      {
        "astId": 3011,
        "contract": "src/SafeSecretHarbour.sol:SafeSecretHarbour",
        "label": "_signatures",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_mapping(t_bytes32,t_uint256))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_mapping(t_bytes32,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(bytes32 => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_uint256)"
      },
      "t_mapping(t_address,t_struct(EncryptionKey)4060_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct EncryptionKey)",
        "numberOfBytes": "32",
        "value": "t_struct(EncryptionKey)4060_storage"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_userDefinedValueType(T)5038,t_struct(T)4073_storage)": {
        "encoding": "mapping",
        "key": "t_userDefinedValueType(T)5038",
        "label": "mapping(RegistrationSelector.T => struct BlockNumbers.T)",
        "numberOfBytes": "32",
        "value": "t_struct(T)4073_storage"
      },
      "t_struct(EncryptionKey)4060_storage": {
        "encoding": "inplace",
        "label": "struct EncryptionKey",
        "members": [
          {
            "astId": 4057,
            "contract": "src/SafeSecretHarbour.sol:SafeSecretHarbour",
            "label": "context",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes32"
          },
          {
            "astId": 4059,
            "contract": "src/SafeSecretHarbour.sol:SafeSecretHarbour",
            "label": "publicKey",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(T)4073_storage": {
        "encoding": "inplace",
        "label": "struct BlockNumbers.T",
        "members": [
          {
            "astId": 4072,
            "contract": "src/SafeSecretHarbour.sol:SafeSecretHarbour",
            "label": "prefix",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_userDefinedValueType(T)5038": {
        "encoding": "inplace",
        "label": "RegistrationSelector.T",
        "numberOfBytes": "32"
      }
    }
  }
}